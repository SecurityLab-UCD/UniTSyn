pub fn unwrap(self) -> T {
        match self {
            Res::Ok(t) | Res::Truncated(t) | Res::Overflow(t) => t,
        }
    }
fn new_engine_opt_renamed_dir() {
    use std::sync::Arc;
    let dir = tempdir();
    let root_path = dir.path();

    let encryption_cfg = test_util::new_file_security_config(root_path);
    let key_manager = Arc::new(
        data_key_manager_from_config(&encryption_cfg, root_path.to_str().unwrap())
            .unwrap()
            .unwrap(),
    );

    let mut db_opts = DbOptions::default();
    db_opts.set_key_manager(Some(key_manager.clone()));
    let cf_opts: Vec<_> = ALL_CFS.iter().map(|cf| (*cf, CfOptions::new())).collect();

    let path = root_path.join("missing").to_str().unwrap().to_owned();
    {
        let db = KvTestEngine::new_kv_engine_opt(&path, db_opts.clone(), cf_opts.clone()).unwrap();
        db.put(b"foo", b"bar").unwrap();
        db.sync().unwrap();
    }
    let new_path = root_path.join("new").to_str().unwrap().to_owned();
    key_manager.link_file(&path, &new_path).unwrap();
    fs::rename(&path, &new_path).unwrap();
    key_manager.delete_file(&path).unwrap();
    {
        let db =
            KvTestEngine::new_kv_engine_opt(&new_path, db_opts.clone(), cf_opts.clone()).unwrap();
        assert_eq!(
            db.get_value_cf(CF_DEFAULT, b"foo").unwrap().unwrap(),
            b"bar"
        );
    }
}