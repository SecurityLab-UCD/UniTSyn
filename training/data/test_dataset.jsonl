{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/kv_service.rs::test_double_run_node", "code": "pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    }", "test": "fn test_double_run_node() {\n    let count = 1;\n    let mut cluster = new_node_cluster(0, count);\n    cluster.run();\n    let id = *cluster.engines.keys().next().unwrap();\n    let engines = cluster.engines.values().next().unwrap().clone();\n    let router = cluster.sim.rl().get_router(id).unwrap();\n    let mut sim = cluster.sim.wl();\n    let node = sim.get_node(id).unwrap();\n    let pd_worker = LazyWorker::new(\"test-pd-worker\");\n    let simulate_trans = SimulateTransport::new(ChannelTransport::new());\n    let tmp = Builder::new().prefix(\"test_cluster\").tempdir().unwrap();\n    let snap_mgr = SnapManager::new(tmp.path().to_str().unwrap());\n    let coprocessor_host = CoprocessorHost::new(router, raftstore::coprocessor::Config::default());\n    let importer = {\n        let dir = Path::new(MiscExt::path(&engines.kv)).join(\"import-sst\");\n        Arc::new(SstImporter::new(&ImportConfig::default(), dir, None, ApiVersion::V1).unwrap())\n    };\n    let (split_check_scheduler, _) = dummy_scheduler();\n\n    let store_meta = Arc::new(Mutex::new(StoreMeta::new(20)));\n    let e = node\n        .start(\n            engines,\n            simulate_trans,\n            snap_mgr,\n            pd_worker,\n            store_meta,\n            coprocessor_host,\n            importer,\n            split_check_scheduler,\n            AutoSplitController::default(),\n            ConcurrencyManager::new(1.into()),\n            CollectorRegHandle::new_for_test(),\n            None,\n            Arc::new(AtomicU64::new(0)),\n        )\n        .unwrap_err();\n    assert!(format!(\"{:?}\", e).contains(\"already started\"), \"{:?}\", e);\n    drop(sim);\n    cluster.shutdown();\n}"}
{"test_id": "winnow-rs-winnow/winnow-rs-winnow-9e88734/tests/testsuite/multiline.rs::read_lines_test", "code": "pub fn read_lines(input: &str) -> IResult<&str, Vec<&str>> {\n    repeat(0.., unpeek(read_line)).parse_peek(input)\n}", "test": "fn read_lines_test() {\n    let res = Ok((\"\", vec![\"Duck\", \"Dog\", \"Cow\"]));\n\n    assert_eq!(read_lines(\"Duck\\nDog\\nCow\\n\"), res);\n    assert_eq!(read_lines(\"Duck\\nDog\\nCow\"), res);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/func.rs::chars", "code": "pub fn call(&self, arguments: &[DataValue]) -> Vec<DataValue> {\n        let mut values = UnboxedValues::make_arguments(arguments, &self.func_signature);\n        let arguments_address = values.as_mut_ptr();\n\n        let function_ptr = self.module.get_finalized_function(self.func_id);\n        let trampoline_ptr = self.module.get_finalized_function(self.trampoline_id);\n\n        let callable_trampoline: fn(*const u8, *mut u128) -> () =\n            unsafe { mem::transmute(trampoline_ptr) };\n        callable_trampoline(function_ptr, arguments_address);\n\n        values.collect_returns(&self.func_signature)\n    }", "test": "fn chars() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"pass\") (param i32) (result i32) local.get 0)\n            )\n            (core instance $i (instantiate $m))\n\n            (func (export \"u32-to-char\") (param \"a\" u32) (result char)\n                (canon lift (core func $i \"pass\"))\n            )\n            (func (export \"char-to-u32\") (param \"a\" char) (result u32)\n                (canon lift (core func $i \"pass\"))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let u32_to_char = instance.get_typed_func::<(u32,), (char,)>(&mut store, \"u32-to-char\")?;\n    let char_to_u32 = instance.get_typed_func::<(char,), (u32,)>(&mut store, \"char-to-u32\")?;\n\n    let mut roundtrip = |x: char| -> Result<()> {\n        assert_eq!(char_to_u32.call(&mut store, (x,))?, (x as u32,));\n        char_to_u32.post_return(&mut store)?;\n        assert_eq!(u32_to_char.call(&mut store, (x as u32,))?, (x,));\n        u32_to_char.post_return(&mut store)?;\n        Ok(())\n    };\n\n    roundtrip('x')?;\n    roundtrip('a')?;\n    roundtrip('\\0')?;\n    roundtrip('\\n')?;\n    roundtrip('\ud83d\udc9d')?;\n\n    let u32_to_char = |store: &mut Store<()>| {\n        Linker::new(&engine)\n            .instantiate(&mut *store, &component)?\n            .get_typed_func::<(u32,), (char,)>(&mut *store, \"u32-to-char\")\n    };\n    let err = u32_to_char(&mut store)?\n        .call(&mut store, (0xd800,))\n        .unwrap_err();\n    assert!(err.to_string().contains(\"integer out of range\"), \"{}\", err);\n    let err = u32_to_char(&mut store)?\n        .call(&mut store, (0xdfff,))\n        .unwrap_err();\n    assert!(err.to_string().contains(\"integer out of range\"), \"{}\", err);\n    let err = u32_to_char(&mut store)?\n        .call(&mut store, (0x110000,))\n        .unwrap_err();\n    assert!(err.to_string().contains(\"integer out of range\"), \"{}\", err);\n    let err = u32_to_char(&mut store)?\n        .call(&mut store, (u32::MAX,))\n        .unwrap_err();\n    assert!(err.to_string().contains(\"integer out of range\"), \"{}\", err);\n\n    Ok(())\n}\n\n#"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_index_aggr_count", "code": "pub fn is_some(&self) -> bool {\n        match_template_evaltype! {\n            TT, match self {\n                ScalarValue::TT(v) => v.is_some(),\n            }\n        }\n    }", "test": "fn test_index_aggr_count() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:3\"), 3),\n        (4, Some(\"name:0\"), 1),\n        (5, Some(\"name:5\"), 4),\n        (6, Some(\"name:5\"), 4),\n        (7, None, 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint) = init_with_data(&product, &data);\n    // for dag\n    let req = DagSelect::from_index(&product, &product[\"name\"])\n        .count(&product[\"id\"])\n        .output_offsets(Some(vec![0]))\n        .build();\n    let mut resp = handle_select(&endpoint, req);\n    let mut spliter = DagChunkSpliter::new(resp.take_chunks().into(), 1);\n    let expected_encoded = datum::encode_value(\n        &mut EvalContext::default(),\n        &[Datum::U64(data.len() as u64)],\n    )\n    .unwrap();\n    let ret_data = spliter.next();\n    assert_eq!(ret_data.is_some(), true);\n    let result_encoded =\n        datum::encode_value(&mut EvalContext::default(), &ret_data.unwrap()).unwrap();\n    assert_eq!(&*result_encoded, &*expected_encoded);\n    assert_eq!(spliter.next().is_none(), true);\n\n    let exp = vec![\n        (Datum::Null, 1),\n        (Datum::Bytes(b\"name:0\".to_vec()), 2),\n        (Datum::Bytes(b\"name:3\".to_vec()), 1),\n        (Datum::Bytes(b\"name:5\".to_vec()), 2),\n    ];\n    // for dag\n    let req = DagSelect::from_index(&product, &product[\"name\"])\n        .count(&product[\"id\"])\n        .group_by(&[&product[\"name\"]])\n        .output_offsets(Some(vec![0, 1]))\n        .build();\n    resp = handle_select(&endpoint, req);\n    let mut row_count = 0;\n    let exp_len = exp.len();\n    let spliter = DagChunkSpliter::new(resp.take_chunks().into(), 2);\n    let mut results = spliter.collect::<Vec<Vec<Datum>>>();\n    sort_by!(results, 1, Bytes);\n    for (row, (name, cnt)) in results.iter().zip(exp) {\n        let expected_datum = vec![Datum::U64(cnt), name];\n        let expected_encoded =\n            datum::encode_value(&mut EvalContext::default(), &expected_datum).unwrap();\n        let result_encoded = datum::encode_value(&mut EvalContext::default(), row).unwrap();\n        assert_eq!(&*result_encoded, &*expected_encoded);\n        row_count += 1;\n    }\n    assert_eq!(row_count, exp_len);\n\n    let exp = vec![\n        (vec![Datum::Null, Datum::I64(4)], 1),\n        (vec![Datum::Bytes(b\"name:0\".to_vec()), Datum::I64(1)], 1),\n        (vec![Datum::Bytes(b\"name:0\".to_vec()), Datum::I64(2)], 1),\n        (vec![Datum::Bytes(b\"name:3\".to_vec()), Datum::I64(3)], 1),\n        (vec![Datum::Bytes(b\"name:5\".to_vec()), Datum::I64(4)], 2),\n    ];\n    let req = DagSelect::from_index(&product, &product[\"name\"])\n        .count(&product[\"id\"])\n        .group_by(&[&product[\"name\"], &product[\"count\"]])\n        .build();\n    resp = handle_select(&endpoint, req);\n    let mut row_count = 0;\n    let exp_len = exp.len();\n    let spliter = DagChunkSpliter::new(resp.take_chunks().into(), 3);\n    let mut results = spliter.collect::<Vec<Vec<Datum>>>();\n    sort_by!(results, 1, Bytes);\n    for (row, (gk_data, cnt)) in results.iter().zip(exp) {\n        let mut expected_datum = vec![Datum::U64(cnt)];\n        expected_datum.extend_from_slice(gk_data.as_slice());\n        let expected_encoded =\n            datum::encode_value(&mut EvalContext::default(), &expected_datum).unwrap();\n        let result_encoded = datum::encode_value(&mut EvalContext::default(), row).unwrap();\n        assert_eq!(&*result_encoded, &*expected_encoded);\n        row_count += 1;\n    }\n    assert_eq!(row_count, exp_len);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_catalog_lookup_soa", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "async fn test_catalog_lookup_soa() {\n    let example = create_example();\n    let test = create_test();\n    let origin = example.origin().clone();\n    let test_origin = test.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin.clone(), Box::new(Arc::new(example)));\n    catalog.upsert(test_origin, Box::new(Arc::new(test)));\n\n    let mut question: Message = Message::new();\n\n    let mut query: Query = Query::new();\n    query.set_name(origin.into());\n    query.set_query_type(RecordType::SOA);\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert!(result.header().authoritative());\n\n    let answers: &[Record] = result.answers();\n\n    assert!(!answers.is_empty());\n    assert_eq!(answers.first().unwrap().record_type(), RecordType::SOA);\n    assert_eq!(\n        answers.first().unwrap().data().unwrap(),\n        &RData::SOA(SOA::new(\n            Name::parse(\"sns.dns.icann.org.\", None).unwrap(),\n            Name::parse(\"noc.dns.icann.org.\", None).unwrap(),\n            2015082403,\n            7200,\n            3600,\n            1209600,\n            3600,\n        ))\n    );\n\n    // assert SOA requests get NS records\n    let mut ns: Vec<Record> = result.name_servers().to_vec();\n    ns.sort();\n\n    assert_eq!(ns.len(), 2);\n    assert_eq!(ns.first().unwrap().record_type(), RecordType::NS);\n    assert_eq!(\n        ns.first().unwrap().data().unwrap(),\n        &RData::NS(NS(Name::parse(\"a.iana-servers.net.\", None).unwrap()))\n    );\n    assert_eq!(ns.last().unwrap().record_type(), RecordType::NS);\n    assert_eq!(\n        ns.last().unwrap().data().unwrap(),\n        &RData::NS(NS(Name::parse(\"b.iana-servers.net.\", None).unwrap()))\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_format_created_time", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_format_created_time() {\n    let args = [\"-c\", \"%w\", \"/bin\"];\n    let ts = TestScenario::new(util_name!());\n    let actual = ts.ucmd().args(&args).succeeds().stdout_move_str();\n    let expect = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    println!(\"actual: {actual:?}\");\n    println!(\"expect: {expect:?}\");\n    // note: using a regex instead of `split_whitespace()` in order to detect whitespace differences\n    let re = regex::Regex::new(r\"\\s\").unwrap();\n    let v_actual: Vec<&str> = re.split(&actual).collect();\n    let v_expect: Vec<&str> = re.split(&expect).collect();\n    assert!(!v_expect.is_empty());\n    // * allow for inequality if `stat` (aka, expect) returns \"-\" (unknown value)\n    assert!(\n        expect == \"-\"\n            || expect == \"-\\n\"\n            || v_actual\n                .iter()\n                .zip(v_expect.iter())\n                .all(|(a, e)| a == e || *e == \"-\" || *e == \"-\\n\")\n    );\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_non_authoritive_nx_refused", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "async fn test_non_authoritive_nx_refused() {\n    let example = create_example();\n    let origin = example.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin, Box::new(Arc::new(example)));\n\n    let mut question: Message = Message::new();\n\n    let mut query: Query = Query::new();\n    query.set_name(Name::parse(\"com.\", None).unwrap());\n    query.set_query_type(RecordType::SOA);\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.response_code(), ResponseCode::Refused);\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert!(!result.header().authoritative());\n\n    assert_eq!(result.name_servers().len(), 0);\n    assert_eq!(result.answers().len(), 0);\n    assert_eq!(result.additionals().len(), 0);\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::remove_entry_multi_3", "code": "pub fn len(&self) -> usize {\n        self.vec.len()\n    }", "test": "fn remove_entry_multi_3() {\n    let mut headers = HeaderMap::new();\n    headers.insert(SET_COOKIE, \"cookie_1=value 1\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_2=value 2\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_3=value 3\".parse().unwrap());\n\n    let cookies = remove_all_values(&mut headers, SET_COOKIE);\n    assert_eq!(cookies.len(), 3);\n    assert_eq!(headers.len(), 0);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::table_zeroed", "code": "pub fn size(&self) -> u32 {\n        match self {\n            Table::Static { size, .. } => *size,\n            Table::Dynamic { elements, .. } => elements.len().try_into().unwrap(),\n        }\n    }", "test": "fn table_zeroed() -> Result<()> {\n    if skip_pooling_allocator_tests() {\n        return Ok(());\n    }\n\n    let pool = crate::small_pool_config();\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(&engine, r#\"(module (table (export \"t\") 10 funcref))\"#)?;\n\n    // Instantiate the module repeatedly after filling table elements\n    for _ in 0..10 {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let table = instance.get_table(&mut store, \"t\").unwrap();\n        let f = Func::wrap(&mut store, || {});\n\n        assert_eq!(table.size(&store), 10);\n\n        for i in 0..10 {\n            match table.get(&mut store, i).unwrap() {\n                Val::FuncRef(r) => assert!(r.is_none()),\n                _ => panic!(\"expected a funcref\"),\n            }\n            table\n                .set(&mut store, i, Val::FuncRef(Some(f.clone())))\n                .unwrap();\n        }\n    }\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/kv_service.rs::test_debug_region_info", "code": "pub fn unwrap(self) -> T {\n        match self {\n            Res::Ok(t) | Res::Truncated(t) | Res::Overflow(t) => t,\n        }\n    }", "test": "fn test_debug_region_info() {\n    let (cluster, debug_client, store_id) = must_new_cluster_and_debug_client();\n\n    let raft_engine = cluster.get_raft_engine(store_id);\n    let kv_engine = cluster.get_engine(store_id);\n\n    let region_id = 100;\n    let mut raft_state = raft_serverpb::RaftLocalState::default();\n    raft_state.set_last_index(42);\n    let mut lb = raft_engine.log_batch(0);\n    lb.put_raft_state(region_id, &raft_state).unwrap();\n    raft_engine.consume(&mut lb, false).unwrap();\n    assert_eq!(\n        raft_engine.get_raft_state(region_id).unwrap().unwrap(),\n        raft_state\n    );\n\n    let apply_state_key = keys::apply_state_key(region_id);\n    let mut apply_state = raft_serverpb::RaftApplyState::default();\n    apply_state.set_applied_index(42);\n    kv_engine\n        .put_msg_cf(CF_RAFT, &apply_state_key, &apply_state)\n        .unwrap();\n    assert_eq!(\n        kv_engine\n            .get_msg_cf::<raft_serverpb::RaftApplyState>(CF_RAFT, &apply_state_key)\n            .unwrap()\n            .unwrap(),\n        apply_state\n    );\n\n    let region_state_key = keys::region_state_key(region_id);\n    let mut region_state = raft_serverpb::RegionLocalState::default();\n    region_state.set_state(raft_serverpb::PeerState::Tombstone);\n    kv_engine\n        .put_msg_cf(CF_RAFT, &region_state_key, &region_state)\n        .unwrap();\n    assert_eq!(\n        kv_engine\n            .get_msg_cf::<raft_serverpb::RegionLocalState>(CF_RAFT, &region_state_key)\n            .unwrap()\n            .unwrap(),\n        region_state\n    );\n\n    // Debug region_info\n    let mut req = debugpb::RegionInfoRequest::default();\n    req.set_region_id(region_id);\n    let mut resp = debug_client.region_info(&req).unwrap();\n    assert_eq!(resp.take_raft_local_state(), raft_state);\n    assert_eq!(resp.take_raft_apply_state(), apply_state);\n    assert_eq!(resp.take_region_local_state(), region_state);\n\n    req.set_region_id(region_id + 1);\n    match debug_client.region_info(&req).unwrap_err() {\n        Error::RpcFailure(status) => {\n            assert_eq!(status.code(), RpcStatusCode::NOT_FOUND);\n        }\n        _ => panic!(\"expect NotFound\"),\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_all_commands", "code": "pub fn is_some(&self) -> bool {\n        self.max_expire_ts.is_some() || self.min_expire_ts.is_some()\n    }", "test": "fn save_point_all_commands() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    db.engine.put(b\"a\", b\"\").unwrap();\n    db.engine.put(b\"d\", b\"\").unwrap();\n\n    wb.set_save_point();\n    wb.delete(b\"a\").unwrap();\n    wb.put(b\"b\", b\"\").unwrap();\n    wb.delete_range(b\"c\", b\"e\").unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n    wb.write().unwrap();\n\n    let a = db.engine.get_value(b\"a\").unwrap();\n    let b = db.engine.get_value(b\"b\").unwrap();\n    let d = db.engine.get_value(b\"d\").unwrap();\n    assert!(a.is_some());\n    assert!(b.is_none());\n    assert!(d.is_some());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    for i in 0..max_keys / 2 {\n        db.engine.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n    db.engine.put(b\"a\", b\"\").unwrap();\n    for i in max_keys / 2..max_keys {\n        db.engine.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n    db.engine.put(b\"d\", b\"\").unwrap();\n\n    wb.set_save_point();\n    for i in 0..max_keys / 2 {\n        wb.delete(&i.to_be_bytes()).unwrap();\n    }\n    wb.delete(b\"a\").unwrap();\n    wb.put(b\"b\", b\"\").unwrap();\n    wb.delete_range(b\"c\", b\"e\").unwrap();\n    wb.delete_range(&(max_keys / 3).to_be_bytes(), &(2 * max_keys).to_be_bytes())\n        .unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n    wb.write().unwrap();\n\n    let a = db.engine.get_value(b\"a\").unwrap();\n    let b = db.engine.get_value(b\"b\").unwrap();\n    let d = db.engine.get_value(b\"d\").unwrap();\n    for i in 0..max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_some());\n    }\n    assert!(a.is_some());\n    assert!(b.is_none());\n    assert!(d.is_some());\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_lint_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn ci_lint_error() {\n    let mut fs = MemoryFileSystem::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), LINT_ERROR.as_bytes());\n\n    let mut console = BufferConsole::default();\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_lint_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_creating_leading_dirs_with_multiple_sources_and_target_dir", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_creating_leading_dirs_with_multiple_sources_and_target_dir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let source1 = \"source_file_1\";\n    let source2 = \"source_file_2\";\n    let target_dir = \"missing_target_dir\";\n\n    at.touch(source1);\n    at.touch(source2);\n\n    // installing multiple files into a missing directory will fail, when -D is used w/o -t parameter\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source1)\n        .arg(source2)\n        .arg(at.plus(target_dir))\n        .fails()\n        .stderr_contains(\"missing_target_dir' is not a directory\");\n\n    assert!(!at.dir_exists(target_dir));\n\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source1)\n        .arg(source2)\n        .arg(\"-t\")\n        .arg(at.plus(target_dir))\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(target_dir));\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::stop_stream", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn stop_stream() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n\n    info!(\"stopping stream\");\n    const ERROR: VarInt = VarInt(42);\n    pair.server_recv(server_ch, s).stop(ERROR).unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n\n    assert_matches!(\n        pair.client_send(client_ch, s).write(b\"foo\"),\n        Err(WriteError::Stopped(ERROR))\n    );\n    assert_matches!(\n        pair.client_send(client_ch, s).finish(),\n        Err(FinishError::Stopped(ERROR))\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_creating_leading_dirs_verbose", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_creating_leading_dirs_verbose() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let source = \"create_leading_test_file\";\n    let target = \"dir1/no-dir2/no-dir3/test_file\";\n\n    at.touch(source);\n    at.mkdir(\"dir1\");\n\n    let creating_dir1 = regex::Regex::new(\"(?m)^install: creating directory.*dir1'$\").unwrap();\n    let creating_nodir23 =\n        regex::Regex::new(r\"(?m)^install: creating directory.*no-dir[23]'$\").unwrap();\n\n    scene\n        .ucmd()\n        .arg(\"-Dv\")\n        .arg(source)\n        .arg(at.plus(target))\n        .succeeds()\n        .stdout_matches(&creating_nodir23)\n        .stdout_does_not_match(&creating_dir1)\n        .no_stderr();\n\n    assert!(at.file_exists(target));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_num_prefixed_chunks_by_lines", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "test": "fn test_split_num_prefixed_chunks_by_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_num_prefixed_chunks_by_lines\";\n    RandomFile::new(&at, name).add_lines(10000);\n    ucmd.args(&[\"-d\", \"-l\", \"1000\", name, \"c\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"c\\d\\d$\");\n    assert_eq!(glob.count(), 10);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_analyze.rs::test_analyze_sampling_reservoir", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_analyze_sampling_reservoir() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, None, 4),\n        (6, Some(\"name:1\"), 1),\n        (7, Some(\"name:1\"), 1),\n        (8, Some(\"name:1\"), 1),\n        (9, Some(\"name:2\"), 1),\n        (10, Some(\"name:2\"), 1),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = init_data_with_commit(&product, &data, true);\n\n    // Pass the 2nd column as a column group.\n    let req = new_analyze_sampling_req(&product, 1, 5, 0.0);\n    let resp = handle_request(&endpoint, req);\n    assert!(!resp.get_data().is_empty());\n    let mut analyze_resp = AnalyzeColumnsResp::default();\n    analyze_resp.merge_from_bytes(resp.get_data()).unwrap();\n    let collector = analyze_resp.get_row_collector();\n    assert_eq!(collector.get_samples().len(), 5);\n    // The column group is at 4th place and the data should be equal to the 2nd.\n    assert_eq!(collector.get_null_counts(), vec![0, 1, 0, 1]);\n    assert_eq!(collector.get_count(), 9);\n    assert_eq!(collector.get_fm_sketch().len(), 4);\n    assert_eq!(collector.get_total_size(), vec![72, 56, 9, 56]);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_overwrite_nonempty_dir", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_mv_overwrite_nonempty_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir_a = \"test_mv_overwrite_nonempty_dir_a\";\n    let dir_b = \"test_mv_overwrite_nonempty_dir_b\";\n    let dummy = \"test_mv_overwrite_nonempty_dir_b/file\";\n\n    at.mkdir(dir_a);\n    at.mkdir(dir_b);\n    at.touch(dummy);\n    // Not same error as GNU; the error message is a rust builtin\n    // TODO: test (and implement) correct error message (or at least decide whether to do so)\n    // Current: \"mv: couldn't rename path (Directory not empty; from=a; to=b)\"\n    // GNU:     \"mv: cannot move 'a' to 'b': Directory not empty\"\n\n    // Verbose output for the move should not be shown on failure\n    let result = ucmd.arg(\"-vT\").arg(dir_a).arg(dir_b).fails();\n    result.no_stdout();\n    assert!(!result.stderr_str().is_empty());\n\n    assert!(at.dir_exists(dir_a));\n    assert!(at.dir_exists(dir_b));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_numbered_if_existing_backup_nil", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_numbered_if_existing_backup_nil() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n    let file_b_backup = \"test_mv_backup_numbering_file_b.~1~\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.touch(file_b_backup);\n    ucmd.arg(\"--backup=nil\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(file_b_backup));\n    assert!(at.file_exists(format!(\"{file_b}.~2~\")));\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/algorithm_tests.rs::test_try_parse_8digits", "code": "pub fn parse<N: FromLexical, Bytes: AsRef<[u8]>>(bytes: Bytes) -> Result<N> {\n    N::from_lexical(bytes.as_ref())\n}", "test": "fn test_try_parse_8digits() {\n    let parse = |bytes: &[u8]| {\n        let mut digits = bytes.bytes::<{ STANDARD }>();\n        algorithm::try_parse_8digits::<u64, _, STANDARD>(&mut digits.integer_iter())\n    };\n\n    assert_eq!(parse(b\"12345678\"), Some(12345678));\n    assert_eq!(parse(b\"1234567\"), None);\n    assert_eq!(parse(b\"1234567\\x00\"), None);\n    assert_eq!(parse(b\"1234567.\"), None);\n    assert_eq!(parse(b\"1234567_\"), None);\n    assert_eq!(parse(b\"12345678\"), Some(12345678));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/resource_metering/test_dynamic_config.rs::test_enable", "code": "pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }", "test": "pub fn test_enable() {\n    let mut test_suite = TestSuite::new(resource_metering::Config {\n        receiver_address: \"\".to_string(),\n        report_receiver_interval: ReadableDuration::millis(2500),\n        max_resource_groups: 5000,\n        precision: ReadableDuration::secs(1),\n    });\n\n    let port = alloc_port();\n    test_suite.start_receiver_at(port);\n\n    // Workload\n    // [req-1, req-2]\n    test_suite.setup_workload(vec![\"req-1\", \"req-2\"]);\n\n    // | Address |\n    // |   x     |\n    sleep(Duration::from_millis(3000));\n    assert!(test_suite.nonblock_receiver_all().is_empty());\n\n    // | Address |\n    // |   o     |\n    test_suite.cfg_receiver_address(format!(\"127.0.0.1:{}\", port));\n    let res = test_suite.block_receive_one();\n    assert!(res.contains_key(\"req-1\"));\n    assert!(res.contains_key(\"req-2\"));\n\n    // | Address |\n    // |   x     |\n    test_suite.cfg_receiver_address(\"\");\n    test_suite.flush_receiver();\n    sleep(Duration::from_millis(3000));\n    assert!(test_suite.nonblock_receiver_all().is_empty());\n\n    // | Address |\n    // |   o     |\n    test_suite.cfg_receiver_address(format!(\"127.0.0.1:{}\", port));\n    let res = test_suite.block_receive_one();\n    assert!(res.contains_key(\"req-1\"));\n    assert!(res.contains_key(\"req-2\"));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/batch-system/tests/cases/batch.rs::test_batch", "code": "fn lock(primary: &[u8]) -> PessimisticLock {\n        PessimisticLock {\n            primary: primary.to_vec().into_boxed_slice(),\n            start_ts: 100.into(),\n            ttl: 3000,\n            for_update_ts: 110.into(),\n            min_commit_ts: 110.into(),\n            last_change_ts: 105.into(),\n            versions_to_last_change: 2,\n        }\n    }", "test": "fn test_batch() {\n    let (control_tx, control_fsm) = Runner::new(10);\n    let (router, mut system) =\n        batch_system::create_system(&Config::default(), control_tx, control_fsm, None);\n    let builder = Builder::new();\n    let metrics = builder.metrics.clone();\n    system.spawn(\"test\".to_owned(), builder);\n    let mut expected_metrics = HandleMetrics::default();\n    assert_eq!(*metrics.lock().unwrap(), expected_metrics);\n    let (tx, rx) = mpsc::unbounded();\n    let tx_ = tx.clone();\n    let r = router.clone();\n    router\n        .send_control(Message::Callback(Box::new(\n            move |_: &Handler, _: &mut Runner| {\n                let (tx, runner) = Runner::new(10);\n                let mailbox = BasicMailbox::new(tx, runner, Arc::default());\n                r.register(1, mailbox);\n                tx_.send(1).unwrap();\n            },\n        )))\n        .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(1));\n    // sleep to wait Batch-System to finish calling end().\n    sleep(Duration::from_millis(20));\n    router\n        .send(\n            1,\n            Message::Callback(Box::new(move |_: &Handler, _: &mut Runner| {\n                tx.send(2).unwrap();\n            })),\n        )\n        .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(2));\n    system.shutdown();\n    expected_metrics.control = 1;\n    expected_metrics.normal = 1;\n    expected_metrics.begin = 2;\n    assert_eq!(*metrics.lock().unwrap(), expected_metrics);\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::push_request_against_concurrency", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "test": "async fn push_request_against_concurrency() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        client\n            .assert_server_handshake_with_settings(frames::settings().max_concurrent_streams(1))\n            .await;\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"https://example.com/\")\n                    .eos(),\n            )\n            .await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 2).request(\"GET\", \"https://http2.akamai.com/style.css\"),\n            )\n            .await;\n        client.recv_frame(frames::headers(2).response(200)).await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 4).request(\"GET\", \"https://http2.akamai.com/style2.css\"),\n            )\n            .await;\n        client.recv_frame(frames::data(2, &b\"\"[..]).eos()).await;\n        client\n            .recv_frame(frames::headers(4).response(200).eos())\n            .await;\n        client\n            .recv_frame(frames::headers(1).response(200).eos())\n            .await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        // Promise stream 2 and start response (concurrency limit reached)\n        let mut s2_tx = {\n            let req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style.css\")\n                .body(())\n                .unwrap();\n            let mut pushed_stream = stream.push_request(req).unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            pushed_stream.send_response(rsp, false).unwrap()\n        };\n\n        // Promise stream 4 and push response\n        {\n            let pushed_req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style2.css\")\n                .body(())\n                .unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream\n                .push_request(pushed_req)\n                .unwrap()\n                .send_response(rsp, true)\n                .unwrap();\n        }\n\n        // Send and finish response for stream 1\n        {\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream.send_response(rsp, true).unwrap();\n        }\n\n        // Finish response for stream 2 (at which point stream 4 will be sent)\n        s2_tx.send_data(vec![0; 0].into(), true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, srv).await;\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hostname.rs::test_hostname_ip", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_hostname_ip() {\n    let result = new_ucmd!().arg(\"-i\").succeeds();\n    assert!(!result.stdout_str().trim().is_empty());\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/cases/config_extends.rs::extends_should_raise_an_error_for_unresolved_configuration_and_show_verbose", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn extends_should_raise_an_error_for_unresolved_configuration_and_show_verbose() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = Path::new(\"biome.json\");\n    fs.insert(\n        rome_json.into(),\n        r#\"{ \"extends\": [\"formatTYPO.json\", \"linter.json\"] }\"#,\n    );\n    let format = Path::new(\"format.json\");\n    fs.insert(\n        format.into(),\n        r#\"{ \"javascript\": { \"formatter\": { \"quoteStyle\": \"single\" } } }\"#,\n    );\n    let lint = Path::new(\"linter.json\");\n    fs.insert(lint.into(), r#\"{ \"linter\": { \"enabled\": false } }\"#);\n\n    let test_file = Path::new(\"test.js\");\n    fs.insert(test_file.into(), r#\"debugger; console.log(\"string\"); \"#);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"check\"),\n                \"--verbose\",\n                test_file.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"extends_should_raise_an_error_for_unresolved_configuration_and_show_verbose\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::div_plus_load_reported_right", "code": "pub fn call(mut self) -> Self {\n        self.is_call = true;\n        self\n    }", "test": "fn div_plus_load_reported_right() -> Result<()> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, ());\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"memory\") 1)\n                (func (export \"i32.div_s\") (param i32 i32) (result i32)\n                    (i32.div_s (local.get 0) (i32.load (local.get 1))))\n                (func (export \"i32.div_u\") (param i32 i32) (result i32)\n                    (i32.div_u (local.get 0) (i32.load (local.get 1))))\n                (func (export \"i32.rem_s\") (param i32 i32) (result i32)\n                    (i32.rem_s (local.get 0) (i32.load (local.get 1))))\n                (func (export \"i32.rem_u\") (param i32 i32) (result i32)\n                    (i32.rem_u (local.get 0) (i32.load (local.get 1))))\n            )\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let memory = instance.get_memory(&mut store, \"memory\").unwrap();\n    let i32_div_s = instance.get_typed_func::<(i32, i32), i32>(&mut store, \"i32.div_s\")?;\n    let i32_div_u = instance.get_typed_func::<(u32, u32), u32>(&mut store, \"i32.div_u\")?;\n    let i32_rem_s = instance.get_typed_func::<(i32, i32), i32>(&mut store, \"i32.rem_s\")?;\n    let i32_rem_u = instance.get_typed_func::<(u32, u32), u32>(&mut store, \"i32.rem_u\")?;\n\n    memory.write(&mut store, 0, &1i32.to_le_bytes()).unwrap();\n    memory.write(&mut store, 4, &0i32.to_le_bytes()).unwrap();\n    memory.write(&mut store, 8, &(-1i32).to_le_bytes()).unwrap();\n\n    assert_eq!(i32_div_s.call(&mut store, (100, 0))?, 100);\n    assert_eq!(i32_div_u.call(&mut store, (101, 0))?, 101);\n    assert_eq!(i32_rem_s.call(&mut store, (102, 0))?, 0);\n    assert_eq!(i32_rem_u.call(&mut store, (103, 0))?, 0);\n\n    assert_trap(\n        i32_div_s.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n    assert_trap(\n        i32_div_u.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n    assert_trap(\n        i32_rem_s.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n    assert_trap(\n        i32_rem_u.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n\n    assert_trap(\n        i32_div_s.call(&mut store, (i32::MIN, 8)),\n        Trap::IntegerOverflow,\n    );\n    assert_eq!(i32_rem_s.call(&mut store, (i32::MIN, 8))?, 0);\n\n    assert_trap(\n        i32_div_s.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n    assert_trap(\n        i32_div_u.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n    assert_trap(\n        i32_rem_s.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n    assert_trap(\n        i32_rem_u.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n\n    return Ok(());\n\n    #[track_caller]\n    fn assert_trap<T>(result: Result<T>, expected: Trap) {\n        match result {\n            Ok(_) => panic!(\"expected failure\"),\n            Err(e) => {\n                if let Some(code) = e.downcast_ref::<Trap>() {\n                    if *code == expected {\n                        return;\n                    }\n                }\n                panic!(\"unexpected error {e:?}\");\n            }\n        }\n    }\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::range_query_reversed", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn range_query_reversed() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.range(3..7).unwrap().rev();\n    for i in (3..7u64).rev() {\n        let (key, value) = iter.next().unwrap().unwrap();\n        assert_eq!(i, key.value());\n        assert_eq!(i, value.value());\n    }\n    assert!(iter.next().is_none());\n\n    // Test reversing multiple times\n    let mut iter = table.range(3..7).unwrap();\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(3, key.value());\n\n    let mut iter = iter.rev();\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(6, key.value());\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(5, key.value());\n\n    let mut iter = iter.rev();\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(4, key.value());\n\n    assert!(iter.next().is_none());\n}"}
{"test_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/tests/empty-read.rs::gzip_encoder_empty_read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }", "test": "fn gzip_encoder_empty_read() {\n    let original: &[u8] = b\"Lorem ipsum dolor sit amet.\";\n    let mut encoder = flate2::read::GzEncoder::new(original, flate2::Compression::default());\n    assert_eq!(encoder.read(&mut []).unwrap(), 0);\n    let mut encoded = Vec::new();\n    encoder.read_to_end(&mut encoded).unwrap();\n    let mut decoder = flate2::read::GzDecoder::new(encoded.as_slice());\n    let mut decoded = Vec::new();\n    decoder.read_to_end(&mut decoded).unwrap();\n    assert_eq!(decoded.as_slice(), original);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/batch-system/tests/cases/batch.rs::test_resource_group", "code": "pub fn recv_timeout<S, I>(s: &mut S, dur: std::time::Duration) -> Result<Option<I>, ()>\nwhere\n    S: Stream<Item = I> + Unpin,\n{\n    poll_timeout(&mut s.next(), dur)\n}", "test": "fn test_resource_group() {\n    let (control_tx, control_fsm) = Runner::new(10);\n    let resource_manager = ResourceGroupManager::default();\n\n    let get_group = |name: &str, read_tokens: u64, write_tokens: u64| -> ResourceGroup {\n        let mut group = ResourceGroup::new();\n        group.set_name(name.to_string());\n        group.set_mode(GroupMode::RawMode);\n        let mut resource_setting = GroupRawResourceSettings::new();\n        resource_setting\n            .mut_cpu()\n            .mut_settings()\n            .set_fill_rate(read_tokens);\n        resource_setting\n            .mut_io_write()\n            .mut_settings()\n            .set_fill_rate(write_tokens);\n        group.set_raw_resource_settings(resource_setting);\n        group\n    };\n\n    resource_manager.add_resource_group(get_group(\"group1\", 10, 10));\n    resource_manager.add_resource_group(get_group(\"group2\", 100, 100));\n\n    let mut cfg = Config::default();\n    cfg.pool_size = 1;\n    let (router, mut system) = batch_system::create_system(\n        &cfg,\n        control_tx,\n        control_fsm,\n        Some(resource_manager.derive_controller(\"test\".to_string(), false)),\n    );\n    let builder = Builder::new();\n    system.spawn(\"test\".to_owned(), builder);\n    let (tx, rx) = mpsc::unbounded();\n    let tx_ = tx.clone();\n    let r = router.clone();\n    let state_cnt = Arc::new(AtomicUsize::new(0));\n    router\n        .send_control(Message::Callback(Box::new(\n            move |_: &Handler, _: &mut Runner| {\n                let (tx, runner) = Runner::new(10);\n                r.register(1, BasicMailbox::new(tx, runner, state_cnt.clone()));\n                let (tx2, runner2) = Runner::new(10);\n                r.register(2, BasicMailbox::new(tx2, runner2, state_cnt));\n                tx_.send(0).unwrap();\n            },\n        )))\n        .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(0));\n\n    let tx_ = tx.clone();\n    let (tx1, rx1) = std::sync::mpsc::sync_channel(0);\n    // block the thread\n    router\n        .send_control(Message::Callback(Box::new(\n            move |_: &Handler, _: &mut Runner| {\n                tx_.send(0).unwrap();\n                tx1.send(0).unwrap();\n            },\n        )))\n        .unwrap();\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(0));\n\n    router\n        .send(1, Message::Resource(\"group1\".to_string(), 1))\n        .unwrap();\n    let tx_ = tx.clone();\n    router\n        .send(\n            1,\n            Message::Callback(Box::new(move |_: &Handler, _: &mut Runner| {\n                tx_.send(1).unwrap();\n            })),\n        )\n        .unwrap();\n\n    router\n        .send(2, Message::Resource(\"group2\".to_string(), 1))\n        .unwrap();\n    router\n        .send(\n            2,\n            Message::Callback(Box::new(move |_: &Handler, _: &mut Runner| {\n                tx.send(2).unwrap();\n            })),\n        )\n        .unwrap();\n\n    // pause the blocking thread\n    assert_eq!(rx1.recv_timeout(Duration::from_secs(3)), Ok(0));\n\n    // should recv from group2 first, because group2 has more tokens and it would be\n    // handled with higher priority.\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(2));\n    assert_eq!(rx.recv_timeout(Duration::from_secs(3)), Ok(1));\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/config_tests.rs::test_parse_toml", "code": "pub fn get_listen_port(&self) -> u16 {\n        self.listen_port.unwrap_or(DEFAULT_PORT)\n    }", "test": "fn test_parse_toml() {\n    let config = Config::from_toml(\"listen_port = 2053\").unwrap();\n    assert_eq!(config.get_listen_port(), 2053);\n\n    let config = Config::from_toml(\"listen_addrs_ipv4 = [\\\"0.0.0.0\\\"]\").unwrap();\n    assert_eq!(\n        config.get_listen_addrs_ipv4(),\n        Ok(vec![Ipv4Addr::new(0, 0, 0, 0)])\n    );\n\n    let config = Config::from_toml(\"listen_addrs_ipv4 = [\\\"0.0.0.0\\\", \\\"127.0.0.1\\\"]\").unwrap();\n    assert_eq!(\n        config.get_listen_addrs_ipv4(),\n        Ok(vec![Ipv4Addr::new(0, 0, 0, 0), Ipv4Addr::new(127, 0, 0, 1)])\n    );\n\n    let config = Config::from_toml(\"listen_addrs_ipv6 = [\\\"::0\\\"]\").unwrap();\n    assert_eq!(\n        config.get_listen_addrs_ipv6(),\n        Ok(vec![Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)])\n    );\n\n    let config = Config::from_toml(\"listen_addrs_ipv6 = [\\\"::0\\\", \\\"::1\\\"]\").unwrap();\n    assert_eq!(\n        config.get_listen_addrs_ipv6(),\n        Ok(vec![\n            Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0),\n            Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1),\n        ])\n    );\n\n    let config = Config::from_toml(\"tcp_request_timeout = 25\").unwrap();\n    assert_eq!(config.get_tcp_request_timeout(), Duration::from_secs(25));\n\n    let config = Config::from_toml(\"log_level = \\\"Debug\\\"\").unwrap();\n    assert_eq!(config.get_log_level(), tracing::Level::DEBUG);\n\n    let config = Config::from_toml(\"directory = \\\"/dev/null\\\"\").unwrap();\n    assert_eq!(config.get_directory(), Path::new(\"/dev/null\"));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_only_mtime", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_only_mtime() {\n    let mtime_args = [\"-m\", \"--time=modify\", \"--time=mtime\"];\n    let file = \"test_touch_set_only_mtime\";\n\n    for mtime_arg in mtime_args {\n        let (at, mut ucmd) = at_and_ucmd!();\n\n        ucmd.args(&[\"-t\", \"201501011234\", mtime_arg, file])\n            .succeeds()\n            .no_stderr();\n\n        assert!(at.file_exists(file));\n\n        let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n        let (atime, mtime) = get_file_times(&at, file);\n        assert!(atime != mtime);\n        assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    }\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_context_merge_custom", "code": "pub fn get_attr(&self, key: &str) -> Result<Value, Error> {\n        Ok(match self.0 {\n            ValueRepr::Undefined => return Err(Error::from(ErrorKind::UndefinedError)),\n            ValueRepr::Map(ref items, _) => items.get(&KeyRef::Str(key)).cloned(),\n            ValueRepr::Dynamic(ref dy) => match dy.kind() {\n                ObjectKind::Struct(s) => s.get_field(key),\n                ObjectKind::Plain | ObjectKind::Seq(_) => None,\n            },\n            _ => None,\n        }\n        .unwrap_or(Value::UNDEFINED))\n    }", "test": "fn test_context_merge_custom() {\n    struct X;\n    impl StructObject for X {\n        fn get_field(&self, name: &str) -> Option<Value> {\n            match name {\n                \"a\" => Some(Value::from(1)),\n                \"b\" => Some(Value::from(2)),\n                _ => None,\n            }\n        }\n    }\n\n    let x = Value::from_struct_object(X);\n    let ctx = context! { a => 42, ..x };\n\n    assert_eq!(ctx.get_attr(\"a\").unwrap(), Value::from(42));\n    assert_eq!(ctx.get_attr(\"b\").unwrap(), Value::from(2));\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/preserve_sequence.rs::test_sequence_ex1", "code": "fn read_original(source: &str) -> String {\n    source.to_string().replace(\"\\r\\n\", \"\\n\")\n}", "test": "fn test_sequence_ex1() {\n    let file = include_str!(\"preserve_sequence_ex1.ron\");\n    assert_eq!(read_original(file), make_roundtrip(file));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression7", "code": "pub(crate) fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.page.memory()[self.value_range.clone()])\n    }", "test": "fn regression7() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let big_value = vec![0u8; 4063];\n        t.insert(&35723, big_value.as_slice()).unwrap();\n        t.remove(&145278).unwrap();\n        t.remove(&145227).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let mut tx = db.begin_write().unwrap();\n    tx.set_durability(Durability::None);\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 47];\n        t.insert(&66469, v.as_slice()).unwrap();\n        let v = vec![0u8; 2414];\n        t.insert(&146255, v.as_slice()).unwrap();\n        let v = vec![0u8; 159];\n        t.insert(&153701, v.as_slice()).unwrap();\n        let v = vec![0u8; 1186];\n        t.insert(&145227, v.as_slice()).unwrap();\n        let v = vec![0u8; 223];\n        t.insert(&118749, v.as_slice()).unwrap();\n\n        t.remove(&145227).unwrap();\n\n        let mut iter = t.range(138763..(138763 + 232359)).unwrap().rev();\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 153701);\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 146255);\n        assert!(iter.next().is_none());\n    }\n    tx.commit().unwrap();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/mod.rs::test_block_cache_backward_compatible", "code": "pub fn is_none(&self) -> bool {\n        !self.is_some()\n    }", "test": "fn test_block_cache_backward_compatible() {\n    let content = read_file_in_project_dir(\"integrations/config/test-cache-compatible.toml\");\n    let mut cfg: TikvConfig = toml::from_str(&content).unwrap();\n    assert!(cfg.storage.block_cache.capacity.is_none());\n    cfg.compatible_adjust();\n    assert!(cfg.storage.block_cache.capacity.is_some());\n    assert_eq!(\n        cfg.storage.block_cache.capacity.unwrap().0,\n        cfg.rocksdb.defaultcf.block_cache_size.0\n            + cfg.rocksdb.writecf.block_cache_size.0\n            + cfg.rocksdb.lockcf.block_cache_size.0\n            + cfg.raftdb.defaultcf.block_cache_size.0\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_short_no_overwrite", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_mv_arg_update_short_no_overwrite() {\n    // same as --update=older\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_none_file1\";\n    let new = \"test_mv_arg_update_none_file2\";\n    let old_content = \"file1 content\\n\";\n    let new_content = \"file2 content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"-u\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), new_content);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u16_pow10_test", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "test": "fn u16_pow10_test() {\n    let values: &[u16] = &[\n        0, 1, 5, 9, 10, 11, 15, 99, 100, 101, 105, 999, 1000, 1001, 1005, 9999, 10000, 10001, 10005,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::keep_alive", "code": "pub fn is_closed(&self) -> bool {\n        self.state.is_closed()\n    }", "test": "fn keep_alive() {\n    let _guard = subscribe();\n    const IDLE_TIMEOUT: u64 = 10;\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            keep_alive_interval: Some(Duration::from_millis(IDLE_TIMEOUT / 2)),\n            max_idle_timeout: Some(VarInt(IDLE_TIMEOUT)),\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    // Run a good while longer than the idle timeout\n    let end = pair.time + Duration::from_millis(20 * IDLE_TIMEOUT);\n    while pair.time < end {\n        if !pair.step() {\n            if let Some(time) = min_opt(pair.client.next_wakeup(), pair.server.next_wakeup()) {\n                pair.time = time;\n            }\n        }\n        assert!(!pair.client_conn_mut(client_ch).is_closed());\n        assert!(!pair.server_conn_mut(server_ch).is_closed());\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_lines", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file_read = |f| {\n        let mut s = String::new();\n        at.open(f).read_to_string(&mut s).unwrap();\n        s\n    };\n\n    // Split into two files without splitting up lines.\n    ucmd.args(&[\"-n\", \"l/2\", \"fivelines.txt\"]).succeeds();\n\n    assert_eq!(file_read(\"xaa\"), \"1\\n2\\n3\\n\");\n    assert_eq!(file_read(\"xab\"), \"4\\n5\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_existing", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_backup_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=existing\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_older_dest_not_older_than_src", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_update_older_dest_not_older_than_src() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_dest_not_older_file1\";\n    let new = \"test_cp_arg_update_dest_not_older_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"--update=older\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"new content\\n\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/relocs.rs::backwards_call_works", "code": "fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n            .await?;\n\n            proxy\n                .wasi_http_incoming_handler()\n                .call_handle(store, req, out)\n                .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    }", "test": "fn backwards_call_works() -> Result<()> {\n    let mut store = store_with_padding(128 * MB)?;\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (module\n                (func (result i32)\n                    i32.const 4)\n                (func (export \"foo\") (result i32)\n                    call 0)\n            )\n        \"#,\n    )?;\n\n    let i = Instance::new(&mut store, &module, &[])?;\n    let foo = i.get_typed_func::<(), i32>(&mut store, \"foo\")?;\n    assert_eq!(foo.call(&mut store, ())?, 4);\n    Ok(())\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/tests-gen/streamid.rs::test_something", "code": "pub fn initiator(self) -> Side {\n        if self.0 & 0x1 == 0 {\n            Side::Client\n        } else {\n            Side::Server\n        }\n    }", "test": "fn test_something() {\n    let data = [];\n    let s = StreamId::new(data.side, data.dir, data.index);\n    assert_eq!(s.initiator(), data.side);\n    assert_eq!(s.dir(), data.dir);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::does_error_with_only_warnings", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn does_error_with_only_warnings() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(\n        file_path.into(),\n        r#\"\n{\n    \"formatter\": { \"enabled\": false},\n  \"linter\": {\n    \"rules\": {\n        \"recommended\": true,\n        \"suspicious\": {\n            \"noClassAssign\": \"warn\"\n        }\n    }\n  }\n}\n        \"#\n        .as_bytes(),\n    );\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(\n        file_path.into(),\n        r#\"class A {};\nA = 0;\n\"#\n        .as_bytes(),\n    );\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                \"ci\",\n                \"--error-on-warnings\",\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"does_error_with_only_warnings\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_points_and_counts", "code": "pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }", "test": "fn save_points_and_counts() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.rollback_to_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.pop_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.clear();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.write().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.rollback_to_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.write().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.pop_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), 1);\n\n    wb.clear();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.rollback_to_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.pop_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.clear();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.write().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.rollback_to_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    wb.set_save_point();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.write().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.pop_save_point().unwrap();\n\n    assert_eq!(wb.is_empty(), false);\n    assert_eq!(wb.count(), max_keys);\n\n    wb.clear();\n\n    assert_eq!(wb.is_empty(), true);\n    assert_eq!(wb.count(), 0);\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_close_notify", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn server_close_notify() {\n    let kt = KeyType::Rsa;\n    let server_config = Arc::new(make_server_config_with_mandatory_client_auth(kt));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions_with_auth(kt, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n        do_handshake(&mut client, &mut server);\n\n        // check that alerts don't overtake appdata\n        assert_eq!(\n            12,\n            server\n                .writer()\n                .write(b\"from-server!\")\n                .unwrap()\n        );\n        assert_eq!(\n            12,\n            client\n                .writer()\n                .write(b\"from-client!\")\n                .unwrap()\n        );\n        server.send_close_notify();\n\n        transfer(&mut server, &mut client);\n        let io_state = client.process_new_packets().unwrap();\n        assert!(io_state.peer_has_closed());\n        check_read_and_close(&mut client.reader(), b\"from-server!\");\n\n        transfer(&mut client, &mut server);\n        server.process_new_packets().unwrap();\n        check_read(&mut server.reader(), b\"from-client!\");\n    }\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::send_data_without_requesting_capacity", "code": "pub fn capacity(&self, stream: &mut store::Ptr) -> WindowSize {\n        stream.capacity(self.prioritize.max_buffer_size())\n    }", "test": "async fn send_data_without_requesting_capacity() {\n    h2_support::trace_init!();\n\n    let payload = vec![0; 1024];\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        .write(&[\n            // POST /\n            0, 0, 16, 1, 4, 0, 0, 0, 1, 131, 135, 65, 139, 157, 41, 172, 75, 143, 168, 233, 25, 151,\n            33, 233, 132,\n        ])\n        .write(&[\n            // DATA\n            0, 4, 0, 0, 1, 0, 0, 0, 1,\n        ])\n        .write(&payload[..])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[0, 0, 1, 1, 5, 0, 0, 0, 1, 0x89])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    let request = Request::builder()\n        .method(Method::POST)\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    let (response, mut stream) = client.send_request(request, false).unwrap();\n\n    // The capacity should be immediately allocated\n    assert_eq!(stream.capacity(), 0);\n\n    // Send the data\n    stream.send_data(payload.into(), true).unwrap();\n\n    // Get the response\n    let resp = h2.run(response).await.unwrap();\n    assert_eq!(resp.status(), StatusCode::NO_CONTENT);\n\n    h2.await.unwrap();\n}"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_float_f32_rounding", "code": "pub fn compute_float32(q: i32, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        many_digits: false,\n    };\n    let fp = bellerophon::<f32>(&num);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_float_f32_rounding() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_float32(0, 16777216), (151, 0));\n    assert_eq!(compute_float32(0, 16777217), (151, 0));\n    assert_eq!(compute_float32(0, 16777218), (151, 1));\n    assert_eq!(compute_float32(0, 16777219), (151, 2));\n    assert_eq!(compute_float32(0, 16777220), (151, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float32(-10, 167772160000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772170000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772180000000000), (151, 1));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(compute_float32(-10, 167772190000000000), (151, 2));\n    assert_eq!(compute_float32(-10, 167772200000000000), (151, 2));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::str_type", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn str_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<&str, &str> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n\n    let mut iter = table.iter().unwrap();\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), \"world\");\n    assert!(iter.next().is_none());\n\n    let mut iter: Range<&str, &str> = table.range(\"a\"..\"z\").unwrap();\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), \"world\");\n    assert!(iter.next().is_none());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_joint_consensus.rs::test_restart_in_joint_state", "code": "pub fn is_in_joint(&self, region_id: u64) -> bool {\n        let region = block_on(self.get_region_by_id(region_id))\n            .unwrap()\n            .expect(\"region not exist\");\n        region.get_peers().iter().any(|p| {\n            p.get_role() == PeerRole::IncomingVoter || p.get_role() == PeerRole::DemotingVoter\n        })\n    }", "test": "fn test_restart_in_joint_state() {\n    let mut cluster = new_node_cluster(0, 3);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n    pd_client.must_add_peer(region_id, new_learner_peer(3, 3));\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    // Enter joint\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddLearnerNode, new_learner_peer(2, 2)),\n            (ConfChangeType::AddNode, new_peer(3, 3)),\n        ],\n    );\n    assert!(pd_client.is_in_joint(region_id));\n\n    cluster.stop_node(1);\n    sleep_ms(50);\n\n    cluster.run_node(1).unwrap();\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    // Still in joint state\n    assert!(pd_client.is_in_joint(region_id));\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(2), b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(3), b\"k2\", b\"v2\");\n\n    // Leave joint\n    pd_client.must_leave_joint(region_id);\n\n    // Joint confchange finished\n    let region = cluster.get_region(b\"k2\");\n    must_has_peer(&region, 1, PeerRole::Voter);\n    must_has_peer(&region, 2, PeerRole::Learner);\n    must_has_peer(&region, 3, PeerRole::Voter);\n}"}
{"test_id": "zip-rs-zip/zip-rs-zip-ed187d6/tests/zip_crypto.rs::encrypted_file", "code": "pub fn len(&self) -> usize {\n        self.shared.files.len()\n    }", "test": "fn encrypted_file() {\n    let zip_file_bytes = &mut Cursor::new(vec![\n        0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x54, 0xbd, 0xb5, 0x50, 0x2f,\n        0x20, 0x79, 0x55, 0x2f, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,\n        0x74, 0x65, 0x73, 0x74, 0x2e, 0x74, 0x78, 0x74, 0xca, 0x2d, 0x1d, 0x27, 0x19, 0x19, 0x63,\n        0x43, 0x77, 0x9a, 0x71, 0x76, 0xc9, 0xec, 0xd1, 0x6f, 0xd9, 0xf5, 0x22, 0x67, 0xb3, 0x8f,\n        0x52, 0xb5, 0x41, 0xbc, 0x5c, 0x36, 0xf2, 0x1d, 0x84, 0xc3, 0xc0, 0x28, 0x3b, 0xfd, 0xe1,\n        0x70, 0xc2, 0xcc, 0x0c, 0x11, 0x0c, 0xc5, 0x95, 0x2f, 0xa4, 0x50, 0x4b, 0x01, 0x02, 0x3f,\n        0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x54, 0xbd, 0xb5, 0x50, 0x2f, 0x20, 0x79, 0x55,\n        0x2f, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x08, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x65, 0x73, 0x74,\n        0x2e, 0x74, 0x78, 0x74, 0x0a, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18,\n        0x00, 0x31, 0xb2, 0x3b, 0xbf, 0xb8, 0x2f, 0xd6, 0x01, 0x31, 0xb2, 0x3b, 0xbf, 0xb8, 0x2f,\n        0xd6, 0x01, 0xa8, 0xc4, 0x45, 0xbd, 0xb8, 0x2f, 0xd6, 0x01, 0x50, 0x4b, 0x05, 0x06, 0x00,\n        0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ]);\n\n    let mut archive = zip::ZipArchive::new(zip_file_bytes).unwrap();\n\n    assert_eq!(archive.len(), 1); //Only one file inside archive: `test.txt`\n\n    {\n        // No password\n        let file = archive.by_index(0);\n        match file {\n            Err(zip::result::ZipError::UnsupportedArchive(\n                zip::result::ZipError::PASSWORD_REQUIRED,\n            )) => (),\n            Err(_) => panic!(\n                \"Expected PasswordRequired error when opening encrypted file without password\"\n            ),\n            Ok(_) => panic!(\"Error: Successfully opened encrypted file without password?!\"),\n        }\n    }\n\n    {\n        // Wrong password\n        let file = archive.by_index_decrypt(0, b\"wrong password\");\n        match file {\n            Ok(Err(zip::result::InvalidPassword)) => (),\n            Err(_) => panic!(\n                \"Expected InvalidPassword error when opening encrypted file with wrong password\"\n            ),\n            Ok(Ok(_)) => panic!(\"Error: Successfully opened encrypted file with wrong password?!\"),\n        }\n    }\n\n    {\n        // Correct password, read contents\n        let mut file = archive\n            .by_index_decrypt(0, \"test\".as_bytes())\n            .unwrap()\n            .unwrap();\n        let file_name = file.enclosed_name().unwrap();\n        assert_eq!(file_name, std::path::PathBuf::from(\"test.txt\"));\n\n        let mut data = Vec::new();\n        file.read_to_end(&mut data).unwrap();\n        assert_eq!(data, \"abcdefghijklmnopqrstuvwxyz123456789\".as_bytes());\n    }\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/tests/main.rs::cover_offset", "code": "pub fn cover_offset(self, offset: TextSize) -> TextRange {\n        self.cover(TextRange::empty(offset))\n    }", "test": "fn cover_offset() {\n    assert_eq!(range(1..3).cover_offset(size(0)), range(0..3));\n    assert_eq!(range(1..3).cover_offset(size(1)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(2)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(3)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(4)), range(1..4));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::array_type", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn array_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<&[u8; 5], &[u8; 9]> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(b\"hello\", b\"world_123\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    let hello = b\"hello\";\n    assert_eq!(b\"world_123\", table.get(hello).unwrap().unwrap().value());\n\n    let mut iter: Range<&[u8; 5], &[u8; 9]> = table.range::<&[u8; 5]>(..).unwrap();\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), b\"world_123\");\n    assert!(iter.next().is_none());\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::shl_test", "code": "pub(crate) fn from_u32(x: &[u32]) -> Vec<Limb> {\n    x.iter().cloned().collect()\n}", "test": "fn shl_test() {\n    // Pattern generated via `''.join([\"1\" +\"0\"*i for i in range(20)])`\n    let mut big = Bigint {\n        data: from_u32(&[0xD2210408]),\n    };\n    big.ishl(5);\n    assert_eq!(big.data, from_u32(&[0x44208100, 0x1A]));\n    big.ishl(32);\n    assert_eq!(big.data, from_u32(&[0, 0x44208100, 0x1A]));\n    big.ishl(27);\n    assert_eq!(big.data, from_u32(&[0, 0, 0xD2210408]));\n\n    // 96-bits of previous pattern\n    let mut big = Bigint {\n        data: from_u32(&[0x20020010, 0x8040100, 0xD2210408]),\n    };\n    big.ishl(5);\n    assert_eq!(big.data, from_u32(&[0x400200, 0x802004, 0x44208101, 0x1A]));\n    big.ishl(32);\n    assert_eq!(\n        big.data,\n        from_u32(&[0, 0x400200, 0x802004, 0x44208101, 0x1A])\n    );\n    big.ishl(27);\n    assert_eq!(\n        big.data,\n        from_u32(&[0, 0, 0x20020010, 0x8040100, 0xD2210408])\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_lines", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_semicolon_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--lines=2\", \"-t\", \";\", \"separator_semicolon.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1;2;\");\n    assert_eq!(file_read(&at, \"xab\"), \"3;4;\");\n    assert_eq!(file_read(&at, \"xac\"), \"5;\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/issues.rs::issue_655", "code": "fn twolines(i: &str) -> IResult<&str, (&str, &str)> {\n    let (i, l1) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n    let (i, l2) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n\n    Ok((i, (l1, l2)))\n  }", "test": "fn issue_655() {\n  use nom::character::streaming::{line_ending, not_line_ending};\n  fn twolines(i: &str) -> IResult<&str, (&str, &str)> {\n    let (i, l1) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n    let (i, l2) = not_line_ending(i)?;\n    let (i, _) = line_ending(i)?;\n\n    Ok((i, (l1, l2)))\n  }\n\n  assert_eq!(twolines(\"foo\\nbar\\n\"), Ok((\"\", (\"foo\", \"bar\"))));\n  assert_eq!(twolines(\"f\u00e9o\\nbar\\n\"), Ok((\"\", (\"f\u00e9o\", \"bar\"))));\n  assert_eq!(twolines(\"fo\u00e9\\nbar\\n\"), Ok((\"\", (\"fo\u00e9\", \"bar\"))));\n  assert_eq!(twolines(\"fo\u00e9\\r\\nbar\\n\"), Ok((\"\", (\"fo\u00e9\", \"bar\"))));\n}\n\n#[cf"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/common_test.rs::test_log10_pow5", "code": "pub fn log10_pow5(e: i32) -> u32 /* or u32 -> u32 */ {\n    // The first value this approximation fails for is 5^2621 which is just greater than 10^1832.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 2620);\n    (e as u32 * 732923) >> 20\n}", "test": "fn test_log10_pow5() {\n    assert_eq!(0, log10_pow5(0));\n    assert_eq!(0, log10_pow5(1));\n    assert_eq!(1, log10_pow5(2));\n    assert_eq!(2, log10_pow5(3));\n    assert_eq!(2, log10_pow5(4));\n    assert_eq!(1831, log10_pow5(2620));\n}"}
{"test_id": "bodil-im-rs/bodil-im-rs-2afaf54/tests-gen/ordset.rs::test_something", "code": "pub fn len(&self) -> usize {\n        self.size\n    }", "test": "fn test_something() {\n    let data = [];\n    let mut set = OrdSet::new();\n    let mut nat = NatSet::new();\n    for action in actions {\n        match action {\n            Action::Insert(value) => {\n                let len = nat.len() + if nat.contains(&value) { 0 } else { 1 };\n                nat.insert(value);\n                set.insert(value);\n                assert_eq!(len, set.len());\n            }\n            Action::Remove(value) => {\n                let len = nat.len() - if nat.contains(&value) { 1 } else { 0 };\n                nat.remove(&value);\n                set.remove(&value);\n                assert_eq!(len, set.len());\n            }\n        }\n        assert_eq!(nat.len(), set.len());\n        assert_eq!(OrdSet::from(nat.clone()), set);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_for_learner", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_force_leader_for_learner() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 5;\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration::millis(40);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store5 = find_peer(&region, 5).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store5.clone());\n\n    let peer_on_store1 = find_peer(&region, 1).unwrap();\n    // replace one peer with learner\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), peer_on_store1.clone());\n    cluster.pd_client.must_add_peer(\n        region.get_id(),\n        new_learner_peer(peer_on_store1.get_store_id(), peer_on_store1.get_id()),\n    );\n    // Sleep 100 ms to wait for the new learner to be initialized.\n    sleep_ms(100);\n\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    confirm_quorum_is_lost(&mut cluster, &region);\n\n    // wait election timeout\n    std::thread::sleep(Duration::from_millis(\n        cluster.cfg.raft_store.raft_election_timeout_ticks as u64\n            * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n            * 2,\n    ));\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // promote the learner first and remove the peers on failed nodes\n    cluster\n        .pd_client\n        .must_add_peer(region.get_id(), find_peer(&region, 1).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k2\"), None);\n    assert_eq!(cluster.must_get(b\"k3\"), None);\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n    cluster.must_transfer_leader(region.get_id(), find_peer(&region, 1).unwrap().clone());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_no_change_to_user_group", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_no_change_to_user_group() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n    let result = scene.cmd(\"id\").arg(\"-ng\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let group_name = String::from(result.stdout_str().trim());\n    assert!(!group_name.is_empty());\n\n    for (i, from) in [\"42\", \":42\", \"42:42\"].iter().enumerate() {\n        let file = i.to_string();\n        at.touch(&file);\n        scene\n            .ucmd()\n            .arg(\"-v\")\n            .arg(format!(\"--from={from}\"))\n            .arg(\"43:43\")\n            .arg(&file)\n            .succeeds()\n            .stdout_only(format!(\n                \"ownership of '{file}' retained as {user_name}:{group_name}\\n\"\n            ));\n    }\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/trailers.rs::send_trailers_immediately", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "test": "async fn send_trailers_immediately() {\n    h2_support::trace_init!();\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        // Write GET /\n        .write(&[\n            0, 0, 0x10, 1, 4, 0, 0, 0, 1, 0x82, 0x87, 0x41, 0x8B, 0x9D, 0x29, 0xAC, 0x4B, 0x8F,\n            0xA8, 0xE9, 0x19, 0x97, 0x21, 0xE9, 0x84, 0, 0, 0x0A, 1, 5, 0, 0, 0, 1, 0x40, 0x83,\n            0xF6, 0x7A, 0x66, 0x84, 0x9C, 0xB4, 0x50, 0x7F,\n        ])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[\n            0, 0, 1, 1, 4, 0, 0, 0, 1, 0x88, 0, 0, 0x0B, 0, 1, 0, 0, 0, 1, 0x68, 0x65, 0x6C, 0x6C,\n            0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64,\n        ])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    // Send the request\n    let request = Request::builder()\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    tracing::info!(\"sending request\");\n    let (response, mut stream) = client.send_request(request, false).unwrap();\n\n    let mut trailers = HeaderMap::new();\n    trailers.insert(\"zomg\", \"hello\".parse().unwrap());\n\n    stream.send_trailers(trailers).unwrap();\n\n    let response = h2.run(response).await.unwrap();\n    assert_eq!(response.status(), StatusCode::OK);\n\n    let (_, mut body) = response.into_parts();\n\n    // There is a data chunk\n    let _ = h2.run(body.next()).await.unwrap().unwrap();\n\n    let chunk = h2.run(body.next()).await;\n    assert!(chunk.is_none());\n\n    let trailers = h2.run(poll_fn(|cx| body.poll_trailers(cx))).await.unwrap();\n    assert!(trailers.is_none());\n\n    h2.await.unwrap();\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/restore.rs::restore_generates_same_descriptors_with_passphrase", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "test": "fn restore_generates_same_descriptors_with_passphrase() {\n  let passphrase = \"foo\";\n  let (mnemonic, descriptors) = {\n    let rpc_server = test_bitcoincore_rpc::spawn();\n\n    let create::Output { mnemonic, .. } =\n      CommandBuilder::new([\"wallet\", \"create\", \"--passphrase\", passphrase])\n        .rpc_server(&rpc_server)\n        .run_and_deserialize_output();\n\n    (mnemonic, rpc_server.descriptors())\n  };\n\n  let rpc_server = test_bitcoincore_rpc::spawn();\n\n  CommandBuilder::new([\n    \"wallet\",\n    \"restore\",\n    \"--passphrase\",\n    passphrase,\n    &mnemonic.to_string(),\n  ])\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Empty>();\n\n  assert_eq!(rpc_server.descriptors(), descriptors);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_stack_overflow", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "test": "fn test_trap_stack_overflow() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module $rec_mod\n            (func $run (export \"run\") (call $run))\n        )\n    \"#;\n\n    let module = Module::new(store.engine(), wat)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func.call(&mut store, ()).unwrap_err();\n\n    let trace = e.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert!(trace.len() >= 32);\n    for i in 0..trace.len() {\n        assert_eq!(trace[i].module().name().unwrap(), \"rec_mod\");\n        assert_eq!(trace[i].func_index(), 0);\n        assert_eq!(trace[i].func_name(), Some(\"run\"));\n    }\n    assert_eq!(e.downcast::<Trap>()?, Trap::StackOverflow);\n\n    Ok(())\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_compare_and_swap_multi", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_compare_and_swap_multi() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // create a record\n    let mut current = RecordSet::with_ttl(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n\n    let current1 = current\n        .new_record(&RData::A(A::new(100, 10, 100, 10)))\n        .clone();\n    let current2 = current\n        .new_record(&RData::A(A::new(100, 10, 100, 11)))\n        .clone();\n    let current = current;\n\n    let result = io_loop\n        .block_on(client.create(current.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let mut new = RecordSet::with_ttl(current.name().clone(), current.record_type(), current.ttl());\n    let new1 = new.new_record(&RData::A(A::new(100, 10, 101, 10))).clone();\n    let new2 = new.new_record(&RData::A(A::new(100, 10, 101, 11))).clone();\n    let new = new;\n\n    let result = io_loop\n        .block_on(client.compare_and_swap(current.clone(), new.clone(), origin.clone()))\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(new.name().clone(), new.dns_class(), new.record_type()))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n    assert!(result.answers().iter().any(|rr| *rr == new1));\n    assert!(result.answers().iter().any(|rr| *rr == new2));\n    assert!(!result.answers().iter().any(|rr| *rr == current1));\n    assert!(!result.answers().iter().any(|rr| *rr == current2));\n\n    // check the it fails if tried again.\n    let mut not = new1.clone();\n    not.set_data(Some(RData::A(A::new(102, 12, 102, 12))));\n    let not = not;\n\n    let result = io_loop\n        .block_on(client.compare_and_swap(current, not.clone(), origin))\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    let result = io_loop\n        .block_on(client.query(new.name().clone(), new.dns_class(), new.record_type()))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n    assert!(result.answers().iter().any(|rr| *rr == new1));\n    assert!(!result.answers().iter().any(|rr| *rr == not));\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_append", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_append() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n    let record = record;\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), true))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    // next append to a non-existent RRset\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), false))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // will fail if already set and not the same value.\n    let mut record2 = record.clone();\n    record2.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let record2 = record2;\n\n    let result = io_loop\n        .block_on(client.append(record2.clone(), origin.clone(), true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n\n    assert!(result.answers().iter().any(|rr| *rr == record));\n    assert!(result.answers().iter().any(|rr| *rr == record2));\n\n    // show that appending the same thing again is ok, but doesn't add any records\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin, true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_lease_read.rs::test_infinite_lease", "code": "pub fn len(&self) -> usize {\n        match_template_evaltype! {\n            TT, match self {\n                VectorValue::TT(v) => v.len(),\n            }\n        }\n    }", "test": "fn test_infinite_lease() {\n    let mut cluster = new_node_cluster(0, 3);\n    // Avoid triggering the log compaction in this test case.\n    cluster.cfg.raft_store.raft_log_gc_threshold = 100;\n    // Increase the Raft tick interval to make this test case running reliably.\n    // Use large election timeout to make leadership stable.\n    configure_for_lease_read(&mut cluster.cfg, Some(50), Some(10_000));\n    // Override max leader lease to 2 seconds.\n    let max_lease = Duration::from_secs(2);\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration(max_lease);\n\n    let peer = new_peer(1, 1);\n    cluster.pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    let key = b\"k\";\n    cluster.must_put(key, b\"v0\");\n    for id in 2..=cluster.engines.len() as u64 {\n        cluster.pd_client.must_add_peer(region_id, new_peer(id, id));\n        must_get_equal(&cluster.get_engine(id), key, b\"v0\");\n    }\n\n    // Force `peer` to become leader.\n    let region = cluster.get_region(key);\n    let region_id = region.get_id();\n    cluster.must_transfer_leader(region_id, peer.clone());\n\n    let detector = LeaseReadFilter::default();\n    cluster.add_send_filter(CloneFilterFactory(detector.clone()));\n\n    // Issue a read request and check the value on response.\n    must_read_on_peer(&mut cluster, peer.clone(), region.clone(), key, b\"v0\");\n    assert_eq!(detector.ctx.rl().len(), 0);\n\n    // Wait for the leader lease to expire.\n    thread::sleep(max_lease);\n\n    // Check if renew-lease-tick proposed a read index and renewed the leader lease.\n    assert_eq!(cluster.leader_of_region(region_id), Some(peer.clone()));\n    assert_eq!(detector.ctx.rl().len(), 1);\n    // Issue a read request to verify the lease.\n    must_read_on_peer(&mut cluster, peer.clone(), region, key, b\"v0\");\n    assert_eq!(cluster.leader_of_region(region_id), Some(peer));\n    assert_eq!(detector.ctx.rl().len(), 1);\n\n    // renew-lease-tick shouldn't propose any request if the leader lease is not\n    // expired.\n    for _ in 0..4 {\n        cluster.must_put(key, b\"v0\");\n        thread::sleep(max_lease / 4);\n    }\n    assert_eq!(detector.ctx.rl().len(), 1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_witness.rs::test_witness_raftlog_gc_after_reboot", "code": "pub fn len(&self) -> usize {\n        self.events.len()\n    }", "test": "fn test_witness_raftlog_gc_after_reboot() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(100);\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(50);\n    cluster\n        .cfg\n        .raft_store\n        .request_voter_replicated_index_interval = ReadableDuration::millis(100);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.must_put(b\"k0\", b\"v0\");\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap().clone();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1);\n    // nonwitness -> witness\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n    cluster.pd_client.must_switch_witnesses(\n        region.get_id(),\n        vec![peer_on_store3.get_id()],\n        vec![true],\n    );\n\n    // make sure raft log gc is triggered\n    std::thread::sleep(Duration::from_millis(200));\n    let mut before_states = HashMap::default();\n    for (&id, engines) in &cluster.engines {\n        let mut state: RaftApplyState = get_raft_msg_or_default(engines, &keys::apply_state_key(1));\n        before_states.insert(id, state.take_truncated_state());\n    }\n\n    // one follower is down\n    cluster.stop_node(nodes[1]);\n\n    // write some data to make log gap exceeds the gc limit\n    for i in 1..1000 {\n        let (k, v) = (format!(\"k{}\", i), format!(\"v{}\", i));\n        let key = k.as_bytes();\n        let value = v.as_bytes();\n        cluster.must_put(key, value);\n    }\n\n    // the witness truncated index is not advanced\n    for (&id, engines) in &cluster.engines {\n        let state: RaftApplyState = get_raft_msg_or_default(engines, &keys::apply_state_key(1));\n        if id == 2 {\n            assert_eq!(\n                state.get_truncated_state().get_index() - before_states[&id].get_index(),\n                0\n            );\n        } else {\n            assert_ne!(\n                900,\n                state.get_truncated_state().get_index() - before_states[&id].get_index()\n            );\n        }\n    }\n\n    fail::cfg(\"on_raft_gc_log_tick\", \"return\").unwrap();\n\n    // the follower is back online\n    cluster.run_node(nodes[1]).unwrap();\n    cluster.must_put(b\"k00\", b\"v00\");\n    must_get_equal(&cluster.get_engine(nodes[1]), b\"k00\", b\"v00\");\n\n    // the witness is down\n    cluster.stop_node(nodes[2]);\n    std::thread::sleep(Duration::from_millis(100));\n    // the witness is back online\n    cluster.run_node(nodes[2]).unwrap();\n\n    // make sure raft log gc is triggered\n    std::thread::sleep(Duration::from_millis(300));\n\n    // the truncated index is advanced now, as all the peers has replicated\n    for (&id, engines) in &cluster.engines {\n        let state: RaftApplyState = get_raft_msg_or_default(engines, &keys::apply_state_key(1));\n        assert_ne!(\n            900,\n            state.get_truncated_state().get_index() - before_states[&id].get_index()\n        );\n    }\n    fail::remove(\"on_raft_gc_log_tick\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_none_then_all", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_update_none_then_all() {\n    // take last if multiple update args are supplied,\n    // update=all wins in this case\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_none_then_all_file1\";\n    let new = \"test_cp_arg_update_none_then_all_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"--update=none\")\n        .arg(\"--update=all\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"old content\\n\");\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::multiple_tables", "code": "fn len(&self) -> Result<u64> {\n        let mut count = 0;\n        for item in self.iter()? {\n            let (_, values) = item?;\n            for v in values {\n                v?;\n                count += 1;\n            }\n        }\n        Ok(count)\n    }", "test": "fn multiple_tables() {\n    let definition1: TableDefinition<&str, &str> = TableDefinition::new(\"1\");\n    let definition2: TableDefinition<&str, &str> = TableDefinition::new(\"2\");\n\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition1).unwrap();\n        let mut table2 = write_txn.open_table(definition2).unwrap();\n\n        table.insert(\"hello\", \"world\").unwrap();\n        table2.insert(\"hello\", \"world2\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition1).unwrap();\n    let table2 = read_txn.open_table(definition2).unwrap();\n    assert_eq!(table.len().unwrap(), 1);\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert_eq!(table2.len().unwrap(), 1);\n    assert_eq!(\"world2\", table2.get(\"hello\").unwrap().unwrap().value());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_server_catching_api_error", "code": "pub fn has_region_error(&self) -> bool {\n        matches!(\n            self,\n            Error::Kv(KvError(box EngineErrorInner::Request(_)))\n                | Error::Txn(TxnError(box TxnErrorInner::Engine(KvError(\n                    box EngineErrorInner::Request(_),\n                ))))\n                | Error::Txn(TxnError(box TxnErrorInner::Mvcc(MvccError(\n                    box MvccErrorInner::Kv(KvError(box EngineErrorInner::Request(_))),\n                ))))\n                | Error::Request(_)\n        )\n    }", "test": "fn test_server_catching_api_error() {\n    let raftkv_fp = \"raftkv_early_error_report\";\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n    let region = cluster.get_region(b\"\");\n    let leader = region.get_peers()[0].clone();\n\n    fail::cfg(raftkv_fp, \"return\").unwrap();\n\n    let env = Arc::new(Environment::new(1));\n    let channel =\n        ChannelBuilder::new(env).connect(&cluster.sim.rl().get_addr(leader.get_store_id()));\n    let client = TikvClient::new(channel);\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region.get_id());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n    ctx.set_peer(leader);\n\n    let mut prewrite_req = PrewriteRequest::default();\n    prewrite_req.set_context(ctx.clone());\n    let mutation = kvrpcpb::Mutation {\n        op: Op::Put,\n        key: b\"k3\".to_vec(),\n        value: b\"v3\".to_vec(),\n        ..Default::default()\n    };\n    prewrite_req.set_mutations(vec![mutation].into_iter().collect());\n    prewrite_req.primary_lock = b\"k3\".to_vec();\n    prewrite_req.start_version = 1;\n    prewrite_req.lock_ttl = prewrite_req.start_version + 1;\n    let prewrite_resp = client.kv_prewrite(&prewrite_req).unwrap();\n    assert!(prewrite_resp.has_region_error(), \"{:?}\", prewrite_resp);\n    assert!(\n        prewrite_resp.get_region_error().has_region_not_found(),\n        \"{:?}\",\n        prewrite_resp\n    );\n    must_get_none(&cluster.get_engine(1), b\"k3\");\n\n    let mut put_req = RawPutRequest::default();\n    put_req.set_context(ctx);\n    put_req.key = b\"k3\".to_vec();\n    put_req.value = b\"v3\".to_vec();\n    let put_resp = client.raw_put(&put_req).unwrap();\n    assert!(put_resp.has_region_error(), \"{:?}\", put_resp);\n    assert!(\n        put_resp.get_region_error().has_region_not_found(),\n        \"{:?}\",\n        put_resp\n    );\n    must_get_none(&cluster.get_engine(1), b\"k3\");\n\n    fail::remove(raftkv_fp);\n    let put_resp = client.raw_put(&put_req).unwrap();\n    assert!(!put_resp.has_region_error(), \"{:?}\", put_resp);\n    must_get_equal(&cluster.get_engine(1), b\"k3\", b\"v3\");\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/mod.rs::spread_in_arrow_function", "code": "pub const fn flags(&self) -> FormalParameterListFlags {\n        self.flags\n    }", "test": "fn spread_in_arrow_function() {\n    let s = r#\"\n    (...b) => {\n        b\n    }\n    \"#;\n\n    let interner = &mut Interner::default();\n    let b = interner.get_or_intern_static(\"b\", utf16!(\"b\"));\n    let params = FormalParameterList::from(FormalParameter::new(\n        Variable::from_identifier(b.into(), None),\n        true,\n    ));\n    assert_eq!(params.flags(), FormalParameterListFlags::HAS_REST_PARAMETER);\n    assert_eq!(params.length(), 0);\n    check_script_parser(\n        s,\n        vec![Statement::Expression(Expression::from(ArrowFunction::new(\n            None,\n            params,\n            FunctionBody::new(\n                vec![Statement::Expression(Expression::from(Identifier::from(b))).into()].into(),\n            ),\n        )))\n        .into()],\n        interner,\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/stack_overflow.rs::big_stack_works_ok", "code": "pub fn call(\n        &self,\n        mut store: impl AsContextMut,\n        params: &[Val],\n        results: &mut [Val],\n    ) -> Result<()> {\n        assert!(\n            !store.as_context().async_support(),\n            \"must use `call_async` when async support is enabled on the config\",\n        );\n        self.call_impl(&mut store.as_context_mut(), params, results)\n    }", "test": "fn big_stack_works_ok() -> Result<()> {\n    const N: usize = 10000;\n\n    // Build a module with a function that uses a very large amount of stack space,\n    // modeled here by calling an i64-returning-function many times followed by\n    // adding them all into one i64.\n    //\n    // This should exercise the ability to consume multi-page stacks and\n    // only touch a few internals of it at a time.\n    let mut s = String::new();\n    s.push_str(\"(module\\n\");\n    s.push_str(\"(func (export \\\"\\\") (result i64)\\n\");\n    s.push_str(\"i64.const 0\\n\");\n    for _ in 0..N {\n        s.push_str(\"call $get\\n\");\n    }\n    for _ in 0..N {\n        s.push_str(\"i64.add\\n\");\n    }\n    s.push_str(\")\\n\");\n    s.push_str(\"(func $get (result i64) i64.const 0)\\n\");\n    s.push_str(\")\\n\");\n\n    let mut store = Store::<()>::default();\n    let module = Module::new(store.engine(), &s)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let func = instance.get_typed_func::<(), i64>(&mut store, \"\")?;\n    assert_eq!(func.call(&mut store, ())?, 0);\n    Ok(())\n}"}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::capture_index_lifetime", "code": "fn inner(s: &str) -> usize {\n        let re = regex!(r\"(?P<number>\\d+)\");\n        let caps = re.captures(t!(s)).unwrap();\n        caps[\"number\"].len()\n    }", "test": "fn capture_index_lifetime() {\n    // This is a test of whether the types on `caps[\"...\"]` are general\n    // enough. If not, this will fail to typecheck.\n    fn inner(s: &str) -> usize {\n        let re = regex!(r\"(?P<number>\\d+)\");\n        let caps = re.captures(t!(s)).unwrap();\n        caps[\"number\"].len()\n    }\n    assert_eq!(3, inner(\"123\"));\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::test_wasmer_run_complex_url", "code": "pub fn contains<S>(&self, name: S) -> bool\n    where\n        S: Into<String>,\n    {\n        self.map.contains_key(&name.into())\n    }", "test": "fn test_wasmer_run_complex_url() {\n    let wasm_test_path = fixtures::qjs();\n    let wasm_test_path = wasm_test_path.canonicalize().unwrap_or(wasm_test_path);\n    let mut wasm_test_path = format!(\"{}\", wasm_test_path.display());\n    if wasm_test_path.starts_with(r#\"\\\\?\\\"#) {\n        wasm_test_path = wasm_test_path.replacen(r#\"\\\\?\\\"#, \"\", 1);\n    }\n    #[cfg(target_os = \"windows\")]\n    {\n        wasm_test_path = wasm_test_path.replace(\"D:\\\\\", \"D://\");\n        wasm_test_path = wasm_test_path.replace(\"C:\\\\\", \"C://\");\n        wasm_test_path = wasm_test_path.replace(\"c:\\\\\", \"c://\");\n        wasm_test_path = wasm_test_path.replace(\"\\\\\", \"/\");\n        // wasmer run used to fail on c:\\Users\\username\\wapm_packages\\ ...\n        assert!(\n            wasm_test_path.contains(\"://\"),\n            \"wasm_test_path path is not complex enough\"\n        );\n    }\n\n    Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(wasm_test_path)\n        .arg(\"--\")\n        .arg(\"-q\")\n        .assert()\n        .success();\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::nth_bit_test", "code": "pub(crate) fn nth_bit(n: u64) -> u64 {\n    let bits: u64 = mem::size_of::<u64>() as u64 * 8;\n    debug_assert!(n < bits, \"nth_bit() overflow in shl.\");\n\n    1 << n\n}", "test": "fn nth_bit_test() {\n    assert_eq!(nth_bit(0u64), 0b1);\n    assert_eq!(nth_bit(1u64), 0b10);\n    assert_eq!(nth_bit(2u64), 0b100);\n    assert_eq!(nth_bit(10u64), 0b10000000000);\n    assert_eq!(nth_bit(31u64), 0b10000000000000000000000000000000);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/test_config_client.rs::test_update_config", "code": "pub fn get_current(&self) -> TikvConfig {\n        self.inner.read().unwrap().current.clone()\n    }", "test": "fn test_update_config() {\n    let (mut cfg, _dir) = TikvConfig::with_tmp().unwrap();\n    cfg.validate().unwrap();\n    let cfg_controller = ConfigController::new(cfg);\n    let mut cfg = cfg_controller.get_current();\n\n    // normal update\n    cfg_controller\n        .update(change(\"raftstore.raft-log-gc-threshold\", \"2000\"))\n        .unwrap();\n    cfg.raft_store.raft_log_gc_threshold = 2000;\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // update not support config\n    let res = cfg_controller.update(change(\"server.addr\", \"localhost:3000\"));\n    res.unwrap_err();\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // update to invalid config\n    let res = cfg_controller.update(change(\"raftstore.raft-log-gc-threshold\", \"0\"));\n    res.unwrap_err();\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // bad update request\n    let res = cfg_controller.update(change(\"xxx.yyy\", \"0\"));\n    res.unwrap_err();\n    let res = cfg_controller.update(change(\"raftstore.xxx\", \"0\"));\n    res.unwrap_err();\n    let res = cfg_controller.update(change(\"raftstore.raft-log-gc-threshold\", \"10MB\"));\n    res.unwrap_err();\n    let res = cfg_controller.update(change(\"raft-log-gc-threshold\", \"10MB\"));\n    res.unwrap_err();\n    assert_eq!(cfg_controller.get_current(), cfg);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::pass_moved_resource", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "test": "fn pass_moved_resource() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (core module $m\n                    (func (export \"f\") (param i32 i32))\n                )\n                (core instance $i (instantiate $m))\n\n                (func (export \"f\") (param \"x\" (own $t)) (param \"y\" (borrow $t))\n                    (canon lift (core func $i \"f\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>, &Resource<MyType>), ()>(&mut store, \"f\")?;\n\n    let resource = Resource::new_own(100);\n    let err = f.call(&mut store, (&resource, &resource)).unwrap_err();\n    assert!(\n        format!(\"{err:?}\").contains(\"host resource already consumed\"),\n        \"bad error: {err:?}\"\n    );\n    Ok(())\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit126_wasi_snapshot1", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "test": "fn exit126_wasi_snapshot1() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit126_wasi_snapshot1.wat\")?;\n    let output = run_wasmtime_for_output(&[wasm.path().to_str().unwrap(), \"-Ccache=n\"], None)?;\n    assert_eq!(output.status.code().unwrap(), 1);\n    assert!(output.stdout.is_empty());\n    assert!(String::from_utf8_lossy(&output.stderr).contains(\"invalid exit status\"));\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_file_into_dir_with_target_arg", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_move_file_into_dir_with_target_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_mv_move_file_into_dir_with_target_arg_dir\";\n    let file = \"test_mv_move_file_into_dir_with_target_arg_file\";\n\n    at.mkdir(dir);\n    at.touch(file);\n\n    ucmd.arg(\"--target\")\n        .arg(dir)\n        .arg(file)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/bellerophon_tests.rs::compute_float_f32_test", "code": "pub fn compute_float32(q: i64, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        is_negative: false,\n        many_digits: false,\n        integer: &[],\n        fraction: None,\n    };\n    let fp = bellerophon::<f32, { STANDARD }>(&num, false);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_float_f32_test() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_float32(0, 16777216), (151, 0));\n    assert_eq!(compute_float32(0, 16777217), (111 + INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_float32(0, 16777218), (151, 1));\n    assert_eq!(compute_float32(0, 16777219), (111 + INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_float32(0, 16777220), (151, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float32(-10, 167772160000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772170000000000), (111 + INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_float32(-10, 167772180000000000), (151, 1));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(compute_float32(-10, 167772190000000000), (111 + INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_float32(-10, 167772200000000000), (151, 2));\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/status_code.rs::is_server_error", "code": "fn is_server_error() {\n    assert!(status_code(500).is_server_error());\n    assert!(status_code(599).is_server_error());\n\n    assert!(!status_code(499).is_server_error());\n    assert!(!status_code(600).is_server_error());\n}", "test": "fn is_server_error() {\n    assert!(status_code(500).is_server_error());\n    assert!(status_code(599).is_server_error());\n\n    assert!(!status_code(499).is_server_error());\n    assert!(!status_code(600).is_server_error());\n}"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/config.rs::c_flags", "code": "fn success(&self) -> usize {\n            self.success.load(Ordering::SeqCst)\n        }", "test": "fn c_flags() {\n    let temp = setup_wasmer_dir();\n    let wasmer_dir = temp.path();\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--bindir\")\n        .assert()\n        .success()\n        .stdout(contains_path(temp.path().join(\"bin\")));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--cflags\")\n        .assert()\n        .success()\n        .stdout(contains(format!(\n            \"-I{}\\n\",\n            wasmer_dir.join(\"include\").display()\n        )));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--includedir\")\n        .assert()\n        .success()\n        .stdout(contains_path(wasmer_dir.join(\"include\")));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--libdir\")\n        .assert()\n        .success()\n        .stdout(contains_path(wasmer_dir.join(\"lib\")));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--libs\")\n        .assert()\n        .stdout(contains(format!(\n            \"-L{} -lwasmer\\n\",\n            wasmer_dir.join(\"lib\").display()\n        )));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--prefix\")\n        .assert()\n        .success()\n        .stdout(contains_path(wasmer_dir));\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--pkg-config\")\n        .output()\n        .unwrap();\n\n    let pkg_config = vec![\n        format!(\"prefix={}\", wasmer_dir.display()),\n        format!(\"exec_prefix={}\", wasmer_dir.join(\"bin\").display()),\n        format!(\"includedir={}\", wasmer_dir.join(\"include\").display()),\n        format!(\"libdir={}\", wasmer_dir.join(\"lib\").display()),\n        format!(\"\"),\n        format!(\"Name: wasmer\"),\n        format!(\"Description: The Wasmer library for running WebAssembly\"),\n        format!(\"Version: {}\", env!(\"CARGO_PKG_VERSION\")),\n        format!(\"Cflags: -I{}\", wasmer_dir.join(\"include\").display()),\n        format!(\"Libs: -L{} -lwasmer\", wasmer_dir.join(\"lib\").display()),\n    ]\n    .join(\"\\n\");\n\n    assert!(output.status.success());\n    let stderr = std::str::from_utf8(&output.stdout)\n        .unwrap()\n        .replace(\"\\r\\n\", \"\\n\");\n    assert_eq!(stderr.trim(), pkg_config.trim());\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--config-path\")\n        .assert()\n        .success()\n        .stdout(contains_path(temp.path().join(\"wasmer.toml\")));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_write_twice_2", "code": "pub fn unwrap(self) -> T {\n        match self {\n            Res::Ok(t) | Res::Truncated(t) | Res::Overflow(t) => t,\n        }\n    }", "test": "fn write_batch_write_twice_2() {\n    let db = default_engine();\n\n    let mut wb = db.engine.write_batch();\n\n    wb.put(b\"a\", b\"aa\").unwrap();\n\n    wb.write().unwrap();\n\n    db.engine.put(b\"a\", b\"b\").unwrap();\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"b\");\n\n    wb.write().unwrap();\n\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"aa\");\n\n    let db = multi_batch_write_engine();\n\n    let mut wb = db.engine.write_batch_with_cap(1024);\n\n    for i in 0..128_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"aa\").unwrap();\n\n    wb.write().unwrap();\n\n    db.engine.put(b\"a\", b\"b\").unwrap();\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"b\");\n\n    for i in 0..128_usize {\n        let k = i.to_be_bytes();\n        let v = (2 * i + 1).to_be_bytes();\n        db.engine.put(&k, &v).unwrap();\n    }\n    for i in 0..128_usize {\n        let k = i.to_be_bytes();\n        let v = (2 * i + 1).to_be_bytes();\n        assert_eq!(db.engine.get_value(&k).unwrap().unwrap(), &v);\n    }\n\n    wb.write().unwrap();\n\n    assert_eq!(db.engine.get_value(b\"a\").unwrap().unwrap(), b\"aa\");\n    for i in 0..128_usize {\n        let x = i.to_be_bytes();\n        assert_eq!(db.engine.get_value(&x).unwrap().unwrap(), &x);\n    }\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::lifecycle", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn lifecycle() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert!(pair.client_conn_mut(client_ch).using_ecn());\n    assert!(pair.server_conn_mut(server_ch).using_ecn());\n\n    const REASON: &[u8] = b\"whee\";\n    info!(\"closing\");\n    pair.client.connections.get_mut(&client_ch).unwrap().close(\n        pair.time,\n        VarInt(42),\n        REASON.into(),\n    );\n    pair.drive();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(),\n                    Some(Event::ConnectionLost { reason: ConnectionError::ApplicationClosed(\n                        ApplicationClose { error_code: VarInt(42), ref reason }\n                    )}) if reason == REASON);\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert_eq!(pair.client.known_connections(), 0);\n    assert_eq!(pair.client.known_cids(), 0);\n    assert_eq!(pair.server.known_connections(), 0);\n    assert_eq!(pair.server.known_cids(), 0);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::rust_catch_panic_import", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "test": "fn rust_catch_panic_import() -> Result<()> {\n    let mut store = Store::<()>::default();\n\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (import \"\" \"panic\" (func $panic))\n                (import \"\" \"catch panic\" (func $catch_panic))\n                (func (export \"panic\") call $panic)\n                (func (export \"run\")\n                  call $catch_panic\n                  call $catch_panic\n                  unreachable\n                )\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let num_panics = std::sync::Arc::new(std::sync::atomic::AtomicU32::new(0));\n    let sig = FuncType::new(None, None);\n    let panic = Func::new(&mut store, sig, {\n        let num_panics = num_panics.clone();\n        move |_, _, _| {\n            num_panics.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n            panic!(\"this is a panic\");\n        }\n    });\n    let catch_panic = Func::wrap(&mut store, |mut caller: Caller<'_, _>| {\n        panic::catch_unwind(AssertUnwindSafe(|| {\n            drop(\n                caller\n                    .get_export(\"panic\")\n                    .unwrap()\n                    .into_func()\n                    .unwrap()\n                    .call(&mut caller, &[], &mut []),\n            );\n        }))\n        .unwrap_err();\n    });\n\n    let instance = Instance::new(&mut store, &module, &[panic.into(), catch_panic.into()])?;\n    let run = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n    let trap = run.call(&mut store, ()).unwrap_err();\n    let trace = trap.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert_eq!(trace.len(), 1);\n    assert_eq!(trace[0].func_index(), 3);\n    assert_eq!(num_panics.load(std::sync::atomic::Ordering::SeqCst), 2);\n    Ok(())\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_iteration", "code": "fn next(&mut self) -> Option<Self::Item> {\n    self.iter.next().map(take)\n  }", "test": "fn ArrayVec_iteration() {\n  let av = array_vec!([i32; 4] => 10, 11, 12, 13);\n\n  let mut i = av.into_iter();\n  assert_eq!(i.next(), Some(10));\n  assert_eq!(i.next(), Some(11));\n  assert_eq!(i.next(), Some(12));\n  assert_eq!(i.next(), Some(13));\n  assert_eq!(i.next(), None);\n\n  let av = array_vec!([i32; 4] => 10, 11, 12, 13);\n\n  let mut av2: ArrayVec<[i32; 4]> = av.clone().into_iter().collect();\n  assert_eq!(av, av2);\n\n  // IntoIterator for &mut ArrayVec\n  for x in &mut av2 {\n    *x = -*x;\n  }\n\n  // IntoIterator for &ArrayVec\n  assert!(av.iter().zip(&av2).all(|(&a, &b)| a == -b));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_total", "code": "fn next(&mut self) -> Option<(Option<usize>, usize)> {\n        match self.max {\n            // iterate until m is reached\n            Some(m) => {\n                if self.cur == m {\n                    None\n                } else {\n                    self.cur += 1;\n                    Some((self.max, self.cur))\n                }\n            }\n            // no limit, just increment a counter\n            None => {\n                self.cur += 1;\n                Some((None, self.cur))\n            }\n        }\n    }", "test": "fn test_total() {\n    // Example output:\n    //\n    //     Filesystem            1K-blocks     Used Available Use% Mounted on\n    //     udev                    3858016        0   3858016   0% /dev\n    //     ...\n    //     /dev/loop14               63488    63488         0 100% /snap/core20/1361\n    //     total                 258775268 98099712 148220200  40% -\n    let output = new_ucmd!().arg(\"--total\").succeeds().stdout_move_str();\n\n    // Skip the header line.\n    let lines: Vec<&str> = output.lines().skip(1).collect();\n\n    // Parse the values from the last row.\n    let last_line = lines.last().unwrap();\n    let mut iter = last_line.split_whitespace();\n    assert_eq!(iter.next().unwrap(), \"total\");\n    let reported_total_size = iter.next().unwrap().parse().unwrap();\n    let reported_total_used = iter.next().unwrap().parse().unwrap();\n    let reported_total_avail = iter.next().unwrap().parse().unwrap();\n\n    // Loop over each row except the last, computing the sum of each column.\n    let mut computed_total_size = 0;\n    let mut computed_total_used = 0;\n    let mut computed_total_avail = 0;\n    let n = lines.len();\n    for line in &lines[..n - 1] {\n        let mut iter = line.split_whitespace();\n        iter.next().unwrap();\n        computed_total_size += iter.next().unwrap().parse::<u64>().unwrap();\n        computed_total_used += iter.next().unwrap().parse::<u64>().unwrap();\n        computed_total_avail += iter.next().unwrap().parse::<u64>().unwrap();\n    }\n\n    // Check that the sum of each column matches the reported value in\n    // the last row.\n    assert_eq!(computed_total_size, reported_total_size);\n    assert_eq!(computed_total_used, reported_total_used);\n    assert_eq!(computed_total_avail, reported_total_avail);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_merge_crash_before_snapshot_then_catch_up_logs", "code": "pub fn get_id(&self) -> ConnId {\n        self.id\n    }", "test": "fn test_node_merge_crash_before_snapshot_then_catch_up_logs() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.merge_max_log_gap = 10;\n    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(11);\n    cluster.cfg.raft_store.raft_log_gc_tick_interval = ReadableDuration::millis(50);\n    // Make merge check resume quickly.\n    cluster.cfg.raft_store.raft_base_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.raft_election_timeout_ticks = 10;\n    // election timeout must be greater than lease\n    cluster.cfg.raft_store.raft_store_max_leader_lease = ReadableDuration::millis(90);\n    cluster.cfg.raft_store.merge_check_tick_interval = ReadableDuration::millis(100);\n    cluster.cfg.raft_store.peer_stale_state_check_interval = ReadableDuration::millis(500);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    let on_raft_gc_log_tick_fp = \"on_raft_gc_log_tick\";\n    fail::cfg(on_raft_gc_log_tick_fp, \"return()\").unwrap();\n\n    cluster.run();\n\n    let mut region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k2\");\n\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k2\").unwrap();\n\n    let left_on_store1 = find_peer(&left, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(left.get_id(), left_on_store1);\n    let right_on_store1 = find_peer(&right, 1).unwrap().to_owned();\n    cluster.must_transfer_leader(right.get_id(), right_on_store1);\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    pd_client.must_merge(left.get_id(), right.get_id());\n\n    region = pd_client.get_region(b\"k1\").unwrap();\n    // Write some logs and the logs' number is greater than\n    // `raft_log_gc_count_limit` for latter log compaction\n    for i in 2..15 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v\");\n    }\n\n    // Aim at making peer 2 only know the compact log but do not know it is\n    // committed\n    let condition = Arc::new(AtomicBool::new(false));\n    let recv_filter = Box::new(\n        RegionPacketFilter::new(region.get_id(), 2)\n            .direction(Direction::Recv)\n            .when(condition.clone())\n            .set_msg_callback(Arc::new(move |msg: &RaftMessage| {\n                if !condition.load(Ordering::Acquire)\n                    && msg.get_message().get_msg_type() == MessageType::MsgAppend\n                    && !msg.get_message().get_entries().is_empty()\n                {\n                    condition.store(true, Ordering::Release);\n                }\n            })),\n    );\n    cluster.sim.wl().add_recv_filter(2, recv_filter);\n\n    let state1 = cluster.truncated_state(region.get_id(), 1);\n    // Remove log compaction failpoint\n    fail::remove(on_raft_gc_log_tick_fp);\n    // Wait to trigger compact raft log\n    cluster.wait_log_truncated(region.get_id(), 1, state1.get_index() + 1);\n\n    let peer_on_store3 = find_peer(&region, 3).unwrap().to_owned();\n    assert_eq!(peer_on_store3.get_id(), 3);\n    // Make peer 3 do not handle snapshot ready\n    // In previous implementation, destroying its source peer and applying snapshot\n    // is not atomic. So making its source peer be destroyed and do not apply\n    // snapshot to reproduce the problem\n    let before_handle_snapshot_ready_3_fp = \"before_handle_snapshot_ready_3\";\n    fail::cfg(before_handle_snapshot_ready_3_fp, \"return()\").unwrap();\n\n    cluster.clear_send_filters();\n    // Peer 1 will send snapshot to peer 3\n    // Source peer sends msg to others to get target region info until the election\n    // timeout. The max election timeout is 2 * 10 * 10 = 200ms\n    let election_timeout = 2\n        * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n        * cluster.cfg.raft_store.raft_election_timeout_ticks as u64;\n    sleep_ms(election_timeout + 100);\n\n    cluster.stop_node(1);\n    cluster.stop_node(3);\n\n    cluster.sim.wl().clear_recv_filters(2);\n    fail::remove(before_handle_snapshot_ready_3_fp);\n    cluster.run_node(3).unwrap();\n    // Peer 2 will become leader and it don't know the compact log is committed.\n    // So it will send logs not snapshot to peer 3\n    for i in 20..30 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v\");\n    }\n    must_get_equal(&cluster.get_engine(3), b\"k29\", b\"v\");\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_generics.rs::test_split_for_impl", "code": "pub(crate) fn to_string(&self) -> String {\n        let mut repr = String::with_capacity(self.digits.len());\n\n        let mut has_nonzero = false;\n        for digit in self.digits.iter().rev() {\n            has_nonzero |= *digit != 0;\n            if has_nonzero {\n                repr.push((*digit + b'0') as char);\n            }\n        }\n\n        if repr.is_empty() {\n            repr.push('0');\n        }\n\n        repr\n    }", "test": "fn test_split_for_impl() {\n    let input = quote! {\n        struct S<'a, 'b: 'a, #[may_dangle] T: 'a = ()> where T: Debug;\n    };\n\n    snapshot!(input as DeriveInput, @r###\"\n    DeriveInput {\n        vis: Visibility::Inherited,\n        ident: \"S\",\n        generics: Generics {\n            lt_token: Some,\n            params: [\n                GenericParam::Lifetime(LifetimeParam {\n                    lifetime: Lifetime {\n                        ident: \"a\",\n                    },\n                }),\n                GenericParam::Lifetime(LifetimeParam {\n                    lifetime: Lifetime {\n                        ident: \"b\",\n                    },\n                    colon_token: Some,\n                    bounds: [\n                        Lifetime {\n                            ident: \"a\",\n                        },\n                    ],\n                }),\n                GenericParam::Type(TypeParam {\n                    attrs: [\n                        Attribute {\n                            style: AttrStyle::Outer,\n                            meta: Meta::Path {\n                                segments: [\n                                    PathSegment {\n                                        ident: \"may_dangle\",\n                                    },\n                                ],\n                            },\n                        },\n                    ],\n                    ident: \"T\",\n                    colon_token: Some,\n                    bounds: [\n                        TypeParamBound::Lifetime {\n                            ident: \"a\",\n                        },\n                    ],\n                    eq_token: Some,\n                    default: Some(Type::Tuple),\n                }),\n            ],\n            gt_token: Some,\n            where_clause: Some(WhereClause {\n                predicates: [\n                    WherePredicate::Type(PredicateType {\n                        bounded_ty: Type::Path {\n                            path: Path {\n                                segments: [\n                                    PathSegment {\n                                        ident: \"T\",\n                                    },\n                                ],\n                            },\n                        },\n                        bounds: [\n                            TypeParamBound::Trait(TraitBound {\n                                path: Path {\n                                    segments: [\n                                        PathSegment {\n                                            ident: \"Debug\",\n                                        },\n                                    ],\n                                },\n                            }),\n                        ],\n                    }),\n                ],\n            }),\n        },\n        data: Data::Struct {\n            fields: Fields::Unit,\n            semi_token: Some,\n        },\n    }\n    \"###);\n\n    let generics = input.generics;\n    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n    let generated = quote! {\n        impl #impl_generics MyTrait for Test #ty_generics #where_clause {}\n    };\n    let expected = quote! {\n        impl<'a, 'b: 'a, #[may_dangle] T: 'a> MyTrait\n        for Test<'a, 'b, T>\n        where\n            T: Debug\n        {}\n    };\n    assert_eq!(generated.to_string(), expected.to_string());\n\n    let turbofish = ty_generics.as_turbofish();\n    let generated = quote! {\n        Test #turbofish\n    };\n    let expected = quote! {\n        Test::<'a, 'b, T>\n    };\n    assert_eq!(generated.to_string(), expected.to_string());\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/large_number.rs::test_large_integer_to_float", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn test_large_integer_to_float() {\n    use ron::value::Float;\n    let test_var = std::i64::MAX as u64 + 1;\n    let expected = test_var as f64; // Is exactly representable by f64\n    let test_ser = ron::ser::to_string(&test_var).unwrap();\n    assert_eq!(test_ser, test_var.to_string());\n    let test_deser = ron::de::from_str::<Value>(&test_ser);\n\n    assert_eq!(\n        test_deser.unwrap(),\n        Value::Number(Number::Float(Float::new(expected))),\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::memory_init", "code": "pub fn data<'a, T: 'a>(&self, store: impl Into<StoreContext<'a, T>>) -> &'a [u8] {\n        unsafe {\n            let store = store.into();\n            let definition = &*store[self.0].definition;\n            debug_assert!(!self.ty(store).is_shared());\n            slice::from_raw_parts(definition.base, definition.current_length())\n        }\n    }", "test": "fn memory_init() -> Result<()> {\n    let mut pool = crate::small_pool_config();\n    pool.memory_pages(2).table_elements(0);\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"m\") 2)\n                (data (i32.const 65530) \"this data spans multiple pages\")\n                (data (i32.const 10) \"hello world\")\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let memory = instance.get_memory(&mut store, \"m\").unwrap();\n\n    assert_eq!(\n        &memory.data(&store)[65530..65560],\n        b\"this data spans multiple pages\"\n    );\n    assert_eq!(&memory.data(&store)[10..21], b\"hello world\");\n\n    Ok(())\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_twice_on_same_peer", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_force_leader_twice_on_same_peer() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store5 = find_peer(&region, 5).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store5.clone());\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    // restart to clean lease\n    cluster.stop_node(1);\n    cluster.run_node(1).unwrap();\n    cluster.stop_node(2);\n    cluster.run_node(2).unwrap();\n\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // remove the peers on failed nodes\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_basic", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_basic() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"target_dir\";\n    let file1 = \"source_file1\";\n    let file2 = \"source_file2\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.mkdir(dir);\n    ucmd.arg(file1).arg(file2).arg(dir).succeeds().no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n    assert!(at.file_exists(format!(\"{dir}/{file1}\")));\n    assert!(at.file_exists(format!(\"{dir}/{file2}\")));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nul_lines", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_split_separator_nul_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--lines=2\", \"-t\", \"\\\\0\", \"separator_nul.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\x002\\0\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\x004\\0\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\0\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_witness.rs::test_witness_not_reported_while_disabled", "code": "pub fn len(&self) -> usize {\n        self.events.len()\n    }", "test": "fn test_witness_not_reported_while_disabled() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n    assert_eq!(nodes[2], 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap().clone();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1);\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n\n    cluster.must_put(b\"k0\", b\"v0\");\n\n    // update region but the peer is not destroyed yet\n    fail::cfg(\"change_peer_after_update_region_store_3\", \"pause\").unwrap();\n\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), peer_on_store3.clone());\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let mut request = new_request(\n        region.get_id(),\n        region.get_region_epoch().clone(),\n        vec![new_get_cmd(b\"k0\")],\n        false,\n    );\n    request.mut_header().set_peer(peer_on_store3);\n    request.mut_header().set_replica_read(true);\n\n    let resp = cluster\n        .read(None, request.clone(), Duration::from_millis(100))\n        .unwrap();\n    assert!(resp.get_header().has_error());\n    assert!(!resp.get_header().get_error().has_is_witness());\n    fail::remove(\"change_peer_after_update_region_store_3\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_append_multi", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "test": "fn test_append_multi() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), true))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    // next append to a non-existent RRset\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), false))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // will fail if already set and not the same value.\n    let mut record2 = record.clone();\n    record2.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let mut record3 = record.clone();\n    record3.set_data(Some(RData::A(A::new(101, 11, 101, 12))));\n\n    // build the append set\n    let mut rrset = RecordSet::from(record2.clone());\n    rrset.insert(record3.clone(), 0);\n\n    let result = io_loop\n        .block_on(client.append(rrset, origin.clone(), true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 3);\n\n    assert!(result.answers().iter().any(|rr| *rr == record));\n    assert!(result.answers().iter().any(|rr| *rr == record2));\n    assert!(result.answers().iter().any(|rr| *rr == record3));\n\n    // show that appending the same thing again is ok, but doesn't add any records\n    // TODO: technically this is a test for the Server, not client...\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin, true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 3);\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_text_size/tests/main.rs::math", "code": "fn size(x: u32) -> TextSize {\n    TextSize::from(x)\n}", "test": "fn math() {\n    assert_eq!(size(10) + size(5), size(15));\n    assert_eq!(size(10) - size(5), size(5));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_stale_peer.rs::test_destroy_uninitialized_peer_when_there_exists_old_peer", "code": "pub fn get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, false)\n    }", "test": "fn test_destroy_uninitialized_peer_when_there_exists_old_peer() {\n    // 4 stores cluster.\n    let mut cluster = new_node_cluster(0, 4);\n    cluster.cfg.raft_store.pd_store_heartbeat_tick_interval = ReadableDuration::millis(10);\n    cluster.cfg.raft_store.hibernate_regions = false;\n\n    let pd_client = cluster.pd_client.clone();\n    // Disable default max peer count check.\n    pd_client.disable_default_operator();\n\n    let r1 = cluster.run_conf_change();\n\n    // Now region 1 only has peer (1, 1);\n    let (key, value) = (b\"k1\", b\"v1\");\n\n    cluster.must_put(key, value);\n    assert_eq!(cluster.get(key), Some(value.to_vec()));\n\n    // add peer (2,2) to region 1.\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n\n    // add peer (3, 3) to region 1.\n    pd_client.must_add_peer(r1, new_peer(3, 3));\n\n    let epoch = pd_client.get_region_epoch(r1);\n\n    // Conf version must change.\n    assert!(epoch.get_conf_ver() > 2);\n\n    // Transfer leader to peer (2, 2).\n    cluster.must_transfer_leader(r1, new_peer(2, 2));\n\n    // Isolate node 1\n    cluster.add_send_filter(IsolationFilterFactory::new(1));\n\n    cluster.must_put(format!(\"k{}\", 2).as_bytes(), b\"v1\");\n\n    // Remove 3 and add 4\n    pd_client.must_add_peer(r1, new_learner_peer(4, 4));\n    pd_client.must_add_peer(r1, new_peer(4, 4));\n    pd_client.must_remove_peer(r1, new_peer(3, 3));\n\n    cluster.must_put(format!(\"k{}\", 3).as_bytes(), b\"v1\");\n\n    // Ensure 5 drops all snapshot\n    let (notify_tx, _notify_rx) = mpsc::channel();\n    cluster\n        .sim\n        .wl()\n        .add_recv_filter(3, Box::new(DropSnapshotFilter::new(notify_tx)));\n\n    // Add learner 5 on store 3\n    pd_client.must_add_peer(r1, new_learner_peer(3, 5));\n\n    cluster.must_put(format!(\"k{}\", 4).as_bytes(), b\"v1\");\n\n    // Remove and destroy the uninitialized 5\n    let peer_5 = new_learner_peer(3, 5);\n    pd_client.must_remove_peer(r1, peer_5.clone());\n    cluster.must_gc_peer(r1, 3, peer_5);\n\n    let region = block_on(pd_client.get_region_by_id(r1)).unwrap();\n    must_region_cleared(&cluster.get_all_engines(3), &region.unwrap());\n\n    // Unisolate 1 and try wakeup 3\n    cluster.clear_send_filters();\n    cluster.sim.wl().clear_recv_filters(3);\n    cluster.partition(vec![1, 3], vec![2, 4]);\n\n    sleep_until_election_triggered(&cluster.cfg);\n\n    let region = block_on(pd_client.get_region_by_id(r1)).unwrap();\n    must_region_cleared(&cluster.get_all_engines(3), &region.unwrap());\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::fs_error_dereferenced_symlink", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn fs_error_dereferenced_symlink() {\n    let fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let root_path = temp_dir().join(\"lint_rome_test_broken_symlink\");\n    let subdir_path = root_path.join(\"prefix\");\n\n    let _ = remove_dir_all(&root_path);\n    create_dir(&root_path).unwrap();\n    create_dir(subdir_path).unwrap();\n\n    #[cfg(target_family = \"unix\")]\n    {\n        symlink(root_path.join(\"null\"), root_path.join(\"broken_symlink\")).unwrap();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        check_windows_symlink!(symlink_file(\n            root_path.join(\"null\"),\n            root_path.join(\"broken_symlink\")\n        ));\n    }\n\n    let result = run_cli(\n        DynRef::Owned(Box::new(OsFileSystem)),\n        &mut console,\n        Args::from([(\"lint\"), root_path.display().to_string().as_str()].as_slice()),\n    );\n\n    remove_dir_all(root_path).unwrap();\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_dereferenced_symlink\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::functions_in_instances", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "test": "fn functions_in_instances() -> Result<()> {\n    let component = r#\"\n        (component\n            (type $import-type (instance\n                (export \"a\" (func (param \"a\" string)))\n            ))\n            (import (interface \"test:test/foo\") (instance $import (type $import-type)))\n            (alias export $import \"a\" (func $log))\n\n            (core module $libc\n                (memory (export \"memory\") 1)\n\n                (func (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n                    unreachable)\n            )\n            (core instance $libc (instantiate $libc))\n            (core func $log_lower\n                (canon lower (func $log) (memory $libc \"memory\") (realloc (func $libc \"realloc\")))\n            )\n            (core module $m\n                (import \"libc\" \"memory\" (memory 1))\n                (import \"host\" \"log\" (func $log (param i32 i32)))\n\n                (func (export \"call\")\n                    i32.const 5\n                    i32.const 11\n                    call $log)\n\n                (data (i32.const 5) \"hello world\")\n            )\n            (core instance $i (instantiate $m\n                (with \"libc\" (instance $libc))\n                (with \"host\" (instance (export \"log\" (func $log_lower))))\n            ))\n            (func $call\n                (canon lift (core func $i \"call\"))\n            )\n            (component $c\n                (import \"import-call\" (func $f))\n                (export \"call\" (func $f))\n            )\n            (instance $export (instantiate $c\n                (with \"import-call\" (func $call))\n            ))\n            (export (interface \"test:test/foo\") (instance $export))\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, None);\n    assert!(store.data().is_none());\n\n    // First, test the static API\n\n    let mut linker = Linker::new(&engine);\n    linker.instance(\"test:test/foo\")?.func_wrap(\n        \"a\",\n        |mut store: StoreContextMut<'_, Option<String>>, (arg,): (WasmStr,)| -> Result<_> {\n            let s = arg.to_str(&store)?.to_string();\n            assert!(store.data().is_none());\n            *store.data_mut() = Some(s);\n            Ok(())\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    let func = instance\n        .exports(&mut store)\n        .instance(\"test:test/foo\")\n        .unwrap()\n        .typed_func::<(), ()>(\"call\")?;\n    func.call(&mut store, ())?;\n    assert_eq!(store.data().as_ref().unwrap(), \"hello world\");\n\n    // Next, test the dynamic API\n\n    *store.data_mut() = None;\n    let mut linker = Linker::new(&engine);\n    linker.instance(\"test:test/foo\")?.func_new(\n        &component,\n        \"a\",\n        |mut store: StoreContextMut<'_, Option<String>>, args, _results| {\n            if let Val::String(s) = &args[0] {\n                assert!(store.data().is_none());\n                *store.data_mut() = Some(s.to_string());\n                Ok(())\n            } else {\n                panic!()\n            }\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    let func = instance\n        .exports(&mut store)\n        .instance(\"test:test/foo\")\n        .unwrap()\n        .func(\"call\")\n        .unwrap();\n    func.call(&mut store, &[], &mut [])?;\n    assert_eq!(store.data().as_ref().unwrap(), \"hello world\");\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_no_clobber", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_no_clobber() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"--no-clobber\")\n        .fails()\n        .stderr_contains(\"not replacing\");\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"How are you?\\n\");\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::maximum_diagnostics", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn maximum_diagnostics() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), ERRORS.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let messages = &console.out_buffer;\n\n    assert_eq!(\n        messages\n            .iter()\n            .filter(|m| m.level == LogLevel::Error)\n            .count(),\n        20_usize\n    );\n\n    assert!(messages\n        .iter()\n        .filter(|m| m.level == LogLevel::Log)\n        .any(|m| {\n            let content = format!(\"{:?}\", m.content);\n            content.contains(\"The number of diagnostics exceeds the number allowed by Biome\")\n                && content.contains(\"Diagnostics not shown\")\n                && content.contains(\"79\")\n        }));\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"maximum_diagnostics\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_joint_consensus.rs::test_joint_consensus_conf_change", "code": "pub fn get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, false)\n    }", "test": "fn test_joint_consensus_conf_change() {\n    let mut cluster = new_node_cluster(0, 4);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    assert_eq!(cluster.get(b\"k1\"), Some(b\"v1\".to_vec()));\n\n    // add multiple nodes\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddNode, new_peer(2, 2)),\n            (ConfChangeType::AddNode, new_peer(3, 3)),\n            (ConfChangeType::AddLearnerNode, new_learner_peer(4, 4)),\n        ],\n    );\n    pd_client.must_leave_joint(region_id);\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(4), b\"k1\", b\"v1\");\n\n    // remove multiple nodes\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddLearnerNode, new_learner_peer(3, 3)),\n            (ConfChangeType::RemoveNode, new_learner_peer(4, 4)),\n        ],\n    );\n    pd_client.must_leave_joint(region_id);\n    assert_eq!(\n        find_peer(&pd_client.get_region(b\"\").unwrap(), 3).unwrap(),\n        &new_learner_peer(3, 3)\n    );\n    must_get_none(&cluster.get_engine(4), b\"k1\");\n\n    // replace node\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::RemoveNode, new_learner_peer(3, 3)),\n            (ConfChangeType::AddNode, new_peer(4, 5)),\n        ],\n    );\n    pd_client.must_leave_joint(region_id);\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    must_get_equal(&cluster.get_engine(4), b\"k1\", b\"v1\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_sparse_always_non_empty", "code": "pub fn read_bytes(&self, name: &str) -> Vec<u8> {\n        let mut f = self.open(name);\n        let mut contents = Vec::new();\n        f.read_to_end(&mut contents)\n            .unwrap_or_else(|e| panic!(\"Couldn't read {name}: {e}\"));\n        contents\n    }", "test": "fn test_cp_sparse_always_non_empty() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    const BUFFER_SIZE: usize = 4096 * 16 + 3;\n    let mut buf: [u8; BUFFER_SIZE] = [0; BUFFER_SIZE];\n    let blocks_to_touch = [buf.len() / 3, 2 * (buf.len() / 3)];\n\n    for i in blocks_to_touch {\n        buf[i] = b'x';\n    }\n\n    at.make_file(\"src_file1\");\n    at.write_bytes(\"src_file1\", &buf);\n\n    ucmd.args(&[\"--sparse=always\", \"src_file1\", \"dst_file_sparse\"])\n        .succeeds();\n\n    let touched_block_count =\n        blocks_to_touch.len() as u64 * at.metadata(\"dst_file_sparse\").blksize() / 512;\n\n    assert_eq!(at.read_bytes(\"dst_file_sparse\"), buf);\n    assert_eq!(at.metadata(\"dst_file_sparse\").blocks(), touched_block_count);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_parents", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--parents\")\n        .arg(TEST_COPY_FROM_FOLDER_FILE)\n        .arg(TEST_COPY_TO_FOLDER)\n        .succeeds();\n\n    assert_eq!(\n        at.read(&format!(\n            \"{TEST_COPY_TO_FOLDER}/{TEST_COPY_FROM_FOLDER_FILE}\"\n        )),\n        \"Hello, World!\\n\"\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/test_config_client.rs::test_dispatch_change", "code": "pub fn get_current(&self) -> TikvConfig {\n        self.inner.read().unwrap().current.clone()\n    }", "test": "fn test_dispatch_change() {\n    use std::{error::Error, result::Result};\n\n    use online_config::ConfigManager;\n\n    #[derive(Clone)]\n    struct CfgManager(Arc<Mutex<RaftstoreConfig>>);\n\n    impl ConfigManager for CfgManager {\n        fn dispatch(&mut self, c: ConfigChange) -> Result<(), Box<dyn Error>> {\n            self.0.lock().unwrap().update(c)\n        }\n    }\n\n    let (mut cfg, _dir) = TikvConfig::with_tmp().unwrap();\n    cfg.validate().unwrap();\n    let cfg_controller = ConfigController::new(cfg);\n    let mut cfg = cfg_controller.get_current();\n    let mgr = CfgManager(Arc::new(Mutex::new(cfg.raft_store.clone())));\n    cfg_controller.register(Module::Raftstore, Box::new(mgr.clone()));\n\n    cfg_controller\n        .update(change(\"raftstore.raft-log-gc-threshold\", \"2000\"))\n        .unwrap();\n\n    // config update\n    cfg.raft_store.raft_log_gc_threshold = 2000;\n    assert_eq!(cfg_controller.get_current(), cfg);\n\n    // config change should also dispatch to raftstore config manager\n    assert_eq!(mgr.0.lock().unwrap().raft_log_gc_threshold, 2000);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tee.rs::test_tee_processing_multiple_operands", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_tee_processing_multiple_operands() {\n    // POSIX says: \"Processing of at least 13 file operands shall be supported.\"\n\n    let content = \"tee_sample_content\";\n    for n in [1, 2, 12, 13] {\n        let files = (1..=n).map(|x| x.to_string()).collect::<Vec<_>>();\n        let (at, mut ucmd) = at_and_ucmd!();\n\n        ucmd.args(&files)\n            .pipe_in(content)\n            .succeeds()\n            .stdout_is(content);\n\n        for file in &files {\n            assert!(at.file_exists(file));\n            assert_eq!(at.read(file), content);\n        }\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/linker.rs::get_host_function", "code": "pub fn is_some(&self) -> bool {\n        !self.0.is_reserved_value()\n    }", "test": "fn get_host_function() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(&engine, r#\"(module (import \"mod\" \"f1\" (func)))\"#)?;\n\n    let mut linker = Linker::new(&engine);\n    linker.func_wrap(\"mod\", \"f1\", || {})?;\n    let mut store = Store::new(&engine, ());\n    assert!(linker\n        .get_by_import(&mut store, &module.imports().nth(0).unwrap())\n        .is_some());\n\n    Ok(())\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/cli/tests/run.rs::test_simple_print", "code": "fn contains_slice<T>(slice: &[T], other: &[T]) -> bool\nwhere\n    T: Eq,\n{\n    if other.is_empty() {\n        return true;\n    }\n    slice.windows(other.len()).any(|window| window == other)\n}", "test": "fn test_simple_print() {\n    let mut cmd = get_cmd();\n    let assert = cmd.arg(get_bin_path(\"simple_print\")).assert();\n    let output = assert.get_output();\n    let stdout = &output.stdout;\n    assert!(contains_slice(stdout, b\"Hello World\"));\n    if !(contains_slice(stdout, b\"Hello World\\n\")) {\n        eprint!(\"UNEQUAL: {}\", std::str::from_utf8(stdout).unwrap());\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_backup_numbering", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_backup_numbering() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_backup_numbering\";\n    let link = \"test_symlink_backup_numbering_link\";\n\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    ucmd.args(&[\"-s\", \"--backup=t\", file, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let backup = &format!(\"{link}.~1~\");\n    assert!(at.is_symlink(backup));\n    assert_eq!(at.resolve_link(backup), file);\n}"}
{"test_id": "gimli-rs-gimli/gimli-rs-gimli-3947879/tests/convert_self.rs::test_convert_debug_info", "code": "pub fn count(&self) -> usize {\n        self.units.len()\n    }", "test": "fn test_convert_debug_info() {\n    // Convert existing sections\n    let debug_abbrev = read_section(\"debug_abbrev\");\n    let debug_abbrev = read::DebugAbbrev::new(&debug_abbrev, LittleEndian);\n\n    let debug_info = read_section(\"debug_info\");\n    let debug_info = read::DebugInfo::new(&debug_info, LittleEndian);\n\n    let debug_line = read_section(\"debug_line\");\n    let debug_line = read::DebugLine::new(&debug_line, LittleEndian);\n\n    let debug_str = read_section(\"debug_str\");\n    let debug_str = read::DebugStr::new(&debug_str, LittleEndian);\n\n    let debug_ranges = read_section(\"debug_ranges\");\n    let debug_ranges = read::DebugRanges::new(&debug_ranges, LittleEndian);\n\n    let debug_rnglists = read::DebugRngLists::new(&[], LittleEndian);\n\n    let ranges = gimli::RangeLists::new(debug_ranges, debug_rnglists);\n\n    let debug_loc = read_section(\"debug_loc\");\n    let debug_loc = read::DebugLoc::new(&debug_loc, LittleEndian);\n\n    let debug_loclists = read::DebugLocLists::new(&[], LittleEndian);\n\n    let locations = gimli::LocationLists::new(debug_loc, debug_loclists);\n\n    let dwarf = read::Dwarf {\n        debug_abbrev,\n        debug_info,\n        debug_line,\n        debug_str,\n        ranges,\n        locations,\n        ..Default::default()\n    };\n\n    let mut dwarf = write::Dwarf::from(&dwarf, &|address| Some(Address::Constant(address)))\n        .expect(\"Should convert DWARF information\");\n\n    assert_eq!(dwarf.units.count(), 23);\n    let entries: usize = (0..dwarf.units.count())\n        .map(|i| dwarf.units.get(dwarf.units.id(i)).count())\n        .sum();\n    assert_eq!(entries, 29_560);\n    assert_eq!(dwarf.line_strings.count(), 0);\n    assert_eq!(dwarf.strings.count(), 3921);\n\n    // Write to new sections\n    let mut write_sections = write::Sections::new(EndianVec::new(LittleEndian));\n    dwarf\n        .write(&mut write_sections)\n        .expect(\"Should write DWARF information\");\n    let debug_info_data = write_sections.debug_info.slice();\n    let debug_abbrev_data = write_sections.debug_abbrev.slice();\n    let debug_line_data = write_sections.debug_line.slice();\n    let debug_ranges_data = write_sections.debug_ranges.slice();\n    let debug_loc_data = write_sections.debug_loc.slice();\n    let debug_str_data = write_sections.debug_str.slice();\n    assert_eq!(debug_info_data.len(), 394_930);\n    assert_eq!(debug_abbrev_data.len(), 9701);\n    assert_eq!(debug_line_data.len(), 105_797);\n    assert_eq!(debug_ranges_data.len(), 155_712);\n    assert_eq!(debug_loc_data.len(), 245_168);\n    assert_eq!(debug_str_data.len(), 144_731);\n\n    // Convert new sections\n    let debug_abbrev = read::DebugAbbrev::new(debug_abbrev_data, LittleEndian);\n    let debug_info = read::DebugInfo::new(debug_info_data, LittleEndian);\n    let debug_line = read::DebugLine::new(debug_line_data, LittleEndian);\n    let debug_str = read::DebugStr::new(debug_str_data, LittleEndian);\n    let debug_ranges = read::DebugRanges::new(debug_ranges_data, LittleEndian);\n    let debug_rnglists = read::DebugRngLists::new(&[], LittleEndian);\n    let debug_loc = read::DebugLoc::new(debug_loc_data, LittleEndian);\n    let debug_loclists = read::DebugLocLists::new(&[], LittleEndian);\n\n    let ranges = gimli::RangeLists::new(debug_ranges, debug_rnglists);\n    let locations = gimli::LocationLists::new(debug_loc, debug_loclists);\n\n    let dwarf = read::Dwarf {\n        debug_abbrev,\n        debug_info,\n        debug_line,\n        debug_str,\n        ranges,\n        locations,\n        ..Default::default()\n    };\n\n    let dwarf = write::Dwarf::from(&dwarf, &|address| Some(Address::Constant(address)))\n        .expect(\"Should convert DWARF information\");\n\n    assert_eq!(dwarf.units.count(), 23);\n    let entries: usize = (0..dwarf.units.count())\n        .map(|i| dwarf.units.get(dwarf.units.id(i)).count())\n        .sum();\n    assert_eq!(entries, 29_560);\n    assert_eq!(dwarf.strings.count(), 3921);\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/func.rs::bools", "code": "pub fn call(&self, arguments: &[DataValue]) -> Vec<DataValue> {\n        let mut values = UnboxedValues::make_arguments(arguments, &self.func_signature);\n        let arguments_address = values.as_mut_ptr();\n\n        let function_ptr = self.module.get_finalized_function(self.func_id);\n        let trampoline_ptr = self.module.get_finalized_function(self.trampoline_id);\n\n        let callable_trampoline: fn(*const u8, *mut u128) -> () =\n            unsafe { mem::transmute(trampoline_ptr) };\n        callable_trampoline(function_ptr, arguments_address);\n\n        values.collect_returns(&self.func_signature)\n    }", "test": "fn bools() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"pass\") (param i32) (result i32) local.get 0)\n            )\n            (core instance $i (instantiate $m))\n\n            (func (export \"u32-to-bool\") (param \"a\" u32) (result bool)\n                (canon lift (core func $i \"pass\"))\n            )\n            (func (export \"bool-to-u32\") (param \"a\" bool) (result u32)\n                (canon lift (core func $i \"pass\"))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let u32_to_bool = instance.get_typed_func::<(u32,), (bool,)>(&mut store, \"u32-to-bool\")?;\n    let bool_to_u32 = instance.get_typed_func::<(bool,), (u32,)>(&mut store, \"bool-to-u32\")?;\n\n    assert_eq!(bool_to_u32.call(&mut store, (false,))?, (0,));\n    bool_to_u32.post_return(&mut store)?;\n    assert_eq!(bool_to_u32.call(&mut store, (true,))?, (1,));\n    bool_to_u32.post_return(&mut store)?;\n    assert_eq!(u32_to_bool.call(&mut store, (0,))?, (false,));\n    u32_to_bool.post_return(&mut store)?;\n    assert_eq!(u32_to_bool.call(&mut store, (1,))?, (true,));\n    u32_to_bool.post_return(&mut store)?;\n    assert_eq!(u32_to_bool.call(&mut store, (2,))?, (true,));\n    u32_to_bool.post_return(&mut store)?;\n\n    Ok(())\n}"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_bad_input", "code": "pub fn s2d(buffer: &[u8]) -> Result<f64, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u64;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index != len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 17 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u64;\n        if m10 != 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.\n                return Err(Error::InputTooLong);\n            }\n            e10 = 10 * e10 + (c - b'0') as i32;\n            if e10 != 0 {\n                e10digits += 1;\n            }\n            i += 1;\n        }\n    }\n\n    if i < len {\n        return Err(Error::MalformedInput);\n    }\n    if signed_e {\n        e10 = -e10;\n    }\n    e10 -= if dot_index < e_index {\n        (e_index - dot_index - 1) as i32\n    } else {\n        0\n    };\n    if m10 == 0 {\n        return Ok(if signed_m { -0.0 } else { 0.0 });\n    }\n\n    if m10digits + e10 <= -324 || m10 == 0 {\n        // Number is less than 1e-324, which should be rounded down to 0; return\n        // +/-0.0.\n        let ieee = (signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n    if m10digits + e10 >= 310 {\n        // Number is larger than 1e+309, which should be rounded to +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // Convert to binary float m2 * 2^e2, while retaining information about\n    // whether the conversion was exact (trailing_zeros).\n    let e2: i32;\n    let m2: u64;\n    let mut trailing_zeros: bool;\n    if e10 >= 0 {\n        // The length of m * 10^e in bits is:\n        //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)\n        //\n        // We want to compute the DOUBLE_MANTISSA_BITS + 1 top-most bits (+1 for\n        // the implicit leading one in IEEE format). We therefore choose a\n        // binary output exponent of\n        //   log2(m10 * 10^e10) - (DOUBLE_MANTISSA_BITS + 1).\n        //\n        // We use floor(log2(5^e10)) so that we get at least this many bits;\n        // better to have an additional bit than to not have enough bits.\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_add(log2_pow5(e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].\n        // To that end, we use the DOUBLE_POW5_SPLIT table.\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_sub(ceil_log2_pow5(e10))\n            .wrapping_add(d2s::DOUBLE_POW5_BITCOUNT);\n        debug_assert!(j >= 0);\n        debug_assert!(e10 < d2s::DOUBLE_POW5_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_SPLIT.get_unchecked(e10 as usize) },\n            j as u32,\n        );\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.\n        // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn\n        // requires that the largest power of 2 that divides m10 + e10 is\n        // greater than e2. If e2 is less than e10, then the result must be\n        // exact. Otherwise we use the existing multiple_of_power_of_2 function.\n        trailing_zeros =\n            e2 < e10 || e2 - e10 < 64 && multiple_of_power_of_2(m10, (e2 - e10) as u32);\n    } else {\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_sub(ceil_log2_pow5(-e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_add(ceil_log2_pow5(-e10))\n            .wrapping_sub(1)\n            .wrapping_add(d2s::DOUBLE_POW5_INV_BITCOUNT);\n        debug_assert!(-e10 < d2s::DOUBLE_POW5_INV_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_INV_SPLIT.get_unchecked(-e10 as usize) },\n            j as u32,\n        );\n        trailing_zeros = multiple_of_power_of_5(m10, -e10 as u32);\n    }\n\n    // Compute the final IEEE exponent.\n    let mut ieee_e2 = i32::max(0, e2 + DOUBLE_EXPONENT_BIAS as i32 + floor_log2(m2) as i32) as u32;\n\n    if ieee_e2 > 0x7fe {\n        // Final IEEE exponent is larger than the maximum representable; return +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // We need to figure out how much we need to shift m2. The tricky part is\n    // that we need to take the final IEEE exponent into account, so we need to\n    // reverse the bias and also special-case the value 0.\n    let shift = if ieee_e2 == 0 { 1 } else { ieee_e2 as i32 }\n        .wrapping_sub(e2)\n        .wrapping_sub(DOUBLE_EXPONENT_BIAS as i32)\n        .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS as i32);\n    debug_assert!(shift >= 0);\n\n    // We need to round up if the exact value is more than 0.5 above the value\n    // we computed. That's equivalent to checking if the last removed bit was 1\n    // and either the value was not just trailing zeros or the result would\n    // otherwise be odd.\n    //\n    // We need to update trailing_zeros given that we have the exact output\n    // exponent ieee_e2 now.\n    trailing_zeros &= (m2 & ((1_u64 << (shift - 1)) - 1)) == 0;\n    let last_removed_bit = (m2 >> (shift - 1)) & 1;\n    let round_up = last_removed_bit != 0 && (!trailing_zeros || ((m2 >> shift) & 1) != 0);\n\n    let mut ieee_m2 = (m2 >> shift).wrapping_add(round_up as u64);\n    debug_assert!(ieee_m2 <= 1_u64 << (d2s::DOUBLE_MANTISSA_BITS + 1));\n    ieee_m2 &= (1_u64 << d2s::DOUBLE_MANTISSA_BITS) - 1;\n    if ieee_m2 == 0 && round_up {\n        // Due to how the IEEE represents +/-Infinity, we don't need to check\n        // for overflow here.\n        ieee_e2 += 1;\n    }\n    let ieee = ((((signed_m as u64) << d2s::DOUBLE_EXPONENT_BITS) | ieee_e2 as u64)\n        << d2s::DOUBLE_MANTISSA_BITS)\n        | ieee_m2;\n    Ok(f64::from_bits(ieee))\n}", "test": "fn test_bad_input() {\n    assert_eq!(Error::MalformedInput, s2d(b\"x\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1..1\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"..\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1..1\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1ee1\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1e.1\").unwrap_err());\n    assert_eq!(Error::InputTooShort, s2d(b\"\").unwrap_err());\n    assert_eq!(Error::InputTooLong, s2d(b\"123456789012345678\").unwrap_err());\n    assert_eq!(Error::InputTooLong, s2d(b\"1e12345\").unwrap_err());\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/lib.rs::strip_inline_internal_text", "code": "fn normalize_html(s: &str) -> String {\n    let parser = make_html_parser();\n    let dom = parser.one(s);\n    let body: SerializableHandle = normalize_dom(&dom).into();\n    let opts = SerializeOpts::default();\n    let mut ret_val = Vec::new();\n    serialize(&mut ret_val, &body, opts)\n        .expect(\"Writing to a string shouldn't fail (expect on OOM)\");\n    String::from_utf8(ret_val).expect(\"html5ever should always produce UTF8\")\n}", "test": "fn strip_inline_internal_text() {\n    assert_eq!(\n        \"<u>a </u>b <u>c</u>\",\n        normalize_html(\"<u> a </u> b <u> c </u>\")\n    )\n}"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/terser/mod.rs::test", "code": "pub fn is_empty(&self) -> bool {\n        self.body.is_empty() && self.directives.is_empty()\n    }", "test": "fn test() {\n    let files = WalkDir::new(\"tests/terser/fixtures\")\n        .into_iter()\n        .filter_map(Result::ok)\n        .filter(|e| !e.file_type().is_dir())\n        .collect::<Vec<_>>();\n    assert!(!files.is_empty());\n    for file in files {\n        let path = file.path();\n        let source_text = std::fs::read_to_string(path).unwrap();\n        let source_type = SourceType::from_path(path).unwrap();\n        let allocator = Allocator::default();\n        let parser_return = Parser::new(&allocator, &source_text, source_type).parse();\n        let program = allocator.alloc(parser_return.program);\n        TestSuite::from_program(&source_text, program).execute_tests();\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/memory.rs::dynamic_extra_growth_unchanged_pointer", "code": "pub fn data_ptr(&self, store: impl AsContext) -> *mut u8 {\n        unsafe { (*store.as_context()[self.0].definition).base }\n    }", "test": "fn dynamic_extra_growth_unchanged_pointer() -> Result<()> {\n    const EXTRA_PAGES: u64 = 5;\n    let mut config = Config::new();\n    config.static_memory_maximum_size(0);\n    // 5 wasm pages extra\n    config.dynamic_memory_reserved_for_growth(EXTRA_PAGES * (1 << 16));\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, ());\n\n    fn assert_behaves_well(store: &mut Store<()>, mem: &Memory) -> Result<()> {\n        let ptr = mem.data_ptr(&store);\n\n        // Each growth here should retain the same linear pointer in memory and the\n        // memory shouldn't get moved.\n        for _ in 0..EXTRA_PAGES {\n            mem.grow(&mut *store, 1)?;\n            assert_eq!(ptr, mem.data_ptr(&store));\n        }\n\n        // Growth afterwards though will be forced to move the pointer\n        mem.grow(&mut *store, 1)?;\n        let new_ptr = mem.data_ptr(&store);\n        assert_ne!(ptr, new_ptr);\n\n        for _ in 0..EXTRA_PAGES - 1 {\n            mem.grow(&mut *store, 1)?;\n            assert_eq!(new_ptr, mem.data_ptr(&store));\n        }\n        Ok(())\n    }\n\n    let mem = Memory::new(&mut store, MemoryType::new(10, None))?;\n    assert_behaves_well(&mut store, &mem)?;\n\n    let module = Module::new(&engine, r#\"(module (memory (export \"mem\") 10))\"#)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let mem = instance.get_memory(&mut store, \"mem\").unwrap();\n    assert_behaves_well(&mut store, &mem)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"mem\") 10)\n                (data (i32.const 0) \"\"))\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let mem = instance.get_memory(&mut store, \"mem\").unwrap();\n    assert_behaves_well(&mut store, &mem)?;\n\n    Ok(())\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_variable_block_lit_expr", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn render_variable_block_lit_expr() {\n    let inputs = vec![\n        (\"{{ 1 }}\", \"1\"),\n        (\"{{ 3.18 }}\", \"3.18\"),\n        (\"{{ \\\"hey\\\" }}\", \"hey\"),\n        (r#\"{{ \"{{ hey }}\" }}\"#, \"{{ hey }}\"),\n        (\"{{ true }}\", \"true\"),\n        (\"{{ false }}\", \"false\"),\n        (\"{{ false and true or true }}\", \"true\"),\n        (\"{{ 1 + 1 }}\", \"2\"),\n        (\"{{ 1 + 1.1 }}\", \"2.1\"),\n        (\"{{ 3 - 1 }}\", \"2\"),\n        (\"{{ 3 - 1.1 }}\", \"1.9\"),\n        (\"{{ 2 * 5 }}\", \"10\"),\n        (\"{{ 10 / 5 }}\", \"2\"),\n        (\"{{ 2.1 * 5 }}\", \"10.5\"),\n        (\"{{ 2.1 * 5.05 }}\", \"10.605\"),\n        (\"{{ 2 / 0.5 }}\", \"4\"),\n        (\"{{ 2.1 / 0.5 }}\", \"4.2\"),\n        (\"{{ 2 + 1 * 2 }}\", \"4\"),\n        (\"{{ (2 + 1) * 2 }}\", \"6\"),\n        (\"{{ 2 * 4 % 8 }}\", \"0\"),\n        (\"{{ 2.8 * 2 | round }}\", \"6\"),\n        (\"{{ 1 / 0 }}\", \"NaN\"),\n        (\"{{ true and 10 }}\", \"true\"),\n        (\"{{ true and not 10 }}\", \"false\"),\n        (\"{{ not true }}\", \"false\"),\n        (\"{{ [1, 2, 3] }}\", \"[1, 2, 3]\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &Context::new()).unwrap(), expected);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_region_info_accessor.rs::test_region_collection_find_region_by_key", "code": "pub fn len(&self) -> usize {\n        self.cmds.len()\n    }", "test": "fn test_region_collection_find_region_by_key() {\n    let mut cluster = new_node_cluster(0, 3);\n\n    let (tx, rx) = channel();\n    cluster\n        .sim\n        .wl()\n        .post_create_coprocessor_host(Box::new(move |id, host| {\n            let p = RegionInfoAccessor::new(host);\n            tx.send((id, p)).unwrap()\n        }));\n\n    cluster.run();\n    let region_info_providers: HashMap<_, _> = rx.try_iter().collect();\n    assert_eq!(region_info_providers.len(), 3);\n    let regions = prepare_cluster(&mut cluster);\n\n    for node_id in cluster.get_node_ids() {\n        let engine = &region_info_providers[&node_id];\n\n        let region = engine.find_region_by_key(b\"\").unwrap();\n        assert_eq!(region, regions[0]);\n\n        let region = engine.find_region_by_key(b\"k2\").unwrap();\n        assert_eq!(region, regions[1]);\n\n        let region = engine.find_region_by_key(b\"k99\").unwrap();\n        assert_eq!(region, *regions.last().unwrap());\n    }\n\n    for (_, p) in region_info_providers {\n        p.stop();\n    }\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_client_data_sent", "code": "fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    }", "test": "fn buffered_client_data_sent() {\n    let server_config = Arc::new(make_server_config(KeyType::Rsa));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n        assert_eq!(5, client.writer().write(b\"hello\").unwrap());\n\n        do_handshake(&mut client, &mut server);\n        transfer(&mut client, &mut server);\n        server.process_new_packets().unwrap();\n\n        check_read(&mut server.reader(), b\"hello\");\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_mkdir_parent_mode", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mkdir_parent_mode() {\n    let _guard = TEST_MUTEX.lock();\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let default_umask: mode_t = 0o160;\n    let original_umask = unsafe { umask(default_umask) };\n\n    ucmd.arg(\"-p\").arg(\"a/b\").succeeds().no_stderr().no_stdout();\n\n    assert!(at.dir_exists(\"a\"));\n    // parents created by -p have permissions set to \"=rwx,u+wx\"\n    assert_eq!(\n        at.metadata(\"a\").permissions().mode() as mode_t,\n        ((!default_umask & 0o777) | 0o300) + 0o40000\n    );\n    assert!(at.dir_exists(\"a/b\"));\n    // sub directory's permission is determined only by the umask\n    assert_eq!(\n        at.metadata(\"a/b\").permissions().mode() as mode_t,\n        (!default_umask & 0o777) + 0o40000\n    );\n\n    unsafe {\n        umask(original_umask);\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_do_not_overwrite", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_do_not_overwrite() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_do_not_overwrite\";\n    let link = \"test_symlink_do_not_overwrite_link\";\n\n    at.touch(file);\n    at.touch(link);\n\n    ucmd.args(&[\"-s\", file, link]).fails();\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(link));\n    assert!(!at.is_symlink(link));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::thread_through_borrow", "code": "pub fn owned(&self) -> bool {\n        match self.state.load(Relaxed) {\n            BORROW => false,\n            _ => true,\n        }\n    }", "test": "fn thread_through_borrow() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (import \"f\" (func $f (param \"x\" (borrow $t))))\n\n                (core func $f (canon lower (func $f)))\n                (core func $drop (canon resource.drop $t))\n\n                (core module $m\n                    (import \"\" \"f\" (func $f (param i32)))\n                    (import \"\" \"drop\" (func $drop (param i32)))\n                    (func (export \"f2\") (param i32)\n                        (call $f (local.get 0))\n                        (call $f (local.get 0))\n                        (call $drop (local.get 0))\n                    )\n                )\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"f\" (func $f))\n                        (export \"drop\" (func $drop))\n                    ))\n                ))\n\n                (func (export \"f2\") (param \"x\" (borrow $t))\n                    (canon lift (core func $i \"f2\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    linker\n        .root()\n        .func_wrap(\"f\", |_cx, (r,): (Resource<MyType>,)| {\n            assert!(!r.owned());\n            assert_eq!(r.rep(), 100);\n            Ok(())\n        })?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f2\")?;\n\n    let resource = Resource::new_own(100);\n    f.call(&mut store, (&resource,))?;\n    f.post_return(&mut store)?;\n    Ok(())\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::enum_named_fields_variant", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "test": "fn enum_named_fields_variant() {\n    let mut key = CacheKeyHasher::new();\n\n    let variant = Enum::NamedFields {\n        a: \"Hello\".to_string(),\n        b: \"World\".to_string(),\n    };\n    variant.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    variant.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::fill_funcref_tables_via_api", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "test": "fn fill_funcref_tables_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let table_ty = TableType::new(ValType::FuncRef, 10, None);\n    let table = Table::new(&mut store, table_ty, Val::FuncRef(None))?;\n\n    for i in 0..10 {\n        assert!(table.get(&mut store, i).unwrap().unwrap_funcref().is_none());\n    }\n\n    let fill = Val::FuncRef(Some(Func::wrap(&mut store, || {})));\n    table.fill(&mut store, 2, fill, 4)?;\n\n    for i in (0..2).chain(7..10) {\n        assert!(table.get(&mut store, i).unwrap().unwrap_funcref().is_none());\n    }\n    for i in 2..6 {\n        assert!(table.get(&mut store, i).unwrap().unwrap_funcref().is_some());\n    }\n\n    Ok(())\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::delete_table", "code": "pub(crate) fn delete_table(\n        &mut self,\n        name: &str,\n        table_type: TableType,\n    ) -> Result<bool, TableError> {\n        if let Some(definition) = self.get_table_untyped(name, table_type)? {\n            if let Some((table_root, _)) = definition.get_root() {\n                let iter = AllPageNumbersBtreeIter::new(\n                    table_root,\n                    definition.fixed_key_size,\n                    definition.fixed_value_size,\n                    self.mem,\n                )?;\n                let mut freed_pages = self.freed_pages.lock().unwrap();\n                for page_number in iter {\n                    freed_pages.push(page_number?);\n                }\n            }\n\n            self.pending_table_updates.remove(name);\n\n            let found = self.tree.remove(&name)?.is_some();\n            return Ok(found);\n        }\n\n        Ok(false)\n    }", "test": "fn delete_table() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let y_def: MultimapTableDefinition<&str, &str> = MultimapTableDefinition::new(\"y\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        let mut multitable = write_txn.open_multimap_table(y_def).unwrap();\n        multitable.insert(\"hello2\", \"world2\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    assert!(write_txn.delete_table(STR_TABLE).unwrap());\n    assert!(!write_txn.delete_table(STR_TABLE).unwrap());\n    assert!(write_txn.delete_multimap_table(y_def).unwrap());\n    assert!(!write_txn.delete_multimap_table(y_def).unwrap());\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let result = read_txn.open_table(STR_TABLE);\n    assert!(result.is_err());\n    let result = read_txn.open_multimap_table(y_def);\n    assert!(result.is_err());\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_context", "code": "pub fn get_attr(&self, key: &str) -> Result<Value, Error> {\n        Ok(match self.0 {\n            ValueRepr::Undefined => return Err(Error::from(ErrorKind::UndefinedError)),\n            ValueRepr::Map(ref items, _) => items.get(&KeyRef::Str(key)).cloned(),\n            ValueRepr::Dynamic(ref dy) => match dy.kind() {\n                ObjectKind::Struct(s) => s.get_field(key),\n                ObjectKind::Plain | ObjectKind::Seq(_) => None,\n            },\n            _ => None,\n        }\n        .unwrap_or(Value::UNDEFINED))\n    }", "test": "fn test_context() {\n    let var1 = 23;\n    let ctx = context!(var1, var2 => 42);\n    assert_eq!(ctx.get_attr(\"var1\").unwrap(), Value::from(23));\n    assert_eq!(ctx.get_attr(\"var2\").unwrap(), Value::from(42));\n}"}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_identifier.rs::test_eq", "code": "pub(super) fn prerelease(text: &str) -> Prerelease {\n    Prerelease::new(text).unwrap()\n}", "test": "fn test_eq() {\n    assert_eq!(prerelease(\"-\"), prerelease(\"-\"));\n    assert_ne!(prerelease(\"a\"), prerelease(\"aa\"));\n    assert_ne!(prerelease(\"aa\"), prerelease(\"a\"));\n    assert_ne!(prerelease(\"aaaaaaaaa\"), prerelease(\"a\"));\n    assert_ne!(prerelease(\"a\"), prerelease(\"aaaaaaaaa\"));\n    assert_ne!(prerelease(\"aaaaaaaaa\"), prerelease(\"bbbbbbbbb\"));\n    assert_ne!(build_metadata(\"1\"), build_metadata(\"001\"));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unlink.rs::test_unlink_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_unlink_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_unlink_file\";\n\n    at.touch(file);\n\n    ucmd.arg(file).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_one_file_system", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_du_one_file_system() {\n    let ts = TestScenario::new(util_name!());\n\n    let result = ts.ucmd().arg(\"-x\").arg(SUB_DIR).succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[\"-x\", SUB_DIR]));\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n    _du_basics_subdir(result.stdout_str());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client_legacy.rs::test_get_tombstone_store", "code": "fn is_cluster_bootstrapped(&self) -> Result<bool> {\n        let _timer = PD_REQUEST_HISTOGRAM_VEC\n            .is_cluster_bootstrapped\n            .start_coarse_timer();\n\n        let mut req = pdpb::IsBootstrappedRequest::default();\n        req.set_header(self.header());\n\n        let resp = sync_request(&self.pd_client, LEADER_CHANGE_RETRY, |client, option| {\n            client.is_bootstrapped_opt(&req, option)\n        })?;\n        check_resp_header(resp.get_header())?;\n\n        Ok(resp.get_bootstrapped())\n    }", "test": "fn test_get_tombstone_store() {\n    let eps_count = 1;\n    let server = MockServer::new(eps_count);\n    let eps = server.bind_addrs();\n    let client = new_client(eps, None);\n\n    let mut all_stores = vec![];\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    client.bootstrap_cluster(store.clone(), region).unwrap();\n\n    all_stores.push(store);\n    assert_eq!(client.is_cluster_bootstrapped().unwrap(), true);\n    let s = client.get_all_stores(false).unwrap();\n    assert_eq!(s, all_stores);\n\n    // Add tombstone store.\n    let mut store99 = metapb::Store::default();\n    store99.set_id(99);\n    store99.set_state(metapb::StoreState::Tombstone);\n    server.default_handler().add_store(store99.clone());\n\n    let r = block_on(client.get_store_async(99));\n    assert_eq!(r.unwrap_err().error_code(), error_code::pd::STORE_TOMBSTONE);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_globals", "code": "pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    }", "test": "fn test_globals() {\n    let mut env = Environment::new();\n    env.add_global(\"a\", Value::from(42));\n    env.add_template(\"test\", \"{{ a }}\").unwrap();\n    let tmpl = env.get_template(\"test\").unwrap();\n    assert_eq!(tmpl.render(()).unwrap(), \"42\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_joint_consensus.rs::test_invalid_confchange_request", "code": "pub fn get_id(&self) -> DownstreamId {\n        self.id\n    }", "test": "fn test_invalid_confchange_request() {\n    let mut cluster = new_node_cluster(0, 3);\n    cluster.cfg.raft_store.allow_remove_leader = false;\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n    let region = cluster.get_region(b\"\");\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    pd_client.must_add_peer(region_id, new_peer(2, 2));\n    pd_client.must_add_peer(region_id, new_learner_peer(3, 3));\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(3), b\"k1\", b\"v1\");\n\n    // Can not remove voter directly in joint confchange request\n    let resp = call_conf_change_v2(\n        &mut cluster,\n        region_id,\n        vec![\n            change_peer(ConfChangeType::RemoveNode, new_peer(2, 2)),\n            change_peer(ConfChangeType::AddLearnerNode, new_learner_peer(4, 4)),\n        ],\n    )\n    .unwrap();\n    must_contains_error(&resp, \"can not remove voter\");\n\n    // Can not have multiple commands for the same peer\n    let resp = call_conf_change_v2(\n        &mut cluster,\n        region_id,\n        vec![\n            change_peer(ConfChangeType::AddLearnerNode, new_learner_peer(2, 2)),\n            change_peer(ConfChangeType::RemoveNode, new_learner_peer(2, 2)),\n        ],\n    )\n    .unwrap();\n    must_contains_error(&resp, \"multiple commands for the same peer\");\n\n    // Can not have multiple changes that only effect learner\n    let resp = call_conf_change_v2(\n        &mut cluster,\n        region_id,\n        vec![\n            change_peer(ConfChangeType::RemoveNode, new_learner_peer(3, 3)),\n            change_peer(ConfChangeType::AddLearnerNode, new_learner_peer(4, 4)),\n        ],\n    )\n    .unwrap();\n    must_contains_error(&resp, \"multiple changes that only effect learner\");\n\n    // Can not demote leader with simple confchange\n    let resp = call_conf_change_v2(\n        &mut cluster,\n        region_id,\n        vec![change_peer(\n            ConfChangeType::AddLearnerNode,\n            new_learner_peer(1, 1),\n        )],\n    )\n    .unwrap();\n    must_contains_error(&resp, \"ignore remove leader or demote leader\");\n\n    let resp = call_conf_change(\n        &mut cluster,\n        region_id,\n        ConfChangeType::AddLearnerNode,\n        new_learner_peer(1, 1),\n    )\n    .unwrap();\n    must_contains_error(&resp, \"ignore remove leader or demote leader\");\n\n    // Can not leave a non-joint config\n    let resp = leave_joint(&mut cluster, region_id).unwrap();\n    must_contains_error(&resp, \"leave a non-joint config\");\n\n    // Split region\n    cluster.must_split(&region, b\"k3\");\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let right = pd_client.get_region(b\"k5\").unwrap();\n    assert_eq!(region_id, right.get_id());\n    // Enter joint\n    pd_client.must_joint_confchange(\n        region_id,\n        vec![\n            (ConfChangeType::AddLearnerNode, new_learner_peer(2, 2)),\n            (ConfChangeType::AddNode, new_peer(3, 3)),\n        ],\n    );\n    assert!(pd_client.is_in_joint(region_id));\n\n    // Can not merge region while in jonit state\n    let resp = cluster.try_merge(right.get_id(), left.get_id());\n    must_contains_error(&resp, \"in joint state, can not propose merge command\");\n\n    // Can not leave joint if which will demote leader\n    cluster.must_transfer_leader(region_id, new_peer(2, 2));\n    let resp = leave_joint(&mut cluster, region_id).unwrap();\n    must_contains_error(&resp, \"ignore leave joint command that demoting leader\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_logname.rs::test_normal", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_normal() {\n    let result = new_ucmd!().run();\n    println!(\"env::var(CI).is_ok() = {}\", env::var(\"CI\").is_ok());\n\n    for (key, value) in env::vars() {\n        println!(\"{key}: {value}\");\n    }\n    if (is_ci() || uucore::os::is_wsl_1()) && result.stderr_str().contains(\"no login name\") {\n        // ToDO: investigate WSL failure\n        // In the CI, some server are failing to return logname.\n        // As seems to be a configuration issue, ignoring it\n        return;\n    }\n\n    result.success();\n    assert!(!result.stdout_str().trim().is_empty());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_never", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_backup_never() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=never\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::static_duplicate_works", "code": "pub fn call(&self, mut ctx: impl AsContextMut, params: Params) -> Result<Results, Trap> {\n        // Note: Cloning an [`Engine`] is intentionally a cheap operation.\n        ctx.as_context().store.engine().clone().execute_func(\n            ctx.as_context_mut(),\n            &self.func,\n            params,\n            <CallResultsTuple<Results>>::default(),\n        )\n    }", "test": "fn static_duplicate_works() {\n    let (mut store, duplicate, duplicate_dyn) = setup_duplicate();\n    let duplicate = duplicate.typed::<i32, (i32, i32)>(&mut store).unwrap();\n    let duplicate_dyn = duplicate_dyn.typed::<i32, (i32, i32)>(&mut store).unwrap();\n    for input in 0..10 {\n        assert_eq!(duplicate.call(&mut store, input).unwrap(), (input, input));\n        assert_eq!(\n            duplicate_dyn.call(&mut store, input).unwrap(),\n            (input, input)\n        );\n    }\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/lib.rs::leaves_necessary_whitespace_all_nested", "code": "fn normalize_html(s: &str) -> String {\n    let parser = make_html_parser();\n    let dom = parser.one(s);\n    let body: SerializableHandle = normalize_dom(&dom).into();\n    let opts = SerializeOpts::default();\n    let mut ret_val = Vec::new();\n    serialize(&mut ret_val, &body, opts)\n        .expect(\"Writing to a string shouldn't fail (expect on OOM)\");\n    String::from_utf8(ret_val).expect(\"html5ever should always produce UTF8\")\n}", "test": "fn leaves_necessary_whitespace_all_nested() {\n    assert_eq!(\n        \"<u></u><u></u><u></u><u></u>\",\n        normalize_html(\"<u> </u><u> </u><u> </u><u> </u>\")\n    )\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/module.rs::serialize_not_overly_massive", "code": "fn len(&self) -> usize {\n                self.0.len()\n            }", "test": "fn serialize_not_overly_massive() -> Result<()> {\n    let mut config = Config::new();\n    config.memory_guaranteed_dense_image_size(1 << 20);\n    let engine = Engine::new(&config)?;\n\n    let assert_smaller_than_1mb = |module: &str| -> Result<()> {\n        println!(\"{}\", module);\n        let bytes = Module::new(&engine, module)?.serialize()?;\n        assert!(bytes.len() < (1 << 20));\n        Ok(())\n    };\n\n    // Tons of space between data segments should use sparse initialization,\n    // along with various permutations of empty and nonempty segments.\n    assert_smaller_than_1mb(\n        r#\"(module\n            (memory 20000)\n            (data (i32.const 0) \"a\")\n            (data (i32.const 0x200000) \"b\")\n        )\"#,\n    )?;\n    assert_smaller_than_1mb(\n        r#\"(module\n            (memory 20000)\n            (data (i32.const 0) \"a\")\n            (data (i32.const 0x200000) \"\")\n        )\"#,\n    )?;\n    assert_smaller_than_1mb(\n        r#\"(module\n            (memory 20000)\n            (data (i32.const 0) \"\")\n            (data (i32.const 0x200000) \"b\")\n        )\"#,\n    )?;\n    assert_smaller_than_1mb(\n        r#\"(module\n            (memory 20000)\n            (data (i32.const 0) \"\")\n            (data (i32.const 0x200000) \"\")\n        )\"#,\n    )?;\n\n    // lone data segment\n    assert_smaller_than_1mb(\n        r#\"(module\n            (memory 20000)\n            (data (i32.const 0x200000) \"b\")\n        )\"#,\n    )?;\n\n    Ok(())\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/threads.rs::test_export_shared_memory", "code": "pub fn size(&self, store: impl AsContext) -> u64 {\n        self.internal_size(store.as_context().0)\n    }", "test": "fn test_export_shared_memory() -> Result<()> {\n    let wat = r#\"(module (memory (export \"memory\") 1 5 shared))\"#;\n    let mut config = Config::new();\n    config.wasm_threads(true);\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, wat)?;\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let shared_memory = instance.get_shared_memory(&mut store, \"memory\").unwrap();\n\n    assert_eq!(shared_memory.size(), 1);\n    assert!(shared_memory.ty().is_shared());\n    assert_eq!(shared_memory.ty().maximum(), Some(5));\n\n    Ok(())\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u64_pow10_test", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "test": "fn u64_pow10_test() {\n    let values: &[u64] = &[\n        0,\n        1,\n        5,\n        9,\n        10,\n        11,\n        15,\n        99,\n        100,\n        101,\n        105,\n        999,\n        1000,\n        1001,\n        1005,\n        9999,\n        10000,\n        10001,\n        10005,\n        99999,\n        100000,\n        100001,\n        100005,\n        999999,\n        1000000,\n        1000001,\n        1000005,\n        9999999,\n        10000000,\n        10000001,\n        10000005,\n        99999999,\n        100000000,\n        100000001,\n        100000005,\n        999999999,\n        1000000000,\n        1000000001,\n        1000000005,\n        9999999999,\n        10000000000,\n        10000000001,\n        10000000005,\n        99999999999,\n        100000000000,\n        100000000001,\n        100000000005,\n        999999999999,\n        1000000000000,\n        1000000000001,\n        1000000000005,\n        9999999999999,\n        10000000000000,\n        10000000000001,\n        10000000000005,\n        99999999999999,\n        100000000000000,\n        100000000000001,\n        100000000000005,\n        999999999999999,\n        1000000000000000,\n        1000000000000001,\n        1000000000000005,\n        9999999999999999,\n        10000000000000000,\n        10000000000000001,\n        10000000000000005,\n        99999999999999999,\n        100000000000000000,\n        100000000000000001,\n        100000000000000005,\n        999999999999999999,\n        1000000000000000000,\n        1000000000000000001,\n        1000000000000000005,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_multiple_files", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_multiple_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(TEST_COPY_TO_FOLDER)\n        .succeeds();\n\n    assert_eq!(at.read(TEST_COPY_TO_FOLDER_FILE), \"Hello, World!\\n\");\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_DEST), \"How are you?\\n\");\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_lit.rs::strings", "code": "pub fn value(&self) -> String {\n        let repr = self.repr.token.to_string();\n        let (value, _suffix) = value::parse_lit_str(&repr);\n        String::from(value)\n    }", "test": "fn strings() {\n    fn test_string(s: &str, value: &str) {\n        match lit(s) {\n            Lit::Str(lit) => {\n                assert_eq!(lit.value(), value);\n                let again = lit.into_token_stream().to_string();\n                if again != s {\n                    test_string(&again, value);\n                }\n            }\n            wrong => panic!(\"{:?}\", wrong),\n        }\n    }\n\n    test_string(\"\\\"a\\\"\", \"a\");\n    test_string(\"\\\"\\\\n\\\"\", \"\\n\");\n    test_string(\"\\\"\\\\r\\\"\", \"\\r\");\n    test_string(\"\\\"\\\\t\\\"\", \"\\t\");\n    test_string(\"\\\"\ud83d\udc15\\\"\", \"\ud83d\udc15\"); // NOTE: This is an emoji\n    test_string(\"\\\"\\\\\\\"\\\"\", \"\\\"\");\n    test_string(\"\\\"'\\\"\", \"'\");\n    test_string(\"\\\"\\\"\", \"\");\n    test_string(\"\\\"\\\\u{1F415}\\\"\", \"\\u{1F415}\");\n    test_string(\"\\\"\\\\u{1_2__3_}\\\"\", \"\\u{123}\");\n    test_string(\n        \"\\\"contains\\nnewlines\\\\\\nescaped newlines\\\"\",\n        \"contains\\nnewlinesescaped newlines\",\n    );\n    test_string(\n        \"\\\"escaped newline\\\\\\n \\x0C unsupported whitespace\\\"\",\n        \"escaped newline\\x0C unsupported whitespace\",\n    );\n    test_string(\"r\\\"raw\\nstring\\\\\\nhere\\\"\", \"raw\\nstring\\\\\\nhere\");\n    test_string(\"\\\"...\\\"q\", \"...\");\n    test_string(\"r\\\"...\\\"q\", \"...\");\n    test_string(\"r##\\\"...\\\"##q\", \"...\");\n}\n\n#[te"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_rawkv.rs::test_region_merge", "code": "pub fn get_end_key(&self) -> &[u8] {\n        self.region.get_end_key()\n    }", "test": "fn test_region_merge() {\n    let mut suite = TestSuite::new(3, ApiVersion::V2);\n    let keys = vec![b\"rk0\", b\"rk1\", b\"rk2\", b\"rk3\", b\"rk4\", b\"rk5\"];\n\n    suite.must_raw_put(keys[1], b\"v1\");\n    suite.must_raw_put(keys[3], b\"v3\");\n    suite.must_raw_put(keys[5], b\"v5\");\n\n    // Split to: region1: (-, 2), region3: [2, 4), region5: [4, +)\n    let region1 = suite.cluster.get_region(keys[1]);\n    suite.cluster.must_split(&region1, keys[2]);\n    let region1 = suite.cluster.get_region(keys[1]);\n    let region3 = suite.cluster.get_region(keys[3]);\n    suite.cluster.must_split(&region3, keys[4]);\n    let region3 = suite.cluster.get_region(keys[3]);\n    let region5 = suite.cluster.get_region(keys[5]);\n    assert_eq!(region1.get_end_key(), region3.get_start_key());\n    assert_eq!(region3.get_end_key(), region5.get_start_key());\n\n    // Transfer leaders: region 1 -> store 1, region 3 -> store 2, region 5 -> store\n    // 3.\n    suite.must_transfer_leader(&region1, 1);\n    suite.must_transfer_leader(&region3, 2);\n    suite.must_transfer_leader(&region5, 3);\n\n    // Write to region 1.\n    {\n        let leader1 = suite.must_leader_on_store(keys[1], 1);\n\n        suite.must_raw_put(keys[1], b\"v2\");\n        suite.must_raw_put(keys[1], b\"v3\");\n        suite.flush_timestamp(leader1.get_store_id()); // Flush to make ts of store 1 larger than others.\n        suite.must_raw_put(keys[1], b\"v4\");\n        assert_eq!(suite.must_raw_get(keys[1]), Some(b\"v4\".to_vec()));\n    }\n\n    // Make causal_ts_provider.async_flush() & handle_update_max_timestamp fail.\n    fail::cfg(FP_GET_TSO, \"return(50)\").unwrap();\n\n    // Merge region 1 to 3.\n    {\n        suite.must_merge_region_by_key(keys[1], keys[3]);\n        suite.must_leader_on_store(keys[1], 2);\n\n        // Write to store 2. Store 2 has a TSO batch smaller than store 1.\n        suite.raw_put_err_by_timestamp_not_synced(keys[1], b\"v5\");\n        assert_eq!(suite.must_raw_get(keys[1]), Some(b\"v4\".to_vec()));\n        suite.raw_put_err_by_timestamp_not_synced(keys[1], b\"v6\");\n        assert_eq!(suite.must_raw_get(keys[1]), Some(b\"v4\".to_vec()));\n    }\n\n    // Make handle_update_max_timestamp succeed.\n    fail::cfg(FP_GET_TSO, \"off\").unwrap();\n\n    // Merge region 3 to 5.\n    {\n        suite.must_merge_region_by_key(keys[3], keys[5]);\n        suite.must_leader_on_store(keys[1], 3);\n\n        // Write to store 3.\n        suite.must_raw_put(keys[1], b\"v7\");\n        assert_eq!(suite.must_raw_get(keys[1]), Some(b\"v7\".to_vec()));\n        suite.must_raw_put(keys[1], b\"v8\");\n        assert_eq!(suite.must_raw_get(keys[1]), Some(b\"v8\".to_vec()));\n    }\n\n    fail::remove(FP_GET_TSO);\n    suite.stop();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_link.rs::test_link_nonexistent_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_link_nonexistent_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_link_nonexistent_file\";\n    let link = \"test_link_nonexistent_file_link\";\n\n    ucmd.args(&[file, link])\n        .fails()\n        .stderr_only(\"link: cannot create link 'test_link_nonexistent_file_link' to 'test_link_nonexistent_file': No such file or directory\\n\");\n    assert!(!at.file_exists(file));\n    assert!(!at.file_exists(link));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::range_query", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn range_query() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.range(3..7).unwrap();\n    for i in 3..7u64 {\n        let (key, value) = iter.next().unwrap().unwrap();\n        assert_eq!(i, key.value());\n        assert_eq!(i, value.value());\n    }\n    assert!(iter.next().is_none());\n\n    let mut iter = table.range(3..=7).unwrap();\n    for i in 3..=7u64 {\n        let (key, value) = iter.next().unwrap().unwrap();\n        assert_eq!(i, key.value());\n        assert_eq!(i, value.value());\n    }\n    assert!(iter.next().is_none());\n\n    let total: u64 = table\n        .range(1..=3)\n        .unwrap()\n        .map(|item| item.unwrap().1.value())\n        .sum();\n    assert_eq!(total, 6);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::vec_fixed_width_value_type", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn vec_fixed_width_value_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, Vec<u64>> = TableDefinition::new(\"x\");\n\n    let value = vec![0, 1, 2, 3];\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(0, &value).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(value, table.get(0).unwrap().unwrap().value());\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::indent_size_parse_errors_overflow", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn indent_size_parse_errors_overflow() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--indent-size=257\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"indent_size_parse_errors_overflow\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::tuple4_type", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn tuple4_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<(&str, u8, u16, u32), (u16, u32)> =\n        TableDefinition::new(\"table\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(table_def).unwrap();\n        table.insert(&(\"hello\", 5, 6, 7), &(0, 123)).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(table_def).unwrap();\n    assert_eq!(\n        table.get(&(\"hello\", 5, 6, 7)).unwrap().unwrap().value(),\n        (0, 123)\n    );\n}"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_boxed_raw_value", "code": "pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }", "test": "fn test_boxed_raw_value() {\n    #[derive(Serialize, Deserialize)]\n    struct Wrapper {\n        a: i8,\n        b: Box<RawValue>,\n        c: i8,\n    }\n\n    let wrapper_from_str: Wrapper =\n        serde_json::from_str(r#\"{\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3}\"#).unwrap();\n    assert_eq!(r#\"{\"foo\": 2}\"#, wrapper_from_str.b.get());\n\n    let wrapper_from_reader: Wrapper =\n        serde_json::from_reader(br#\"{\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3}\"#.as_ref()).unwrap();\n    assert_eq!(r#\"{\"foo\": 2}\"#, wrapper_from_reader.b.get());\n\n    let wrapper_from_value: Wrapper =\n        serde_json::from_value(json!({\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3})).unwrap();\n    assert_eq!(r#\"{\"foo\":2}\"#, wrapper_from_value.b.get());\n\n    let wrapper_to_string = serde_json::to_string(&wrapper_from_str).unwrap();\n    assert_eq!(r#\"{\"a\":1,\"b\":{\"foo\": 2},\"c\":3}\"#, wrapper_to_string);\n\n    let wrapper_to_value = serde_json::to_value(&wrapper_from_str).unwrap();\n    assert_eq!(json!({\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3}), wrapper_to_value);\n\n    let array_from_str: Vec<Box<RawValue>> =\n        serde_json::from_str(r#\"[\"a\", 42, {\"foo\": \"bar\"}, null]\"#).unwrap();\n    assert_eq!(r#\"\"a\"\"#, array_from_str[0].get());\n    assert_eq!(r#\"42\"#, array_from_str[1].get());\n    assert_eq!(r#\"{\"foo\": \"bar\"}\"#, array_from_str[2].get());\n    assert_eq!(r#\"null\"#, array_from_str[3].get());\n\n    let array_from_reader: Vec<Box<RawValue>> =\n        serde_json::from_reader(br#\"[\"a\", 42, {\"foo\": \"bar\"}, null]\"#.as_ref()).unwrap();\n    assert_eq!(r#\"\"a\"\"#, array_from_reader[0].get());\n    assert_eq!(r#\"42\"#, array_from_reader[1].get());\n    assert_eq!(r#\"{\"foo\": \"bar\"}\"#, array_from_reader[2].get());\n    assert_eq!(r#\"null\"#, array_from_reader[3].get());\n\n    let array_to_string = serde_json::to_string(&array_from_str).unwrap();\n    assert_eq!(r#\"[\"a\",42,{\"foo\": \"bar\"},null]\"#, array_to_string);\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::extended_connect_protocol_enabled_during_handshake", "code": "pub fn is_extended_connect_protocol_enabled(&self) -> Option<bool> {\n        self.enable_connect_protocol.map(|val| val != 0)\n    }", "test": "async fn extended_connect_protocol_enabled_during_handshake() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let settings = client.assert_server_handshake().await;\n\n        assert_eq!(settings.is_extended_connect_protocol_enabled(), Some(true));\n\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"CONNECT\", \"http://bread/baguette\")\n                    .protocol(\"the-bread-protocol\"),\n            )\n            .await;\n\n        client.recv_frame(frames::headers(1).response(200)).await;\n    };\n\n    let srv = async move {\n        let mut builder = server::Builder::new();\n\n        builder.enable_connect_protocol();\n\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(\n            req.extensions().get::<crate::ext::Protocol>(),\n            Some(&crate::ext::Protocol::from_static(\"the-bread-protocol\"))\n        );\n\n        let rsp = Response::new(());\n        stream.send_response(rsp, false).unwrap();\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n            .await\n            .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}"}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::sub_capture_matches", "code": "pub fn len(&self) -> usize {\n        self.locs.len()\n    }", "test": "fn sub_capture_matches() {\n    let re = regex!(r\"([a-z])(([a-z])|([0-9]))\");\n    let cap = re.captures(t!(\"a5\")).unwrap();\n    let subs: Vec<_> = cap.iter().collect();\n\n    assert_eq!(5, subs.len());\n    assert!(subs[0].is_some());\n    assert!(subs[1].is_some());\n    assert!(subs[2].is_some());\n    assert!(subs[3].is_none());\n    assert!(subs[4].is_some());\n\n    assert_eq!(t!(\"a5\"), match_text!(subs[0].unwrap()));\n    assert_eq!(t!(\"a\"), match_text!(subs[1].unwrap()));\n    assert_eq!(t!(\"5\"), match_text!(subs[2].unwrap()));\n    assert_eq!(t!(\"5\"), match_text!(subs[4].unwrap()));\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_data_padding", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "test": "async fn read_data_padding() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 16, 0, 0x8, 0, 0, 0, 1,\n            5,       // Pad length\n            \"helloworld\", // Data\n            \"\\0\\0\\0\\0\\0\", // Padding\n        ];\n    };\n\n    let data = poll_frame!(Data, codec);\n    assert_eq!(data.stream_id(), 1);\n    assert_eq!(data.payload(), &b\"helloworld\"[..]);\n    assert!(!data.is_end_stream());\n\n    assert_closed!(codec);\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/trailers.rs::recv_trailers_only", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "test": "async fn recv_trailers_only() {\n    h2_support::trace_init!();\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        // Write GET /\n        .write(&[\n            0, 0, 0x10, 1, 5, 0, 0, 0, 1, 0x82, 0x87, 0x41, 0x8B, 0x9D, 0x29, 0xAC, 0x4B, 0x8F,\n            0xA8, 0xE9, 0x19, 0x97, 0x21, 0xE9, 0x84,\n        ])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[\n            0, 0, 1, 1, 4, 0, 0, 0, 1, 0x88, 0, 0, 9, 1, 5, 0, 0, 0, 1, 0x40, 0x84, 0x42, 0x46,\n            0x9B, 0x51, 0x82, 0x3F, 0x5F,\n        ])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    // Send the request\n    let request = Request::builder()\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    tracing::info!(\"sending request\");\n    let (response, _) = client.send_request(request, true).unwrap();\n\n    let response = h2.run(response).await.unwrap();\n    assert_eq!(response.status(), StatusCode::OK);\n\n    let (_, mut body) = response.into_parts();\n\n    // Make sure there is no body\n    let chunk = h2.run(Box::pin(body.next())).await;\n    assert!(chunk.is_none());\n\n    let trailers = h2\n        .run(poll_fn(|cx| body.poll_trailers(cx)))\n        .await\n        .unwrap()\n        .unwrap();\n    assert_eq!(1, trailers.len());\n    assert_eq!(trailers[\"status\"], \"ok\");\n\n    h2.await.unwrap();\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/globals.rs::v128", "code": "fn v128() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::V128, Mutability::Var),\n        0u128.into(),\n    )?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(0)));\n    g.set(&mut store, 1u128.into())?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(1)));\n    Ok(())\n}", "test": "fn v128() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::V128, Mutability::Var),\n        0u128.into(),\n    )?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(0)));\n    g.set(&mut store, 1u128.into())?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(1)));\n    Ok(())\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_client_complete_io_for_handshake", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "test": "fn buffered_client_complete_io_for_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    assert!(client.is_handshaking());\n    let (rdlen, wrlen) = client\n        .complete_io(&mut OtherSession::new_buffered(&mut server))\n        .unwrap();\n    assert!(rdlen > 0 && wrlen > 0);\n    assert!(!client.is_handshaking());\n    assert!(!client.wants_write());\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::drop_host_twice", "code": "fn to_string(lit: Literal) -> String {\n    let formatted = lit.to_string();\n\n    let mut it = formatted.chars();\n    assert_eq!(it.next(), Some('\"'));\n\n    let mut rv = String::new();\n    loop {\n        match it.next() {\n            Some('\"') => match it.next() {\n                Some(_) => panic!(),\n                None => break,\n            },\n            Some('\\\\') => match it.next() {\n                Some('x') => {\n                    let hi = it.next().unwrap().to_digit(16).unwrap();\n                    let lo = it.next().unwrap().to_digit(16).unwrap();\n                    let v = (hi << 16) | lo;\n                    rv.push(v as u8 as char);\n                }\n                Some('u') => {\n                    assert_eq!(it.next(), Some('{'));\n                    let mut c = it.next().unwrap();\n                    let mut ch = 0;\n                    while let Some(v) = c.to_digit(16) {\n                        ch *= 16;\n                        ch |= v;\n                        c = it.next().unwrap();\n                    }\n                    assert_eq!(c, '}');\n                    rv.push(::std::char::from_u32(ch).unwrap());\n                }\n                Some('0') => rv.push('\\0'),\n                Some('\\\\') => rv.push('\\\\'),\n                Some('\\\"') => rv.push('\\\"'),\n                Some('r') => rv.push('\\r'),\n                Some('n') => rv.push('\\n'),\n                Some('t') => rv.push('\\t'),\n                Some(_) => panic!(),\n                None => panic!(),\n            },\n            Some(c) => rv.push(c),\n            None => panic!(),\n        }\n    }\n\n    rv\n}", "test": "fn drop_host_twice() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n\n                (core func $dtor (canon resource.drop $t))\n                (func (export \"dtor\") (param \"x\" (own $t))\n                    (canon lift (core func $dtor)))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n    let dtor = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"dtor\")?;\n\n    let t = Resource::new_own(100);\n    dtor.call(&mut store, (&t,))?;\n    dtor.post_return(&mut store)?;\n\n    assert_eq!(\n        dtor.call(&mut store, (&t,)).unwrap_err().to_string(),\n        \"host resource already consumed\"\n    );\n\n    Ok(())\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::timeout_in_start", "code": "fn success() -> Self {\n        Self::Success\n    }", "test": "fn timeout_in_start() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/iloop-start.wat\")?;\n    let output = run_wasmtime_for_output(\n        &[\n            \"run\",\n            \"-Wtimeout=1ms\",\n            \"-Ccache=n\",\n            wasm.path().to_str().unwrap(),\n        ],\n        None,\n    )?;\n    assert!(!output.status.success());\n    assert_eq!(output.stdout, b\"\");\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"wasm trap: interrupt\"),\n        \"bad stderr: {}\",\n        stderr\n    );\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_overwrite_dir_fail", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_symlink_overwrite_dir_fail() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let path_a = \"test_symlink_overwrite_dir_a\";\n    let path_b = \"test_symlink_overwrite_dir_b\";\n\n    at.touch(path_a);\n    at.mkdir(path_b);\n\n    assert!(!ucmd\n        .args(&[\"-s\", \"-T\", path_a, path_b])\n        .fails()\n        .stderr_str()\n        .is_empty());\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/server_future_tests.rs::test_server_form_error_on_multiple_queries", "code": "pub(super) fn len(&self) -> usize {\n            self.buffer.len()\n        }", "test": "fn test_server_form_error_on_multiple_queries() {\n    let runtime = Runtime::new().expect(\"failed to create Tokio Runtime\");\n    let addr = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 0));\n    let udp_socket = runtime.block_on(UdpSocket::bind(&addr)).unwrap();\n\n    let ipaddr = udp_socket.local_addr().unwrap();\n    println!(\"udp_socket on port: {ipaddr}\");\n    let server_continue = Arc::new(AtomicBool::new(true));\n    let server_continue2 = server_continue.clone();\n\n    let server_thread = thread::Builder::new()\n        .name(\"test_server:udp:server\".to_string())\n        .spawn(move || server_thread_udp(runtime, udp_socket, server_continue2))\n        .unwrap();\n\n    let conn = UdpClientConnection::new(ipaddr).unwrap();\n    let client = SyncClient::new(conn);\n\n    // build the message\n    let query_a = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let query_aaaa = Query::query(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        RecordType::AAAA,\n    );\n    let mut message: Message = Message::new();\n    message\n        .add_query(query_a)\n        .add_query(query_aaaa)\n        .set_message_type(MessageType::Query)\n        .set_op_code(OpCode::Query)\n        .set_recursion_desired(true);\n\n    let mut client_result = client.send(message);\n\n    assert_eq!(client_result.len(), 1);\n    let client_result = client_result\n        .pop()\n        .expect(\"there should be one response\")\n        .expect(\"should have been a successful network request\");\n\n    assert_eq!(client_result.response_code(), ResponseCode::FormErr);\n\n    server_continue.store(false, Ordering::Relaxed);\n    server_thread.join().unwrap();\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression8", "code": "pub(crate) fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.page.memory()[self.value_range.clone()])\n    }", "test": "fn regression8() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let mut tx = db.begin_write().unwrap();\n    tx.set_durability(Durability::None);\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 1186];\n        t.insert(&145227, v.as_slice()).unwrap();\n        let v = vec![0u8; 1585];\n        t.insert(&565922, v.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 2040];\n        t.insert(&94937, v.as_slice()).unwrap();\n        let v = vec![0u8; 2058];\n        t.insert(&130571, v.as_slice()).unwrap();\n        t.remove(&145227).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 947];\n        t.insert(&118749, v.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let t = tx.open_table(table_def).unwrap();\n        let mut iter = t.range(118749..142650).unwrap();\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 118749);\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 130571);\n        assert!(iter.next().is_none());\n    }\n    tx.commit().unwrap();\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::with_invalid_semicolons_option", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn with_invalid_semicolons_option() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--semicolons\"), (\"asneed\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"with_invalid_semicolons_option\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_hex_suffix_no_value", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_hex_suffix_no_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-l\", \"9\", \"--hex-suffixes\", \"onehundredlines.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x00\"), \"00\\n01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n\");\n    assert_eq!(at.read(\"x01\"), \"09\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n\");\n    assert_eq!(at.read(\"x02\"), \"18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n\");\n    assert_eq!(at.read(\"x03\"), \"27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n\");\n    assert_eq!(at.read(\"x04\"), \"36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n\");\n    assert_eq!(at.read(\"x05\"), \"45\\n46\\n47\\n48\\n49\\n50\\n51\\n52\\n53\\n\");\n    assert_eq!(at.read(\"x06\"), \"54\\n55\\n56\\n57\\n58\\n59\\n60\\n61\\n62\\n\");\n    assert_eq!(at.read(\"x07\"), \"63\\n64\\n65\\n66\\n67\\n68\\n69\\n70\\n71\\n\");\n    assert_eq!(at.read(\"x08\"), \"72\\n73\\n74\\n75\\n76\\n77\\n78\\n79\\n80\\n\");\n    assert_eq!(at.read(\"x09\"), \"81\\n82\\n83\\n84\\n85\\n86\\n87\\n88\\n89\\n\");\n    assert_eq!(at.read(\"x0a\"), \"90\\n91\\n92\\n93\\n94\\n95\\n96\\n97\\n98\\n\");\n    assert_eq!(at.read(\"x0b\"), \"99\\n\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_witness.rs::test_witness_conf_change", "code": "pub fn len(&self) -> usize {\n        self.events.len()\n    }", "test": "fn test_witness_conf_change() {\n    let mut cluster = new_server_cluster(0, 3);\n    cluster.run();\n    let nodes = Vec::from_iter(cluster.get_node_ids());\n    assert_eq!(nodes.len(), 3);\n\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();\n    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1.clone());\n\n    // can't switch witness by conf change\n    let mut peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n    let mut peer = peer_on_store3.clone();\n    peer.set_is_witness(true);\n    let mut cp = ChangePeerRequest::default();\n    cp.set_change_type(ConfChangeType::AddLearnerNode);\n    cp.set_peer(peer);\n    let req = new_admin_request(\n        region.get_id(),\n        region.get_region_epoch(),\n        new_change_peer_v2_request(vec![cp]),\n    );\n    let resp = cluster\n        .call_command_on_leader(req, Duration::from_millis(100))\n        .unwrap();\n    assert!(resp.get_header().has_error());\n\n    // add a new witness peer\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), peer_on_store3.clone());\n    peer_on_store3.set_is_witness(true);\n    let applied_index = cluster.apply_state(1, 2).applied_index;\n    cluster\n        .pd_client\n        .must_add_peer(region.get_id(), peer_on_store3.clone());\n    must_get_none(&cluster.get_engine(3), b\"k1\");\n    let region = cluster.get_region(b\"k1\");\n    cluster.wait_applied_index(region.get_id(), nodes[2], applied_index + 1);\n    assert_eq!(\n        cluster\n            .region_local_state(region.get_id(), nodes[2])\n            .get_region(),\n        &region\n    );\n\n    // remove a witness peer\n    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), peer_on_store3);\n\n    std::thread::sleep(Duration::from_millis(10));\n\n    assert_eq!(\n        cluster\n            .region_local_state(region.get_id(), nodes[2])\n            .get_state(),\n        PeerState::Tombstone\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_relative", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_symlink_relative() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_symlink_relative_a\";\n    let link = \"test_symlink_relative_link\";\n\n    at.touch(file_a);\n\n    // relative symlink\n    ucmd.args(&[\"-r\", \"-s\", file_a, link]).succeeds();\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file_a);\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_goaway_with_debug_data", "code": "pub(crate) fn reason(&self) -> Reason {\n        self.reason\n    }", "test": "async fn read_goaway_with_debug_data() {\n    let mut codec = raw_codec! {\n        read => [\n            // head\n            0, 0, 22, 7, 0, 0, 0, 0, 0,\n            // last_stream_id\n            0, 0, 0, 1,\n            // error_code\n            0, 0, 0, 11,\n            // debug_data\n            \"too_many_pings\",\n        ];\n    };\n\n    let data = poll_frame!(GoAway, codec);\n    assert_eq!(data.reason(), Reason::ENHANCE_YOUR_CALM);\n    assert_eq!(data.last_stream_id(), 1);\n    assert_eq!(&**data.debug_data(), b\"too_many_pings\");\n\n    assert_closed!(codec);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_simple", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_backup_simple() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=simple\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_compiler.rs::test_referenced_names_empty_bug", "code": "pub fn is_empty(&self) -> bool {\n        self.instructions.is_empty()\n    }", "test": "fn test_referenced_names_empty_bug() {\n    let c = CodeGenerator::new(\"<unknown>\", \"\");\n    let instructions = c.finish().0;\n    let rv = instructions.get_referenced_names(0);\n    assert!(rv.is_empty());\n}"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_generics.rs::test_where_clause_at_end_of_input", "code": "pub fn len(&self) -> usize {\n        self.inner.len() + if self.last.is_some() { 1 } else { 0 }\n    }", "test": "fn test_where_clause_at_end_of_input() {\n    let input = quote! {\n        where\n    };\n\n    snapshot!(input as WhereClause, @\"WhereClause\");\n\n    assert_eq!(input.predicates.len(), 0);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_list_final_new_line", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_kill_list_final_new_line() {\n    let re = Regex::new(\"\\\\n$\").unwrap();\n    assert!(re.is_match(new_ucmd!().arg(\"-l\").succeeds().stdout_str()));\n}"}
{"test_id": "dtolnay-serde-yaml/dtolnay-serde-yaml-f8adb28/tests/test_serde.rs::test_float32", "code": "pub fn is_nan(&self) -> bool {\n        match self.n {\n            N::PosInt(_) | N::NegInt(_) => false,\n            N::Float(f) => f.is_nan(),\n        }\n    }", "test": "fn test_float32() {\n    let thing: f32 = 25.5;\n    let yaml = indoc! {\"\n        25.5\n    \"};\n    test_serde(&thing, yaml);\n\n    let thing = f32::INFINITY;\n    let yaml = indoc! {\"\n        .inf\n    \"};\n    test_serde(&thing, yaml);\n\n    let thing = f32::NEG_INFINITY;\n    let yaml = indoc! {\"\n        -.inf\n    \"};\n    test_serde(&thing, yaml);\n\n    let single_float: f32 = serde_yaml::from_str(indoc! {\"\n        .nan\n    \"})\n    .unwrap();\n    assert!(single_float.is_nan());\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u128_pow10_test", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "test": "fn u128_pow10_test() {\n    let values: &[u128] = &[\n        0,\n        1,\n        5,\n        9,\n        10,\n        11,\n        15,\n        99,\n        100,\n        101,\n        105,\n        999,\n        1000,\n        1001,\n        1005,\n        9999,\n        10000,\n        10001,\n        10005,\n        99999,\n        100000,\n        100001,\n        100005,\n        999999,\n        1000000,\n        1000001,\n        1000005,\n        9999999,\n        10000000,\n        10000001,\n        10000005,\n        99999999,\n        100000000,\n        100000001,\n        100000005,\n        999999999,\n        1000000000,\n        1000000001,\n        1000000005,\n        9999999999,\n        10000000000,\n        10000000001,\n        10000000005,\n        99999999999,\n        100000000000,\n        100000000001,\n        100000000005,\n        999999999999,\n        1000000000000,\n        1000000000001,\n        1000000000005,\n        9999999999999,\n        10000000000000,\n        10000000000001,\n        10000000000005,\n        99999999999999,\n        100000000000000,\n        100000000000001,\n        100000000000005,\n        999999999999999,\n        1000000000000000,\n        1000000000000001,\n        1000000000000005,\n        9999999999999999,\n        10000000000000000,\n        10000000000000001,\n        10000000000000005,\n        99999999999999999,\n        100000000000000000,\n        100000000000000001,\n        100000000000000005,\n        999999999999999999,\n        1000000000000000000,\n        1000000000000000001,\n        1000000000000000005,\n        9999999999999999999,\n        10000000000000000000,\n        10000000000000000001,\n        10000000000000000005,\n        99999999999999999999,\n        100000000000000000000,\n        100000000000000000001,\n        100000000000000000005,\n        999999999999999999999,\n        1000000000000000000000,\n        1000000000000000000001,\n        1000000000000000000005,\n        9999999999999999999999,\n        10000000000000000000000,\n        10000000000000000000001,\n        10000000000000000000005,\n        99999999999999999999999,\n        100000000000000000000000,\n        100000000000000000000001,\n        100000000000000000000005,\n        999999999999999999999999,\n        1000000000000000000000000,\n        1000000000000000000000001,\n        1000000000000000000000005,\n        9999999999999999999999999,\n        10000000000000000000000000,\n        10000000000000000000000001,\n        10000000000000000000000005,\n        99999999999999999999999999,\n        100000000000000000000000000,\n        100000000000000000000000001,\n        100000000000000000000000005,\n        999999999999999999999999999,\n        1000000000000000000000000000,\n        1000000000000000000000000001,\n        1000000000000000000000000005,\n        9999999999999999999999999999,\n        10000000000000000000000000000,\n        10000000000000000000000000001,\n        10000000000000000000000000005,\n        99999999999999999999999999999,\n        100000000000000000000000000000,\n        100000000000000000000000000001,\n        100000000000000000000000000005,\n        999999999999999999999999999999,\n        1000000000000000000000000000000,\n        1000000000000000000000000000001,\n        1000000000000000000000000000005,\n        9999999999999999999999999999999,\n        10000000000000000000000000000000,\n        10000000000000000000000000000001,\n        10000000000000000000000000000005,\n        99999999999999999999999999999999,\n        100000000000000000000000000000000,\n        100000000000000000000000000000001,\n        100000000000000000000000000000005,\n        999999999999999999999999999999999,\n        1000000000000000000000000000000000,\n        1000000000000000000000000000000001,\n        1000000000000000000000000000000005,\n        9999999999999999999999999999999999,\n        10000000000000000000000000000000000,\n        10000000000000000000000000000000001,\n        10000000000000000000000000000000005,\n        99999999999999999999999999999999999,\n        100000000000000000000000000000000000,\n        100000000000000000000000000000000001,\n        100000000000000000000000000000000005,\n        999999999999999999999999999999999999,\n        1000000000000000000000000000000000000,\n        1000000000000000000000000000000000001,\n        1000000000000000000000000000000000005,\n        9999999999999999999999999999999999999,\n        10000000000000000000000000000000000000,\n        10000000000000000000000000000000000001,\n        10000000000000000000000000000000000005,\n        99999999999999999999999999999999999999,\n        100000000000000000000000000000000000000,\n        100000000000000000000000000000000000001,\n        100000000000000000000000000000000000005,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_no_change_to_group", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_no_change_to_group() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n    let result = scene.cmd(\"id\").arg(\"-ng\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let group_name = String::from(result.stdout_str().trim());\n    assert!(!group_name.is_empty());\n\n    for (i, from) in [\"42\", \":42\", \"42:42\"].iter().enumerate() {\n        let file = i.to_string();\n        at.touch(&file);\n        scene\n            .ucmd()\n            .arg(\"-v\")\n            .arg(format!(\"--from={from}\"))\n            .arg(\":43\")\n            .arg(&file)\n            .succeeds()\n            .stdout_only(format!(\"ownership of '{file}' retained as {group_name}\\n\"));\n    }\n}"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_closing_bracket_in_double_quote_attr", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "test": "fn test_closing_bracket_in_double_quote_attr() {\n    let mut r = Reader::from_str(r#\"<a attr=\">\" check=\"2\"></a>\"#);\n    r.trim_text(true);\n    match r.read_event() {\n        Ok(Start(e)) => {\n            let mut attrs = e.attributes();\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"attr\"),\n                    value: Cow::Borrowed(b\">\"),\n                }))\n            );\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"check\"),\n                    value: Cow::Borrowed(b\"2\"),\n                }))\n            );\n            assert_eq!(attrs.next(), None);\n        }\n        x => panic!(\"expected <a attr='>'>, got {:?}\", x),\n    }\n    next_eq!(r, End, b\"a\");\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_concurrent_requests_2_conns", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "test": "fn test_concurrent_requests_2_conns() {\n    let mut options = ResolverOpts::default();\n\n    // there are only 2 conns, so this matches that count\n    options.num_concurrent_reqs = 2;\n\n    // we want to make sure that both udp connections are called\n    //   this will count down to 0 only if both are called.\n    let on_send = OnSendBarrier::new(2);\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let udp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n\n    let udp_message = message(query.clone(), vec![udp_record.clone()], vec![], vec![]);\n\n    let udp1_nameserver = mock_nameserver_on_send(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        options.clone(),\n        on_send.clone(),\n    );\n    let udp2_nameserver = mock_nameserver_on_send(vec![], options.clone(), on_send);\n\n    let pool = mock_nameserver_pool_on_send(\n        vec![udp2_nameserver, udp1_nameserver],\n        vec![],\n        None,\n        options,\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    // there's no actual network traffic happening, 1 sec should be plenty\n    //   TODO: for some reason this timeout doesn't work, not clear why...\n    // let future = Timeout::new(future, Duration::from_secs(1));\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], udp_record);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_mode_numeric", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_mode_numeric() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"dir1\";\n    let dir2 = \"dir2\";\n\n    let file = \"file\";\n    let mode_arg = \"--mode=333\";\n\n    at.touch(file);\n    at.mkdir(dir);\n    scene\n        .ucmd()\n        .arg(file)\n        .arg(dir)\n        .arg(mode_arg)\n        .succeeds()\n        .no_stderr();\n\n    let dest_file = &format!(\"{dir}/{file}\");\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(dest_file));\n    let permissions = at.metadata(dest_file).permissions();\n    assert_eq!(0o100_333_u32, PermissionsExt::mode(&permissions));\n\n    let mode_arg = \"-m 0333\";\n    at.mkdir(dir2);\n\n    scene.ucmd().arg(mode_arg).arg(file).arg(dir2).succeeds();\n\n    let dest_file = &format!(\"{dir2}/{file}\");\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(dest_file));\n    let permissions = at.metadata(dest_file).permissions();\n    assert_eq!(0o100_333_u32, PermissionsExt::mode(&permissions));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_mdhm_time", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_mdhm_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_mdhm_time\";\n\n    ucmd.args(&[\"-t\", \"01011234\", file]).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\n        \"%Y%m%d%H%M\",\n        &format!(\"{}01010000\", time::OffsetDateTime::now_utc().year()),\n    );\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error32_test", "code": "fn compute_error32(q: i64, w: u64) -> (i32, u64) {\n    let fp = lemire::compute_error::<f32>(q, w);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_error32_test() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_error32(0, 16777216), (111 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error32(0, 16777217), (111 + INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_error32(0, 16777218), (111 + INVALID_FP, 9223373136366403584));\n    assert_eq!(compute_error32(0, 16777219), (111 + INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_error32(0, 16777220), (111 + INVALID_FP, 9223374235878031360));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_error32(-10, 167772160000000000), (111 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error32(-10, 167772170000000000), (111 + INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_error32(-10, 167772180000000000), (111 + INVALID_FP, 9223373136366403584));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(compute_error32(-10, 167772190000000000), (111 + INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_error32(-10, 167772200000000000), (111 + INVALID_FP, 9223374235878031360));\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::fs_error_read_only", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn fs_error_read_only() {\n    let mut fs = MemoryFileSystem::new_read_only();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"test.js\");\n    fs.insert(file_path.into(), *b\"content\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                (\"--write\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Do not store the content of the file in the snapshot\n    fs.remove(file_path);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_read_only\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/gc.rs::global_init_no_leak", "code": "pub fn strong_count(&self) -> usize {\n        self.extern_data().ref_count.load(Ordering::SeqCst)\n    }", "test": "fn global_init_no_leak() -> anyhow::Result<()> {\n    let (mut store, module) = ref_types_module(\n        false,\n        r#\"\n            (module\n                (import \"\" \"\" (global externref))\n                (global externref (global.get 0))\n            )\n        \"#,\n    )?;\n\n    let externref = ExternRef::new(());\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::ExternRef, Mutability::Const),\n        externref.clone().into(),\n    )?;\n    Instance::new(&mut store, &module, &[global.into()])?;\n    drop(store);\n    assert_eq!(externref.strong_count(), 1);\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_elide_empty_files", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_elide_empty_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-e\", \"-n\", \"4\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"a\");\n    assert_eq!(at.read(\"xab\"), \"b\");\n    assert_eq!(at.read(\"xac\"), \"c\");\n    assert!(!at.plus(\"xad\").exists());\n}"}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::unnamed_field_struct", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "test": "fn unnamed_field_struct() {\n    #[derive(CacheKey, Hash)]\n    struct UnnamedFieldsStruct(String, String);\n\n    let mut key = CacheKeyHasher::new();\n\n    let unnamed_fields = UnnamedFieldsStruct(\"Hello\".into(), \"World\".into());\n\n    unnamed_fields.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    unnamed_fields.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_target_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_target_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let file2 = \"target_file\";\n\n    at.touch(file1);\n    at.touch(file2);\n    ucmd.arg(file1).arg(file2).succeeds().no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client.rs::test_rpc_client", "code": "fn fetch_cluster_id(&mut self) -> Result<u64> {\n        if !self.raw_client.initialized() {\n            block_on(self.raw_client.wait_for_ready())?;\n        }\n        let id = self.raw_client.cluster_id();\n        assert!(id > 0);\n        Ok(id)\n    }", "test": "fn test_rpc_client() {\n    let rt = setup_runtime();\n    let _g = rt.enter();\n    let eps_count = 1;\n    let server = MockServer::new(eps_count);\n    let eps = server.bind_addrs();\n\n    let mut client = new_client_v2(eps.clone(), None);\n    assert_ne!(client.fetch_cluster_id().unwrap(), 0);\n\n    let store_id = client.alloc_id().unwrap();\n    let mut store = metapb::Store::default();\n    store.set_id(store_id);\n    debug!(\"bootstrap store {:?}\", store);\n\n    let peer_id = client.alloc_id().unwrap();\n    let mut peer = metapb::Peer::default();\n    peer.set_id(peer_id);\n    peer.set_store_id(store_id);\n\n    let region_id = client.alloc_id().unwrap();\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    region.mut_peers().push(peer.clone());\n    debug!(\"bootstrap region {:?}\", region);\n\n    client\n        .bootstrap_cluster(store.clone(), region.clone())\n        .unwrap();\n    assert_eq!(client.is_cluster_bootstrapped().unwrap(), true);\n\n    let tmp_stores = client.get_all_stores(false).unwrap();\n    assert_eq!(tmp_stores.len(), 1);\n    assert_eq!(tmp_stores[0], store);\n\n    let tmp_store = client.get_store(store_id).unwrap();\n    assert_eq!(tmp_store.get_id(), store.get_id());\n\n    let region_key = region.get_start_key();\n    let tmp_region = client.get_region(region_key).unwrap();\n    assert_eq!(tmp_region.get_id(), region.get_id());\n\n    let region_info = client.get_region_info(region_key).unwrap();\n    assert_eq!(region_info.region, region);\n    assert_eq!(region_info.leader, None);\n\n    let tmp_region = block_on(client.get_region_by_id(region_id))\n        .unwrap()\n        .unwrap();\n    assert_eq!(tmp_region.get_id(), region.get_id());\n\n    let ts = must_get_tso(&mut client, 1);\n    assert_ne!(ts, TimeStamp::zero());\n\n    let ts100 = must_get_tso(&mut client, 100);\n    assert_eq!(ts.logical() + 100, ts100.logical());\n\n    let mut prev_id = 0;\n    for _ in 0..10 {\n        let mut client = new_client_v2(eps.clone(), None);\n        let alloc_id = client.alloc_id().unwrap();\n        assert!(alloc_id > prev_id);\n        prev_id = alloc_id;\n    }\n\n    let (tx, mut responses) = client\n        .create_region_heartbeat_stream(WakePolicy::Immediately)\n        .unwrap();\n    let mut req = pdpb::RegionHeartbeatRequest::default();\n    req.set_region(region.clone());\n    req.set_leader(peer.clone());\n    tx.send(req).unwrap();\n    block_on(tokio::time::timeout(\n        Duration::from_secs(3),\n        responses.next(),\n    ))\n    .unwrap();\n\n    let region_info = client.get_region_info(region_key).unwrap();\n    assert_eq!(region_info.region, region);\n    assert_eq!(region_info.leader.unwrap(), peer);\n\n    block_on(client.store_heartbeat(\n        pdpb::StoreStats::default(),\n        None, // store_report\n        None,\n    ))\n    .unwrap();\n    block_on(client.ask_batch_split(metapb::Region::default(), 1)).unwrap();\n    block_on(client.report_batch_split(vec![metapb::Region::default(), metapb::Region::default()]))\n        .unwrap();\n\n    let region_info = client.get_region_info(region_key).unwrap();\n    client.scatter_region(region_info).unwrap();\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::multi_page_kv", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn multi_page_kv() {\n    let tmpfile = create_tempfile();\n    let elements = 4;\n    let page_size = 4096;\n\n    let db = Builder::new().create(tmpfile.path()).unwrap();\n    let txn = db.begin_write().unwrap();\n\n    let mut key = vec![0u8; page_size + 1];\n    let mut value = vec![0; page_size + 1];\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..elements {\n            key[0] = i;\n            value[0] = i;\n            table.insert(key.as_slice(), value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_read().unwrap();\n    let table = txn.open_table(SLICE_TABLE).unwrap();\n    for i in 0..elements {\n        key[0] = i;\n        value[0] = i;\n        assert_eq!(&value, table.get(key.as_slice()).unwrap().unwrap().value());\n    }\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..elements {\n            key[0] = i;\n            table.remove(key.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_preserve_timestamps", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_preserve_timestamps() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let file2 = \"target_file\";\n    at.touch(file1);\n\n    ucmd.arg(file1).arg(file2).arg(\"-p\").succeeds().no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n\n    let file1_metadata = at.metadata(file1);\n    let file2_metadata = at.metadata(file2);\n\n    assert_eq!(\n        file1_metadata.accessed().ok(),\n        file2_metadata.accessed().ok()\n    );\n    assert_eq!(\n        file1_metadata.modified().ok(),\n        file2_metadata.modified().ok()\n    );\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_none", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_update_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"--update=none\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"How are you?\\n\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_symlink_multiple_fail", "code": "fn code(&self) -> i32 {\n        match self {\n            Self::BackupImpossible() => 2,\n            _ => 1,\n        }\n    }", "test": "fn test_du_symlink_multiple_fail() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.symlink_file(\"non-existing.txt\", \"target.txt\");\n    let mut file1 = at.make_file(\"file1\");\n    file1.write_all(b\"azeaze\").unwrap();\n\n    let result = ts.ucmd().arg(\"-L\").arg(\"target.txt\").arg(\"file1\").fails();\n    assert_eq!(result.code(), 1);\n    result.stdout_contains(\"4\\tfile1\\n\");\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error64_test", "code": "fn compute_error64(q: i64, w: u64) -> (i32, u64) {\n    let fp = lemire::compute_error::<f64>(q, w);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_error64_test() {\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_error64(0, 9007199254740992), (1065 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error64(0, 9007199254740993), (1065 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(0, 9007199254740994), (1065 + INVALID_FP, 9223372036854777856));\n    assert_eq!(compute_error64(0, 9007199254740995), (1065 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_error64(0, 9007199254740996), (1065 + INVALID_FP, 9223372036854779904));\n    assert_eq!(compute_error64(0, 18014398509481984), (1066 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error64(0, 18014398509481986), (1066 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(0, 18014398509481988), (1066 + INVALID_FP, 9223372036854777856));\n    assert_eq!(compute_error64(0, 18014398509481990), (1066 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_error64(0, 18014398509481992), (1066 + INVALID_FP, 9223372036854779904));\n\n    // Test a much closer set of examples.\n    assert_eq!(compute_error64(0, 9007199254740991), (1064 + INVALID_FP, 18446744073709549568));\n    assert_eq!(compute_error64(0, 9223372036854776831), (1075 + INVALID_FP, 9223372036854776830));\n    assert_eq!(compute_error64(0, 9223372036854776832), (1075 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(0, 9223372036854776833), (1075 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(-42, 9123456727292927), (925 + INVALID_FP, 13021432563531497894));\n    assert_eq!(compute_error64(-43, 91234567272929275), (925 + INVALID_FP, 13021432563531498606));\n    assert_eq!(compute_error64(-42, 9123456727292928), (925 + INVALID_FP, 13021432563531499320));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_error64(-3, 9007199254740992000), (1065 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error64(-3, 9007199254740993000), (1065 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(-3, 9007199254740994000), (1065 + INVALID_FP, 9223372036854777856));\n    assert_eq!(compute_error64(-3, 9007199254740995000), (1065 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_error64(-3, 9007199254740996000), (1065 + INVALID_FP, 9223372036854779904));\n\n    // Test from errors in atof.\n    assert_eq!(compute_error64(-18, 1000000178813934326), (1012 + INVALID_FP, 9223373686122217470));\n\n    // Check edge-cases from previous errors.\n    assert_eq!(\n        compute_error64(-342, 2470328229206232720),\n        (-64 + INVALID_FP, 18446744073709551608)\n    );\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_variable_block_ident", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn render_variable_block_ident() {\n    let mut context = Context::new();\n    context.insert(\"name\", &\"john\");\n    context.insert(\"malicious\", &\"<html>\");\n    context.insert(\"a\", &2);\n    context.insert(\"b\", &3);\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n    context.insert(\"tuple_list\", &vec![(1, 2, 3), (1, 2, 3)]);\n    context.insert(\"review\", &Review::new());\n    context.insert(\"with_newline\", &\"Animal Alphabets\\nB is for Bee-Eater\");\n\n    let inputs = vec![\n        (\"{{ name }}\", \"john\"),\n        (\"{{ malicious }}\", \"&lt;html&gt;\"),\n        (\"{{ \\\"<html>\\\" }}\", \"&lt;html&gt;\"),\n        (\"{{ \\\" html \\\" | upper | trim }}\", \"HTML\"),\n        (\"{{ 'html' }}\", \"html\"),\n        (\"{{ `html` }}\", \"html\"),\n        // https://github.com/Keats/tera/issues/273\n        (\n            r#\"{{ 'hangar new \"Will Smoth <will_s@example.com>\"' | safe }}\"#,\n            r#\"hangar new \"Will Smoth <will_s@example.com>\"\"#,\n        ),\n        (\"{{ malicious | safe }}\", \"<html>\"),\n        (\"{{ malicious | upper }}\", \"&lt;HTML&gt;\"),\n        (\"{{ malicious | upper | safe }}\", \"<HTML>\"),\n        (\"{{ malicious | safe | upper }}\", \"&lt;HTML&gt;\"),\n        (\"{{ review | length }}\", \"2\"),\n        (\"{{ review.paragraphs.1 }}\", \"B\"),\n        (\"{{ numbers }}\", \"[1, 2, 3]\"),\n        (\"{{ numbers.0 }}\", \"1\"),\n        (\"{{ tuple_list.1.1 }}\", \"2\"),\n        (\"{{ name and true }}\", \"true\"),\n        (\"{{ name | length }}\", \"4\"),\n        (\"{{ name is defined }}\", \"true\"),\n        (\"{{ not name is defined }}\", \"false\"),\n        (\"{{ name is not defined }}\", \"false\"),\n        (\"{{ not name is not defined }}\", \"true\"),\n        (\"{{ a is odd }}\", \"false\"),\n        (\"{{ a is odd or b is odd  }}\", \"true\"),\n        (\"{{ range(start=1, end=4) }}\", \"[1, 2, 3]\"),\n        (\"{{ a + b }}\", \"5\"),\n        (\"{{ a + 1.5 }}\", \"3.5\"),\n        (\"{{ 1 + 1 + 1 }}\", \"3\"),\n        (\"{{ 2 - 2 - 1 }}\", \"-1\"),\n        (\"{{ 1 - 1 + 1 }}\", \"1\"),\n        (\"{{ 1 + get_number() }}\", \"11\"),\n        (\"{{ get_number() + 1 }}\", \"11\"),\n        (\"{{ (1.9 + a) | round }}\", \"4\"),\n        (\"{{ 1.9 + a | round }}\", \"4\"),\n        (\"{{ numbers | length - 1 }}\", \"2\"),\n        (\"{{ 1.9 + a | round - 1 }}\", \"3\"),\n        (\"{{ 1.9 + a | round - 1.8 + a | round }}\", \"0\"),\n        (\"{{ 1.9 + a | round - 1.8 + a | round - 1 }}\", \"-1\"),\n        (\"{{ 4 + 40 / (2 + 8) / 4 }}\", \"5\"),\n        (\"{{ ( ( 2 ) + ( 2 ) ) }}\", \"4\"),\n        (\"{{ ( ( 4 / 1 ) + ( 2 / 1 ) ) }}\", \"6\"),\n        (\"{{ ( ( 4 + 2 ) / ( 2 + 1 ) ) }}\", \"2\"),\n        // https://github.com/Keats/tera/issues/435\n        (\n            \"{{ with_newline | replace(from='\\n', to='<br>') | safe }}\",\n            \"Animal Alphabets<br>B is for Bee-Eater\",\n        ),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/storage/test_region_info_accessor.rs::test_region_collection_get_regions_in_range", "code": "pub fn len(&self) -> usize {\n        self.cmds.len()\n    }", "test": "fn test_region_collection_get_regions_in_range() {\n    let mut cluster = new_node_cluster(0, 3);\n\n    let (tx, rx) = channel();\n    cluster\n        .sim\n        .wl()\n        .post_create_coprocessor_host(Box::new(move |id, host| {\n            let p = RegionInfoAccessor::new(host);\n            tx.send((id, p)).unwrap()\n        }));\n\n    cluster.run();\n    let region_info_providers: HashMap<_, _> = rx.try_iter().collect();\n    assert_eq!(region_info_providers.len(), 3);\n    let regions = prepare_cluster(&mut cluster);\n\n    for node_id in cluster.get_node_ids() {\n        let engine = &region_info_providers[&node_id];\n\n        let result = engine.get_regions_in_range(b\"\", b\"\").unwrap();\n        assert_eq!(result, regions);\n\n        let result = engine.get_regions_in_range(b\"k1\", b\"k3\").unwrap();\n        assert_eq!(&result, &regions[1..3]);\n\n        let result = engine.get_regions_in_range(b\"k3\", b\"k8\").unwrap();\n        assert_eq!(&result, &regions[2..5]);\n\n        let result = engine.get_regions_in_range(b\"k6\", b\"k8\").unwrap();\n        assert_eq!(&result, &regions[3..5]);\n\n        let result = engine.get_regions_in_range(b\"k7\", b\"k99\").unwrap();\n        assert_eq!(&result, &regions[4..6]);\n\n        let result = engine.get_regions_in_range(b\"k99\", b\"\").unwrap();\n        assert_eq!(&result, &regions[5..6]);\n    }\n\n    for (_, p) in region_info_providers {\n        p.stop();\n    }\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/options_tests.rs::options_tests", "code": "pub const fn is_valid(&self) -> bool {\n        if !is_valid_ascii(self.exponent) {\n            false\n        } else if !is_valid_ascii(self.decimal_point) {\n            false\n        } else if !self.nan_str_is_valid() {\n            false\n        } else if !self.inf_str_is_valid() {\n            false\n        } else if !self.infinity_string_is_valid() {\n            false\n        } else {\n            true\n        }\n    }", "test": "fn options_tests() {\n    const X: Options = Options::new();\n    assert!(X.is_valid());\n    assert_eq!(X, Options::default());\n    assert!(OptionsBuilder::new().build().is_ok());\n    assert!(OptionsBuilder::default().build().is_ok());\n    assert!(OptionsBuilder::default().is_valid());\n    assert_eq!(X.rebuild(), Options::builder());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/status_server.rs::test_region_meta_endpoint", "code": "pub fn is_some(&self) -> bool {\n        match_template_evaltype! {\n            TT, match self {\n                ScalarValue::TT(v) => v.is_some(),\n            }\n        }\n    }", "test": "fn test_region_meta_endpoint() {\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n    let region = cluster.get_region(b\"\");\n    let region_id = region.get_id();\n    let peer = region.get_peers().get(0);\n    assert!(peer.is_some());\n    let store_id = peer.unwrap().get_store_id();\n    let router = cluster.raft_extension(store_id);\n    let mut status_server = StatusServer::new(\n        1,\n        ConfigController::default(),\n        Arc::new(SecurityConfig::default()),\n        router,\n        std::env::temp_dir(),\n        None,\n        GrpcServiceManager::dummy(),\n    )\n    .unwrap();\n    let addr = format!(\"127.0.0.1:{}\", test_util::alloc_port());\n    status_server.start(addr).unwrap();\n    let check_task = check(status_server.listening_addr(), region_id);\n    let rt = tokio::runtime::Runtime::new().unwrap();\n    if let Err(err) = rt.block_on(check_task) {\n        panic!(\"{}\", err);\n    }\n    status_server.stop();\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_node_failed_merge_before_succeed_merge", "code": "pub fn get_id(&self) -> DownstreamId {\n        self.id\n    }", "test": "fn test_node_failed_merge_before_succeed_merge() {\n    let mut cluster = new_node_cluster(0, 3);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.raft_store.merge_max_log_gap = 30;\n    cluster.cfg.raft_store.store_batch_system.max_batch_size = Some(1);\n    cluster.cfg.raft_store.store_batch_system.pool_size = 2;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    for i in 0..10 {\n        cluster.must_put(format!(\"k{}\", i).as_bytes(), b\"v1\");\n    }\n    let region = pd_client.get_region(b\"k1\").unwrap();\n    cluster.must_split(&region, b\"k5\");\n\n    let left = pd_client.get_region(b\"k1\").unwrap();\n    let mut right = pd_client.get_region(b\"k5\").unwrap();\n    let left_peer_1 = find_peer(&left, 1).cloned().unwrap();\n    cluster.must_transfer_leader(left.get_id(), left_peer_1);\n\n    let left_peer_3 = find_peer(&left, 3).cloned().unwrap();\n    assert_eq!(left_peer_3.get_id(), 1003);\n\n    // Prevent sched_merge_tick to propose CommitMerge\n    let schedule_merge_fp = \"on_schedule_merge\";\n    fail::cfg(schedule_merge_fp, \"return\").unwrap();\n\n    // To minimize peers log gap for merging\n    cluster.must_put(b\"k11\", b\"v2\");\n    must_get_equal(&cluster.get_engine(2), b\"k11\", b\"v2\");\n    must_get_equal(&cluster.get_engine(3), b\"k11\", b\"v2\");\n    // Make peer 1003 can't receive PrepareMerge and RollbackMerge log\n    cluster.add_send_filter(IsolationFilterFactory::new(3));\n\n    cluster.must_try_merge(left.get_id(), right.get_id());\n\n    // Change right region's epoch to make this merge failed\n    cluster.must_split(&right, b\"k8\");\n    fail::remove(schedule_merge_fp);\n    // Wait for left region to rollback merge\n    cluster.must_put(b\"k12\", b\"v2\");\n    // Prevent apply fsm applying the `PrepareMerge` and `RollbackMerge` log after\n    // cleaning send filter.\n    let before_handle_normal_1003_fp = \"before_handle_normal_1003\";\n    fail::cfg(before_handle_normal_1003_fp, \"return\").unwrap();\n    cluster.clear_send_filters();\n\n    right = pd_client.get_region(b\"k5\").unwrap();\n    let right_peer_1 = find_peer(&right, 1).cloned().unwrap();\n    cluster.must_transfer_leader(right.get_id(), right_peer_1);\n    // Add some data for checking data integrity check at a later time\n    for i in 0..5 {\n        cluster.must_put(format!(\"k2{}\", i).as_bytes(), b\"v3\");\n    }\n    // Do a really succeed merge\n    pd_client.must_merge(left.get_id(), right.get_id());\n    // Wait right region to send CatchUpLogs to left region.\n    sleep_ms(100);\n    // After executing CatchUpLogs in source peer fsm, the committed log will send\n    // to apply fsm in the end of this batch. So even the first\n    // `on_ready_prepare_merge` is executed after CatchUplogs, the latter\n    // committed logs is still sent to apply fsm if CatchUpLogs and\n    // `on_ready_prepare_merge` is in different batch.\n    //\n    // In this case, the data is complete because the wrong up-to-date msg from the\n    // first `on_ready_prepare_merge` is sent after all committed log.\n    // Sleep a while to wait apply fsm to send `on_ready_prepare_merge` to peer fsm.\n    let after_send_to_apply_1003_fp = \"after_send_to_apply_1003\";\n    fail::cfg(after_send_to_apply_1003_fp, \"sleep(300)\").unwrap();\n\n    fail::remove(before_handle_normal_1003_fp);\n    // Wait `after_send_to_apply_1003` timeout\n    sleep_ms(300);\n    fail::remove(after_send_to_apply_1003_fp);\n    // Check the data integrity\n    for i in 0..5 {\n        must_get_equal(&cluster.get_engine(3), format!(\"k2{}\", i).as_bytes(), b\"v3\");\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_key_is_locked_for_index", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_key_is_locked_for_index() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = init_data_with_commit(&product, &data, false);\n\n    let req = DagSelect::from_index(&product, &product[\"name\"]).build();\n    let resp = handle_request(&endpoint, req);\n    assert!(resp.get_data().is_empty(), \"{:?}\", resp);\n    assert!(resp.has_locked(), \"{:?}\", resp);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/lib.rs::strip_double_space", "code": "fn normalize_html(s: &str) -> String {\n    let parser = make_html_parser();\n    let dom = parser.one(s);\n    let body: SerializableHandle = normalize_dom(&dom).into();\n    let opts = SerializeOpts::default();\n    let mut ret_val = Vec::new();\n    serialize(&mut ret_val, &body, opts)\n        .expect(\"Writing to a string shouldn't fail (expect on OOM)\");\n    String::from_utf8(ret_val).expect(\"html5ever should always produce UTF8\")\n}", "test": "fn strip_double_space() {\n    assert_eq!(\"test mess\", normalize_html(\"test  mess\"));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_strip_slashes", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_strip_slashes() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"test_mv_strip_slashes_dir\";\n    let file = \"test_mv_strip_slashes_file\";\n    let mut source = file.to_owned();\n    source.push('/');\n\n    at.mkdir(dir);\n    at.touch(file);\n\n    scene.ucmd().arg(&source).arg(dir).fails();\n\n    assert!(!at.file_exists(format!(\"{dir}/{file}\")));\n\n    scene\n        .ucmd()\n        .arg(\"--strip-trailing-slashes\")\n        .arg(source)\n        .arg(dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_trace", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "test": "fn test_trap_trace() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module $hello_mod\n            (func (export \"run\") (call $hello))\n            (func $hello (unreachable))\n        )\n    \"#;\n\n    let module = Module::new(store.engine(), wat)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func.call(&mut store, ()).unwrap_err();\n\n    let trace = e.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert_eq!(trace.len(), 2);\n    assert_eq!(trace[0].module().name().unwrap(), \"hello_mod\");\n    assert_eq!(trace[0].func_index(), 1);\n    assert_eq!(trace[0].func_name(), Some(\"hello\"));\n    assert_eq!(trace[0].func_offset(), Some(1));\n    assert_eq!(trace[0].module_offset(), Some(0x26));\n    assert_eq!(trace[1].module().name().unwrap(), \"hello_mod\");\n    assert_eq!(trace[1].func_index(), 0);\n    assert_eq!(trace[1].func_name(), None);\n    assert_eq!(trace[1].func_offset(), Some(1));\n    assert_eq!(trace[1].module_offset(), Some(0x21));\n    assert_eq!(e.downcast::<Trap>()?, Trap::UnreachableCodeReached);\n\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_fail_id", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_chown_fail_id() {\n    // test chown 1111. file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"id\").arg(\"-u\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let user_id = String::from(result.stdout_str().trim());\n    assert!(!user_id.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    scene\n        .ucmd()\n        .arg(format!(\"{user_id}:\"))\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"invalid spec\");\n\n    scene\n        .ucmd()\n        .arg(format!(\"{user_id}.\"))\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"invalid spec\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_bootstrap.rs::test_node_bootstrap_with_prepared_data", "code": "pub fn is_some(&self) -> bool {\n        self.max_expire_ts.is_some() || self.min_expire_ts.is_some()\n    }", "test": "fn test_node_bootstrap_with_prepared_data() {\n    // create a node\n    let pd_client = Arc::new(TestPdClient::new(0, false));\n    let cfg = new_tikv_config(0);\n\n    let (_, system) = fsm::create_raft_batch_system(&cfg.raft_store, &None);\n    let simulate_trans = SimulateTransport::new(ChannelTransport::new());\n    let tmp_path = Builder::new().prefix(\"test_cluster\").tempdir().unwrap();\n    let engine =\n        engine_rocks::util::new_engine(tmp_path.path().to_str().unwrap(), ALL_CFS).unwrap();\n    let tmp_path_raft = tmp_path.path().join(Path::new(\"raft\"));\n    let raft_engine =\n        engine_rocks::util::new_engine(tmp_path_raft.to_str().unwrap(), &[CF_DEFAULT]).unwrap();\n    let engines = Engines::new(engine.clone(), raft_engine);\n    let tmp_mgr = Builder::new().prefix(\"test_cluster\").tempdir().unwrap();\n    let bg_worker = WorkerBuilder::new(\"background\").thread_count(2).create();\n    let mut node = Node::new(\n        system,\n        &cfg.server,\n        Arc::new(VersionTrack::new(cfg.raft_store.clone())),\n        cfg.storage.api_version(),\n        Arc::clone(&pd_client),\n        Arc::default(),\n        bg_worker,\n        None,\n        None,\n    );\n    let snap_mgr = SnapManager::new(tmp_mgr.path().to_str().unwrap());\n    let pd_worker = LazyWorker::new(\"test-pd-worker\");\n\n    // assume there is a node has bootstrapped the cluster and add region in pd\n    // successfully\n    bootstrap_with_first_region(Arc::clone(&pd_client)).unwrap();\n\n    // now another node at same time begin bootstrap node, but panic after prepared\n    // bootstrap now rocksDB must have some prepare data\n    bootstrap_store(&engines, 0, 1).unwrap();\n    let region = node.prepare_bootstrap_cluster(&engines, 1).unwrap();\n    assert!(\n        engine\n            .get_msg::<metapb::Region>(keys::PREPARE_BOOTSTRAP_KEY)\n            .unwrap()\n            .is_some()\n    );\n    let region_state_key = keys::region_state_key(region.get_id());\n    assert!(\n        engine\n            .get_msg_cf::<RegionLocalState>(CF_RAFT, &region_state_key)\n            .unwrap()\n            .is_some()\n    );\n\n    // Create coprocessor.\n    let coprocessor_host = CoprocessorHost::new(node.get_router(), cfg.coprocessor);\n\n    let importer = {\n        let dir = tmp_path.path().join(\"import-sst\");\n        Arc::new(SstImporter::new(&cfg.import, dir, None, cfg.storage.api_version()).unwrap())\n    };\n    let (split_check_scheduler, _) = dummy_scheduler();\n\n    node.try_bootstrap_store(engines.clone()).unwrap();\n    // try to restart this node, will clear the prepare data\n    node.start(\n        engines,\n        simulate_trans,\n        snap_mgr,\n        pd_worker,\n        Arc::new(Mutex::new(StoreMeta::new(0))),\n        coprocessor_host,\n        importer,\n        split_check_scheduler,\n        AutoSplitController::default(),\n        ConcurrencyManager::new(1.into()),\n        CollectorRegHandle::new_for_test(),\n        None,\n        Arc::new(AtomicU64::new(0)),\n    )\n    .unwrap();\n    assert!(\n        engine\n            .get_msg::<metapb::Region>(keys::PREPARE_BOOTSTRAP_KEY)\n            .unwrap()\n            .is_none()\n    );\n    assert!(\n        engine\n            .get_msg_cf::<RegionLocalState>(CF_RAFT, &region_state_key)\n            .unwrap()\n            .is_none()\n    );\n    assert_eq!(pd_client.get_regions_number() as u32, 1);\n    node.stop();\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::fabsf_spec_test", "code": "fn is_nan(self) -> bool {\n        self.is_special() && (self.to_bits() & Self::MANTISSA_MASK) != Self::Unsigned::ZERO\n    }", "test": "fn fabsf_spec_test() {\n    assert!(libm::fabsf(f32::NAN).is_nan());\n    for f in [0.0, -0.0].iter().copied() {\n        assert_eq!(libm::fabsf(f), 0.0);\n    }\n    for f in [f32::INFINITY, f32::NEG_INFINITY].iter().copied() {\n        assert_eq!(libm::fabsf(f), f32::INFINITY);\n    }\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::no_lint_when_file_is_ignored", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn no_lint_when_file_is_ignored() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), CONFIG_LINTER_IGNORED_FILES.as_bytes());\n\n    let file_path = Path::new(\"test.js\");\n    fs.insert(file_path.into(), FIX_BEFORE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, FIX_BEFORE);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"no_lint_when_file_is_ignored\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/tests-gen/message.rs::test_something", "code": "pub fn used(&self) -> usize {\n        self.cursor\n    }", "test": "fn test_something() {\n    let data = [];\n    let mut rdr = Reader::init(data);\n    if let Ok(m) = OpaqueMessage::read(&mut rdr) {\n        let msg = match Message::try_from(m.into_plain_message()) {\n            Ok(msg) => msg,\n            Err(_) => return,\n        };\n        let enc = PlainMessage::from(msg)\n            .into_unencrypted_opaque()\n            .encode();\n        assert_eq!(enc, data[..rdr.used()]);\n    }\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::server_builder_set_max_concurrent_streams", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "test": "async fn server_builder_set_max_concurrent_streams() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let mut settings = frame::Settings::default();\n    settings.set_max_concurrent_streams(Some(1));\n\n    let client = async move {\n        let recv_settings = client.assert_server_handshake().await;\n        assert_frame_eq(recv_settings, settings);\n        client\n            .send_frame(frames::headers(1).request(\"GET\", \"https://example.com/\"))\n            .await;\n        client\n            .send_frame(frames::headers(3).request(\"GET\", \"https://example.com/\"))\n            .await;\n        client\n            .send_frame(frames::data(1, &b\"hello\"[..]).eos())\n            .await;\n        client.recv_frame(frames::reset(3).refused()).await;\n        client\n            .recv_frame(frames::headers(1).response(200).eos())\n            .await;\n    };\n\n    let mut builder = server::Builder::new();\n    builder.max_concurrent_streams(1);\n\n    let h2 = async move {\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        let rsp = http::Response::builder().status(200).body(()).unwrap();\n        stream.send_response(rsp, true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, h2).await;\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_mvcc_concurrent_commit_and_rollback_at_shutdown", "code": "pub fn has_region_error(&self) -> bool {\n        matches!(\n            self,\n            Error::Kv(KvError(box EngineErrorInner::Request(_)))\n                | Error::Txn(TxnError(box TxnErrorInner::Engine(KvError(\n                    box EngineErrorInner::Request(_),\n                ))))\n                | Error::Txn(TxnError(box TxnErrorInner::Mvcc(MvccError(\n                    box MvccErrorInner::Kv(KvError(box EngineErrorInner::Request(_))),\n                ))))\n                | Error::Request(_)\n        )\n    }", "test": "fn test_mvcc_concurrent_commit_and_rollback_at_shutdown() {\n    let (mut cluster, mut client, mut ctx) = must_new_cluster_and_kv_client_mul(3);\n    let k = b\"key\".to_vec();\n    // Use big value to force it in default cf.\n    let v = vec![0; 10240];\n\n    let mut ts = 0;\n\n    // Prewrite\n    ts += 1;\n    let prewrite_start_version = ts;\n    let mut mutation = kvrpcpb::Mutation::default();\n    mutation.set_op(Op::Put);\n    mutation.set_key(k.clone());\n    mutation.set_value(v.clone());\n    must_kv_prewrite(\n        &client,\n        ctx.clone(),\n        vec![mutation],\n        k.clone(),\n        prewrite_start_version,\n    );\n\n    // So all following operation will not be committed by this leader.\n    let leader_fp = \"before_leader_handle_committed_entries\";\n    fail::cfg(leader_fp, \"pause\").unwrap();\n\n    // Commit\n    ts += 1;\n    let commit_version = ts;\n    let mut commit_req = CommitRequest::default();\n    commit_req.set_context(ctx.clone());\n    commit_req.start_version = prewrite_start_version;\n    commit_req.mut_keys().push(k.clone());\n    commit_req.commit_version = commit_version;\n    let _commit_resp = client.kv_commit_async(&commit_req).unwrap();\n\n    // Rollback\n    let rollback_start_version = prewrite_start_version;\n    let mut rollback_req = BatchRollbackRequest::default();\n    rollback_req.set_context(ctx.clone());\n    rollback_req.start_version = rollback_start_version;\n    rollback_req.mut_keys().push(k.clone());\n    let _rollback_resp = client.kv_batch_rollback_async(&rollback_req).unwrap();\n\n    // Sleep some time to make sure both commit and rollback are queued in latch.\n    thread::sleep(Duration::from_millis(100));\n    let shutdown_fp = \"after_shutdown_apply\";\n    fail::cfg_callback(shutdown_fp, move || {\n        fail::remove(leader_fp);\n        // Sleep some time to ensure all logs can be replicated.\n        thread::sleep(Duration::from_millis(300));\n    })\n    .unwrap();\n    let mut leader = cluster.leader_of_region(1).unwrap();\n    cluster.stop_node(leader.get_store_id());\n\n    // So a new leader should be elected.\n    cluster.must_put(b\"k2\", b\"v2\");\n    leader = cluster.leader_of_region(1).unwrap();\n    ctx.set_peer(leader.clone());\n    let env = Arc::new(Environment::new(1));\n    let channel =\n        ChannelBuilder::new(env).connect(&cluster.sim.rl().get_addr(leader.get_store_id()));\n    client = TikvClient::new(channel);\n\n    // The first request is commit, the second is rollback, the first one should\n    // succeed.\n    ts += 1;\n    let get_version = ts;\n    let mut get_req = GetRequest::default();\n    get_req.set_context(ctx);\n    get_req.key = k;\n    get_req.version = get_version;\n    let get_resp = client.kv_get(&get_req).unwrap();\n    assert!(\n        !get_resp.has_region_error() && !get_resp.has_error(),\n        \"{:?}\",\n        get_resp\n    );\n    assert_eq!(get_resp.value, v);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/coprocessor/test_select.rs::test_key_is_locked_for_primary", "code": "fn is_empty(&self) -> bool {\n        self.pending_writes.is_empty() && self.unpacked_size == 0\n    }", "test": "fn test_key_is_locked_for_primary() {\n    let data = vec![\n        (1, Some(\"name:0\"), 2),\n        (2, Some(\"name:4\"), 3),\n        (4, Some(\"name:3\"), 1),\n        (5, Some(\"name:1\"), 4),\n    ];\n\n    let product = ProductTable::new();\n    let (_, endpoint, _) = init_data_with_commit(&product, &data, false);\n\n    let req = DagSelect::from(&product).build();\n    let resp = handle_request(&endpoint, req);\n    assert!(resp.get_data().is_empty(), \"{:?}\", resp);\n    assert!(resp.has_locked(), \"{:?}\", resp);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_same_rollback_one", "code": "pub fn is_some(&self) -> bool {\n        self.max_expire_ts.is_some() || self.min_expire_ts.is_some()\n    }", "test": "fn save_point_same_rollback_one() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.set_save_point();\n    wb.set_save_point();\n    wb.set_save_point();\n\n    wb.put(b\"b\", b\"\").unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n\n    wb.write().unwrap();\n\n    let a = db.engine.get_value(b\"a\").unwrap();\n    let b = db.engine.get_value(b\"b\").unwrap();\n\n    assert!(a.is_some());\n    assert!(b.is_none());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.set_save_point();\n    wb.set_save_point();\n    wb.set_save_point();\n\n    wb.put(b\"b\", b\"\").unwrap();\n    for i in max_keys..2 * max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    wb.rollback_to_save_point().unwrap();\n\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    for i in 0..max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_some());\n    }\n\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    for i in max_keys..2 * max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_data_empty_payload", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "test": "async fn read_data_empty_payload() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 0, 0, 0, 0, 0, 0, 1,\n        ];\n    };\n\n    let data = poll_frame!(Data, codec);\n    assert_eq!(data.stream_id(), 1);\n    assert_eq!(data.payload(), &b\"\"[..]);\n    assert!(!data.is_end_stream());\n\n    assert_closed!(codec);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::abort", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn abort() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"aborted\").unwrap();\n        assert_eq!(\"aborted\", table.get(\"hello\").unwrap().unwrap().value());\n    }\n    write_txn.abort().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE);\n    assert!(table.is_err());\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert_eq!(table.len().unwrap(), 1);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/config/dynamic/pessimistic_txn.rs::test_lock_manager_cfg_update", "code": "pub fn as_millis(&self) -> u64 {\n        crate::time::duration_to_ms(self.0)\n    }", "test": "fn test_lock_manager_cfg_update() {\n    const DEFAULT_TIMEOUT: u64 = 3000;\n    const DEFAULT_DELAY: u64 = 100;\n    let (mut cfg, _dir) = TikvConfig::with_tmp().unwrap();\n    cfg.pessimistic_txn.wait_for_lock_timeout = ReadableDuration::millis(DEFAULT_TIMEOUT);\n    cfg.pessimistic_txn.wake_up_delay_duration = ReadableDuration::millis(DEFAULT_DELAY);\n    cfg.pessimistic_txn.pipelined = false;\n    cfg.pessimistic_txn.in_memory = false;\n    cfg.validate().unwrap();\n    let (cfg_controller, waiter, deadlock, mut lock_mgr) = setup(cfg);\n\n    // update of other module's config should not effect lock manager config\n    cfg_controller\n        .update_config(\"raftstore.raft-log-gc-threshold\", \"2000\")\n        .unwrap();\n    validate_waiter(&waiter, move |timeout: ReadableDuration| {\n        assert_eq!(timeout.as_millis(), DEFAULT_TIMEOUT);\n    });\n    validate_dead_lock(&deadlock, move |ttl: u64| {\n        assert_eq!(ttl, DEFAULT_TIMEOUT);\n    });\n\n    // only update wait_for_lock_timeout\n    cfg_controller\n        .update_config(\"pessimistic-txn.wait-for-lock-timeout\", \"4000ms\")\n        .unwrap();\n    validate_waiter(&waiter, move |timeout: ReadableDuration| {\n        assert_eq!(timeout.as_millis(), 4000);\n    });\n    validate_dead_lock(&deadlock, move |ttl: u64| {\n        assert_eq!(ttl, 4000);\n    });\n\n    // update pipelined\n    assert!(\n        !lock_mgr\n            .get_storage_dynamic_configs()\n            .pipelined_pessimistic_lock\n            .load(Ordering::SeqCst)\n    );\n    cfg_controller\n        .update_config(\"pessimistic-txn.pipelined\", \"true\")\n        .unwrap();\n    assert!(\n        lock_mgr\n            .get_storage_dynamic_configs()\n            .pipelined_pessimistic_lock\n            .load(Ordering::SeqCst)\n    );\n\n    // update in-memory\n    assert!(\n        !lock_mgr\n            .get_storage_dynamic_configs()\n            .in_memory_pessimistic_lock\n            .load(Ordering::SeqCst)\n    );\n    cfg_controller\n        .update_config(\"pessimistic-txn.in-memory\", \"true\")\n        .unwrap();\n    assert!(\n        lock_mgr\n            .get_storage_dynamic_configs()\n            .in_memory_pessimistic_lock\n            .load(Ordering::SeqCst)\n    );\n\n    // update wake-up-delay-duration\n    assert_eq!(\n        lock_mgr\n            .get_storage_dynamic_configs()\n            .wake_up_delay_duration_ms\n            .load(Ordering::SeqCst),\n        DEFAULT_DELAY\n    );\n    cfg_controller\n        .update_config(\"pessimistic-txn.wake-up-delay-duration\", \"500ms\")\n        .unwrap();\n    assert_eq!(\n        lock_mgr\n            .get_storage_dynamic_configs()\n            .wake_up_delay_duration_ms\n            .load(Ordering::SeqCst),\n        500\n    );\n\n    lock_mgr.stop();\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_block_size_from_env", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "test": "fn test_block_size_from_env() {\n    fn get_header(env_var: &str, env_value: &str) -> String {\n        let output = new_ucmd!()\n            .arg(\"--output=size\")\n            .env(env_var, env_value)\n            .succeeds()\n            .stdout_move_str();\n        output.lines().next().unwrap().trim().to_string()\n    }\n\n    assert_eq!(get_header(\"DF_BLOCK_SIZE\", \"111\"), \"111B-blocks\");\n    assert_eq!(get_header(\"BLOCK_SIZE\", \"222\"), \"222B-blocks\");\n    assert_eq!(get_header(\"BLOCKSIZE\", \"333\"), \"333B-blocks\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_both_offset_date_and_reference", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_touch_set_both_offset_date_and_reference() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ref_file = \"test_touch_reference\";\n    let file = \"test_touch_set_both_date_and_reference\";\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501011234\");\n    let five_days_later = str_to_filetime(\"%Y%m%d%H%M\", \"201501061234\");\n\n    at.touch(ref_file);\n    set_file_times(&at, ref_file, start_of_year, start_of_year);\n    assert!(at.file_exists(ref_file));\n\n    ucmd.args(&[\"-d\", \"+5 days\", \"-r\", ref_file, file])\n        .succeeds()\n        .no_stderr();\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, five_days_later);\n    assert_eq!(mtime, five_days_later);\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::datagram_recv_buffer_overflow", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn datagram_recv_buffer_overflow() {\n    let _guard = subscribe();\n    const WINDOW: usize = 100;\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            datagram_receive_buffer_size: Some(WINDOW),\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    assert_eq!(\n        pair.client_conn_mut(client_ch).datagrams().max_size(),\n        Some(WINDOW - Datagram::SIZE_BOUND)\n    );\n\n    const DATA1: &[u8] = &[0xAB; (WINDOW / 3) + 1];\n    const DATA2: &[u8] = &[0xBC; (WINDOW / 3) + 1];\n    const DATA3: &[u8] = &[0xCD; (WINDOW / 3) + 1];\n    pair.client_datagrams(client_ch).send(DATA1.into()).unwrap();\n    pair.client_datagrams(client_ch).send(DATA2.into()).unwrap();\n    pair.client_datagrams(client_ch).send(DATA3.into()).unwrap();\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::DatagramReceived)\n    );\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA2);\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA3);\n    assert_matches!(pair.server_datagrams(server_ch).recv(), None);\n\n    pair.client_datagrams(client_ch).send(DATA1.into()).unwrap();\n    pair.drive();\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA1);\n    assert_matches!(pair.server_datagrams(server_ch).recv(), None);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_signal_prefixed_name_old_form", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "test": "fn test_kill_with_signal_prefixed_name_old_form() {\n    let mut target = Target::new();\n    new_ucmd!()\n        .arg(\"-SIGKILL\")\n        .arg(format!(\"{}\", target.pid()))\n        .succeeds();\n    assert_eq!(target.wait_for_signal(), Some(libc::SIGKILL));\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/format_builder_tests.rs::decimal_test", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn decimal_test() {\n    const FORMAT: u128 = NumberFormatBuilder::decimal();\n    let format = NumberFormat::<FORMAT> {};\n    assert!(format.is_valid());\n    assert_eq!(format.radix(), 10);\n    assert_eq!(format.mantissa_radix(), 10);\n    assert_eq!(format.exponent_base(), 10);\n    assert_eq!(format.exponent_radix(), 10);\n}"}
{"test_id": "weggli-rs-weggli/weggli-rs-weggli-ad8d424/tests/query.rs::simple", "code": "fn parse_and_match(needle: &str, source: &str) -> usize {\n    parse_and_match_helper(needle, source, false).len()\n}", "test": "fn simple() {\n    assert_eq!(\n        parse_and_match(\"{int $a = _+foo+$a;}\", \"void foo() {int bar=10+foo+bar;}\"),\n        1\n    );\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::fs_error_infinite_symlink_expansion_to_files", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn fs_error_infinite_symlink_expansion_to_files() {\n    let mut console = BufferConsole::default();\n\n    let root_path = temp_dir().join(\"lint_rome_test_infinite_symlink_expansion_to_files\");\n    let subdir1_path = root_path.join(\"prefix\");\n    let subdir2_path = root_path.join(\"foo\").join(\"bar\");\n\n    let _ = remove_dir_all(&root_path);\n    create_dir_all(&subdir1_path).unwrap();\n    create_dir_all(&subdir2_path).unwrap();\n\n    let symlink1_path = subdir1_path.join(\"symlink1\");\n    let symlink2_path = subdir2_path.join(\"symlink2\");\n\n    #[cfg(target_family = \"unix\")]\n    {\n        symlink(&symlink2_path, &symlink1_path).unwrap();\n        symlink(&symlink1_path, &symlink2_path).unwrap();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        check_windows_symlink!(symlink_dir(&symlink2_path, &symlink1_path));\n        check_windows_symlink!(symlink_dir(&symlink1_path, &symlink2_path));\n    }\n\n    let result = run_cli(\n        DynRef::Owned(Box::new(OsFileSystem)),\n        &mut console,\n        Args::from([(\"lint\"), (root_path.display().to_string().as_str())].as_slice()),\n    );\n\n    remove_dir_all(root_path).unwrap();\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Don't use a snapshot here, since the diagnostics can be reported in\n    // arbitrary order:\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(\"Deeply nested symlink expansion\")));\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(&symlink1_path.display().to_string())));\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(&symlink2_path.display().to_string())));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/resource_metering/test_pubsub.rs::test_multiple_subscribers", "code": "pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    }", "test": "pub fn test_multiple_subscribers() {\n    let mut test_suite = TestSuite::new(resource_metering::Config {\n        report_receiver_interval: ReadableDuration::secs(3),\n        precision: ReadableDuration::secs(1),\n        ..Default::default()\n    });\n\n    // Workload\n    // [req-1, req-2]\n    test_suite.setup_workload(vec![\"req-1\", \"req-2\"]);\n    let jhs: Vec<_> = (0..3)\n        .map(|_| {\n            let (client, stream) = test_suite.subscribe();\n            test_suite.rt.spawn(async move {\n                let _client = client;\n                let tags = stream.take(4).map(|record| {\n                    String::from_utf8_lossy(record.unwrap().get_record().get_resource_group_tag())\n                        .into_owned()\n                });\n                tags.collect::<HashSet<_>>().await\n            })\n        })\n        .collect();\n\n    for jh in jhs {\n        let res = test_suite.rt.block_on(jh).unwrap();\n        assert!(res.contains(\"req-1\"));\n        assert!(res.contains(\"req-2\"));\n    }\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::packet_splitting_with_default_mtu", "code": "fn len(self) -> bool {\n        self.0 & 0x02 != 0\n    }", "test": "fn packet_splitting_with_default_mtu() {\n    let _guard = subscribe();\n\n    // The payload needs to be split in 2 in order to be sent, because it is higher than the max MTU\n    let payload = vec![42; 1300];\n\n    let mut pair = Pair::default();\n    let (client_ch, _) = pair.connect();\n    pair.drive();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    pair.client_send(client_ch, s).write(&payload).unwrap();\n    pair.client.drive(pair.time, pair.server.addr);\n    assert_eq!(pair.client.outbound.len(), 2);\n\n    pair.drive_client();\n    assert_eq!(pair.server.inbound.len(), 2);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_on_hibernated_leader", "code": "pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {\n        self.get_impl(CF_DEFAULT, key, true)\n    }", "test": "fn test_force_leader_on_hibernated_leader() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store1 = find_peer(&region, 1).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store1.clone());\n\n    // wait a while to hibernate\n    std::thread::sleep(Duration::from_millis(\n        cluster.cfg.raft_store.raft_election_timeout_ticks as u64\n            * cluster.cfg.raft_store.raft_base_tick_interval.as_millis()\n            * 3,\n    ));\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // remove the peers on failed nodes\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k2\"), None);\n    assert_eq!(cluster.must_get(b\"k3\"), None);\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_unsafe_recovery.rs::test_force_leader_twice_on_different_peers", "code": "pub fn get_id(&self) -> ConnId {\n        self.id\n    }", "test": "fn test_force_leader_twice_on_different_peers() {\n    let mut cluster = new_node_cluster(0, 5);\n    cluster.pd_client.disable_default_operator();\n\n    cluster.run();\n    cluster.must_put(b\"k1\", b\"v1\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k9\");\n    let region = cluster.get_region(b\"k2\");\n    let peer_on_store5 = find_peer(&region, 5).unwrap();\n    cluster.must_transfer_leader(region.get_id(), peer_on_store5.clone());\n\n    cluster.stop_node(3);\n    cluster.stop_node(4);\n    cluster.stop_node(5);\n\n    // restart to clean lease\n    cluster.stop_node(1);\n    cluster.run_node(1).unwrap();\n    cluster.stop_node(2);\n    cluster.run_node(2).unwrap();\n    confirm_quorum_is_lost(&mut cluster, &region);\n\n    cluster.must_enter_force_leader(region.get_id(), 1, vec![3, 4, 5]);\n    // enter force leader on a different peer\n    cluster.enter_force_leader(region.get_id(), 2, vec![3, 4, 5]);\n    assert_eq!(\n        cluster.leader_of_region(region.get_id()).unwrap(),\n        *find_peer(&region, 1).unwrap()\n    );\n\n    let conf_change = new_change_peer_request(ConfChangeType::RemoveNode, new_peer(3, 3));\n    let mut req = new_admin_request(region.get_id(), region.get_region_epoch(), conf_change);\n    req.mut_header()\n        .set_peer(find_peer(&region, 2).unwrap().clone());\n    let resp = cluster\n        .call_command(req, Duration::from_millis(10))\n        .unwrap();\n    let mut not_leader = kvproto::errorpb::NotLeader {\n        region_id: region.get_id(),\n        ..Default::default()\n    };\n    not_leader.set_leader(find_peer(&region, 1).unwrap().clone());\n    assert_eq!(resp.get_header().get_error().get_not_leader(), &not_leader,);\n\n    // remove the peers on failed nodes\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 3).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 4).unwrap().clone());\n    cluster\n        .pd_client\n        .must_remove_peer(region.get_id(), find_peer(&region, 5).unwrap().clone());\n    cluster.exit_force_leader(region.get_id(), 1);\n\n    // quorum is formed, can propose command successfully now\n    cluster.must_put(b\"k4\", b\"v4\");\n    assert_eq!(cluster.must_get(b\"k4\"), Some(b\"v4\".to_vec()));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_notrunc_does_not_truncate", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "test": "fn test_notrunc_does_not_truncate() {\n    // Set up test if needed (eg. after failure)\n    let fname = \"this-file-exists-notrunc.txt\";\n    let fpath = fixture_path!(fname);\n    match fpath.metadata() {\n        Ok(m) if m.len() == 256 => {}\n        _ => build_test_file!(&fpath, &build_ascii_block(256)),\n    }\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"status=none\", \"conv=notrunc\", of!(&fname), \"if=null.txt\"])\n        .run()\n        .no_stdout()\n        .no_stderr()\n        .success();\n\n    assert_eq!(256, fix.metadata(fname).len());\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_float_f32_rounding", "code": "pub fn compute_float32(q: i64, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        is_negative: false,\n        many_digits: false,\n        integer: &[],\n        fraction: None,\n    };\n    let fp = bellerophon::<f32, { STANDARD }>(&num, false);\n    (fp.exp, fp.mant)\n}", "test": "fn compute_float_f32_rounding() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_float32(0, 16777216), (151, 0));\n    assert_eq!(compute_float32(0, 16777217), (151, 0));\n    assert_eq!(compute_float32(0, 16777218), (151, 1));\n    assert_eq!(compute_float32(0, 16777219), (151, 2));\n    assert_eq!(compute_float32(0, 16777220), (151, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float32(-10, 167772160000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772170000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772180000000000), (151, 1));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(compute_float32(-10, 167772190000000000), (151, 2));\n    assert_eq!(compute_float32(-10, 167772200000000000), (151, 2));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_mode_directories", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_mode_directories() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let component = \"component\";\n    let directories_arg = \"-d\";\n    let mode_arg = \"--mode=333\";\n\n    ucmd.arg(directories_arg)\n        .arg(component)\n        .arg(mode_arg)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(component));\n    let permissions = at.metadata(component).permissions();\n    assert_eq!(0o040_333_u32, PermissionsExt::mode(&permissions));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client.rs::test_pd_client_heartbeat_send_failed", "code": "fn is_ok(&self) -> bool {\n        let count = self.count.fetch_add(1, Ordering::SeqCst);\n        if count != 0 && count % self.retry == 0 {\n            // it's ok.\n            return true;\n        }\n        // let's sleep awhile, so that client will update its connection.\n        thread::sleep(REQUEST_RECONNECT_INTERVAL);\n        false\n    }", "test": "fn test_pd_client_heartbeat_send_failed() {\n    let rt = setup_runtime();\n    let _g = rt.enter();\n    let pd_client_send_fail_fp = \"region_heartbeat_send_failed\";\n    fail::cfg(pd_client_send_fail_fp, \"return()\").unwrap();\n    let server = MockServer::with_case(1, Arc::new(AlreadyBootstrapped));\n    let eps = server.bind_addrs();\n\n    let mut client = new_client_v2(eps, None);\n\n    let (tx, mut responses) = client\n        .create_region_heartbeat_stream(WakePolicy::Immediately)\n        .unwrap();\n\n    let mut heartbeat_send_fail = |ok| {\n        let mut region = metapb::Region::default();\n        region.set_id(1);\n        let mut req = pdpb::RegionHeartbeatRequest::default();\n        req.set_region(region);\n        tx.send(req).unwrap();\n\n        let rsp = block_on(tokio::time::timeout(\n            Duration::from_millis(100),\n            responses.next(),\n        ));\n        if ok {\n            assert!(rsp.is_ok());\n            assert_eq!(rsp.unwrap().unwrap().unwrap().get_region_id(), 1);\n        } else {\n            rsp.unwrap_err();\n        }\n\n        let region = block_on(client.get_region_by_id(1));\n        if ok {\n            assert!(region.is_ok());\n            let r = region.unwrap();\n            assert!(r.is_some());\n            assert_eq!(1, r.unwrap().get_id());\n        } else {\n            region.unwrap_err();\n        }\n    };\n    // send fail if network is block.\n    heartbeat_send_fail(false);\n    fail::remove(pd_client_send_fail_fp);\n    // send success after network recovered.\n    heartbeat_send_fail(true);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_version_flag", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_version_flag() {\n    let version_short = new_ucmd!().arg(\"-V\").succeeds();\n    let version_long = new_ucmd!().arg(\"--version\").succeeds();\n\n    assert_eq!(version_short.stdout_str(), version_long.stdout_str());\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_raw_tag", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn render_raw_tag() {\n    let inputs = vec![\n        (\"{% raw %}hey{% endraw %}\", \"hey\"),\n        (\"{% raw %}{{hey}}{% endraw %}\", \"{{hey}}\"),\n        (\"{% raw %}{% if true %}{% endraw %}\", \"{% if true %}\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &Context::new()).unwrap(), expected);\n    }\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_complete_io_for_handshake_eof", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "test": "fn server_complete_io_for_handshake_eof() {\n    let (_, mut server) = make_pair(KeyType::Rsa);\n    let mut input = io::Cursor::new(Vec::new());\n\n    assert!(server.is_handshaking());\n    let err = server\n        .complete_io(&mut input)\n        .unwrap_err();\n    assert_eq!(io::ErrorKind::UnexpectedEof, err.kind());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_split_region.rs::test_split_region_keep_records", "code": "pub fn is_empty(&self) -> bool {\n        self.key.is_empty() && self.iv.is_empty()\n    }", "test": "fn test_split_region_keep_records() {\n    let mut cluster = test_raftstore_v2::new_node_cluster(0, 3);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    let r1 = cluster.run_conf_change();\n    cluster.must_put(b\"k1\", b\"v1\");\n    pd_client.must_add_peer(r1, new_peer(2, 2));\n    must_get_equal(&cluster.get_engine(2), b\"k1\", b\"v1\");\n    pd_client.must_remove_peer(r1, new_peer(2, 2));\n\n    let leader = cluster.leader_of_region(r1).unwrap();\n    cluster.add_send_filter_on_node(\n        leader.get_store_id(),\n        Box::new(DropMessageFilter::new(Arc::new(|m: &RaftMessage| {\n            // Drop all gc peer requests and responses.\n            !(m.has_extra_msg()\n                && (m.get_extra_msg().get_type() == ExtraMessageType::MsgGcPeerRequest\n                    || m.get_extra_msg().get_type() == ExtraMessageType::MsgGcPeerResponse))\n        }))),\n    );\n\n    // Make sure split has applied.\n    let region = pd_client.get_region(b\"\").unwrap();\n    cluster.must_split(&region, b\"k1\");\n    cluster.must_put(b\"k2\", b\"v2\");\n    cluster.must_put(b\"k0\", b\"v0\");\n\n    let region_state = cluster.region_local_state(r1, leader.get_store_id());\n    assert!(\n        !region_state.get_removed_records().is_empty(),\n        \"{:?}\",\n        region_state\n    );\n}"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::datagram_send_recv", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "test": "fn datagram_send_recv() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    assert_matches!(pair.client_datagrams(client_ch).max_size(), Some(x) if x > 0);\n\n    const DATA: &[u8] = b\"whee\";\n    pair.client_datagrams(client_ch).send(DATA.into()).unwrap();\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::DatagramReceived)\n    );\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA);\n    assert_matches!(pair.server_datagrams(server_ch).recv(), None);\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_il", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_il() {\n    // Test iterators that skip single, internal or leading-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_leading_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"_45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"_.45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4_5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4_5__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"_45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"_45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"_4_5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"_4_5__.56\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/cdc/tests/integrations/test_cdc.rs::test_flashback", "code": "fn len(&self) -> usize {\n        self.length\n    }", "test": "fn test_flashback() {\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.cfg.resolved_ts.advance_ts_interval = ReadableDuration::millis(50);\n    let mut suite = TestSuiteBuilder::new().cluster(cluster).build();\n\n    let key = Key::from_raw(b\"a\");\n    let region = suite.cluster.get_region(key.as_encoded());\n    let region_id = region.get_id();\n    let req = suite.new_changedata_request(region_id);\n    let (mut req_tx, _, receive_event) = new_event_feed(suite.get_region_cdc_client(region_id));\n    block_on(req_tx.send((req, WriteFlags::default()))).unwrap();\n    let event = receive_event(false);\n    event.events.into_iter().for_each(|e| {\n        match e.event.unwrap() {\n            // Even if there is no write,\n            // it should always outputs an Initialized event.\n            Event_oneof_event::Entries(es) => {\n                assert!(es.entries.len() == 1, \"{:?}\", es);\n                let e = &es.entries[0];\n                assert_eq!(e.get_type(), EventLogType::Initialized, \"{:?}\", es);\n            }\n            other => panic!(\"unknown event {:?}\", other),\n        }\n    });\n    // Sleep a while to make sure the stream is registered.\n    sleep_ms(1000);\n    let start_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    for i in 0..2 {\n        let (k, v) = (\n            format!(\"key{}\", i).as_bytes().to_vec(),\n            format!(\"value{}\", i).as_bytes().to_vec(),\n        );\n        // Prewrite\n        let start_ts1 = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n        let mut mutation = Mutation::default();\n        mutation.set_op(Op::Put);\n        mutation.key = k.clone();\n        mutation.value = v;\n        suite.must_kv_prewrite(1, vec![mutation], k.clone(), start_ts1);\n        // Commit\n        let commit_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n        suite.must_kv_commit(1, vec![k.clone()], start_ts1, commit_ts);\n    }\n    let (start_key, end_key) = (b\"key0\".to_vec(), b\"key2\".to_vec());\n    // Prepare flashback.\n    let flashback_start_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    suite.must_kv_prepare_flashback(region_id, &start_key, &end_key, flashback_start_ts);\n    // resolved ts should not be advanced anymore.\n    let mut counter = 0;\n    let mut last_resolved_ts = 0;\n    loop {\n        let event = receive_event(true);\n        if let Some(resolved_ts) = event.resolved_ts.as_ref() {\n            if resolved_ts.ts == last_resolved_ts {\n                counter += 1;\n            }\n            last_resolved_ts = resolved_ts.ts;\n        }\n        if counter > 20 {\n            break;\n        }\n        sleep_ms(50);\n    }\n    // Flashback.\n    let flashback_commit_ts = block_on(suite.cluster.pd_client.get_tso()).unwrap();\n    suite.must_kv_flashback(\n        region_id,\n        &start_key,\n        &end_key,\n        flashback_start_ts,\n        flashback_commit_ts,\n        start_ts,\n    );\n    // Check the flashback event.\n    let mut resolved_ts = 0;\n    let mut event_counter = 0;\n    loop {\n        let mut cde = receive_event(true);\n        if cde.get_resolved_ts().get_ts() > resolved_ts {\n            resolved_ts = cde.get_resolved_ts().get_ts();\n        }\n        let events = cde.mut_events();\n        if !events.is_empty() {\n            assert_eq!(events.len(), 1);\n            match events.pop().unwrap().event.unwrap() {\n                Event_oneof_event::Entries(entries) => {\n                    assert_eq!(entries.entries.len(), 1);\n                    event_counter += 1;\n                    let e = &entries.entries[0];\n                    assert!(e.commit_ts > resolved_ts);\n                    assert_eq!(e.get_op_type(), EventRowOpType::Delete);\n                    match e.get_type() {\n                        EventLogType::Committed => {\n                            // First entry should be a 1PC flashback.\n                            assert_eq!(e.get_key(), b\"key1\");\n                            assert_eq!(event_counter, 1);\n                        }\n                        EventLogType::Commit => {\n                            // Second entry should be a 2PC commit.\n                            assert_eq!(e.get_key(), b\"key0\");\n                            assert_eq!(event_counter, 2);\n                            break;\n                        }\n                        _ => panic!(\"unknown event type {:?}\", e.get_type()),\n                    }\n                }\n                other => panic!(\"unknown event {:?}\", other),\n            }\n        }\n    }\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_str_utils", "code": "fn purify(&self) -> &Self {\n        let mut line = self;\n        for (n, _) in self\n            .as_bytes()\n            .iter()\n            .enumerate()\n            .filter(|(_, c)| **c == b'#')\n        {\n            // Ignore the content after '#'\n            // only if it is preceded by at least one whitespace\n            match self[..n].chars().last() {\n                Some(c) if c.is_whitespace() => {\n                    line = &self[..n - c.len_utf8()];\n                    break;\n                }\n                None => {\n                    // n == 0\n                    line = &self[..0];\n                    break;\n                }\n                _ => (),\n            }\n        }\n        line.trim()\n    }", "test": "fn test_str_utils() {\n    let s = \"  asd#zcv #hk\\t\\n  \";\n    assert_eq!(\"asd#zcv\", s.purify());\n\n    let s = \"con256asd\";\n    assert!(s.fnmatch(\"*[2][3-6][5-9]?sd\")); // spell-checker:disable-line\n\n    let s = \"zxc \\t\\nqwe jlk    hjl\"; // spell-checker:disable-line\n    let (k, v) = s.split_two();\n    assert_eq!(\"zxc\", k);\n    assert_eq!(\"qwe jlk    hjl\", v);\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_filter_basics", "code": "pub fn apply_filter(&self, filter: &str, args: &[Value]) -> Result<Value, Error> {\n        match self.env.get_filter(filter) {\n            Some(filter) => filter.apply_to(self, args),\n            None => Err(Error::from(ErrorKind::UnknownFilter)),\n        }\n    }", "test": "fn test_filter_basics() {\n    fn test(a: u32, b: u32) -> Result<u32, Error> {\n        Ok(a + b)\n    }\n\n    let mut env = Environment::new();\n    env.add_filter(\"test\", test);\n    assert_eq!(\n        env.empty_state()\n            .apply_filter(\"test\", args!(23, 42))\n            .unwrap(),\n        Value::from(65)\n    );\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_respects_buffer_limit_pre_handshake", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn server_respects_buffer_limit_pre_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    server.set_buffer_limit(Some(32));\n\n    assert_eq!(\n        server\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        20\n    );\n    assert_eq!(\n        server\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        12\n    );\n\n    do_handshake(&mut client, &mut server);\n    transfer(&mut server, &mut client);\n    client.process_new_packets().unwrap();\n\n    check_read(&mut client.reader(), b\"01234567890123456789012345678901\");\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::cap_zero", "code": "pub fn is_some(&self) -> bool {\n        match_template_evaltype! {\n            TT, match self {\n                ScalarValue::TT(v) => v.is_some(),\n            }\n        }\n    }", "test": "fn cap_zero() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch_with_cap(0);\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.put(b\"b\", b\"\").unwrap();\n    wb.put(b\"c\", b\"\").unwrap();\n    wb.put(b\"d\", b\"\").unwrap();\n    wb.put(b\"e\", b\"\").unwrap();\n    wb.put(b\"f\", b\"\").unwrap();\n    wb.write().unwrap();\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"f\").unwrap().is_some());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(0);\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n    wb.put(b\"b\", b\"\").unwrap();\n    wb.put(b\"c\", b\"\").unwrap();\n    wb.put(b\"d\", b\"\").unwrap();\n    wb.put(b\"e\", b\"\").unwrap();\n    wb.put(b\"f\", b\"\").unwrap();\n    wb.write().unwrap();\n    assert!(\n        db.engine\n            .get_value(&0_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    assert!(\n        db.engine\n            .get_value(&123_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    assert!(\n        db.engine\n            .get_value(&255_usize.to_be_bytes())\n            .unwrap()\n            .is_some()\n    );\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    assert!(db.engine.get_value(b\"f\").unwrap().is_some());\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_storage.rs::test_atomic_cas_lock_by_latch", "code": "pub fn load(&self, ctx: TabletContext, create: bool) -> Result<CachedTablet<EK>>\n    where\n        EK: Clone,\n    {\n        assert!(ctx.suffix.is_some());\n        let id = ctx.id;\n        let path = self.tablet_path(id, ctx.suffix.unwrap());\n        if !create && !self.tablets.factory.exists(&path) {\n            return Err(Error::Other(box_err!(\n                \"tablet ({}, {:?}) doesn't exist\",\n                id,\n                ctx.suffix\n            )));\n        }\n        // TODO: use compaction filter to trim range.\n        let tablet = self.tablets.factory.open_tablet(ctx, &path)?;\n        let mut cached = self.get_or_default(id);\n        cached.set(tablet);\n        Ok(cached)\n    }", "test": "fn test_atomic_cas_lock_by_latch() {\n    let mut cluster = new_server_cluster(0, 1);\n    cluster.run();\n\n    let engine = cluster\n        .sim\n        .read()\n        .unwrap()\n        .storages\n        .get(&1)\n        .unwrap()\n        .clone();\n    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())\n        .build()\n        .unwrap();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(1);\n    ctx.set_region_epoch(cluster.get_region_epoch(1));\n    ctx.set_peer(cluster.leader_of_region(1).unwrap());\n\n    let latch_acquire_success_fp = \"txn_scheduler_acquire_success\";\n    let latch_acquire_fail_fp = \"txn_scheduler_acquire_fail\";\n    let pending_cas_fp = \"txn_commands_compare_and_swap\";\n    let wakeup_latch_fp = \"txn_scheduler_try_to_wake_up\";\n    let acquire_flag = Arc::new(AtomicBool::new(false));\n    let acquire_flag1 = acquire_flag.clone();\n    let acquire_flag_fail = Arc::new(AtomicBool::new(false));\n    let acquire_flag_fail1 = acquire_flag_fail.clone();\n    let wakeup_latch_flag = Arc::new(AtomicBool::new(false));\n    let wakeup1 = wakeup_latch_flag.clone();\n\n    fail::cfg(pending_cas_fp, \"pause\").unwrap();\n    fail::cfg_callback(latch_acquire_success_fp, move || {\n        acquire_flag1.store(true, Ordering::Release);\n    })\n    .unwrap();\n    fail::cfg_callback(latch_acquire_fail_fp, move || {\n        acquire_flag_fail1.store(true, Ordering::Release);\n    })\n    .unwrap();\n    fail::cfg_callback(wakeup_latch_fp, move || {\n        wakeup1.store(true, Ordering::Release);\n    })\n    .unwrap();\n    let (cb, f1) = paired_future_callback();\n    storage\n        .raw_compare_and_swap_atomic(\n            ctx.clone(),\n            \"\".to_string(),\n            b\"key\".to_vec(),\n            None,\n            b\"v1\".to_vec(),\n            0,\n            cb,\n        )\n        .unwrap();\n    thread::sleep(Duration::from_secs(1));\n    assert!(acquire_flag.load(Ordering::Acquire));\n    assert!(!acquire_flag_fail.load(Ordering::Acquire));\n    acquire_flag.store(false, Ordering::Release);\n    let (cb, f2) = paired_future_callback();\n    storage\n        .raw_compare_and_swap_atomic(\n            ctx.clone(),\n            \"\".to_string(),\n            b\"key\".to_vec(),\n            Some(b\"v1\".to_vec()),\n            b\"v2\".to_vec(),\n            0,\n            cb,\n        )\n        .unwrap();\n    thread::sleep(Duration::from_secs(1));\n    assert!(acquire_flag_fail.load(Ordering::Acquire));\n    assert!(!acquire_flag.load(Ordering::Acquire));\n    fail::remove(pending_cas_fp);\n    let _ = block_on(f1).unwrap();\n    let (prev_val, succeed) = block_on(f2).unwrap().unwrap();\n    assert!(wakeup_latch_flag.load(Ordering::Acquire));\n    assert!(succeed);\n    assert_eq!(prev_val, Some(b\"v1\".to_vec()));\n    let f = storage.raw_get(ctx, \"\".to_string(), b\"key\".to_vec());\n    let ret = block_on(f).unwrap().unwrap();\n    assert_eq!(b\"v2\".to_vec(), ret);\n}"}
{"test_id": "raphlinus-pulldown-cmark/raphlinus-pulldown-cmark-3da63d5/tests/lib.rs::leaves_necessary_whitespace_alone", "code": "fn normalize_html(s: &str) -> String {\n    let parser = make_html_parser();\n    let dom = parser.one(s);\n    let body: SerializableHandle = normalize_dom(&dom).into();\n    let opts = SerializeOpts::default();\n    let mut ret_val = Vec::new();\n    serialize(&mut ret_val, &body, opts)\n        .expect(\"Writing to a string shouldn't fail (expect on OOM)\");\n    String::from_utf8(ret_val).expect(\"html5ever should always produce UTF8\")\n}", "test": "fn leaves_necessary_whitespace_alone() {\n    assert_eq!(\"<u>a</u> b <u>c</u>\", normalize_html(\"<u>a</u> b <u>c</u>\"))\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::lint_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn lint_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), LINT_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"lint_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::handle_ws_both_sides_for_forloop_tag_and_remove_empty_node", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "test": "fn handle_ws_both_sides_for_forloop_tag_and_remove_empty_node() {\n    let start_ws = WS { left: true, right: true };\n    let end_ws = WS { left: true, right: true };\n    let ast = vec![\n        Node::Forloop(\n            start_ws,\n            Forloop {\n                key: None,\n                value: \"item\".to_string(),\n                container: Expr::new(ExprVal::Int(1)),\n                // not valid but we don't care about it here\n                body: vec![Node::Text(\"   \".to_string()), Node::Text(\"hey   \".to_string())],\n                empty_body: None,\n            },\n            end_ws,\n        ),\n        Node::Text(\"  hey\".to_string()),\n    ];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![\n            Node::Forloop(\n                start_ws,\n                Forloop {\n                    key: None,\n                    value: \"item\".to_string(),\n                    container: Expr::new(ExprVal::Int(1)),\n                    // not valid but we don't care about it here\n                    body: vec![Node::Text(\"hey\".to_string())],\n                    empty_body: None,\n                },\n                end_ws,\n            ),\n            Node::Text(\"hey\".to_string()),\n        ]\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/server/kv_service.rs::test_debug_region_size_v2", "code": "fn len(&self) -> usize {\n        self.buf.len()\n    }", "test": "fn test_debug_region_size_v2() {\n    let (cluster, debug_client, store_id) = test_raftstore_v2::must_new_cluster_and_debug_client();\n    let raft_engine = cluster.get_raft_engine(store_id);\n    let engine = cluster.get_engine(store_id);\n\n    let mut lb = raft_engine.log_batch(10);\n    // Put some data.\n    let region_id = 1;\n    let mut region = metapb::Region::default();\n    region.set_id(region_id);\n    region.set_start_key(b\"a\".to_vec());\n    region.set_end_key(b\"z\".to_vec());\n    let mut state = RegionLocalState::default();\n    state.set_region(region);\n    state.set_tablet_index(5);\n    lb.put_region_state(region_id, 5, &state).unwrap();\n    raft_engine.consume(&mut lb, false).unwrap();\n\n    let cfs = vec![CF_DEFAULT, CF_LOCK, CF_WRITE];\n    // At lease 8 bytes for the WRITE cf.\n    let (k, v) = (keys::data_key(b\"kkkk_kkkk\"), b\"v\");\n    for cf in &cfs {\n        engine.put_cf(cf, k.as_slice(), v).unwrap();\n    }\n\n    let mut req = debugpb::RegionSizeRequest::default();\n    req.set_region_id(region_id);\n    req.set_cfs(cfs.iter().map(|s| s.to_string()).collect());\n    let entries: Vec<_> = debug_client\n        .region_size(&req)\n        .unwrap()\n        .take_entries()\n        .into();\n    assert_eq!(entries.len(), 3);\n    for e in entries {\n        cfs.iter().find(|&&c| c == e.cf).unwrap();\n        assert!(e.size > 0);\n    }\n\n    req.set_region_id(region_id + 1);\n    match debug_client.region_size(&req).unwrap_err() {\n        Error::RpcFailure(status) => {\n            assert_eq!(status.code(), RpcStatusCode::NOT_FOUND);\n        }\n        _ => panic!(\"expect NotFound\"),\n    }\n}"}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::push_request_between_data", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "test": "async fn push_request_between_data() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        client\n            .assert_server_handshake_with_settings(frames::settings().max_concurrent_streams(100))\n            .await;\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"https://example.com/\")\n                    .eos(),\n            )\n            .await;\n        client.recv_frame(frames::headers(1).response(200)).await;\n        client.recv_frame(frames::data(1, &b\"\"[..])).await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 2).request(\"GET\", \"https://http2.akamai.com/style.css\"),\n            )\n            .await;\n        client\n            .recv_frame(frames::headers(2).response(200).eos())\n            .await;\n        client.recv_frame(frames::data(1, &b\"\"[..]).eos()).await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        // Push response to stream 1 and send some data\n        let mut s1_tx = {\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            let mut tx = stream.send_response(rsp, false).unwrap();\n            tx.send_data(vec![0; 0].into(), false).unwrap();\n            tx\n        };\n\n        // Promise stream 2 and push response headers\n        {\n            let pushed_req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style.css\")\n                .body(())\n                .unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream\n                .push_request(pushed_req)\n                .unwrap()\n                .send_response(rsp, true)\n                .unwrap();\n        }\n\n        // End response for stream 1\n        s1_tx.send_data(vec![0; 0].into(), true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, srv).await;\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_scale_pool.rs::test_decrease_pool", "code": "pub fn get_current(&self) -> TikvConfig {\n        self.inner.read().unwrap().current.clone()\n    }", "test": "fn test_decrease_pool() {\n    let mut cluster = new_node_cluster(0, 1);\n    cluster.pd_client.disable_default_operator();\n    cluster.cfg.raft_store.store_batch_system.pool_size = 2;\n    cluster.cfg.raft_store.apply_batch_system.pool_size = 2;\n    let _ = cluster.run_conf_change();\n\n    // Save current poller tids before shrinking\n    let original_poller_tids = get_poller_thread_ids();\n\n    // Request can be handled as usual\n    cluster.must_put(b\"k1\", b\"v1\");\n    must_get_equal(&cluster.get_engine(1), b\"k1\", b\"v1\");\n\n    {\n        let sim = cluster.sim.rl();\n        let cfg_controller = sim.get_cfg_controller().unwrap();\n        let change = {\n            let mut change = HashMap::new();\n            change.insert(\"raftstore.store_pool_size\".to_owned(), \"1\".to_owned());\n            change.insert(\"raftstore.apply-pool-size\".to_owned(), \"1\".to_owned());\n            change\n        };\n\n        // Update config, shrink from 2 to 1\n        cfg_controller.update(change).unwrap();\n        std::thread::sleep(std::time::Duration::from_secs(1));\n\n        assert_eq!(\n            cfg_controller\n                .get_current()\n                .raft_store\n                .apply_batch_system\n                .pool_size,\n            1\n        );\n        assert_eq!(\n            cfg_controller\n                .get_current()\n                .raft_store\n                .store_batch_system\n                .pool_size,\n            1\n        );\n    }\n\n    // Save current poller tids after scaling down\n    let current_poller_tids = get_poller_thread_ids();\n    // Compared with before shrinking, the thread num should be reduced by two\n    assert_eq!(current_poller_tids.len(), original_poller_tids.len() - 2);\n    // After shrinking, all the left tids must be there before\n    for tid in current_poller_tids {\n        assert!(original_poller_tids.contains(&tid));\n    }\n\n    // Request can be handled as usual\n    cluster.must_put(b\"k2\", b\"v2\");\n    must_get_equal(&cluster.get_engine(1), b\"k2\", b\"v2\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_descend_directory", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_rm_descend_directory() {\n    // This test descends into each directory and deletes the files and folders inside of them\n    // This test will have the rm process asks 6 question and us answering Y to them will delete all the files and folders\n\n    // Needed for talking with stdin on platforms where CRLF or LF matters\n    const END_OF_LINE: &str = if cfg!(windows) { \"\\r\\n\" } else { \"\\n\" };\n\n    let yes = format!(\"y{END_OF_LINE}\");\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_1 = \"a/at.txt\";\n    let file_2 = \"a/b/bt.txt\";\n\n    at.mkdir_all(\"a/b/\");\n    at.touch(file_1);\n    at.touch(file_2);\n\n    let mut child = scene\n        .ucmd()\n        .set_stdin(Stdio::piped())\n        .arg(\"-ri\")\n        .arg(\"a\")\n        .run_no_wait();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n\n    child.wait().unwrap();\n\n    assert!(!at.dir_exists(\"a/b\"));\n    assert!(!at.dir_exists(\"a\"));\n    assert!(!at.file_exists(file_1));\n    assert!(!at.file_exists(file_2));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes_no_empty_file", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_line_bytes_no_empty_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C\", \"1\"])\n        .pipe_in(\"1\\n2222\\n3\\n4\")\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"1\");\n    assert_eq!(at.read(\"xab\"), \"\\n\");\n    assert_eq!(at.read(\"xac\"), \"2\");\n    assert_eq!(at.read(\"xad\"), \"2\");\n    assert_eq!(at.read(\"xae\"), \"2\");\n    assert_eq!(at.read(\"xaf\"), \"2\");\n    assert_eq!(at.read(\"xag\"), \"\\n\");\n    assert_eq!(at.read(\"xah\"), \"3\");\n    assert_eq!(at.read(\"xai\"), \"\\n\");\n    assert_eq!(at.read(\"xaj\"), \"4\");\n    assert!(!at.plus(\"xak\").exists());\n}"}
{"test_id": "yamafaktory-jql/yamafaktory-jql-d2dde2f/crates/jql-runner/tests/integration.rs::check_token_integration", "code": "pub fn token(tokens: &[Token], json: &Value) -> Result<Value, JqlRunnerError> {\n    let groups = split(tokens);\n\n    let result = groups\n        .par_iter()\n        .try_fold_with(vec![], |mut acc: Vec<Value>, group| {\n            acc.push(group_runner(group, json)?);\n\n            Ok::<Vec<Value>, JqlRunnerError>(acc)\n        })\n        .try_reduce(Vec::new, |mut a, b| {\n            a.extend(b);\n\n            Ok(a)\n        });\n\n    result.map(|group| {\n        if groups.len() == 1 {\n            json!(group[0])\n        } else {\n            json!(group)\n        }\n    })\n}", "test": "fn check_token_integration() {\n    assert_eq!(\n        token(\n            &[\n                Token::KeySelector(\"a\"),\n                Token::GroupSeparator,\n                Token::KeySelector(\"b\")\n            ],\n            &json!({ \"a\": 1, \"b\": 2 })\n        ),\n        Ok(json!([1, 2]))\n    );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/globals.rs::use_after_drop", "code": "pub fn i32(val: i32) -> Self {\n        Self::I32(val as u32)\n    }", "test": "fn use_after_drop() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (module\n                (global (export \"foo\") (mut i32) (i32.const 100)))\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let g = instance.get_global(&mut store, \"foo\").unwrap();\n    assert_eq!(g.get(&mut store).i32(), Some(100));\n    g.set(&mut store, 101.into())?;\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n    Instance::new(&mut store, &module, &[])?;\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n    drop(module);\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n\n    // spray some heap values\n    let mut x = Vec::new();\n    for _ in 0..100 {\n        x.push(\"xy\".to_string());\n    }\n    drop(x);\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n    Ok(())\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_values_in_vec", "code": "pub fn apply_filter(&self, filter: &str, args: &[Value]) -> Result<Value, Error> {\n        match self.env.get_filter(filter) {\n            Some(filter) => filter.apply_to(self, args),\n            None => Err(Error::from(ErrorKind::UnknownFilter)),\n        }\n    }", "test": "fn test_values_in_vec() {\n    fn upper(value: &str) -> String {\n        value.to_uppercase()\n    }\n\n    fn sum(value: Vec<i64>) -> i64 {\n        value.into_iter().sum::<i64>()\n    }\n\n    let mut env = Environment::new();\n    env.add_filter(\"upper\", upper);\n    env.add_filter(\"sum\", sum);\n    let state = env.empty_state();\n\n    assert_eq!(\n        state.apply_filter(\"upper\", args!(\"Hello World!\")).unwrap(),\n        Value::from(\"HELLO WORLD!\")\n    );\n\n    assert_eq!(\n        state.apply_filter(\"sum\", args!(vec![1, 2])).unwrap(),\n        Value::from(3)\n    );\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_parse_error", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn ci_parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), PARSE_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::write_batch_count", "code": "fn count(&self) -> usize {\n        panic!()\n    }", "test": "fn write_batch_count() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    assert_eq!(wb.count(), 0);\n    wb.put(b\"a\", b\"\").unwrap();\n    assert_eq!(wb.count(), 1);\n    wb.write().unwrap();\n    assert_eq!(wb.count(), 1);\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    assert_eq!(wb.count(), 0);\n    for i in 0..256_usize {\n        let x = i.to_be_bytes();\n        wb.put(&x, &x).unwrap();\n    }\n    assert_eq!(wb.count(), 256);\n    wb.write().unwrap();\n    assert_eq!(wb.count(), 256);\n}"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/escape.rs::test_non_ascii", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "test": "fn test_non_ascii() {\n    assert_eq!(to_string(&\"\u2660\").unwrap(), \"\\\"\u2660\\\"\");\n    assert_eq!(to_string(&\"\u00df\").unwrap(), \"\\\"\u00df\\\"\");\n    assert_eq!(to_string(&\"\u00e4\").unwrap(), \"\\\"\u00e4\\\"\");\n    assert_eq!(to_string(&\"\u00f6\").unwrap(), \"\\\"\u00f6\\\"\");\n    assert_eq!(to_string(&\"\u00fc\").unwrap(), \"\\\"\u00fc\\\"\");\n}\n\n#[test]\nfn"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/cf_names.rs::default_names", "code": "pub fn len(&self) -> usize {\n        self.events.len()\n    }", "test": "fn default_names() {\n    let db = default_engine();\n    let names = db.engine.cf_names();\n    assert_eq!(names.len(), 1);\n    assert_eq!(names[0], CF_DEFAULT);\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_user_provided_server_order", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "test": "fn test_user_provided_server_order() {\n    use hickory_proto::rr::Record;\n\n    let mut options = ResolverOpts::default();\n\n    options.num_concurrent_reqs = 1;\n    options.server_ordering_strategy = ServerOrderingStrategy::UserProvidedOrder;\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let preferred_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n    let secondary_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 2));\n\n    let preferred_server_records = vec![preferred_record; 10];\n    let secondary_server_records = vec![secondary_record; 10];\n\n    let to_dns_response = |records: Vec<Record>| -> Vec<Result<DnsResponse, ResolveError>> {\n        records\n            .iter()\n            .map(|record| {\n                Ok(DnsResponse::from_message(message(\n                    query.clone(),\n                    vec![record.clone()],\n                    vec![],\n                    vec![],\n                ))\n                .unwrap())\n            })\n            .collect()\n    };\n\n    // Specify different IP addresses for each name server to ensure that they\n    // are considered separately.\n    let preferred_nameserver = mock_nameserver_with_addr(\n        to_dns_response(preferred_server_records.clone()),\n        Ipv4Addr::new(128, 0, 0, 1).into(),\n        Default::default(),\n    );\n    let secondary_nameserver = mock_nameserver_with_addr(\n        to_dns_response(secondary_server_records.clone()),\n        Ipv4Addr::new(129, 0, 0, 1).into(),\n        Default::default(),\n    );\n\n    let pool = mock_nameserver_pool(\n        vec![preferred_nameserver, secondary_nameserver],\n        vec![],\n        None,\n        options,\n    );\n\n    // The returned records should consistently be from the preferred name\n    // server until the configured records are exhausted. Subsequently, the\n    // secondary server should be used.\n    preferred_server_records\n        .into_iter()\n        .chain(secondary_server_records)\n        .for_each(|expected_record| {\n            let request = message(query.clone(), vec![], vec![], vec![]);\n            let future = pool.send(request).first_answer();\n\n            let response = block_on(future).unwrap();\n            assert_eq!(response.answers()[0], expected_record);\n        });\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_copy_file", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_copy_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let file2 = \"target_file\";\n\n    at.touch(file1);\n    ucmd.arg(file1).arg(file2).succeeds().no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_ic", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_ic() {\n    // Test iterators that skip multiple, internal digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"__.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__455\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\"_.455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"__.455\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"45__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__45__.56\");\n}"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::filter_filter_works", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "test": "fn filter_filter_works() {\n    #[derive(Debug, Serialize)]\n    struct Author {\n        id: u8,\n    }\n\n    let mut context = Context::new();\n    context.insert(\"authors\", &vec![Author { id: 1 }, Author { id: 2 }, Author { id: 3 }]);\n\n    let inputs =\n        vec![(r#\"{{ authors | filter(attribute=\"id\", value=1) | first | get(key=\"id\") }}\"#, \"1\")];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_merge.rs::test_merge_pessimistic_locks_propose_fail", "code": "fn read(&self, _name: &str) -> crate::ExternalData<'_> {\n            unimplemented!(\"use restore instead of read\")\n        }", "test": "fn test_merge_pessimistic_locks_propose_fail() {\n    let mut cluster = new_server_cluster(0, 2);\n    configure_for_merge(&mut cluster.cfg);\n    cluster.cfg.pessimistic_txn.pipelined = true;\n    cluster.cfg.pessimistic_txn.in_memory = true;\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n\n    cluster.run();\n\n    cluster.must_transfer_leader(1, new_peer(1, 1));\n\n    cluster.must_put(b\"k1\", b\"v1\");\n    cluster.must_put(b\"k3\", b\"v3\");\n\n    let region = cluster.get_region(b\"k1\");\n    cluster.must_split(&region, b\"k2\");\n    let left = cluster.get_region(b\"k1\");\n    let right = cluster.get_region(b\"k3\");\n\n    // Sending a TransferLeaeder message to make left region fail to propose.\n\n    let snapshot = cluster.must_get_snapshot_of_region(left.id);\n    let txn_ext = snapshot.ext().get_txn_ext().unwrap().clone();\n    let lock = PessimisticLock {\n        primary: b\"k1\".to_vec().into_boxed_slice(),\n        start_ts: 10.into(),\n        ttl: 3000,\n        for_update_ts: 20.into(),\n        min_commit_ts: 30.into(),\n        last_change_ts: 15.into(),\n        versions_to_last_change: 3,\n    };\n    txn_ext\n        .pessimistic_locks\n        .write()\n        .insert(vec![(Key::from_raw(b\"k1\"), lock)])\n        .unwrap();\n\n    fail::cfg(\"raft_propose\", \"pause\").unwrap();\n\n    cluster.merge_region(left.id, right.id, Callback::None);\n    thread::sleep(Duration::from_millis(500));\n    assert_eq!(\n        txn_ext.pessimistic_locks.read().status,\n        LocksStatus::MergingRegion\n    );\n\n    // With the fail point set, we will fail to propose the locks or the\n    // PrepareMerge request.\n    fail::cfg(\"raft_propose\", \"return()\").unwrap();\n\n    // But after that, the pessimistic locks status should remain unchanged.\n    for _ in 0..5 {\n        thread::sleep(Duration::from_millis(500));\n        if txn_ext.pessimistic_locks.read().status == LocksStatus::Normal {\n            return;\n        }\n    }\n    panic!(\n        \"pessimistic locks status should return to Normal, but got {:?}\",\n        txn_ext.pessimistic_locks.read().status\n    );\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_clone", "code": "fn render(env: &Environment, template: &str, ctx: &Value, locals: &BTreeMap<String, Value>) {\n    match env.render_str(\n        template,\n        context!(\n            ..Value::from_iter(locals.iter().map(|x| (x.0.clone(), x.1.clone()))),\n            ..ctx.clone()\n        ),\n    ) {\n        Ok(rv) => {\n            println!(\"{}\", rv);\n        }\n        Err(err) => print_error(&Error::from(err)),\n    }\n}", "test": "fn test_clone() {\n    let mut env = Environment::new();\n    env.add_template(\"test\", \"a\").unwrap();\n    let mut env2 = env.clone();\n    assert_eq!(env2.get_template(\"test\").unwrap().render(()).unwrap(), \"a\");\n    env2.add_template(\"test\", \"b\").unwrap();\n    assert_eq!(env2.get_template(\"test\").unwrap().render(()).unwrap(), \"b\");\n    assert_eq!(env.get_template(\"test\").unwrap().render(()).unwrap(), \"a\");\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::wasi_misaligned_pointer", "code": "fn success() -> Self {\n        Self::Success\n    }", "test": "fn wasi_misaligned_pointer() -> Result<()> {\n    let output = get_wasmtime_command()?\n        .arg(\"./tests/all/cli_tests/wasi_misaligned_pointer.wat\")\n        .output()?;\n    assert!(!output.status.success());\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"Pointer not aligned\"),\n        \"bad stderr: {stderr}\",\n    );\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_number_n", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "test": "fn test_number_n() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_read = |f| {\n        let mut s = String::new();\n        at.open(f).read_to_string(&mut s).unwrap();\n        s\n    };\n    ucmd.args(&[\"-n\", \"5\", \"asciilowercase.txt\"]).succeeds();\n    assert_eq!(file_read(\"xaa\"), \"abcde\");\n    assert_eq!(file_read(\"xab\"), \"fghij\");\n    assert_eq!(file_read(\"xac\"), \"klmno\");\n    assert_eq!(file_read(\"xad\"), \"pqrst\");\n    assert_eq!(file_read(\"xae\"), \"uvwxyz\\n\");\n    #[cfg(unix)]\n    new_ucmd!()\n        .args(&[\"--number=100\", \"/dev/null\"])\n        .succeeds()\n        .stdout_only(\"\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_simple_protect_source", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_backup_simple_protect_source() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let source = format!(\"{TEST_HELLO_WORLD_SOURCE}~\");\n    at.touch(&source);\n    ucmd.arg(\"--backup=simple\")\n        .arg(&source)\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .fails()\n        .stderr_only(format!(\n            \"cp: backing up '{TEST_HELLO_WORLD_SOURCE}' might destroy source;  '{source}' not copied\\n\",\n        ));\n\n    assert_eq!(at.read(TEST_HELLO_WORLD_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(at.read(&source), \"\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_short_no_overwrite", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_arg_update_short_no_overwrite() {\n    // same as --update=older\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_short_no_overwrite_file1\";\n    let new = \"test_cp_arg_update_short_no_overwrite_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"-u\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"new content\\n\");\n}"}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_try_move_to_heap_and_shrink", "code": "pub fn is_inline(&self) -> bool {\n    !self.is_heap()\n  }", "test": "fn TinyVec_try_move_to_heap_and_shrink() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert!(tv.is_inline());\n  assert!(tv.try_move_to_the_heap().is_ok());\n  assert!(tv.is_heap());\n  assert_eq!(tv.capacity(), 0);\n\n  assert!(tv.try_reserve_exact(1).is_ok());\n  assert_eq!(tv.capacity(), 1);\n  tv.push(1);\n  tv.shrink_to_fit();\n  assert!(tv.is_inline());\n  assert_eq!(tv.capacity(), 4);\n\n  assert!(tv.try_move_to_the_heap_and_reserve(3).is_ok());\n  assert!(tv.is_heap());\n  assert_eq!(tv.capacity(), 4);\n  tv.extend(2..=4);\n  assert_eq!(tv.capacity(), 4);\n  assert_eq!(tv.as_slice(), [1, 2, 3, 4]);\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_pd_client_legacy.rs::test_reconnect_limit", "code": "pub fn contains(&self, op: IoOp) -> bool {\n        match *self {\n            IoRateLimitMode::WriteOnly => op == IoOp::Write,\n            IoRateLimitMode::ReadOnly => op == IoOp::Read,\n            _ => true,\n        }\n    }", "test": "fn test_reconnect_limit() {\n    let pd_client_reconnect_fp = \"pd_client_reconnect\";\n    let (_server, client) = new_test_server_and_client(ReadableDuration::secs(100));\n\n    // The GLOBAL_RECONNECT_INTERVAL is 0.1s so sleeps 0.2s here.\n    thread::sleep(Duration::from_millis(200));\n\n    // The first reconnection will succeed, and the last_update will not be updated.\n    fail::cfg(pd_client_reconnect_fp, \"return\").unwrap();\n    client.reconnect().unwrap();\n    // The subsequent reconnection will be cancelled.\n    for _ in 0..10 {\n        let ret = client.reconnect();\n        assert!(format!(\"{:?}\", ret.unwrap_err()).contains(\"cancel reconnection\"));\n    }\n\n    fail::remove(pd_client_reconnect_fp);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_signal_name_new_form", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "test": "fn test_kill_with_signal_name_new_form() {\n    let mut target = Target::new();\n    new_ucmd!()\n        .arg(\"-s\")\n        .arg(\"KILL\")\n        .arg(format!(\"{}\", target.pid()))\n        .succeeds();\n    assert_eq!(target.wait_for_signal(), Some(libc::SIGKILL));\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_exposes_offered_sni", "code": "pub fn server_name(&self) -> Option<&str> {\n        self.server_name\n            .as_ref()\n            .map(<DnsName as AsRef<str>>::as_ref)\n    }", "test": "fn server_exposes_offered_sni() {\n    let kt = KeyType::Rsa;\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"second.testserver.com\"))\n                .unwrap();\n        let mut server = ServerConnection::new(Arc::new(make_server_config(kt))).unwrap();\n\n        assert_eq!(None, server.server_name());\n        do_handshake(&mut client, &mut server);\n        assert_eq!(Some(\"second.testserver.com\"), server.server_name());\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/failpoints/cases/test_local_read.rs::test_consistency_after_lease_pass", "code": "pub fn to_vec(self) -> Vec<u8> {\n        if self.is_empty() {\n            return vec![];\n        }\n        let ctx = self.bits();\n        vec![ctx]\n    }", "test": "fn test_consistency_after_lease_pass() {\n    let mut cluster = new_server_cluster(0, 3);\n    let pd_client = Arc::clone(&cluster.pd_client);\n    pd_client.disable_default_operator();\n    cluster.run();\n    let leader = new_peer(1, 1);\n    cluster.must_transfer_leader(1, leader);\n\n    // Create clients.\n    let env = Arc::new(Environment::new(1));\n    let channel = ChannelBuilder::new(Arc::clone(&env)).connect(&cluster.sim.rl().get_addr(1));\n    let client = TikvClient::new(channel);\n\n    let region = cluster.get_region(&b\"key1\"[..]);\n    let region_id = region.id;\n    let leader = cluster.leader_of_region(region_id).unwrap();\n\n    let mut ctx = Context::default();\n    ctx.set_region_id(region_id);\n    ctx.set_peer(leader.clone());\n    ctx.set_region_epoch(region.get_region_epoch().clone());\n\n    must_raw_put(&client, ctx.clone(), b\"key1\".to_vec(), b\"value1\".to_vec());\n    must_get_equal(&cluster.get_engine(1), b\"key1\", b\"value1\");\n\n    // Ensure the request is executed by the local reader\n    fail::cfg(\"localreader_before_redirect\", \"panic\").unwrap();\n\n    // Lease read works correctly\n    assert_eq!(\n        must_raw_get(&client, ctx.clone(), b\"key1\".to_vec()).unwrap(),\n        b\"value1\".to_vec()\n    );\n\n    // we pause just after pass the lease check, and then remove the peer. We can\n    // still read the relevant value as we should have already got the snapshot when\n    // passing the lease check.\n    fail::cfg(\"after_pass_lease_check\", \"pause\").unwrap();\n\n    let mut get_req = RawGetRequest::default();\n    get_req.set_context(ctx);\n    get_req.key = b\"key1\".to_vec();\n    let mut receiver = client.raw_get_async(&get_req).unwrap();\n\n    thread::sleep(Duration::from_millis(200));\n\n    let mut peer = leader.clone();\n    cluster.must_transfer_leader(1, new_peer(2, 2));\n    pd_client.must_remove_peer(region_id, leader);\n    peer.id = 1000;\n    // After we pass the lease check, we should have got the snapshot, so the data\n    // that the region contains cannot be deleted.\n    // So we need to add the new peer for this region and stop before applying the\n    // snapshot so that the old data will be deleted and the snapshot data has not\n    // been written.\n    fail::cfg(\"apply_snap_cleanup_range\", \"pause\").unwrap();\n    pd_client.must_add_peer(region_id, peer);\n\n    // Wait for data to be cleaned\n    must_get_none(&cluster.get_engine(1), b\"key1\");\n    fail::cfg(\"after_pass_lease_check\", \"off\").unwrap();\n\n    assert_eq!(b\"value1\", receiver.receive_sync().unwrap().1.get_value());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_no_args_file_to_dir", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_short_no_args_file_to_dir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file = \"test_install_simple_backup_file_a\";\n    let dest_dir = \"test_install_dest/\";\n    let expect = format!(\"{dest_dir}{file}\");\n\n    at.touch(file);\n    at.mkdir(dest_dir);\n    at.touch(&expect);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .arg(file)\n        .arg(dest_dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(&expect));\n    assert!(at.file_exists(format!(\"{expect}~\")));\n}"}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::line_width_parse_errors_overflow", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "test": "fn line_width_parse_errors_overflow() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--line-width\"), (\"321\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"line_width_parse_errors_overflow\",\n        fs,\n        console,\n        result,\n    ));\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/pd/test_rpc_client.rs::test_incompatible_version", "code": "pub fn to_string(&self) -> Result<String> {\n        let s = match *self {\n            Datum::I64(i) => format!(\"{}\", i),\n            Datum::U64(u) => format!(\"{}\", u),\n            Datum::F64(f) => format!(\"{}\", f),\n            Datum::Bytes(ref bs) => String::from_utf8(bs.to_vec())?,\n            Datum::Time(t) => format!(\"{}\", t),\n            Datum::Dur(ref d) => format!(\"{}\", d),\n            Datum::Dec(ref d) => format!(\"{}\", d),\n            Datum::Json(ref d) => d.to_string(),\n            Datum::Enum(ref e) => e.to_string(),\n            Datum::Set(ref s) => s.to_string(),\n            ref d => return Err(invalid_type!(\"can't convert {} to string\", d)),\n        };\n        Ok(s)\n    }", "test": "fn test_incompatible_version() {\n    let incompatible = Arc::new(Incompatible);\n    let server = MockServer::with_case(1, incompatible);\n    let eps = server.bind_addrs();\n\n    let mut client = new_client_v2(eps, None);\n\n    let resp = block_on(client.ask_batch_split(metapb::Region::default(), 2));\n    assert_eq!(\n        resp.unwrap_err().to_string(),\n        PdError::Incompatible.to_string()\n    );\n}"}
{"test_id": "hyperium-http/hyperium-http-818269d/tests/header_map.rs::remove_entry_multi_3_others", "code": "pub fn len(&self) -> usize {\n        self.vec.len()\n    }", "test": "fn remove_entry_multi_3_others() {\n    let mut headers = HeaderMap::new();\n    headers.insert(VIA, \"1.1 example.com\".parse().unwrap());\n    headers.insert(SET_COOKIE, \"cookie_1=value 1\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_2=value 2\".parse().unwrap());\n    headers.append(VIA, \"1.1 other.com\".parse().unwrap());\n    headers.append(SET_COOKIE, \"cookie_3=value 3\".parse().unwrap());\n    headers.insert(VARY, \"*\".parse().unwrap());\n\n    let cookies = remove_all_values(&mut headers, SET_COOKIE);\n    assert_eq!(cookies.len(), 3);\n    assert_eq!(headers.len(), 3);\n\n    let vias = remove_all_values(&mut headers, VIA);\n    assert_eq!(vias.len(), 2);\n    assert_eq!(headers.len(), 1);\n\n    let varies = remove_all_values(&mut headers, VARY);\n    assert_eq!(varies.len(), 1);\n    assert_eq!(headers.len(), 0);\n}"}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::iter", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "test": "fn iter() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.iter().unwrap();\n    for i in 0..10 {\n        let (k, v) = iter.next().unwrap().unwrap();\n        assert_eq!(i, k.value());\n        assert_eq!(i, v.value());\n    }\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/components/engine_traits_tests/src/write_batch.rs::save_point_same_rollback_all", "code": "pub fn is_some(&self) -> bool {\n        self.max_expire_ts.is_some() || self.min_expire_ts.is_some()\n    }", "test": "fn save_point_same_rollback_all() {\n    let db = default_engine();\n    let mut wb = db.engine.write_batch();\n\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.set_save_point();\n    wb.set_save_point();\n    wb.set_save_point();\n\n    wb.put(b\"b\", b\"\").unwrap();\n\n    wb.rollback_to_save_point().unwrap();\n    wb.rollback_to_save_point().unwrap();\n    wb.rollback_to_save_point().unwrap();\n\n    assert_engine_error(wb.pop_save_point());\n    assert_engine_error(wb.rollback_to_save_point());\n\n    wb.write().unwrap();\n\n    let a = db.engine.get_value(b\"a\").unwrap();\n    let b = db.engine.get_value(b\"b\").unwrap();\n\n    assert!(a.is_some());\n    assert!(b.is_none());\n\n    let db = multi_batch_write_engine();\n    let mut wb = db.engine.write_batch_with_cap(1024);\n    let max_keys = 256_usize;\n\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n    wb.put(b\"a\", b\"\").unwrap();\n\n    wb.set_save_point();\n    wb.set_save_point();\n    wb.set_save_point();\n\n    wb.put(b\"b\", b\"\").unwrap();\n    for i in 0..max_keys {\n        wb.put(&i.to_be_bytes(), b\"\").unwrap();\n    }\n\n    wb.rollback_to_save_point().unwrap();\n    wb.rollback_to_save_point().unwrap();\n    wb.rollback_to_save_point().unwrap();\n\n    assert_engine_error(wb.pop_save_point());\n    assert_engine_error(wb.rollback_to_save_point());\n\n    wb.write().unwrap();\n\n    assert!(db.engine.get_value(b\"a\").unwrap().is_some());\n    for i in 0..max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_some());\n    }\n\n    assert!(db.engine.get_value(b\"b\").unwrap().is_none());\n    for i in max_keys..2 * max_keys {\n        assert!(db.engine.get_value(&i.to_be_bytes()).unwrap().is_none());\n    }\n}"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2f_test.rs::test_basic", "code": "pub fn s2f(buffer: &[u8]) -> Result<f32, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u32;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index != len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 9 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u32;\n        if m10 != 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.\n                return Err(Error::InputTooLong);\n            }\n            e10 = 10 * e10 + (c - b'0') as i32;\n            if e10 != 0 {\n                e10digits += 1;\n            }\n            i += 1;\n        }\n    }\n\n    if i < len {\n        return Err(Error::MalformedInput);\n    }\n    if signed_e {\n        e10 = -e10;\n    }\n    e10 -= if dot_index < e_index {\n        (e_index - dot_index - 1) as i32\n    } else {\n        0\n    };\n    if m10 == 0 {\n        return Ok(if signed_m { -0.0 } else { 0.0 });\n    }\n\n    if m10digits + e10 <= -46 || m10 == 0 {\n        // Number is less than 1e-46, which should be rounded down to 0; return\n        // +/-0.0.\n        let ieee = (signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n    if m10digits + e10 >= 40 {\n        // Number is larger than 1e+39, which should be rounded to +/-Infinity.\n        let ieee = ((signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS))\n            | (0xff_u32 << f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n\n    // Convert to binary float m2 * 2^e2, while retaining information about\n    // whether the conversion was exact (trailing_zeros).\n    let e2: i32;\n    let m2: u32;\n    let mut trailing_zeros: bool;\n    if e10 >= 0 {\n        // The length of m * 10^e in bits is:\n        //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)\n        //\n        // We want to compute the FLOAT_MANTISSA_BITS + 1 top-most bits (+1 for\n        // the implicit leading one in IEEE format). We therefore choose a\n        // binary output exponent of\n        //   log2(m10 * 10^e10) - (FLOAT_MANTISSA_BITS + 1).\n        //\n        // We use floor(log2(5^e10)) so that we get at least this many bits; better to\n        // have an additional bit than to not have enough bits.\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_add(log2_pow5(e10) as u32)\n            .wrapping_sub(f2s::FLOAT_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].\n        // To that end, we use the FLOAT_POW5_SPLIT table.\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_sub(ceil_log2_pow5(e10))\n            .wrapping_add(f2s::FLOAT_POW5_BITCOUNT);\n        debug_assert!(j >= 0);\n        m2 = mul_pow5_div_pow2(m10, e10 as u32, j);\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.\n        // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn\n        // requires that the largest power of 2 that divides m10 + e10 is\n        // greater than e2. If e2 is less than e10, then the result must be\n        // exact. Otherwise we use the existing multiple_of_power_of_2 function.\n        trailing_zeros =\n            e2 < e10 || e2 - e10 < 32 && multiple_of_power_of_2_32(m10, (e2 - e10) as u32);\n    } else {\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_sub(ceil_log2_pow5(-e10) as u32)\n            .wrapping_sub(f2s::FLOAT_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 / (5^(-e10) 2^(e2-e10))].\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_add(ceil_log2_pow5(-e10))\n            .wrapping_sub(1)\n            .wrapping_add(f2s::FLOAT_POW5_INV_BITCOUNT);\n        m2 = mul_pow5_inv_div_pow2(m10, -e10 as u32, j);\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 / (5^(-e10) 2^(e2-e10))] == m10 / (5^(-e10) 2^(e2-e10))\n        //\n        // If e2-e10 >= 0, we need to check whether (5^(-e10) 2^(e2-e10))\n        // divides m10, which is the case iff pow5(m10) >= -e10 AND pow2(m10) >=\n        // e2-e10.\n        //\n        // If e2-e10 < 0, we have actually computed [m10 * 2^(e10 e2) /\n        // 5^(-e10)] above, and we need to check whether 5^(-e10) divides (m10 *\n        // 2^(e10-e2)), which is the case iff pow5(m10 * 2^(e10-e2)) = pow5(m10)\n        // >= -e10.\n        trailing_zeros = (e2 < e10\n            || (e2 - e10 < 32 && multiple_of_power_of_2_32(m10, (e2 - e10) as u32)))\n            && multiple_of_power_of_5_32(m10, -e10 as u32);\n    }\n\n    // Compute the final IEEE exponent.\n    let mut ieee_e2 = i32::max(0, e2 + FLOAT_EXPONENT_BIAS as i32 + floor_log2(m2) as i32) as u32;\n\n    if ieee_e2 > 0xfe {\n        // Final IEEE exponent is larger than the maximum representable; return\n        // +/-Infinity.\n        let ieee = ((signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS))\n            | (0xff_u32 << f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n\n    // We need to figure out how much we need to shift m2. The tricky part is\n    // that we need to take the final IEEE exponent into account, so we need to\n    // reverse the bias and also special-case the value 0.\n    let shift = if ieee_e2 == 0 { 1 } else { ieee_e2 as i32 }\n        .wrapping_sub(e2)\n        .wrapping_sub(FLOAT_EXPONENT_BIAS as i32)\n        .wrapping_sub(f2s::FLOAT_MANTISSA_BITS as i32);\n    debug_assert!(shift >= 0);\n\n    // We need to round up if the exact value is more than 0.5 above the value\n    // we computed. That's equivalent to checking if the last removed bit was 1\n    // and either the value was not just trailing zeros or the result would\n    // otherwise be odd.\n    //\n    // We need to update trailing_zeros given that we have the exact output\n    // exponent ieee_e2 now.\n    trailing_zeros &= (m2 & ((1_u32 << (shift - 1)) - 1)) == 0;\n    let last_removed_bit = (m2 >> (shift - 1)) & 1;\n    let round_up = last_removed_bit != 0 && (!trailing_zeros || ((m2 >> shift) & 1) != 0);\n\n    let mut ieee_m2 = (m2 >> shift).wrapping_add(round_up as u32);\n    debug_assert!(ieee_m2 <= 1_u32 << (f2s::FLOAT_MANTISSA_BITS + 1));\n    ieee_m2 &= (1_u32 << f2s::FLOAT_MANTISSA_BITS) - 1;\n    if ieee_m2 == 0 && round_up {\n        // Rounding up may overflow the mantissa.\n        // In this case we move a trailing zero of the mantissa into the\n        // exponent.\n        // Due to how the IEEE represents +/-Infinity, we don't need to check\n        // for overflow here.\n        ieee_e2 += 1;\n    }\n    let ieee = ((((signed_m as u32) << f2s::FLOAT_EXPONENT_BITS) | ieee_e2)\n        << f2s::FLOAT_MANTISSA_BITS)\n        | ieee_m2;\n    Ok(f32::from_bits(ieee))\n}", "test": "fn test_basic() {\n    assert_eq!(0.0, s2f(b\"0\").unwrap());\n    assert_eq!(-0.0, s2f(b\"-0\").unwrap());\n    assert_eq!(1.0, s2f(b\"1\").unwrap());\n    assert_eq!(-1.0, s2f(b\"-1\").unwrap());\n    assert_eq!(123456792.0, s2f(b\"123456789\").unwrap());\n    assert_eq!(299792448.0, s2f(b\"299792458\").unwrap());\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_help_flag", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "test": "fn test_help_flag() {\n    let help_short = new_ucmd!().arg(\"-h\").succeeds();\n    let help_long = new_ucmd!().arg(\"--help\").succeeds();\n\n    assert_eq!(help_short.stdout_str(), help_long.stdout_str());\n}"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_value_as_bytes", "code": "pub fn as_bytes(&self) -> Option<&[u8]> {\n        match &self.0 {\n            ValueRepr::String(ref s, _) => Some(s.as_bytes()),\n            ValueRepr::Bytes(ref b) => Some(&b[..]),\n            _ => None,\n        }\n    }", "test": "fn test_value_as_bytes() {\n    assert_eq!(Value::from(\"foo\").as_bytes(), Some(&b\"foo\"[..]));\n    assert_eq!(Value::from(&b\"foo\"[..]).as_bytes(), Some(&b\"foo\"[..]));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_custom_suffix", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_short_custom_suffix() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_custom_suffix_file_a\";\n    let file_b = \"test_install_backup_custom_suffix_file_b\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .arg(format!(\"--suffix={suffix}\"))\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}"}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/server.rs::inscription_metadata", "code": "async fn status(Extension(index): Extension<Arc<Index>>) -> (StatusCode, &'static str) {\n    if index.is_unrecoverably_reorged() {\n      (\n        StatusCode::OK,\n        \"unrecoverable reorg detected, please rebuild the database.\",\n      )\n    } else {\n      (\n        StatusCode::OK,\n        StatusCode::OK.canonical_reason().unwrap_or_default(),\n      )\n    }\n  }", "test": "fn inscription_metadata() {\n  let metadata = r#\"{\"foo\":\"bar\",\"baz\":1}\"#;\n  let mut encoded_metadata = Vec::new();\n  let cbor_map = ciborium::value::Value::Map(vec![\n    (\n      ciborium::value::Value::Text(\"foo\".into()),\n      ciborium::value::Value::Text(\"bar\".into()),\n    ),\n    (\n      ciborium::value::Value::Text(\"baz\".into()),\n      ciborium::value::Value::Integer(Integer::from(1)),\n    ),\n  ]);\n  ciborium::ser::into_writer(&cbor_map, &mut encoded_metadata).unwrap();\n\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  rpc_server.mine_blocks(1);\n\n  let inscription_id = CommandBuilder::new(\n    \"wallet inscribe --fee-rate 1 --json-metadata metadata.json --file foo.txt\",\n  )\n  .write(\"foo.txt\", \"FOO\")\n  .write(\"metadata.json\", metadata)\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Inscribe>()\n  .inscriptions\n  .get(0)\n  .unwrap()\n  .id;\n\n  rpc_server.mine_blocks(1);\n\n  let response =\n    TestServer::spawn_with_args(&rpc_server, &[]).request(format!(\"/r/metadata/{inscription_id}\"));\n\n  assert_eq!(response.status(), StatusCode::OK);\n  assert_eq!(\n    response.headers().get(\"content-type\").unwrap(),\n    \"application/json\"\n  );\n  assert_eq!(\n    response.text().unwrap(),\n    format!(\"\\\"{}\\\"\", hex::encode(encoded_metadata))\n  );\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u64_pow2_test", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "test": "fn u64_pow2_test() {\n    let values: &[u64] = &[\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        7,\n        8,\n        9,\n        15,\n        16,\n        17,\n        31,\n        32,\n        33,\n        63,\n        64,\n        65,\n        127,\n        128,\n        129,\n        255,\n        256,\n        257,\n        511,\n        512,\n        513,\n        1023,\n        1024,\n        1025,\n        2047,\n        2048,\n        2049,\n        4095,\n        4096,\n        4097,\n        8191,\n        8192,\n        8193,\n        16383,\n        16384,\n        16385,\n        32767,\n        32768,\n        32769,\n        65535,\n        65536,\n        65537,\n        131071,\n        131072,\n        131073,\n        262143,\n        262144,\n        262145,\n        524287,\n        524288,\n        524289,\n        1048575,\n        1048576,\n        1048577,\n        2097151,\n        2097152,\n        2097153,\n        4194303,\n        4194304,\n        4194305,\n        8388607,\n        8388608,\n        8388609,\n        16777215,\n        16777216,\n        16777217,\n        33554431,\n        33554432,\n        33554433,\n        67108863,\n        67108864,\n        67108865,\n        134217727,\n        134217728,\n        134217729,\n        268435455,\n        268435456,\n        268435457,\n        536870911,\n        536870912,\n        536870913,\n        1073741823,\n        1073741824,\n        1073741825,\n        2147483647,\n        2147483648,\n        2147483649,\n        4294967295,\n        4294967296,\n        4294967297,\n        8589934591,\n        8589934592,\n        8589934593,\n        17179869183,\n        17179869184,\n        17179869185,\n        34359738367,\n        34359738368,\n        34359738369,\n        68719476735,\n        68719476736,\n        68719476737,\n        137438953471,\n        137438953472,\n        137438953473,\n        274877906943,\n        274877906944,\n        274877906945,\n        549755813887,\n        549755813888,\n        549755813889,\n        1099511627775,\n        1099511627776,\n        1099511627777,\n        2199023255551,\n        2199023255552,\n        2199023255553,\n        4398046511103,\n        4398046511104,\n        4398046511105,\n        8796093022207,\n        8796093022208,\n        8796093022209,\n        17592186044415,\n        17592186044416,\n        17592186044417,\n        35184372088831,\n        35184372088832,\n        35184372088833,\n        70368744177663,\n        70368744177664,\n        70368744177665,\n        140737488355327,\n        140737488355328,\n        140737488355329,\n        281474976710655,\n        281474976710656,\n        281474976710657,\n        562949953421311,\n        562949953421312,\n        562949953421313,\n        1125899906842623,\n        1125899906842624,\n        1125899906842625,\n        2251799813685247,\n        2251799813685248,\n        2251799813685249,\n        4503599627370495,\n        4503599627370496,\n        4503599627370497,\n        9007199254740991,\n        9007199254740992,\n        9007199254740993,\n        18014398509481983,\n        18014398509481984,\n        18014398509481985,\n        36028797018963967,\n        36028797018963968,\n        36028797018963969,\n        72057594037927935,\n        72057594037927936,\n        72057594037927937,\n        144115188075855871,\n        144115188075855872,\n        144115188075855873,\n        288230376151711743,\n        288230376151711744,\n        288230376151711745,\n        576460752303423487,\n        576460752303423488,\n        576460752303423489,\n        1152921504606846975,\n        1152921504606846976,\n        1152921504606846977,\n        2305843009213693951,\n        2305843009213693952,\n        2305843009213693953,\n        4611686018427387903,\n        4611686018427387904,\n        4611686018427387905,\n        9223372036854775807,\n        9223372036854775808,\n        9223372036854775809,\n        18446744073709551615,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_respects_buffer_limit_pre_handshake_with_vectored_write", "code": "fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self\n            .conn\n            .writer()\n            .write_vectored(bufs)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn server_respects_buffer_limit_pre_handshake_with_vectored_write() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    server.set_buffer_limit(Some(32));\n\n    assert_eq!(\n        server\n            .writer()\n            .write_vectored(&[\n                IoSlice::new(b\"01234567890123456789\"),\n                IoSlice::new(b\"01234567890123456789\")\n            ])\n            .unwrap(),\n        32\n    );\n\n    do_handshake(&mut client, &mut server);\n    transfer(&mut server, &mut client);\n    client.process_new_packets().unwrap();\n\n    check_read(&mut client.reader(), b\"01234567890123456789012345678901\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_head_count", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "test": "fn test_head_count() {\n    let repeat_limit = 5;\n    let input_seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let input = input_seq\n        .iter()\n        .map(ToString::to_string)\n        .collect::<Vec<String>>()\n        .join(\"\\n\");\n\n    let result = new_ucmd!()\n        .args(&[\"-n\", &repeat_limit.to_string()])\n        .pipe_in(input.as_bytes())\n        .succeeds();\n    result.no_stderr();\n\n    let mut result_seq: Vec<i32> = result\n        .stdout_str()\n        .split('\\n')\n        .filter(|x| !x.is_empty())\n        .map(|x| x.parse().unwrap())\n        .collect();\n    result_seq.sort_unstable();\n    assert_eq!(result_seq.len(), repeat_limit, \"Output is not limited\");\n    assert!(\n        result_seq.iter().all(|x| input_seq.contains(x)),\n        \"Output includes element not from input: {}\",\n        result.stdout_str()\n    );\n}"}
{"test_id": "tikv-tikv/tikv-tikv-8632b39/tests/integrations/raftstore/test_life.rs::test_gc_removed_peer", "code": "pub fn get_region_id(&self) -> u64 {\n        self.region().get_id()\n    }", "test": "fn test_gc_removed_peer() {\n    let mut cluster = test_raftstore::new_node_cluster(1, 2);\n    cluster.cfg.raft_store.enable_v2_compatible_learner = true;\n    cluster.pd_client.disable_default_operator();\n    let region_id = cluster.run_conf_change();\n\n    let (tx, rx) = channel();\n    let tx = Mutex::new(tx);\n    let factory = ForwardFactory {\n        node_id: 1,\n        chain_send: Arc::new(move |m| {\n            if m.get_extra_msg().get_type() == ExtraMessageType::MsgGcPeerResponse {\n                let _ = tx.lock().unwrap().send(m);\n            }\n        }),\n        keep_msg: true,\n    };\n    cluster.add_send_filter(factory);\n\n    let check_gc_peer = |to_peer: kvproto::metapb::Peer, timeout| -> bool {\n        let epoch = cluster.get_region_epoch(region_id);\n        let mut msg = RaftMessage::default();\n        msg.set_is_tombstone(true);\n        msg.set_region_id(region_id);\n        msg.set_from_peer(new_peer(1, 1));\n        msg.set_to_peer(to_peer.clone());\n        msg.set_region_epoch(epoch.clone());\n        let extra_msg = msg.mut_extra_msg();\n        extra_msg.set_type(ExtraMessageType::MsgGcPeerRequest);\n        let check_peer = extra_msg.mut_check_gc_peer();\n        check_peer.set_from_region_id(region_id);\n        check_peer.set_check_region_id(region_id);\n        check_peer.set_check_peer(to_peer.clone());\n        check_peer.set_check_region_epoch(epoch);\n\n        cluster.sim.wl().send_raft_msg(msg.clone()).unwrap();\n        let Ok(gc_resp) = rx.recv_timeout(timeout) else {\n            return false;\n        };\n        assert_eq!(gc_resp.get_region_id(), region_id);\n        assert_eq!(*gc_resp.get_from_peer(), to_peer);\n        true\n    };\n\n    // Mock gc a peer that has been removed before creation.\n    assert!(check_gc_peer(\n        new_learner_peer(2, 5),\n        Duration::from_secs(5)\n    ));\n\n    cluster\n        .pd_client\n        .must_add_peer(region_id, new_learner_peer(2, 4));\n    // Make sure learner is created.\n    cluster.wait_peer_state(region_id, 2, PeerState::Normal);\n\n    cluster\n        .pd_client\n        .must_remove_peer(region_id, new_learner_peer(2, 4));\n    // Make sure learner is removed.\n    cluster.wait_peer_state(region_id, 2, PeerState::Tombstone);\n\n    // Mock gc peer request. GC learner(2, 4).\n    let start = Instant::now();\n    loop {\n        if check_gc_peer(new_learner_peer(2, 4), Duration::from_millis(200)) {\n            return;\n        }\n        if start.saturating_elapsed() > Duration::from_secs(5) {\n            break;\n        }\n    }\n    assert!(check_gc_peer(\n        new_learner_peer(2, 4),\n        Duration::from_millis(200)\n    ));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_printenv.rs::test_ignore_equal_var", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "test": "fn test_ignore_equal_var() {\n    let scene = TestScenario::new(util_name!());\n    // tested by gnu/tests/misc/printenv.sh\n    let result = scene.ucmd().env(\"a=b\", \"c\").arg(\"a=b\").fails();\n\n    assert!(result.stdout_str().is_empty());\n}"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_ltc", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "test": "fn test_skip_iter_ltc() {\n    // Test iterators that skip multiple, leading or trailing digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_leading_digit_separator(true)\n        .integer_trailing_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"4_5.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"4__5.56\");\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pinky.rs::test_capitalize", "code": "fn capitalize(&self) -> String {\n        self.char_indices()\n            .fold(String::with_capacity(self.len()), |mut acc, x| {\n                if x.0 == 0 {\n                    acc.push(x.1.to_ascii_uppercase());\n                } else {\n                    acc.push(x.1);\n                }\n                acc\n            })\n    }", "test": "fn test_capitalize() {\n    assert_eq!(\"Zbnmasd\", \"zbnmasd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"Abnmasd\", \"Abnmasd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"1masd\", \"1masd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"\", \"\".capitalize());\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::get_set_funcref_globals_via_api", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "test": "fn get_set_funcref_globals_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let f = Func::wrap(&mut store, || {});\n\n    // Initialize with a null funcref.\n\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::FuncRef, Mutability::Var),\n        Val::FuncRef(None),\n    )?;\n    assert!(global.get(&mut store).unwrap_funcref().is_none());\n\n    global.set(&mut store, Val::FuncRef(Some(f.clone())))?;\n    let f2 = global.get(&mut store).unwrap_funcref().cloned().unwrap();\n    assert_eq!(f.ty(&store), f2.ty(&store));\n\n    // Initialize with a non-null funcref.\n\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::FuncRef, Mutability::Var),\n        Val::FuncRef(Some(f.clone())),\n    )?;\n    let f2 = global.get(&mut store).unwrap_funcref().cloned().unwrap();\n    assert_eq!(f.ty(&store), f2.ty(&store));\n\n    Ok(())\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/arithmetic_ast.rs::expr_test", "code": "pub fn map<I, O1, O2, E, F, G>(mut parser: F, mut f: G) -> impl FnMut(I) -> IResult<I, O2, E>\nwhere\n  F: Parser<I, O1, E>,\n  G: FnMut(O1) -> O2,\n{\n  move |input: I| {\n    let (input, o1) = parser.parse(input)?;\n    Ok((input, f(o1)))\n  }\n}", "test": "fn expr_test() {\n  assert_eq!(\n    expr(\" 1 + 2 *  3 \").map(|(i, x)| (i, format!(\"{:?}\", x))),\n    Ok((\"\", String::from(\"(1 + (2 * 3))\")))\n  );\n  assert_eq!(\n    expr(\" 1 + 2 *  3 / 4 - 5 \").map(|(i, x)| (i, format!(\"{:?}\", x))),\n    Ok((\"\", String::from(\"((1 + ((2 * 3) / 4)) - 5)\")))\n  );\n  assert_eq!(\n    expr(\" 72 / 2 / 3 \").map(|(i, x)| (i, format!(\"{:?}\", x))),\n    Ok((\"\", String::from(\"((72 / 2) / 3)\")))\n  );\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_through_host", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "test": "fn test_trap_through_host() -> Result<()> {\n    let wat = r#\"\n        (module $hello_mod\n            (import \"\" \"\" (func $host_func_a))\n            (import \"\" \"\" (func $host_func_b))\n            (func $a (export \"a\")\n                call $host_func_a\n            )\n            (func $b (export \"b\")\n                call $host_func_b\n            )\n            (func $c (export \"c\")\n                unreachable\n            )\n        )\n    \"#;\n\n    let engine = Engine::default();\n    let module = Module::new(&engine, wat)?;\n    let mut store = Store::<()>::new(&engine, ());\n\n    let host_func_a = Func::new(\n        &mut store,\n        FuncType::new(vec![], vec![]),\n        |mut caller, _args, _results| {\n            caller\n                .get_export(\"b\")\n                .unwrap()\n                .into_func()\n                .unwrap()\n                .call(caller, &[], &mut [])?;\n            Ok(())\n        },\n    );\n    let host_func_b = Func::new(\n        &mut store,\n        FuncType::new(vec![], vec![]),\n        |mut caller, _args, _results| {\n            caller\n                .get_export(\"c\")\n                .unwrap()\n                .into_func()\n                .unwrap()\n                .call(caller, &[], &mut [])?;\n            Ok(())\n        },\n    );\n\n    let instance = Instance::new(\n        &mut store,\n        &module,\n        &[host_func_a.into(), host_func_b.into()],\n    )?;\n    let a = instance.get_typed_func::<(), ()>(&mut store, \"a\")?;\n    let err = a.call(&mut store, ()).unwrap_err();\n    let trace = err.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert_eq!(trace.len(), 3);\n    assert_eq!(trace[0].func_name(), Some(\"c\"));\n    assert_eq!(trace[1].func_name(), Some(\"b\"));\n    assert_eq!(trace[2].func_name(), Some(\"a\"));\n    Ok(())\n}"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/escaped.rs::test_escaped", "code": "fn esc(s: &str) -> IResult<&str, &str, (&str, ErrorKind)> {\n  escaped(digit1, '\\\\', one_of(\"\\\"n\\\\\"))(s)\n}", "test": "fn test_escaped() {\n  assert_eq!(esc(\"abcd\"), Err(Err::Error((\"abcd\", ErrorKind::Escaped))));\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_initial_memory_limits_exceeded", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "test": "fn test_initial_memory_limits_exceeded() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(&engine, r#\"(module (memory (export \"m\") 11))\"#)?;\n\n    let mut store = Store::new(\n        &engine,\n        StoreLimitsBuilder::new()\n            .memory_size(10 * WASM_PAGE_SIZE)\n            .build(),\n    );\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    match Instance::new(&mut store, &module, &[]) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"memory minimum size of 11 pages exceeds memory limits\"\n        ),\n    }\n\n    match Memory::new(&mut store, MemoryType::new(25, None)) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"memory minimum size of 25 pages exceeds memory limits\"\n        ),\n    }\n\n    Ok(())\n}"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_closes_uncleanly", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "test": "fn client_closes_uncleanly() {\n    let kt = KeyType::Rsa;\n    let server_config = Arc::new(make_server_config(kt));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n        do_handshake(&mut client, &mut server);\n\n        // check that unclean EOF reporting does not overtake appdata\n        assert_eq!(\n            12,\n            server\n                .writer()\n                .write(b\"from-server!\")\n                .unwrap()\n        );\n        assert_eq!(\n            12,\n            client\n                .writer()\n                .write(b\"from-client!\")\n                .unwrap()\n        );\n\n        transfer(&mut client, &mut server);\n        transfer_eof(&mut server);\n        let io_state = server.process_new_packets().unwrap();\n        assert!(!io_state.peer_has_closed());\n        check_read(&mut server.reader(), b\"from-client!\");\n\n        check_read_err(\n            &mut server.reader() as &mut dyn io::Read,\n            io::ErrorKind::UnexpectedEof,\n        );\n\n        // may still transmit pending frames\n        transfer(&mut server, &mut client);\n        client.process_new_packets().unwrap();\n        check_read(&mut client.reader(), b\"from-server!\");\n    }\n}"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/nested.rs::thread_options_through_inner", "code": "pub fn to_str<'a, T: 'a>(&self, store: impl Into<StoreContext<'a, T>>) -> Result<Cow<'a, str>> {\n        let store = store.into().0;\n        let memory = self.options.memory(store);\n        self.to_str_from_memory(memory)\n    }", "test": "fn thread_options_through_inner() -> Result<()> {\n    let component = format!(\n        r#\"\n(component\n  (import \"hostfn\" (func $host (param \"a\" u32) (result string)))\n\n  (component $c\n    (import \"hostfn\" (func $host (param \"a\" u32) (result string)))\n\n    (core module $libc\n        (memory (export \"memory\") 1)\n        {REALLOC_AND_FREE}\n    )\n    (core instance $libc (instantiate $libc))\n\n    (core func $host_lower\n        (canon lower\n            (func $host)\n            (memory $libc \"memory\")\n            (realloc (func $libc \"realloc\"))\n        )\n    )\n\n    (core module $m\n        (import \"\" \"host\" (func $host (param i32 i32)))\n        (import \"libc\" \"memory\" (memory 1))\n        (func (export \"run\") (param i32) (result i32)\n            i32.const 42\n            i32.const 100\n            call $host\n            i32.const 100\n        )\n        (export \"memory\" (memory 0))\n    )\n    (core instance $m (instantiate $m\n        (with \"\" (instance (export \"host\" (func $host_lower))))\n        (with \"libc\" (instance $libc))\n    ))\n\n    (func (export \"run\") (param \"a\" u32) (result string)\n        (canon lift\n            (core func $m \"run\")\n            (memory $m \"memory\")\n        )\n    )\n  )\n  (instance $c (instantiate $c (with \"hostfn\" (func $host))))\n  (export \"run\" (func $c \"run\"))\n)\n    \"#\n    );\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, 0);\n    let mut linker = Linker::new(&engine);\n    linker\n        .root()\n        .func_wrap(\"hostfn\", |_, (param,): (u32,)| Ok((param.to_string(),)))?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    let result = instance\n        .get_typed_func::<(u32,), (WasmStr,)>(&mut store, \"run\")?\n        .call(&mut store, (43,))?\n        .0;\n    assert_eq!(result.to_str(&store)?, \"42\");\n    Ok(())\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_file_into_file_with_target_arg", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_mv_move_file_into_file_with_target_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"test_mv_move_file_into_file_with_target_arg_file1\";\n    let file2 = \"test_mv_move_file_into_file_with_target_arg_file2\";\n\n    at.touch(file1);\n    at.touch(file2);\n\n    ucmd.arg(\"--target\")\n        .arg(file1)\n        .arg(file2)\n        .fails()\n        .stderr_is(format!(\"mv: target directory '{file1}': Not a directory\\n\"));\n\n    assert!(at.file_exists(file1));\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_dir_dot", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_dir_dot() {\n    // To match tests/install/d-slashdot.sh\n    let scene = TestScenario::new(util_name!());\n\n    scene.ucmd().arg(\"-d\").arg(\"dir1/.\").succeeds();\n    scene.ucmd().arg(\"-d\").arg(\"dir2/..\").succeeds();\n    // Tests that we don't have dir3/. in the output\n    // but only 'dir3'\n    scene\n        .ucmd()\n        .arg(\"-d\")\n        .arg(\"dir3/.\")\n        .arg(\"-v\")\n        .succeeds()\n        .stdout_contains(\"creating directory 'dir3'\");\n    scene\n        .ucmd()\n        .arg(\"-d\")\n        .arg(\"dir4/./cal\")\n        .arg(\"-v\")\n        .succeeds()\n        .stdout_contains(\"creating directory 'dir4/./cal'\");\n    scene\n        .ucmd()\n        .arg(\"-d\")\n        .arg(\"dir5/./cali/.\")\n        .arg(\"-v\")\n        .succeeds()\n        .stdout_contains(\"creating directory 'dir5/cali'\");\n\n    let at = &scene.fixtures;\n\n    assert!(at.dir_exists(\"dir1\"));\n    assert!(at.dir_exists(\"dir2\"));\n    assert!(at.dir_exists(\"dir3\"));\n    assert!(at.dir_exists(\"dir4/cal\"));\n    assert!(at.dir_exists(\"dir5/cali\"));\n}"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/store_file_tests.rs::test_ttl_wilcard", "code": "pub fn ttl(&self) -> u32 {\n        self.ttl\n    }", "test": "async fn test_ttl_wilcard() {\n    let config = FileConfig {\n        zone_file_path: \"../../tests/test-data/test_configs/default/test.local.zone\".to_string(),\n    };\n\n    let zone_name = LowerName::from_str(\"test.local.\").unwrap();\n    let mut authority = FileAuthority::try_from_config(\n        Name::from(zone_name.clone()),\n        ZoneType::Primary,\n        false,\n        None,\n        &config,\n    )\n    .unwrap();\n\n    // This one pass.\n    let rrkey = RrKey {\n        record_type: RecordType::A,\n        name: LowerName::from(Name::from_ascii(\"simple.test.local.\").unwrap()),\n    };\n    assert_eq!(authority.records_get_mut().get(&rrkey).unwrap().ttl(), 120);\n    // // This one related to a wildcard don't pass arround $TTL\n    let name = LowerName::from(Name::from_ascii(\"x.wc.test.local.\").unwrap());\n    let rr = authority\n        .lookup(&name, RecordType::A, LookupOptions::default())\n        .await\n        .unwrap();\n    let data = rr\n        .into_iter()\n        .next()\n        .expect(\"A record not found in authority\");\n\n    assert_eq!(data.record_type(), RecordType::A);\n    assert_eq!(data.ttl(), 120);\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_none", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "test": "fn test_cp_backup_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=none\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert!(!at.file_exists(format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")));\n}"}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_allocation_chains", "code": "pub fn map(&self) -> JsObject {\n        self.map.clone()\n    }", "test": "fn eph_allocation_chains() {\n    run_test(|| {\n        let gc_value = Gc::new(String::from(\"foo\"));\n\n        {\n            let cloned_gc = gc_value.clone();\n            let weak = WeakGc::new(&cloned_gc);\n            let wrap = Gc::new(weak);\n\n            assert_eq!(wrap.upgrade().as_deref().map(String::as_str), Some(\"foo\"));\n\n            let eph = Ephemeron::new(&wrap, 3);\n\n            drop(cloned_gc);\n            force_collect();\n            assert_eq!(wrap.upgrade().as_deref().map(String::as_str), Some(\"foo\"));\n            assert_eq!(eph.value(), Some(3));\n\n            drop(gc_value);\n            force_collect();\n            assert!(wrap.upgrade().is_none());\n            assert_eq!(eph.value(), Some(3));\n\n            drop(wrap);\n            force_collect();\n            assert!(eph.value().is_none());\n        }\n    });\n}"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_numbered_if_existing_backup_nil", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "test": "fn test_install_backup_numbered_if_existing_backup_nil() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n    let file_b_backup = \"test_install_backup_numbering_file_b.~1~\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.touch(file_b_backup);\n    scene\n        .ucmd()\n        .arg(\"--backup=nil\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(file_b_backup));\n    assert!(at.file_exists(format!(\"{file_b}.~2~\")));\n}"}
