fn to_string(lit: Literal) -> String {
    let formatted = lit.to_string();

    let mut it = formatted.chars();
    assert_eq!(it.next(), Some('"'));

    let mut rv = String::new();
    loop {
        match it.next() {
            Some('"') => match it.next() {
                Some(_) => panic!(),
                None => break,
            },
            Some('\\') => match it.next() {
                Some('x') => {
                    let hi = it.next().unwrap().to_digit(16).unwrap();
                    let lo = it.next().unwrap().to_digit(16).unwrap();
                    let v = (hi << 16) | lo;
                    rv.push(v as u8 as char);
                }
                Some('u') => {
                    assert_eq!(it.next(), Some('{'));
                    let mut c = it.next().unwrap();
                    let mut ch = 0;
                    while let Some(v) = c.to_digit(16) {
                        ch *= 16;
                        ch |= v;
                        c = it.next().unwrap();
                    }
                    assert_eq!(c, '}');
                    rv.push(::std::char::from_u32(ch).unwrap());
                }
                Some('0') => rv.push('\0'),
                Some('\\') => rv.push('\\'),
                Some('\"') => rv.push('\"'),
                Some('r') => rv.push('\r'),
                Some('n') => rv.push('\n'),
                Some('t') => rv.push('\t'),
                Some(_) => panic!(),
                None => panic!(),
            },
            Some(c) => rv.push(c),
            None => panic!(),
        }
    }

    rv
}
fn copy_wrong() {
    let mut store = Store::<()>::default();
    let ty = TableType::new(ValType::FuncRef, 1, None);
    let table1 = Table::new(&mut store, ty, Val::FuncRef(None)).unwrap();
    let ty = TableType::new(ValType::ExternRef, 1, None);
    let table2 = Table::new(&mut store, ty, Val::ExternRef(None)).unwrap();
    assert_eq!(
        Table::copy(&mut store, &table1, 0, &table2, 0, 1)
            .map_err(|e| e.to_string())
            .unwrap_err(),
        "tables do not have the same element type"
    );
}