fn is_nan(self) -> bool {
        self.is_special() && (self.to_bits() & Self::MANTISSA_MASK) != Self::Unsigned::ZERO
    }
fn special_bytes_test() {
    const FORMAT: u128 = STANDARD;

    // Test serializing and deserializing special strings.
    assert!(f32::from_lexical(b"NaN").unwrap().is_nan());
    assert!(f32::from_lexical(b"nan").unwrap().is_nan());
    assert!(f32::from_lexical(b"NAN").unwrap().is_nan());
    assert!(f32::from_lexical(b"inf").unwrap().is_infinite());
    assert!(f32::from_lexical(b"INF").unwrap().is_infinite());
    assert!(f32::from_lexical(b"Infinity").unwrap().is_infinite());

    let options =
        Options::builder().nan_string(Some(b"nan")).inf_string(Some(b"Infinity")).build().unwrap();

    // The error message depends on whether the radix feature is enabled.
    assert!(f32::from_lexical_with_options::<FORMAT>(b"inf", &options).is_err());
    assert!(f32::from_lexical_with_options::<FORMAT>(b"Infinity", &options).unwrap().is_infinite());
}