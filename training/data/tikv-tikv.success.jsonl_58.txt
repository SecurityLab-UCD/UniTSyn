pub fn is_none(&self) -> bool {
        !self.is_some()
    }
fn test_put_delete() {
    let mut cluster = Cluster::default();
    let router = &mut cluster.routers[0];
    let header = Box::new(router.new_request_for(2).take_header());
    let mut put = SimpleWriteEncoder::with_capacity(64);
    put.put(CF_DEFAULT, b"key", b"value");

    router.wait_applied_to_current_term(2, Duration::from_secs(3));

    let snap = router.stale_snapshot(2);
    assert!(snap.get_value(b"key").unwrap().is_none());
    let (msg, mut sub) = PeerMsg::simple_write(header.clone(), put.encode());
    router.send(2, msg).unwrap();
    assert!(block_on(sub.wait_proposed()));
    assert!(block_on(sub.wait_committed()));
    let resp = block_on(sub.result()).unwrap();
    assert!(!resp.get_header().has_error(), "{:?}", resp);
    let snap = router.stale_snapshot(2);
    assert_eq!(snap.get_value(b"key").unwrap().unwrap(), b"value");

    let mut delete = SimpleWriteEncoder::with_capacity(64);
    delete.delete(CF_DEFAULT, b"key");
    let (msg, mut sub) = PeerMsg::simple_write(header, delete.encode());
    router.send(2, msg).unwrap();
    assert!(block_on(sub.wait_proposed()));
    assert!(block_on(sub.wait_committed()));
    let resp = block_on(sub.result()).unwrap();
    assert!(!resp.get_header().has_error(), "{:?}", resp);
    let snap = router.stale_snapshot(2);
    assert_matches!(snap.get_value(b"key"), Ok(None));

    // Check if WAL is skipped for basic writes.
    let mut cached = cluster.node(0).tablet_registry().get(2).unwrap();
    check_skip_wal(cached.latest().unwrap().as_inner().path());
}