fn clone(&self) -> Self {
        let refs = self.refs.fetch_add(1, atomic::Ordering::SeqCst);

        trace!(
            "Storage referenced"; "original_ref" => refs
        );

        Self {
            engine: self.engine.clone(),
            sched: self.sched.clone(),
            read_pool: self.read_pool.clone(),
            refs: self.refs.clone(),
            max_key_size: self.max_key_size,
            concurrency_manager: self.concurrency_manager.clone(),
            api_version: self.api_version,
            causal_ts_provider: self.causal_ts_provider.clone(),
            resource_tag_factory: self.resource_tag_factory.clone(),
            quota_limiter: self.quota_limiter.clone(),
            _phantom: PhantomData,
        }
    }
fn test_raft_storage() {
    let (_cluster, storage, mut ctx) = new_raft_storage();
    let key = Key::from_raw(b"key");
    assert_eq!(storage.get(ctx.clone(), &key, 5).unwrap().0, None);
    storage
        .prewrite(
            ctx.clone(),
            vec![Mutation::make_put(key.clone(), b"value".to_vec())],
            b"key".to_vec(),
            10,
        )
        .unwrap();
    storage
        .commit(ctx.clone(), vec![key.clone()], 10, 15)
        .unwrap();
    assert_eq!(
        storage.get(ctx.clone(), &key, 20).unwrap().0.unwrap(),
        b"value".to_vec()
    );

    // Test wrong region id.
    let region_id = ctx.get_region_id();
    ctx.set_region_id(region_id + 1);
    storage.get(ctx.clone(), &key, 20).unwrap_err();
    storage
        .batch_get(ctx.clone(), &[key.clone()], 20)
        .unwrap_err();
    storage
        .scan(ctx.clone(), key, None, 1, false, 20)
        .unwrap_err();
    storage.scan_locks(ctx, 20, None, None, 100).unwrap_err();
}