pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {
        self.get_impl(CF_DEFAULT, key, true)
    }
fn test_select_failed() {
    let mut cluster = test_raftstore::new_server_cluster(0, 3);
    cluster.cfg.raft_store.check_leader_lease_interval = ReadableDuration::hours(10);
    cluster.run();
    // make sure leader has been elected.
    assert_eq!(cluster.must_get(b""), None);
    let region = cluster.get_region(b"");
    let leader = cluster.leader_of_region(region.get_id()).unwrap();
    let engine = cluster.sim.rl().storages[&leader.get_id()].clone();
    let mut ctx = Context::default();
    ctx.set_region_id(region.get_id());
    ctx.set_region_epoch(region.get_region_epoch().clone());
    ctx.set_peer(leader);

    let product = ProductTable::new();
    let (_, endpoint, _) =
        init_data_with_engine_and_commit(ctx.clone(), engine, &product, &[], true);

    // Sleep until the leader lease is expired.
    thread::sleep(
        cluster.cfg.raft_store.raft_heartbeat_interval()
            * cluster.cfg.raft_store.raft_election_timeout_ticks as u32
            * 2,
    );
    for id in 1..=3 {
        if id != ctx.get_peer().get_store_id() {
            cluster.stop_node(id);
        }
    }
    let req = DagSelect::from(&product).build_with(ctx.clone(), &[0]);
    let f = endpoint.parse_and_handle_unary_request(req, None);
    cluster.stop_node(ctx.get_peer().get_store_id());
    drop(cluster);
    let _ = futures::executor::block_on(f);
}