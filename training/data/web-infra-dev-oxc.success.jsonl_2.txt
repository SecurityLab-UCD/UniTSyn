pub fn join(self, rhs: Self) -> Self {
        let must_return = self.must_return() && rhs.must_return();
        let explicit = self.may_return_explicit() || rhs.may_return_explicit();
        let implicit = self.may_return_implicit() || rhs.may_return_implicit();

        Self::create(must_return, explicit, implicit)
    }
fn crypto_js() {
    let f = super::fixture();

    let resolver = Resolver::new(ResolveOptions {
        alias_fields: vec![vec!["browser".into()]],
        fallback: vec![(
            "crypto".into(),
            vec![AliasValue::Path(f.join("lib.js").to_string_lossy().to_string())],
        )],
        ..ResolveOptions::default()
    });

    let resolved_path = resolver.resolve(f.join("crypto-js"), "crypto").map(|r| r.full_path());
    assert_eq!(resolved_path, Err(ResolveError::Ignored(f.join("crypto-js"))));
}