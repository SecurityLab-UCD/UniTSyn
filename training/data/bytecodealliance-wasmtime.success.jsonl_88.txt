pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {
        self.root
            .expand()
            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))
            .is_some()
    }
fn test_trap_return_downcast() -> Result<()> {
    let mut store = Store::<()>::default();
    let wat = r#"
        (module
        (func $hello (import "" "hello"))
        (func (export "run") (call $hello))
        )
    "#;

    #[derive(Debug)]
    struct MyTrap;
    impl std::fmt::Display for MyTrap {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "my trap")
        }
    }
    impl std::error::Error for MyTrap {}

    let module = Module::new(store.engine(), wat)?;
    let hello_type = FuncType::new(None, None);
    let hello_func = Func::new(&mut store, hello_type, |_, _, _| {
        Err(anyhow::Error::from(MyTrap))
    });

    let instance = Instance::new(&mut store, &module, &[hello_func.into()])?;
    let run_func = instance.get_typed_func::<(), ()>(&mut store, "run")?;

    let e = run_func
        .call(&mut store, ())
        .err()
        .expect("error calling function");
    let dbg = format!("{:?}", e);
    println!("{}", dbg);

    assert!(!e.to_string().contains("my trap"));
    assert!(dbg.contains("Caused by:\n    my trap"));

    e.downcast_ref::<MyTrap>()
        .expect("error downcasts to MyTrap");
    let bt = e
        .downcast_ref::<WasmBacktrace>()
        .expect("error downcasts to WasmBacktrace");
    assert_eq!(bt.frames().len(), 1);
    println!("{:?}", bt);

    Ok(())
}