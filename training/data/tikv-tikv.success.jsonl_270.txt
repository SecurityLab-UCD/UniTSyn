pub fn load(&self, ctx: TabletContext, create: bool) -> Result<CachedTablet<EK>>
    where
        EK: Clone,
    {
        assert!(ctx.suffix.is_some());
        let id = ctx.id;
        let path = self.tablet_path(id, ctx.suffix.unwrap());
        if !create && !self.tablets.factory.exists(&path) {
            return Err(Error::Other(box_err!(
                "tablet ({}, {:?}) doesn't exist",
                id,
                ctx.suffix
            )));
        }
        // TODO: use compaction filter to trim range.
        let tablet = self.tablets.factory.open_tablet(ctx, &path)?;
        let mut cached = self.get_or_default(id);
        cached.set(tablet);
        Ok(cached)
    }
fn test_batch_size_edge_limit() {
    let msg_count = Arc::new(AtomicUsize::new(0));
    let batch_msg_count = Arc::new(AtomicUsize::new(0));
    let service = MockKvForRaft::new(Arc::clone(&msg_count), Arc::clone(&batch_msg_count), true);
    let (mock_server, port) = create_mock_server(service, 60200, 60300).unwrap();

    let mut raft_client = get_raft_client_by_port(port);

    // Put them in buffer so sibling messages will be likely be batched during
    // sending.
    let mut msgs = Vec::with_capacity(5);
    for _ in 0..5 {
        let mut raft_m = RaftMessage::default();
        // Magic number, this can make estimated size about 4940000, hence two messages
        // will be batched together, but the total size will be way larger than
        // 10MiB as there are many indexes and terms.
        for _ in 0..38000 {
            let mut e = Entry::default();
            e.set_term(1);
            e.set_index(256);
            e.set_data(vec![b'a'; 130].into());
            raft_m.mut_message().mut_entries().push(e);
        }
        msgs.push(raft_m);
    }
    for m in msgs {
        raft_client.send(m).unwrap();
    }
    raft_client.flush();

    check_msg_count(10000, &msg_count, 5);
    // The final received message count should be 5 exactly.
    drop(raft_client);
    drop(mock_server);
    assert_eq!(msg_count.load(Ordering::SeqCst), 5);
}