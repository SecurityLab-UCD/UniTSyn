pub fn call(mut self) -> Self {
        self.is_call = true;
        self
    }
fn div_plus_load_reported_right() -> Result<()> {
    let engine = Engine::default();
    let mut store = Store::new(&engine, ());
    let module = Module::new(
        &engine,
        r#"
            (module
                (memory (export "memory") 1)
                (func (export "i32.div_s") (param i32 i32) (result i32)
                    (i32.div_s (local.get 0) (i32.load (local.get 1))))
                (func (export "i32.div_u") (param i32 i32) (result i32)
                    (i32.div_u (local.get 0) (i32.load (local.get 1))))
                (func (export "i32.rem_s") (param i32 i32) (result i32)
                    (i32.rem_s (local.get 0) (i32.load (local.get 1))))
                (func (export "i32.rem_u") (param i32 i32) (result i32)
                    (i32.rem_u (local.get 0) (i32.load (local.get 1))))
            )
        "#,
    )?;
    let instance = Instance::new(&mut store, &module, &[])?;
    let memory = instance.get_memory(&mut store, "memory").unwrap();
    let i32_div_s = instance.get_typed_func::<(i32, i32), i32>(&mut store, "i32.div_s")?;
    let i32_div_u = instance.get_typed_func::<(u32, u32), u32>(&mut store, "i32.div_u")?;
    let i32_rem_s = instance.get_typed_func::<(i32, i32), i32>(&mut store, "i32.rem_s")?;
    let i32_rem_u = instance.get_typed_func::<(u32, u32), u32>(&mut store, "i32.rem_u")?;

    memory.write(&mut store, 0, &1i32.to_le_bytes()).unwrap();
    memory.write(&mut store, 4, &0i32.to_le_bytes()).unwrap();
    memory.write(&mut store, 8, &(-1i32).to_le_bytes()).unwrap();

    assert_eq!(i32_div_s.call(&mut store, (100, 0))?, 100);
    assert_eq!(i32_div_u.call(&mut store, (101, 0))?, 101);
    assert_eq!(i32_rem_s.call(&mut store, (102, 0))?, 0);
    assert_eq!(i32_rem_u.call(&mut store, (103, 0))?, 0);

    assert_trap(
        i32_div_s.call(&mut store, (100, 4)),
        Trap::IntegerDivisionByZero,
    );
    assert_trap(
        i32_div_u.call(&mut store, (100, 4)),
        Trap::IntegerDivisionByZero,
    );
    assert_trap(
        i32_rem_s.call(&mut store, (100, 4)),
        Trap::IntegerDivisionByZero,
    );
    assert_trap(
        i32_rem_u.call(&mut store, (100, 4)),
        Trap::IntegerDivisionByZero,
    );

    assert_trap(
        i32_div_s.call(&mut store, (i32::MIN, 8)),
        Trap::IntegerOverflow,
    );
    assert_eq!(i32_rem_s.call(&mut store, (i32::MIN, 8))?, 0);

    assert_trap(
        i32_div_s.call(&mut store, (100, 100_000)),
        Trap::MemoryOutOfBounds,
    );
    assert_trap(
        i32_div_u.call(&mut store, (100, 100_000)),
        Trap::MemoryOutOfBounds,
    );
    assert_trap(
        i32_rem_s.call(&mut store, (100, 100_000)),
        Trap::MemoryOutOfBounds,
    );
    assert_trap(
        i32_rem_u.call(&mut store, (100, 100_000)),
        Trap::MemoryOutOfBounds,
    );

    return Ok(());

    #[track_caller]
    fn assert_trap<T>(result: Result<T>, expected: Trap) {
        match result {
            Ok(_) => panic!("expected failure"),
            Err(e) => {
                if let Some(code) = e.downcast_ref::<Trap>() {
                    if *code == expected {
                        return;
                    }
                }
                panic!("unexpected error {e:?}");
            }
        }
    }
}