pub fn len(&self) -> usize {
        self.events.len()
    }
fn test_witness_leader_ignore_gen_snapshot() {
    let mut cluster = new_server_cluster(0, 3);
    cluster.cfg.raft_store.raft_log_gc_count_limit = Some(100);
    configure_for_snapshot(&mut cluster.cfg);
    cluster.run();
    let nodes = Vec::from_iter(cluster.get_node_ids());
    assert_eq!(nodes.len(), 3);

    let pd_client = Arc::clone(&cluster.pd_client);
    pd_client.disable_default_operator();

    cluster.must_put(b"k0", b"v0");

    let region = block_on(pd_client.get_region_by_id(1)).unwrap().unwrap();
    let peer_on_store1 = find_peer(&region, nodes[0]).unwrap().clone();
    cluster.must_transfer_leader(region.get_id(), peer_on_store1.clone());

    // the other follower is isolated
    cluster.add_send_filter(IsolationFilterFactory::new(3));

    // make sure raft log gc is triggered
    std::thread::sleep(Duration::from_millis(200));
    let mut before_states = HashMap::default();
    for (&id, engines) in &cluster.engines {
        let mut state: RaftApplyState = get_raft_msg_or_default(engines, &keys::apply_state_key(1));
        before_states.insert(id, state.take_truncated_state());
    }

    // write some data to make log gap exceeds the gc limit
    for i in 1..1000 {
        let (k, v) = (format!("k{}", i), format!("v{}", i));
        let key = k.as_bytes();
        let value = v.as_bytes();
        cluster.must_put(key, value);
    }

    std::thread::sleep(Duration::from_millis(200));

    // the truncated index is advanced
    for (&id, engines) in &cluster.engines {
        let state: RaftApplyState = get_raft_msg_or_default(engines, &keys::apply_state_key(1));
        let diff = state.get_truncated_state().get_index() - before_states[&id].get_index();
        error!("EEEEE";
            "id" => &id,
            "diff" => diff,
            "state.get_truncated_state().get_index()" => state.get_truncated_state().get_index(),
            "before_states[&id].get_index()" => before_states[&id].get_index()
        );
        assert_ne!(
            900,
            state.get_truncated_state().get_index() - before_states[&id].get_index()
        );
    }

    // ingore raft log gc to avoid canceling snapshots
    fail::cfg("on_raft_gc_log_tick", "return").unwrap();
    // wait for leader applied switch to witness
    fail::cfg("before_region_gen_snap", "pause").unwrap();
    fail::cfg("ignore_snap_try_cnt", "return").unwrap();
    // After the snapshot is generated, it will be checked as invalidated and will
    // not be regenerated (handle_snapshot will not generate a snapshot for
    // witness)
    cluster.clear_send_filters();
    std::thread::sleep(Duration::from_millis(500));

    // non-witness -> witness
    fail::cfg("ignore_forbid_leader_to_be_witness", "return").unwrap();
    cluster.pd_client.must_switch_witnesses(
        region.get_id(),
        vec![peer_on_store1.get_id()],
        vec![true],
    );
    fail::remove("before_region_gen_snap");

    std::thread::sleep(Duration::from_millis(500));

    // forbid writes
    let put = new_put_cmd(b"k3", b"v3");
    must_get_error_is_witness(&mut cluster, &region, put);
    // forbid reads
    let get = new_get_cmd(b"k1");
    must_get_error_is_witness(&mut cluster, &region, get);
    // forbid read index
    let read_index = new_read_index_cmd();
    must_get_error_is_witness(&mut cluster, &region, read_index);

    // reject to transfer, as can't send snapshot to peer_on_store3, there's a log
    // gap
    let peer_on_store3 = find_peer(&region, nodes[2]).unwrap().clone();
    let _ = cluster.try_transfer_leader(region.get_id(), peer_on_store3);
    std::thread::sleep(Duration::from_secs(5));
    assert_eq!(cluster.leader_of_region(1).unwrap(), peer_on_store1);

    // should be enable to transfer leader to peer_on_store2
    let peer_on_store2 = find_peer(&region, nodes[1]).unwrap().clone();
    cluster.must_transfer_leader(1, peer_on_store2);
    cluster.must_put(b"k1", b"v1");
    assert_eq!(
        cluster.leader_of_region(region.get_id()).unwrap().store_id,
        nodes[1],
    );
    assert_eq!(cluster.must_get(b"k9"), Some(b"v9".to_vec()));

    fail::remove("on_raft_gc_log_tick");
    fail::remove("ignore_snap_try_cnt");
    fail::remove("ignore_forbid_leader_to_be_witness");
}