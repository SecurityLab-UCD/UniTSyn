pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {
        self.root
            .expand()
            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))
            .is_some()
    }
fn wasm_fault_address_reported_by_default() -> Result<()> {
    let engine = Engine::default();
    let mut store = Store::new(&engine, ());
    let module = Module::new(
        &engine,
        r#"
            (module
                (memory 1)
                (func $start
                    i32.const 0xdeadbeef
                    i32.load
                    drop)
                (start $start)
            )
        "#,
    )?;
    let err = Instance::new(&mut store, &module, &[]).unwrap_err();

    // NB: at this time there's no programmatic access to the fault address
    // because it's not always available for load/store traps. Only static
    // memories on 32-bit have this information, but bounds-checked memories
    // use manual trapping instructions and otherwise don't have a means of
    // communicating the faulting address at this time.
    //
    // It looks like the exact reported fault address may not be deterministic,
    // so assert that we have the right error message, but not the exact address.
    let err = format!("{err:?}");
    assert!(
        err.contains("memory fault at wasm address ")
            && err.contains(" in linear memory of size 0x10000"),
        "bad error: {err}"
    );
    Ok(())
}