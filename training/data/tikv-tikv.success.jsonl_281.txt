pub fn must_get(&mut self, key: &[u8]) -> Option<Vec<u8>> {
        self.get_impl(CF_DEFAULT, key, true)
    }
fn test_read_on_replica_check_memory_locks() {
    let count = 3;
    let mut cluster = new_server_cluster(0, count);
    cluster.cfg.raft_store.hibernate_regions = false;
    cluster.run();

    let raw_key = b"key";
    let encoded_key = Key::from_raw(raw_key);

    // make sure leader has been elected.
    assert_eq!(cluster.must_get(raw_key), None);

    let region = cluster.get_region(b"");
    let leader = cluster.leader_of_region(region.get_id()).unwrap();
    let leader_cm = cluster.sim.rl().get_concurrency_manager(leader.get_id());

    let lock = Lock::new(
        LockType::Put,
        raw_key.to_vec(),
        10.into(),
        20000,
        None,
        10.into(),
        1,
        20.into(),
    );
    let guard = block_on(leader_cm.lock_key(&encoded_key));
    guard.with_lock(|l| *l = Some(lock.clone()));

    // read on follower
    let mut follower_peer = None;
    let mut follower_id = 0;
    let peers = region.get_peers();
    for p in peers {
        if p.get_id() != leader.get_id() {
            follower_id = p.get_id();
            follower_peer = Some(p.clone());
            break;
        }
    }

    assert!(follower_peer.is_some());
    let mut follower_ctx = Context::default();
    follower_ctx.set_region_id(region.get_id());
    follower_ctx.set_region_epoch(region.get_region_epoch().clone());
    follower_ctx.set_peer(follower_peer.as_ref().unwrap().clone());
    follower_ctx.set_replica_read(true);
    for use_max_ts in [false, true] {
        let mut range = KeyRange::default();
        range.set_start_key(encoded_key.as_encoded().to_vec());
        let ts = if use_max_ts {
            Some(TimeStamp::max())
        } else {
            Some(100.into())
        };
        let follower_snap_ctx = SnapContext {
            pb_ctx: &follower_ctx,
            start_ts: ts,
            key_ranges: vec![range],
            ..Default::default()
        };
        let mut follower_storage = cluster.sim.rl().storages[&follower_id].clone();
        match follower_storage.snapshot(follower_snap_ctx) {
            Err(Error(box ErrorInner::KeyIsLocked(lock_info))) => {
                assert_eq!(lock_info, lock.clone().into_lock_info(raw_key.to_vec()))
            }
            other => panic!("unexpected result: {:?}", other),
        }
    }
}