fn is_ok(&self) -> bool {
        let count = self.count.fetch_add(1, Ordering::SeqCst);
        if count != 0 && count % self.retry == 0 {
            // it's ok.
            return true;
        }
        // let's sleep awhile, so that client will update its connection.
        thread::sleep(REQUEST_RECONNECT_INTERVAL);
        false
    }
fn test_scheduler_pool_auto_switch_for_resource_ctl() {
    let mut cluster = new_server_cluster(0, 1);
    cluster.run();

    let engine = cluster
        .sim
        .read()
        .unwrap()
        .storages
        .get(&1)
        .unwrap()
        .clone();
    let resource_manager = ResourceGroupManager::default();
    let resource_ctl = resource_manager.derive_controller("test".to_string(), true);

    let storage = TestStorageBuilderApiV1::from_engine_and_lock_mgr(engine, MockLockManager::new())
        .config(cluster.cfg.tikv.storage.clone())
        .build_for_resource_controller(resource_ctl)
        .unwrap();

    let region = cluster.get_region(b"k1");
    let mut ctx = Context::default();
    ctx.set_region_id(region.id);
    ctx.set_region_epoch(region.get_region_epoch().clone());
    ctx.set_peer(cluster.leader_of_region(region.id).unwrap());

    let do_prewrite = |key: &[u8], val: &[u8]| {
        // prewrite
        let (prewrite_tx, prewrite_rx) = channel();
        storage
            .sched_txn_command(
                commands::Prewrite::new(
                    vec![Mutation::make_put(Key::from_raw(key), val.to_vec())],
                    key.to_vec(),
                    10.into(),
                    100,
                    false,
                    2,
                    TimeStamp::default(),
                    TimeStamp::default(),
                    None,
                    false,
                    AssertionLevel::Off,
                    ctx.clone(),
                ),
                Box::new(move |res: storage::Result<_>| {
                    let _ = prewrite_tx.send(res);
                }),
            )
            .unwrap();
        prewrite_rx.recv_timeout(Duration::from_secs(2))
    };

    let (sender, receiver) = channel();
    let priority_queue_sender = Mutex::new(sender.clone());
    let single_queue_sender = Mutex::new(sender);
    fail::cfg_callback("priority_pool_task", move || {
        let sender = priority_queue_sender.lock().unwrap();
        sender.send("priority_queue").unwrap();
    })
    .unwrap();
    fail::cfg_callback("single_queue_pool_task", move || {
        let sender = single_queue_sender.lock().unwrap();
        sender.send("single_queue").unwrap();
    })
    .unwrap();

    // Default is use single queue
    assert_eq!(do_prewrite(b"k1", b"v1").is_ok(), true);
    assert_eq!(
        receiver.recv_timeout(Duration::from_millis(500)).unwrap(),
        "single_queue"
    );

    // Add group use priority queue
    use kvproto::resource_manager::{GroupMode, GroupRequestUnitSettings, ResourceGroup};
    let mut group = ResourceGroup::new();
    group.set_name("rg1".to_string());
    group.set_mode(GroupMode::RuMode);
    let mut ru_setting = GroupRequestUnitSettings::new();
    ru_setting.mut_r_u().mut_settings().set_fill_rate(100000);
    group.set_r_u_settings(ru_setting);
    resource_manager.add_resource_group(group);
    thread::sleep(Duration::from_millis(200));
    assert_eq!(do_prewrite(b"k2", b"v2").is_ok(), true);
    assert_eq!(
        receiver.recv_timeout(Duration::from_millis(500)).unwrap(),
        "priority_queue"
    );

    // Delete group use single queue
    resource_manager.remove_resource_group("rg1");
    thread::sleep(Duration::from_millis(200));
    assert_eq!(do_prewrite(b"k3", b"v3").is_ok(), true);
    assert_eq!(
        receiver.recv_timeout(Duration::from_millis(500)).unwrap(),
        "single_queue"
    );

    // Scale pool size
    let scheduler = storage.get_scheduler();
    let pool = scheduler.get_sched_pool();
    assert_eq!(pool.get_pool_size(CommandPri::Normal), 1);
    pool.scale_pool_size(2);
    assert_eq!(pool.get_pool_size(CommandPri::Normal), 2);
}