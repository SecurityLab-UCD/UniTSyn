fn to_string(lit: Literal) -> String {
    let formatted = lit.to_string();

    let mut it = formatted.chars();
    assert_eq!(it.next(), Some('"'));

    let mut rv = String::new();
    loop {
        match it.next() {
            Some('"') => match it.next() {
                Some(_) => panic!(),
                None => break,
            },
            Some('\\') => match it.next() {
                Some('x') => {
                    let hi = it.next().unwrap().to_digit(16).unwrap();
                    let lo = it.next().unwrap().to_digit(16).unwrap();
                    let v = (hi << 16) | lo;
                    rv.push(v as u8 as char);
                }
                Some('u') => {
                    assert_eq!(it.next(), Some('{'));
                    let mut c = it.next().unwrap();
                    let mut ch = 0;
                    while let Some(v) = c.to_digit(16) {
                        ch *= 16;
                        ch |= v;
                        c = it.next().unwrap();
                    }
                    assert_eq!(c, '}');
                    rv.push(::std::char::from_u32(ch).unwrap());
                }
                Some('0') => rv.push('\0'),
                Some('\\') => rv.push('\\'),
                Some('\"') => rv.push('\"'),
                Some('r') => rv.push('\r'),
                Some('n') => rv.push('\n'),
                Some('t') => rv.push('\t'),
                Some(_) => panic!(),
                None => panic!(),
            },
            Some(c) => rv.push(c),
            None => panic!(),
        }
    }

    rv
}
fn drop_host_twice() -> Result<()> {
    let engine = super::engine();
    let c = Component::new(
        &engine,
        r#"
            (component
                (import "t" (type $t (sub resource)))

                (core func $dtor (canon resource.drop $t))
                (func (export "dtor") (param "x" (own $t))
                    (canon lift (core func $dtor)))
            )
        "#,
    )?;

    struct MyType;

    let mut store = Store::new(&engine, ());
    let mut linker = Linker::new(&engine);
    linker.root().resource::<MyType>("t", |_, _| Ok(()))?;
    let i = linker.instantiate(&mut store, &c)?;
    let dtor = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, "dtor")?;

    let t = Resource::new_own(100);
    dtor.call(&mut store, (&t,))?;
    dtor.post_return(&mut store)?;

    assert_eq!(
        dtor.call(&mut store, (&t,)).unwrap_err().to_string(),
        "host resource already consumed"
    );

    Ok(())
}