fn call(&mut self, req: Request) -> Self::Future {
        use http_body_util::BodyExt;

        let handler = self.clone();

        let (sender, receiver) = tokio::sync::oneshot::channel();

        // TODO: need to track the join handle, but don't want to block the response on it
        tokio::task::spawn(async move {
            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;

            let req = store.data_mut().new_incoming_request(
                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),
            )?;

            let out = store.data_mut().new_response_outparam(sender)?;

            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(
                &mut store,
                &handler.0.instance_pre,
            )
            .await?;

            proxy
                .wasi_http_incoming_handler()
                .call_handle(store, req, out)
                .await?;

            Ok::<_, anyhow::Error>(())
        });

        Box::pin(async move {
            let resp = receiver.await.unwrap()?;
            Ok(resp)
        })
    }
fn backwards_call_works() -> Result<()> {
    let mut store = store_with_padding(128 * MB)?;
    let module = Module::new(
        store.engine(),
        r#"
            (module
                (func (result i32)
                    i32.const 4)
                (func (export "foo") (result i32)
                    call 0)
            )
        "#,
    )?;

    let i = Instance::new(&mut store, &module, &[])?;
    let foo = i.get_typed_func::<(), i32>(&mut store, "foo")?;
    assert_eq!(foo.call(&mut store, ())?, 4);
    Ok(())
}