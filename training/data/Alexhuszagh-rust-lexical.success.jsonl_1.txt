pub fn compute_float32(q: i64, w: u64) -> (i32, u64) {
    let num = Number {
        exponent: q,
        mantissa: w,
        is_negative: false,
        many_digits: false,
        integer: &[],
        fraction: None,
    };
    let fp = bellerophon::<f32, { STANDARD }>(&num, false);
    (fp.exp, fp.mant)
}
fn compute_float_f32_test() {
    // These test near-halfway cases for single-precision floats.
    assert_eq!(compute_float32(0, 16777216), (151, 0));
    assert_eq!(compute_float32(0, 16777217), (111 + INVALID_FP, 9223372586610589696));
    assert_eq!(compute_float32(0, 16777218), (151, 1));
    assert_eq!(compute_float32(0, 16777219), (111 + INVALID_FP, 9223373686122217472));
    assert_eq!(compute_float32(0, 16777220), (151, 2));

    // These are examples of the above tests, with
    // digits from the exponent shifted to the mantissa.
    assert_eq!(compute_float32(-10, 167772160000000000), (151, 0));
    assert_eq!(compute_float32(-10, 167772170000000000), (111 + INVALID_FP, 9223372586610589696));
    assert_eq!(compute_float32(-10, 167772180000000000), (151, 1));
    // Let's check the lines to see if anything is different in table...
    assert_eq!(compute_float32(-10, 167772190000000000), (111 + INVALID_FP, 9223373686122217472));
    assert_eq!(compute_float32(-10, 167772200000000000), (151, 2));
}