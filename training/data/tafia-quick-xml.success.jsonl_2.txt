fn next(&mut self) -> Option<Self::Item> {
        match self.state.next(self.bytes) {
            None => None,
            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),
            Some(Err(e)) => Some(Err(e)),
        }
    }
fn attributes_empty_ns_expanded() {
    let src = "<a att1='a' r:att2='b' xmlns:r='urn:example:r' />";

    let mut r = NsReader::from_str(src);
    r.trim_text(true).expand_empty_elements(true);
    {
        let e = match r.read_resolved_event() {
            Ok((Unbound, Start(e))) => e,
            e => panic!("Expecting Empty event, got {:?}", e),
        };

        let mut attrs = e
            .attributes()
            .map(|ar| ar.expect("Expecting attribute parsing to succeed."))
            // we don't care about xmlns attributes for this test
            .filter(|kv| kv.key.as_namespace_binding().is_none())
            .map(|Attribute { key: name, value }| {
                let (opt_ns, local_name) = r.resolve_attribute(name);
                (opt_ns, local_name.into_inner(), value)
            });
        assert_eq!(
            attrs.next(),
            Some((Unbound, &b"att1"[..], Cow::Borrowed(&b"a"[..])))
        );
        assert_eq!(
            attrs.next(),
            Some((
                Bound(Namespace(b"urn:example:r")),
                &b"att2"[..],
                Cow::Borrowed(&b"b"[..])
            ))
        );
        assert_eq!(attrs.next(), None);
    }

    match r.read_resolved_event() {
        Ok((Unbound, End(e))) => assert_eq!(e.name(), QName(b"a")),
        e => panic!("Expecting End event, got {:?}", e),
    }
}