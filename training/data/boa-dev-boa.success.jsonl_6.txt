pub fn has_value(&self) -> bool {
        // SAFETY: this is safe because `Ephemeron` is tracked to always point to a valid pointer
        // `inner_ptr`.
        unsafe { self.inner_ptr.get().as_ref().value().is_some() }
    }
fn eph_finalizer() {
    #[derive(Clone, Trace)]
    struct S {
        #[unsafe_ignore_trace]
        inner: Rc<Cell<bool>>,
    }

    impl Finalize for S {
        fn finalize(&self) {
            self.inner.set(true);
        }
    }

    run_test(|| {
        let val = S {
            inner: Rc::new(Cell::new(false)),
        };

        let key = Gc::new(50u32);
        let eph = Ephemeron::new(&key, Gc::new(val.clone()));
        assert!(eph.has_value());
        // finalize hasn't been run
        assert!(!val.inner.get());

        drop(key);
        force_collect();
        assert!(!eph.has_value());
        // finalize ran when collecting
        assert!(val.inner.get());
    });
}