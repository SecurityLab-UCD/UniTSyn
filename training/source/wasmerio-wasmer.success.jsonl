{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/compilers/artifact.rs::artifact_deserialization_roundtrip", "test": "fn artifact_deserialization_roundtrip() {\n    // This test is included to make sure we don't break the serialized format\n    // by mistake. Otherwise, everything in this test is already tested in\n    // `artifact_serialization_roundtrip`.\n    let file_names = [\"bash.wasmu\", \"cowsay.wasmu\", \"python-3.11.3.wasmu\"];\n\n    cfg_if!(\n        if #[cfg(target_os = \"windows\")] {\n            let base_path = \"tests/compilers/wasmu/windows\";\n        } else {\n            let base_path = \"tests/compilers/wasmu/linux\";\n        }\n    );\n\n    for file_name in file_names {\n        let path = PathBuf::from(base_path).join(file_name);\n        let wasm_module_bytes = fs::read(path).unwrap();\n        let engine = Engine::default();\n        let module = unsafe { Module::deserialize(&engine, wasm_module_bytes.clone()) }.unwrap();\n        let reserialized_bytes = module.serialize().unwrap();\n        assert_eq!(wasm_module_bytes.to_vec(), reserialized_bytes);\n    }\n}", "code_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/lib/types/src/types.rs::to_vec", "code": "pub fn to_vec(self) -> Vec<u8> {\n        self.0.to_vec()\n    }", "docstring": null}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/config.rs::c_flags", "test": "fn c_flags() {\n    let temp = setup_wasmer_dir();\n    let wasmer_dir = temp.path();\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--bindir\")\n        .assert()\n        .success()\n        .stdout(contains_path(temp.path().join(\"bin\")));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--cflags\")\n        .assert()\n        .success()\n        .stdout(contains(format!(\n            \"-I{}\\n\",\n            wasmer_dir.join(\"include\").display()\n        )));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--includedir\")\n        .assert()\n        .success()\n        .stdout(contains_path(wasmer_dir.join(\"include\")));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--libdir\")\n        .assert()\n        .success()\n        .stdout(contains_path(wasmer_dir.join(\"lib\")));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--libs\")\n        .assert()\n        .stdout(contains(format!(\n            \"-L{} -lwasmer\\n\",\n            wasmer_dir.join(\"lib\").display()\n        )));\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--prefix\")\n        .assert()\n        .success()\n        .stdout(contains_path(wasmer_dir));\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--pkg-config\")\n        .output()\n        .unwrap();\n\n    let pkg_config = vec![\n        format!(\"prefix={}\", wasmer_dir.display()),\n        format!(\"exec_prefix={}\", wasmer_dir.join(\"bin\").display()),\n        format!(\"includedir={}\", wasmer_dir.join(\"include\").display()),\n        format!(\"libdir={}\", wasmer_dir.join(\"lib\").display()),\n        format!(\"\"),\n        format!(\"Name: wasmer\"),\n        format!(\"Description: The Wasmer library for running WebAssembly\"),\n        format!(\"Version: {}\", env!(\"CARGO_PKG_VERSION\")),\n        format!(\"Cflags: -I{}\", wasmer_dir.join(\"include\").display()),\n        format!(\"Libs: -L{} -lwasmer\", wasmer_dir.join(\"lib\").display()),\n    ]\n    .join(\"\\n\");\n\n    assert!(output.status.success());\n    let stderr = std::str::from_utf8(&output.stdout)\n        .unwrap()\n        .replace(\"\\r\\n\", \"\\n\");\n    assert_eq!(stderr.trim(), pkg_config.trim());\n\n    wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"--config-path\")\n        .assert()\n        .success()\n        .stdout(contains_path(temp.path().join(\"wasmer.toml\")));\n}", "code_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/lib/wasix/src/runtime/module_cache/fallback.rs::success", "code": "fn success(&self) -> usize {\n            self.success.load(Ordering::SeqCst)\n        }", "docstring": null}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/gen_c_header.rs::gen_c_header_works", "test": "fn gen_c_header_works() -> anyhow::Result<()> {\n    let temp_dir = tempfile::tempdir()?;\n    let operating_dir: PathBuf = temp_dir.path().to_owned();\n\n    let wasm_path = operating_dir.join(fixtures::qjs());\n    let out_path = temp_dir.path().join(\"header.h\");\n\n    let _ = Command::new(get_wasmer_path())\n        .arg(\"gen-c-header\")\n        .arg(&wasm_path)\n        .arg(\"-o\")\n        .arg(&out_path)\n        .output()\n        .unwrap();\n\n    let file = std::fs::read_to_string(&out_path).expect(\"no header.h file\");\n    assert!(file.contains(\"wasmer_function_6f62a6bc5c8f8e3e12a54e2ecbc5674ccfe1c75f91d8e4dd6ebb3fec422a4d6c_0\"), \"no wasmer_function_6f62a6bc5c8f8e3e12a54e2ecbc5674ccfe1c75f91d8e4dd6ebb3fec422a4d6c_0 in file\");\n\n    let _ = Command::new(get_wasmer_path())\n        .arg(\"gen-c-header\")\n        .arg(&wasm_path)\n        .arg(\"-o\")\n        .arg(&out_path)\n        .arg(\"--prefix\")\n        .arg(\"abc123\")\n        .output()\n        .unwrap();\n\n    let file = std::fs::read_to_string(&out_path).expect(\"no header.h file\");\n    assert!(\n        file.contains(\"wasmer_function_abc123_0\"),\n        \"no wasmer_function_abc123_0 in file\"\n    );\n\n    Ok(())\n}", "code_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/lib/api/src/exports.rs::contains", "code": "pub fn contains<S>(&self, name: S) -> bool\n    where\n        S: Into<String>,\n    {\n        self.map.contains_key(&name.into())\n    }", "docstring": null}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/gen_c_header.rs::gen_c_header_works_pirita", "test": "fn gen_c_header_works_pirita() -> anyhow::Result<()> {\n    let temp_dir = tempfile::tempdir()?;\n    let operating_dir: PathBuf = temp_dir.path().to_owned();\n\n    let wasm_path = operating_dir.join(fixtures::wabt());\n    let out_path = temp_dir.path().join(\"header.h\");\n\n    let _ = Command::new(get_wasmer_path())\n        .arg(\"gen-c-header\")\n        .arg(&wasm_path)\n        .arg(\"-o\")\n        .arg(&out_path)\n        .arg(\"--atom\")\n        .arg(\"wasm-validate\")\n        .output()\n        .unwrap();\n\n    let file = std::fs::read_to_string(&out_path).expect(\"no header.h file\");\n    assert!(file.contains(\"wasmer_function_0f41d38dcfb5abc1fadb5e9acbc5c645e53fe4d0dd86270b72a09bfeee04d055_0\"), \"no wasmer_function_6f62a6bc5c8f8e3e12a54e2ecbc5674ccfe1c75f91d8e4dd6ebb3fec422a4d6c_0 in file\");\n\n    let cmd = Command::new(get_wasmer_path())\n        .arg(\"gen-c-header\")\n        .arg(&wasm_path)\n        .arg(\"-o\")\n        .arg(&out_path)\n        .output()\n        .unwrap();\n\n    assert!(!cmd.status.success());\n\n    Ok(())\n}", "code_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/lib/api/src/exports.rs::contains", "code": "pub fn contains<S>(&self, name: S) -> bool\n    where\n        S: Into<String>,\n    {\n        self.map.contains_key(&name.into())\n    }", "docstring": null}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::test_wasmer_run_works_with_dir", "test": "fn test_wasmer_run_works_with_dir() {\n    let temp_dir = tempfile::TempDir::new().unwrap();\n    let qjs_path = temp_dir.path().join(\"qjs.wasm\");\n\n    std::fs::copy(fixtures::qjs(), &qjs_path).unwrap();\n    std::fs::copy(\n        fixtures::qjs_wasmer_toml(),\n        temp_dir.path().join(\"wasmer.toml\"),\n    )\n    .unwrap();\n\n    assert!(temp_dir.path().exists());\n    assert!(temp_dir.path().join(\"wasmer.toml\").exists());\n    assert!(temp_dir.path().join(\"qjs.wasm\").exists());\n\n    // test with \"wasmer qjs.wasm\"\n    Command::new(get_wasmer_path())\n        .arg(temp_dir.path())\n        .arg(\"--\")\n        .arg(\"--quit\")\n        .assert()\n        .success();\n\n    // test again with \"wasmer run qjs.wasm\"\n    Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(temp_dir.path())\n        .arg(\"--\")\n        .arg(\"--quit\")\n        .assert()\n        .success();\n}", "code_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/lib/api/src/imports.rs::exists", "code": "pub fn exists(&self, module: &str, name: &str) -> bool {\n        self.map\n            .contains_key(&(module.to_string(), name.to_string()))\n    }", "docstring": null}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/run.rs::test_wasmer_run_complex_url", "test": "fn test_wasmer_run_complex_url() {\n    let wasm_test_path = fixtures::qjs();\n    let wasm_test_path = wasm_test_path.canonicalize().unwrap_or(wasm_test_path);\n    let mut wasm_test_path = format!(\"{}\", wasm_test_path.display());\n    if wasm_test_path.starts_with(r#\"\\\\?\\\"#) {\n        wasm_test_path = wasm_test_path.replacen(r#\"\\\\?\\\"#, \"\", 1);\n    }\n    #[cfg(target_os = \"windows\")]\n    {\n        wasm_test_path = wasm_test_path.replace(\"D:\\\\\", \"D://\");\n        wasm_test_path = wasm_test_path.replace(\"C:\\\\\", \"C://\");\n        wasm_test_path = wasm_test_path.replace(\"c:\\\\\", \"c://\");\n        wasm_test_path = wasm_test_path.replace(\"\\\\\", \"/\");\n        // wasmer run used to fail on c:\\Users\\username\\wapm_packages\\ ...\n        assert!(\n            wasm_test_path.contains(\"://\"),\n            \"wasm_test_path path is not complex enough\"\n        );\n    }\n\n    Command::new(get_wasmer_path())\n        .arg(\"run\")\n        .arg(wasm_test_path)\n        .arg(\"--\")\n        .arg(\"-q\")\n        .assert()\n        .success();\n}", "code_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/lib/api/src/exports.rs::contains", "code": "pub fn contains<S>(&self, name: S) -> bool\n    where\n        S: Into<String>,\n    {\n        self.map.contains_key(&name.into())\n    }", "docstring": null}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests-gen/equivalence_universal.rs::test_something", "test": "fn test_something() {\n    let data = [];\n    let wasm_bytes = module.0.to_bytes();\n    if let Ok(path) = std::env::var(\"DUMP_TESTCASE\") {\n        use std::fs::File;\n        use std::io::Write;\n        let mut file = File::create(path).unwrap();\n        file.write_all(&wasm_bytes).unwrap();\n        return;\n    }\n    #[cfg(feature = \"singlepass\")]\n    let singlepass = maybe_instantiate_singlepass(&wasm_bytes)\n        .transpose()\n        .map(evaluate_instance);\n    #[cfg(feature = \"cranelift\")]\n    let cranelift = maybe_instantiate_cranelift(&wasm_bytes)\n        .transpose()\n        .map(evaluate_instance);\n    #[cfg(feature = \"llvm\")]\n    let llvm = maybe_instantiate_llvm(&wasm_bytes)\n        .transpose()\n        .map(evaluate_instance);\n    #[cfg(all(feature = \"singlepass\", feature = \"cranelift\"))]\n    if singlepass.is_some() && cranelift.is_some() {\n        assert_eq!(singlepass.as_ref().unwrap(), cranelift.as_ref().unwrap());\n    }\n    #[cfg(all(feature = \"singlepass\", feature = \"llvm\"))]\n    if singlepass.is_some() && llvm.is_some() {\n        assert_eq!(singlepass.as_ref().unwrap(), llvm.as_ref().unwrap());\n    }\n    #[cfg(all(feature = \"cranelift\", feature = \"llvm\"))]\n    if cranelift.is_some() && llvm.is_some() {\n        assert_eq!(cranelift.as_ref().unwrap(), llvm.as_ref().unwrap());\n    }\n}", "code_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/lib/api/src/js/js_handle.rs::as_ref", "code": "fn as_ref(&self) -> &A {\n        self.integrity.check();\n        self.value.as_ref()\n    }", "docstring": null}
