{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cat.rs::test_write_to_self", "test": "fn test_write_to_self() {\n    let s = TestScenario::new(util_name!());\n    let file_path = s.fixtures.plus(\"first_file\");\n    s.fixtures.write(\"second_file\", \"second_file_content.\");\n\n    let file = OpenOptions::new()\n        .create_new(true)\n        .write(true)\n        .append(true)\n        .open(file_path)\n        .unwrap();\n\n    s.fixtures.append(\"first_file\", \"first_file_content.\");\n\n    s.ucmd()\n        .set_stdout(file)\n        .arg(\"first_file\")\n        .arg(\"first_file\")\n        .arg(\"second_file\")\n        .fails()\n        .code_is(2)\n        .stderr_only(\"cat: first_file: input file is output file\\ncat: first_file: input file is output file\\n\");\n\n    assert_eq!(\n        s.fixtures.read(\"first_file\"),\n        \"first_file_content.second_file_content.\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        match self {\n            #[cfg(not(unix))]\n            Self::Stdin(stdin) => stdin.read(buf),\n            Self::File(f) => f.read(buf),\n            #[cfg(unix)]\n            Self::StdinFile(f) => f.read(buf),\n            #[cfg(unix)]\n            Self::Fifo(f) => f.read(buf),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_directory", "test": "fn valid_context_directory() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.mkdir(\"a\");\n    dir.symlink_dir(\"a\", \"la\");\n\n    let b_path = Path::new(\"a\").join(\"b.txt\");\n    dir.touch(b_path.to_str().unwrap());\n\n    let la_context = get_file_context(dir.plus(\"la\")).unwrap();\n    let b_context = get_file_context(dir.plus(b_path.to_str().unwrap())).unwrap();\n\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    cmd.args(&[\"--verbose\", new_la_context])\n        .arg(dir.plus(\"la\"))\n        .succeeds();\n    assert_eq!(get_file_context(dir.plus(\"la\")).unwrap(), la_context);\n    assert_eq!(\n        get_file_context(dir.plus(\"a\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(\n        get_file_context(dir.plus(b_path.to_str().unwrap())).unwrap(),\n        b_context\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::plus", "code": "pub fn plus<P: AsRef<Path>>(&self, name: P) -> PathBuf {\n        let mut pathbuf = self.subdir.clone();\n        pathbuf.push(name);\n        pathbuf\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_directory_recursive_follow_all_symlinks", "test": "fn valid_context_directory_recursive_follow_all_symlinks() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.mkdir(\"a\");\n    dir.symlink_dir(\"a\", \"la\");\n\n    let b_path = Path::new(\"a\").join(\"b.txt\");\n    dir.touch(b_path.to_str().unwrap());\n\n    let c_path = Path::new(\"a\").join(\"c\");\n    dir.touch(c_path.to_str().unwrap());\n\n    let lc_path = Path::new(\"a\").join(\"lc\");\n    dir.symlink_dir(c_path.to_str().unwrap(), lc_path.to_str().unwrap());\n\n    let la_context = get_file_context(dir.plus(\"la\")).unwrap();\n    let lc_context = get_file_context(dir.plus(lc_path.to_str().unwrap())).unwrap();\n\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    // -L: traverse every symbolic link to a directory encountered.\n    cmd.args(&[\"--verbose\", \"--recursive\", \"-L\", new_la_context])\n        .arg(dir.plus(\"la\"))\n        .succeeds();\n    assert_eq!(get_file_context(dir.plus(\"la\")).unwrap(), la_context);\n    assert_eq!(\n        get_file_context(dir.plus(\"a\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(\n        get_file_context(dir.plus(b_path.to_str().unwrap()))\n            .unwrap()\n            .as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(\n        get_file_context(dir.plus(lc_path.to_str().unwrap())).unwrap(),\n        lc_context\n    );\n    assert_eq!(\n        get_file_context(dir.plus(c_path.to_str().unwrap()))\n            .unwrap()\n            .as_deref(),\n        Some(new_la_context)\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::plus", "code": "pub fn plus<P: AsRef<Path>>(&self, name: P) -> PathBuf {\n        let mut pathbuf = self.subdir.clone();\n        pathbuf.push(name);\n        pathbuf\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_keep_setgid", "test": "fn test_chmod_keep_setgid() {\n    for (from, arg, to) in [\n        (0o7777, \"777\", 0o46777),\n        (0o7777, \"=777\", 0o40777),\n        (0o7777, \"0777\", 0o46777),\n        (0o7777, \"=0777\", 0o40777),\n        (0o7777, \"00777\", 0o40777),\n        (0o2444, \"a+wx\", 0o42777),\n        (0o2444, \"a=wx\", 0o42333),\n        (0o1444, \"g+s\", 0o43444),\n        (0o4444, \"u-s\", 0o40444),\n        (0o7444, \"a-s\", 0o41444),\n    ] {\n        let (at, mut ucmd) = at_and_ucmd!();\n        at.mkdir(\"dir\");\n        set_permissions(at.plus(\"dir\"), Permissions::from_mode(from)).unwrap();\n        let r = ucmd.arg(arg).arg(\"dir\").succeeds();\n        println!(\"{}\", r.stderr_str());\n        assert_eq!(at.metadata(\"dir\").permissions().mode(), to);\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/install/src/install.rs::mode", "code": "pub fn mode(&self) -> u32 {\n        match self.specified_mode {\n            Some(x) => x,\n            None => DEFAULT_MODE,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_file_after_non_existing_file", "test": "fn test_chmod_file_after_non_existing_file() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    at.touch(TEST_FILE);\n    at.touch(\"file2\");\n    set_permissions(at.plus(TEST_FILE), Permissions::from_mode(0o664)).unwrap();\n    set_permissions(at.plus(\"file2\"), Permissions::from_mode(0o664)).unwrap();\n    scene\n        .ucmd()\n        .arg(\"u+x\")\n        .arg(\"does-not-exist\")\n        .arg(TEST_FILE)\n        .fails()\n        .stderr_contains(\"chmod: cannot access 'does-not-exist': No such file or directory\")\n        .code_is(1);\n\n    assert_eq!(at.metadata(TEST_FILE).permissions().mode(), 0o100_764);\n\n    scene\n        .ucmd()\n        .arg(\"u+x\")\n        .arg(\"--q\")\n        .arg(\"does-not-exist\")\n        .arg(\"file2\")\n        .fails()\n        .no_stderr()\n        .code_is(1);\n    assert_eq!(at.metadata(\"file2\").permissions().mode(), 0o100_764);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/install/src/install.rs::mode", "code": "pub fn mode(&self) -> u32 {\n        match self.specified_mode {\n            Some(x) => x,\n            None => DEFAULT_MODE,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_chmod_file_symlink_after_non_existing_file", "test": "fn test_chmod_file_symlink_after_non_existing_file() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let existing = \"file\";\n    let test_existing_symlink = \"file_symlink\";\n\n    let non_existing = \"test_chmod_symlink_non_existing_file\";\n    let test_dangling_symlink = \"test_chmod_symlink_non_existing_file_symlink\";\n    let expected_stdout = &format!(\n        \"failed to change mode of '{test_dangling_symlink}' from 0000 (---------) to 1500 (r-x-----T)\"\n    );\n    let expected_stderr = &format!(\"cannot operate on dangling symlink '{test_dangling_symlink}'\");\n\n    at.touch(existing);\n    set_permissions(at.plus(existing), Permissions::from_mode(0o664)).unwrap();\n    at.symlink_file(non_existing, test_dangling_symlink);\n    at.symlink_file(existing, test_existing_symlink);\n\n    // this cannot succeed since the symbolic link dangles\n    // but the metadata for the existing target should change\n    scene\n        .ucmd()\n        .arg(\"u+x\")\n        .arg(\"-v\")\n        .arg(test_dangling_symlink)\n        .arg(test_existing_symlink)\n        .fails()\n        .code_is(1)\n        .stdout_contains(expected_stdout)\n        .stderr_contains(expected_stderr);\n    assert_eq!(\n        at.metadata(test_existing_symlink).permissions().mode(),\n        0o100_764\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/install/src/install.rs::mode", "code": "pub fn mode(&self) -> u32 {\n        match self.specified_mode {\n            Some(x) => x,\n            None => DEFAULT_MODE,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_only_owner", "test": "fn test_chown_only_owner() {\n    // test chown username file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    // since only superuser can change owner, we have to change from ourself to ourself\n    let result = scene\n        .ucmd()\n        .arg(user_name)\n        .arg(\"--verbose\")\n        .arg(file1)\n        .run();\n    result.stderr_contains(\"retained as\");\n\n    // try to change to another existing user, e.g. 'root'\n    scene\n        .ucmd()\n        .arg(\"root\")\n        .arg(\"--verbose\")\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"failed to change\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_only_owner_colon", "test": "fn test_chown_only_owner_colon() {\n    // test chown username: file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    scene\n        .ucmd()\n        .arg(format!(\"{user_name}:\"))\n        .arg(\"--verbose\")\n        .arg(file1)\n        .succeeds()\n        .stderr_contains(\"retained as\");\n\n    scene\n        .ucmd()\n        .arg(format!(\"{user_name}.\"))\n        .arg(\"--verbose\")\n        .arg(file1)\n        .succeeds()\n        .stderr_contains(\"retained as\");\n\n    scene\n        .ucmd()\n        .arg(\"root:\")\n        .arg(\"--verbose\")\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"failed to change\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_only_user_id", "test": "fn test_chown_only_user_id() {\n    // test chown 1111 file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"id\").arg(\"-u\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let user_id = String::from(result.stdout_str().trim());\n    assert!(!user_id.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    let result = scene.ucmd().arg(user_id).arg(\"--verbose\").arg(file1).run();\n    if skipping_test_is_okay(&result, \"invalid user\") {\n        // From the Logs: \"Build (ubuntu-18.04, x86_64-unknown-linux-gnu, feat_os_unix, use-cross)\"\n        // stderr: \"chown: invalid user: '1001'\n        return;\n    }\n    result.stderr_contains(\"retained as\");\n\n    scene\n        .ucmd()\n        .arg(\"0\")\n        .arg(\"--verbose\")\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"failed to change\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_fail_id", "test": "fn test_chown_fail_id() {\n    // test chown 1111. file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"id\").arg(\"-u\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let user_id = String::from(result.stdout_str().trim());\n    assert!(!user_id.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    scene\n        .ucmd()\n        .arg(format!(\"{user_id}:\"))\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"invalid spec\");\n\n    scene\n        .ucmd()\n        .arg(format!(\"{user_id}.\"))\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"invalid spec\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_owner_group_id", "test": "fn test_chown_owner_group_id() {\n    // test chown 1111:1111 file.txt\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"id\").arg(\"-u\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let user_id = String::from(result.stdout_str().trim());\n    assert!(!user_id.is_empty());\n\n    let result = scene.cmd(\"id\").arg(\"-g\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let group_id = String::from(result.stdout_str().trim());\n    assert!(!group_id.is_empty());\n\n    let file1 = \"test_chown_file1\";\n    at.touch(file1);\n\n    let result = scene\n        .ucmd()\n        .arg(format!(\"{user_id}:{group_id}\"))\n        .arg(\"--verbose\")\n        .arg(file1)\n        .run();\n    if skipping_test_is_okay(&result, \"invalid user\") {\n        // From the Logs: \"Build (ubuntu-18.04, x86_64-unknown-linux-gnu, feat_os_unix, use-cross)\"\n        // stderr: \"chown: invalid user: '1001:116'\n        return;\n    }\n    result.stderr_contains(\"retained as\");\n\n    let result = scene\n        .ucmd()\n        .arg(format!(\"{user_id}.{group_id}\"))\n        .arg(\"--verbose\")\n        .arg(file1)\n        .run();\n    if skipping_test_is_okay(&result, \"invalid user\") {\n        // From the Logs: \"Build (ubuntu-18.04, x86_64-unknown-linux-gnu, feat_os_unix, use-cross)\"\n        // stderr: \"chown: invalid user: '1001.116'\n        return;\n    }\n    result.stderr_contains(\"retained as\");\n\n    scene\n        .ucmd()\n        .arg(\"0:0\")\n        .arg(\"--verbose\")\n        .arg(file1)\n        .fails()\n        .stderr_contains(\"failed to change\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_recursive", "test": "fn test_chown_recursive() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    at.mkdir_all(\"a/b/c\");\n    at.mkdir(\"z\");\n    at.touch(at.plus_as_string(\"a/a\"));\n    at.touch(at.plus_as_string(\"a/b/b\"));\n    at.touch(at.plus_as_string(\"a/b/c/c\"));\n    at.touch(at.plus_as_string(\"z/y\"));\n\n    let result = scene\n        .ucmd()\n        .arg(\"-R\")\n        .arg(\"--verbose\")\n        .arg(user_name)\n        .arg(\"a\")\n        .arg(\"z\")\n        .run();\n    result.stderr_contains(\"ownership of 'a/a' retained as\");\n    result.stderr_contains(\"ownership of 'z/y' retained as\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_root_preserve", "test": "fn test_root_preserve() {\n    let scene = TestScenario::new(util_name!());\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    let result = scene\n        .ucmd()\n        .arg(\"--preserve-root\")\n        .arg(\"-R\")\n        .arg(user_name)\n        .arg(\"/\")\n        .fails();\n    result.stderr_contains(\"chown: it is dangerous to operate recursively\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_file_notexisting", "test": "fn test_chown_file_notexisting() {\n    // test chown username not_existing\n\n    let scene = TestScenario::new(util_name!());\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    scene\n        .ucmd()\n        .arg(&user_name)\n        .arg(\"--verbose\")\n        .arg(\"not_existing\")\n        .fails()\n        .stdout_contains(format!(\n            \"failed to change ownership of 'not_existing' to {user_name}\"\n        ));\n    // TODO: uncomment once message changed from \"cannot dereference\" to \"cannot access\"\n    // result.stderr_contains(\"cannot access 'not_existing': No such file or directory\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_no_change_to_user", "test": "fn test_chown_no_change_to_user() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n\n    for (i, from) in [\"42\", \":42\", \"42:42\"].iter().enumerate() {\n        let file = i.to_string();\n        at.touch(&file);\n        scene\n            .ucmd()\n            .arg(\"-v\")\n            .arg(format!(\"--from={from}\"))\n            .arg(\"43\")\n            .arg(&file)\n            .succeeds()\n            .stdout_only(format!(\"ownership of '{file}' retained as {user_name}\\n\"));\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_no_change_to_group", "test": "fn test_chown_no_change_to_group() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n    let result = scene.cmd(\"id\").arg(\"-ng\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let group_name = String::from(result.stdout_str().trim());\n    assert!(!group_name.is_empty());\n\n    for (i, from) in [\"42\", \":42\", \"42:42\"].iter().enumerate() {\n        let file = i.to_string();\n        at.touch(&file);\n        scene\n            .ucmd()\n            .arg(\"-v\")\n            .arg(format!(\"--from={from}\"))\n            .arg(\":43\")\n            .arg(&file)\n            .succeeds()\n            .stdout_only(format!(\"ownership of '{file}' retained as {group_name}\\n\"));\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chown.rs::test_chown_no_change_to_user_group", "test": "fn test_chown_no_change_to_user_group() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let result = scene.cmd(\"whoami\").run();\n    if skipping_test_is_okay(&result, \"whoami: cannot find name for user ID\") {\n        return;\n    }\n    let user_name = String::from(result.stdout_str().trim());\n    assert!(!user_name.is_empty());\n    let result = scene.cmd(\"id\").arg(\"-ng\").run();\n    if skipping_test_is_okay(&result, \"id: cannot find name for group ID\") {\n        return;\n    }\n    let group_name = String::from(result.stdout_str().trim());\n    assert!(!group_name.is_empty());\n\n    for (i, from) in [\"42\", \":42\", \"42:42\"].iter().enumerate() {\n        let file = i.to_string();\n        at.touch(&file);\n        scene\n            .ucmd()\n            .arg(\"-v\")\n            .arg(format!(\"--from={from}\"))\n            .arg(\"43:43\")\n            .arg(&file)\n            .succeeds()\n            .stdout_only(format!(\n                \"ownership of '{file}' retained as {user_name}:{group_name}\\n\"\n            ));\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chroot.rs::test_chroot_skip_chdir", "test": "fn test_chroot_skip_chdir() {\n    let ts = TestScenario::new(util_name!());\n    let at = ts.fixtures.clone();\n    let dirs = [\"/\", \"/.\", \"/..\", \"isroot\"];\n    at.symlink_file(\"/\", \"isroot\");\n    for dir in dirs {\n        let env_cd = std::env::current_dir().unwrap();\n        if let Ok(result) = run_ucmd_as_root(&ts, &[dir, \"--skip-chdir\"]) {\n            // Should return the same path\n            assert_eq!(\n                result.success().no_stderr().stdout_str(),\n                env_cd.to_str().unwrap()\n            );\n        } else {\n            print!(\"Test skipped; requires root user\");\n        }\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chroot.rs::test_chroot_extra_arg", "test": "fn test_chroot_extra_arg() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    let dir = \"CHROOT_DIR\";\n    at.mkdir(dir);\n    let env_cd = std::env::current_dir().unwrap();\n    // Verify that -P is pwd's and not chroot\n    if let Ok(result) = run_ucmd_as_root(&ts, &[dir, \"pwd\", \"-P\"]) {\n        assert_eq!(\n            result.success().no_stderr().stdout_str(),\n            env_cd.to_str().unwrap()\n        );\n    } else {\n        print!(\"Test skipped; requires root user\");\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_cp", "test": "fn test_cp_cp() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    // Invoke our binary to make the copy.\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HELLO_WORLD_DEST)\n        .succeeds();\n\n    // Check the content of the destination file that was copied.\n    assert_eq!(at.read(TEST_HELLO_WORLD_DEST), \"Hello, World!\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_existing_target", "test": "fn test_cp_existing_target() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_EXISTING_FILE)\n        .succeeds();\n\n    // Check the content of the destination file\n    assert_eq!(at.read(TEST_EXISTING_FILE), \"Hello, World!\\n\");\n\n    // No backup should have been created\n    assert!(!at.file_exists(format!(\"{TEST_EXISTING_FILE}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_duplicate_files", "test": "fn test_cp_duplicate_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_COPY_TO_FOLDER)\n        .succeeds()\n        .stderr_contains(\"specified more than once\");\n    assert_eq!(at.read(TEST_COPY_TO_FOLDER_FILE), \"Hello, World!\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_multiple_files", "test": "fn test_cp_multiple_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(TEST_COPY_TO_FOLDER)\n        .succeeds();\n\n    assert_eq!(at.read(TEST_COPY_TO_FOLDER_FILE), \"Hello, World!\\n\");\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_DEST), \"How are you?\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_with_dirs_t", "test": "fn test_cp_with_dirs_t() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(\"-t\")\n        .arg(TEST_COPY_TO_FOLDER)\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .succeeds();\n    assert_eq!(at.read(TEST_COPY_TO_FOLDER_FILE), \"Hello, World!\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_target_directory", "test": "fn test_cp_arg_target_directory() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(\"-t\")\n        .arg(TEST_COPY_TO_FOLDER)\n        .succeeds();\n\n    assert_eq!(at.read(TEST_COPY_TO_FOLDER_FILE), \"Hello, World!\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_none", "test": "fn test_cp_arg_update_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"--update=none\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"How are you?\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_all", "test": "fn test_cp_arg_update_all() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"--update=all\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(\n        at.read(TEST_HOW_ARE_YOU_SOURCE),\n        at.read(TEST_HELLO_WORLD_SOURCE)\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_older_dest_not_older_than_src", "test": "fn test_cp_arg_update_older_dest_not_older_than_src() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_dest_not_older_file1\";\n    let new = \"test_cp_arg_update_dest_not_older_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"--update=older\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"new content\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_older_dest_older_than_src", "test": "fn test_cp_arg_update_older_dest_older_than_src() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_dest_older_file1\";\n    let new = \"test_cp_arg_update_dest_older_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(new)\n        .arg(old)\n        .arg(\"--update=older\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(old), \"new content\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_short_no_overwrite", "test": "fn test_cp_arg_update_short_no_overwrite() {\n    // same as --update=older\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_short_no_overwrite_file1\";\n    let new = \"test_cp_arg_update_short_no_overwrite_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"-u\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"new content\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_short_overwrite", "test": "fn test_cp_arg_update_short_overwrite() {\n    // same as --update=older\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_short_overwrite_file1\";\n    let new = \"test_cp_arg_update_short_overwrite_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(new)\n        .arg(old)\n        .arg(\"-u\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(old), \"new content\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_none_then_all", "test": "fn test_cp_arg_update_none_then_all() {\n    // take last if multiple update args are supplied,\n    // update=all wins in this case\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_none_then_all_file1\";\n    let new = \"test_cp_arg_update_none_then_all_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"--update=none\")\n        .arg(\"--update=all\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"old content\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_update_all_then_none", "test": "fn test_cp_arg_update_all_then_none() {\n    // take last if multiple update args are supplied,\n    // update=none wins in this case\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_cp_arg_update_all_then_none_file1\";\n    let new = \"test_cp_arg_update_all_then_none_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"--update=all\")\n        .arg(\"--update=none\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"new content\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_symlink", "test": "fn test_cp_arg_symlink() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(\"--symbolic-link\")\n        .arg(TEST_HELLO_WORLD_DEST)\n        .succeeds();\n\n    assert!(at.is_symlink(TEST_HELLO_WORLD_DEST));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::is_symlink", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_no_clobber", "test": "fn test_cp_arg_no_clobber() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"--no-clobber\")\n        .fails()\n        .stderr_contains(\"not replacing\");\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"How are you?\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_no_clobber_inferred_arg", "test": "fn test_cp_arg_no_clobber_inferred_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"--no-clob\")\n        .fails();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"How are you?\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_backup", "test": "fn test_cp_arg_backup() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"-b\")\n        .succeeds();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_backup_with_other_args", "test": "fn test_cp_arg_backup_with_other_args() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(\"-vbL\")\n        .succeeds();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_backup_arg_first", "test": "fn test_cp_arg_backup_arg_first() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_suffix", "test": "fn test_cp_arg_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(\"-b\")\n        .arg(\"--suffix\")\n        .arg(\".bak\")\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}.bak\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_suffix_hyphen_value", "test": "fn test_cp_arg_suffix_hyphen_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(\"-b\")\n        .arg(\"--suffix\")\n        .arg(\"-v\")\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}-v\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_custom_backup_suffix_via_env", "test": "fn test_cp_custom_backup_suffix_via_env() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let suffix = \"super-suffix-of-the-century\";\n\n    ucmd.arg(\"-b\")\n        .env(\"SIMPLE_BACKUP_SUFFIX\", suffix)\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}{suffix}\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_numbered_with_t", "test": "fn test_cp_backup_numbered_with_t() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=t\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}.~1~\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_numbered", "test": "fn test_cp_backup_numbered() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=numbered\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}.~1~\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_existing", "test": "fn test_cp_backup_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=existing\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_nil", "test": "fn test_cp_backup_nil() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=nil\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_numbered_if_existing_backup_existing", "test": "fn test_cp_numbered_if_existing_backup_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let existing_backup = &format!(\"{TEST_HOW_ARE_YOU_SOURCE}.~1~\");\n    at.touch(existing_backup);\n\n    ucmd.arg(\"--backup=existing\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(TEST_HOW_ARE_YOU_SOURCE));\n    assert!(at.file_exists(existing_backup));\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}.~2~\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_numbered_if_existing_backup_nil", "test": "fn test_cp_numbered_if_existing_backup_nil() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let existing_backup = &format!(\"{TEST_HOW_ARE_YOU_SOURCE}.~1~\");\n\n    at.touch(existing_backup);\n    ucmd.arg(\"--backup=nil\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(TEST_HOW_ARE_YOU_SOURCE));\n    assert!(at.file_exists(existing_backup));\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}.~2~\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_simple", "test": "fn test_cp_backup_simple() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=simple\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_simple_protect_source", "test": "fn test_cp_backup_simple_protect_source() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let source = format!(\"{TEST_HELLO_WORLD_SOURCE}~\");\n    at.touch(&source);\n    ucmd.arg(\"--backup=simple\")\n        .arg(&source)\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .fails()\n        .stderr_only(format!(\n            \"cp: backing up '{TEST_HELLO_WORLD_SOURCE}' might destroy source;  '{source}' not copied\\n\",\n        ));\n\n    assert_eq!(at.read(TEST_HELLO_WORLD_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(at.read(&source), \"\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_never", "test": "fn test_cp_backup_never() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=never\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert_eq!(\n        at.read(&format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_none", "test": "fn test_cp_backup_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=none\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert!(!at.file_exists(format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_backup_off", "test": "fn test_cp_backup_off() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--backup=off\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(TEST_HOW_ARE_YOU_SOURCE), \"Hello, World!\\n\");\n    assert!(!at.file_exists(format!(\"{TEST_HOW_ARE_YOU_SOURCE}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_no_deref_link_onto_link", "test": "fn test_cp_no_deref_link_onto_link() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.copy(TEST_HELLO_WORLD_SOURCE, TEST_HELLO_WORLD_DEST);\n\n    #[cfg(not(windows))]\n    let _r = fs::symlink(\n        TEST_HELLO_WORLD_SOURCE,\n        at.subdir.join(TEST_HELLO_WORLD_SOURCE_SYMLINK),\n    );\n    #[cfg(windows)]\n    let _r = symlink_file(\n        TEST_HELLO_WORLD_SOURCE,\n        at.subdir.join(TEST_HELLO_WORLD_SOURCE_SYMLINK),\n    );\n\n    #[cfg(not(windows))]\n    let _r = fs::symlink(\n        TEST_HELLO_WORLD_DEST,\n        at.subdir.join(TEST_HELLO_WORLD_DEST_SYMLINK),\n    );\n    #[cfg(windows)]\n    let _r = symlink_file(\n        TEST_HELLO_WORLD_DEST,\n        at.subdir.join(TEST_HELLO_WORLD_DEST_SYMLINK),\n    );\n\n    ucmd.arg(\"-P\")\n        .arg(TEST_HELLO_WORLD_SOURCE_SYMLINK)\n        .arg(TEST_HELLO_WORLD_DEST_SYMLINK)\n        .succeeds();\n\n    // Ensure that the target of the destination was not modified.\n    assert!(!at\n        .symlink_metadata(TEST_HELLO_WORLD_DEST)\n        .file_type()\n        .is_symlink());\n    assert!(at\n        .symlink_metadata(TEST_HELLO_WORLD_DEST_SYMLINK)\n        .file_type()\n        .is_symlink());\n    assert_eq!(at.read(TEST_HELLO_WORLD_DEST_SYMLINK), \"Hello, World!\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::is_symlink", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_strip_trailing_slashes", "test": "fn test_cp_strip_trailing_slashes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    //using --strip-trailing-slashes option\n    ucmd.arg(\"--strip-trailing-slashes\")\n        .arg(format!(\"{TEST_HELLO_WORLD_SOURCE}/\"))\n        .arg(TEST_HELLO_WORLD_DEST)\n        .succeeds();\n\n    // Check the content of the destination file that was copied.\n    assert_eq!(at.read(TEST_HELLO_WORLD_DEST), \"Hello, World!\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_parents", "test": "fn test_cp_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--parents\")\n        .arg(TEST_COPY_FROM_FOLDER_FILE)\n        .arg(TEST_COPY_TO_FOLDER)\n        .succeeds();\n\n    assert_eq!(\n        at.read(&format!(\n            \"{TEST_COPY_TO_FOLDER}/{TEST_COPY_FROM_FOLDER_FILE}\"\n        )),\n        \"Hello, World!\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_parents_multiple_files", "test": "fn test_cp_parents_multiple_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    ucmd.arg(\"--parents\")\n        .arg(TEST_COPY_FROM_FOLDER_FILE)\n        .arg(TEST_HOW_ARE_YOU_SOURCE)\n        .arg(TEST_COPY_TO_FOLDER)\n        .succeeds();\n\n    assert_eq!(\n        at.read(&format!(\n            \"{TEST_COPY_TO_FOLDER}/{TEST_COPY_FROM_FOLDER_FILE}\"\n        )),\n        \"Hello, World!\\n\"\n    );\n    assert_eq!(\n        at.read(&format!(\"{TEST_COPY_TO_FOLDER}/{TEST_HOW_ARE_YOU_SOURCE}\")),\n        \"How are you?\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_parents_with_permissions_copy_file", "test": "fn test_cp_parents_with_permissions_copy_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let dir = \"dir\";\n    let file = \"p1/p2/file\";\n\n    at.mkdir(dir);\n    at.mkdir_all(\"p1/p2\");\n    at.touch(file);\n\n    #[cfg(unix)]\n    {\n        let p1_mode = 0o0777;\n        let p2_mode = 0o0711;\n        let file_mode = 0o0702;\n\n        at.set_mode(\"p1\", p1_mode);\n        at.set_mode(\"p1/p2\", p2_mode);\n        at.set_mode(file, file_mode);\n    }\n\n    ucmd.arg(\"-p\")\n        .arg(\"--parents\")\n        .arg(file)\n        .arg(dir)\n        .succeeds();\n\n    #[cfg(all(unix, not(target_os = \"freebsd\")))]\n    {\n        let p1_metadata = at.metadata(\"p1\");\n        let p2_metadata = at.metadata(\"p1/p2\");\n        let file_metadata = at.metadata(file);\n\n        assert_metadata_eq!(p1_metadata, at.metadata(\"dir/p1\"));\n        assert_metadata_eq!(p2_metadata, at.metadata(\"dir/p1/p2\"));\n        assert_metadata_eq!(file_metadata, at.metadata(\"dir/p1/p2/file\"));\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::metadata", "code": "pub fn metadata(&self, path: &str) -> fs::Metadata {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m,\n            Err(e) => panic!(\"{}\", e),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_parents_with_permissions_copy_dir", "test": "fn test_cp_parents_with_permissions_copy_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let dir1 = \"dir\";\n    let dir2 = \"p1/p2\";\n    let file = \"p1/p2/file\";\n\n    at.mkdir(dir1);\n    at.mkdir_all(dir2);\n    at.touch(file);\n\n    #[cfg(unix)]\n    {\n        let p1_mode = 0o0777;\n        let p2_mode = 0o0711;\n        let file_mode = 0o0702;\n\n        at.set_mode(\"p1\", p1_mode);\n        at.set_mode(\"p1/p2\", p2_mode);\n        at.set_mode(file, file_mode);\n    }\n\n    ucmd.arg(\"-p\")\n        .arg(\"--parents\")\n        .arg(\"-r\")\n        .arg(dir2)\n        .arg(dir1)\n        .succeeds();\n\n    #[cfg(all(unix, not(target_os = \"freebsd\")))]\n    {\n        let p1_metadata = at.metadata(\"p1\");\n        let p2_metadata = at.metadata(\"p1/p2\");\n        let file_metadata = at.metadata(file);\n\n        assert_metadata_eq!(p1_metadata, at.metadata(\"dir/p1\"));\n        assert_metadata_eq!(p2_metadata, at.metadata(\"dir/p1/p2\"));\n        assert_metadata_eq!(file_metadata, at.metadata(\"dir/p1/p2/file\"));\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::metadata", "code": "pub fn metadata(&self, path: &str) -> fs::Metadata {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m,\n            Err(e) => panic!(\"{}\", e),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_sparse_never_empty", "test": "fn test_cp_sparse_never_empty() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    const BUFFER_SIZE: usize = 4096 * 4;\n    let buf: [u8; BUFFER_SIZE] = [0; BUFFER_SIZE];\n\n    at.make_file(\"src_file1\");\n    at.write_bytes(\"src_file1\", &buf);\n\n    ucmd.args(&[\"--sparse=never\", \"src_file1\", \"dst_file_non_sparse\"])\n        .succeeds();\n    assert_eq!(at.read_bytes(\"dst_file_non_sparse\"), buf);\n    assert_eq!(\n        at.metadata(\"dst_file_non_sparse\").blocks() * 512,\n        buf.len() as u64\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::read_bytes", "code": "pub fn read_bytes(&self, name: &str) -> Vec<u8> {\n        let mut f = self.open(name);\n        let mut contents = Vec::new();\n        f.read_to_end(&mut contents)\n            .unwrap_or_else(|e| panic!(\"Couldn't read {name}: {e}\"));\n        contents\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_sparse_always_empty", "test": "fn test_cp_sparse_always_empty() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    const BUFFER_SIZE: usize = 4096 * 4;\n    let buf: [u8; BUFFER_SIZE] = [0; BUFFER_SIZE];\n\n    at.make_file(\"src_file1\");\n    at.write_bytes(\"src_file1\", &buf);\n\n    ucmd.args(&[\"--sparse=always\", \"src_file1\", \"dst_file_sparse\"])\n        .succeeds();\n\n    assert_eq!(at.read_bytes(\"dst_file_sparse\"), buf);\n    assert_eq!(at.metadata(\"dst_file_sparse\").blocks(), 0);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::read_bytes", "code": "pub fn read_bytes(&self, name: &str) -> Vec<u8> {\n        let mut f = self.open(name);\n        let mut contents = Vec::new();\n        f.read_to_end(&mut contents)\n            .unwrap_or_else(|e| panic!(\"Couldn't read {name}: {e}\"));\n        contents\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_sparse_always_non_empty", "test": "fn test_cp_sparse_always_non_empty() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    const BUFFER_SIZE: usize = 4096 * 16 + 3;\n    let mut buf: [u8; BUFFER_SIZE] = [0; BUFFER_SIZE];\n    let blocks_to_touch = [buf.len() / 3, 2 * (buf.len() / 3)];\n\n    for i in blocks_to_touch {\n        buf[i] = b'x';\n    }\n\n    at.make_file(\"src_file1\");\n    at.write_bytes(\"src_file1\", &buf);\n\n    ucmd.args(&[\"--sparse=always\", \"src_file1\", \"dst_file_sparse\"])\n        .succeeds();\n\n    let touched_block_count =\n        blocks_to_touch.len() as u64 * at.metadata(\"dst_file_sparse\").blksize() / 512;\n\n    assert_eq!(at.read_bytes(\"dst_file_sparse\"), buf);\n    assert_eq!(at.metadata(\"dst_file_sparse\").blocks(), touched_block_count);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::read_bytes", "code": "pub fn read_bytes(&self, name: &str) -> Vec<u8> {\n        let mut f = self.open(name);\n        let mut contents = Vec::new();\n        f.read_to_end(&mut contents)\n            .unwrap_or_else(|e| panic!(\"Couldn't read {name}: {e}\"));\n        contents\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_notrunc_does_not_truncate", "test": "fn test_notrunc_does_not_truncate() {\n    // Set up test if needed (eg. after failure)\n    let fname = \"this-file-exists-notrunc.txt\";\n    let fpath = fixture_path!(fname);\n    match fpath.metadata() {\n        Ok(m) if m.len() == 256 => {}\n        _ => build_test_file!(&fpath, &build_ascii_block(256)),\n    }\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"status=none\", \"conv=notrunc\", of!(&fname), \"if=null.txt\"])\n        .run()\n        .no_stdout()\n        .no_stderr()\n        .success();\n\n    assert_eq!(256, fix.metadata(fname).len());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::len", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_existing_file_truncated", "test": "fn test_existing_file_truncated() {\n    // Set up test if needed (eg. after failure)\n    let fname = \"this-file-exists-truncated.txt\";\n    let fpath = fixture_path!(fname);\n    match fpath.metadata() {\n        Ok(m) if m.len() == 256 => {}\n        _ => build_test_file!(&fpath, &vec![0; 256]),\n    }\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"status=none\", \"if=null.txt\", of!(fname)])\n        .run()\n        .no_stdout()\n        .no_stderr()\n        .success();\n\n    assert_eq!(0, fix.metadata(fname).len());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::len", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_ascii_521k_to_file", "test": "fn test_ascii_521k_to_file() {\n    let tname = \"ascii-521k\";\n    let input = build_ascii_block(512 * 1024);\n    let tmp_fn = format!(\"TESTFILE-{}.tmp\", &tname);\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"status=none\", of!(tmp_fn)])\n        .pipe_in(input.clone())\n        .run()\n        .no_stderr()\n        .no_stdout()\n        .success();\n\n    assert_eq!(512 * 1024, fix.metadata(&tmp_fn).len());\n\n    cmp_file!(\n        {\n            let mut input_f = tempfile().unwrap();\n            input_f.write_all(&input).unwrap();\n            input_f\n        },\n        fix.open(&tmp_fn)\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::len", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dd.rs::test_ascii_5_gibi_to_file", "test": "fn test_ascii_5_gibi_to_file() {\n    let tname = \"ascii-5G\";\n    let tmp_fn = format!(\"TESTFILE-{}.tmp\", &tname);\n\n    let (fix, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\n        \"status=none\",\n        \"count=5G\",\n        \"iflag=count_bytes\",\n        \"if=/dev/zero\",\n        of!(tmp_fn),\n    ])\n    .run()\n    .no_stderr()\n    .no_stdout()\n    .success();\n\n    assert_eq!(5 * 1024 * 1024 * 1024, fix.metadata(&tmp_fn).len());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::len", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_output_mp_repeat", "test": "fn test_output_mp_repeat() {\n    let output1 = new_ucmd!().arg(\"/\").arg(\"/\").succeeds().stdout_move_str();\n    let output1: Vec<String> = output1\n        .lines()\n        .map(|l| String::from(l.split_once(' ').unwrap().0))\n        .collect();\n    assert_eq!(3, output1.len());\n    assert_eq!(output1[1], output1[2]);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::len", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_total", "test": "fn test_total() {\n    // Example output:\n    //\n    //     Filesystem            1K-blocks     Used Available Use% Mounted on\n    //     udev                    3858016        0   3858016   0% /dev\n    //     ...\n    //     /dev/loop14               63488    63488         0 100% /snap/core20/1361\n    //     total                 258775268 98099712 148220200  40% -\n    let output = new_ucmd!().arg(\"--total\").succeeds().stdout_move_str();\n\n    // Skip the header line.\n    let lines: Vec<&str> = output.lines().skip(1).collect();\n\n    // Parse the values from the last row.\n    let last_line = lines.last().unwrap();\n    let mut iter = last_line.split_whitespace();\n    assert_eq!(iter.next().unwrap(), \"total\");\n    let reported_total_size = iter.next().unwrap().parse().unwrap();\n    let reported_total_used = iter.next().unwrap().parse().unwrap();\n    let reported_total_avail = iter.next().unwrap().parse().unwrap();\n\n    // Loop over each row except the last, computing the sum of each column.\n    let mut computed_total_size = 0;\n    let mut computed_total_used = 0;\n    let mut computed_total_avail = 0;\n    let n = lines.len();\n    for line in &lines[..n - 1] {\n        let mut iter = line.split_whitespace();\n        iter.next().unwrap();\n        computed_total_size += iter.next().unwrap().parse::<u64>().unwrap();\n        computed_total_used += iter.next().unwrap().parse::<u64>().unwrap();\n        computed_total_avail += iter.next().unwrap().parse::<u64>().unwrap();\n    }\n\n    // Check that the sum of each column matches the reported value in\n    // the last row.\n    assert_eq!(computed_total_size, reported_total_size);\n    assert_eq!(computed_total_used, reported_total_used);\n    assert_eq!(computed_total_avail, reported_total_avail);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/csplit/src/patterns.rs::next", "code": "fn next(&mut self) -> Option<(Option<usize>, usize)> {\n        match self.max {\n            // iterate until m is reached\n            Some(m) => {\n                if self.cur == m {\n                    None\n                } else {\n                    self.cur += 1;\n                    Some((self.max, self.cur))\n                }\n            }\n            // no limit, just increment a counter\n            None => {\n                self.cur += 1;\n                Some((None, self.cur))\n            }\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_default_block_size_in_posix_portability_mode", "test": "fn test_default_block_size_in_posix_portability_mode() {\n    fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }\n\n    let output = new_ucmd!().arg(\"-P\").succeeds().stdout_move_str();\n    assert_eq!(get_header(&output), \"1024-blocks\");\n\n    let output = new_ucmd!()\n        .arg(\"-P\")\n        .env(\"POSIXLY_CORRECT\", \"1\")\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(get_header(&output), \"512-blocks\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::get_header", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_block_size_1024", "test": "fn test_block_size_1024() {\n    fn get_header(block_size: u64) -> String {\n        let output = new_ucmd!()\n            .args(&[\"-B\", &format!(\"{block_size}\"), \"--output=size\"])\n            .succeeds()\n            .stdout_move_str();\n        output.lines().next().unwrap().trim().to_string()\n    }\n\n    assert_eq!(get_header(1024), \"1K-blocks\");\n    assert_eq!(get_header(2048), \"2K-blocks\");\n    assert_eq!(get_header(4096), \"4K-blocks\");\n    assert_eq!(get_header(1024 * 1024), \"1M-blocks\");\n    assert_eq!(get_header(2 * 1024 * 1024), \"2M-blocks\");\n    assert_eq!(get_header(1024 * 1024 * 1024), \"1G-blocks\");\n    assert_eq!(get_header(34 * 1024 * 1024 * 1024), \"34G-blocks\");\n\n    // multiples of both 1024 and 1000\n    assert_eq!(get_header(128_000), \"128kB-blocks\");\n    assert_eq!(get_header(1000 * 1024), \"1.1MB-blocks\");\n    assert_eq!(get_header(1_000_000_000_000), \"1TB-blocks\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::get_header", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_block_size_with_suffix", "test": "fn test_block_size_with_suffix() {\n    fn get_header(block_size: &str) -> String {\n        let output = new_ucmd!()\n            .args(&[\"-B\", block_size, \"--output=size\"])\n            .succeeds()\n            .stdout_move_str();\n        output.lines().next().unwrap().trim().to_string()\n    }\n\n    assert_eq!(get_header(\"K\"), \"1K-blocks\");\n    assert_eq!(get_header(\"M\"), \"1M-blocks\");\n    assert_eq!(get_header(\"G\"), \"1G-blocks\");\n    assert_eq!(get_header(\"1K\"), \"1K-blocks\");\n    assert_eq!(get_header(\"1M\"), \"1M-blocks\");\n    assert_eq!(get_header(\"1G\"), \"1G-blocks\");\n    assert_eq!(get_header(\"1KiB\"), \"1K-blocks\");\n    assert_eq!(get_header(\"1MiB\"), \"1M-blocks\");\n    assert_eq!(get_header(\"1GiB\"), \"1G-blocks\");\n    assert_eq!(get_header(\"1KB\"), \"1kB-blocks\");\n    assert_eq!(get_header(\"1MB\"), \"1MB-blocks\");\n    assert_eq!(get_header(\"1GB\"), \"1GB-blocks\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::get_header", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_block_size_in_posix_portability_mode", "test": "fn test_block_size_in_posix_portability_mode() {\n    fn get_header(block_size: &str) -> String {\n        let output = new_ucmd!()\n            .args(&[\"-P\", \"-B\", block_size])\n            .succeeds()\n            .stdout_move_str();\n        output\n            .lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }\n\n    assert_eq!(get_header(\"1024\"), \"1024-blocks\");\n    assert_eq!(get_header(\"1K\"), \"1024-blocks\");\n    assert_eq!(get_header(\"1KB\"), \"1000-blocks\");\n    assert_eq!(get_header(\"1M\"), \"1048576-blocks\");\n    assert_eq!(get_header(\"1MB\"), \"1000000-blocks\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::get_header", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_block_size_from_env", "test": "fn test_block_size_from_env() {\n    fn get_header(env_var: &str, env_value: &str) -> String {\n        let output = new_ucmd!()\n            .arg(\"--output=size\")\n            .env(env_var, env_value)\n            .succeeds()\n            .stdout_move_str();\n        output.lines().next().unwrap().trim().to_string()\n    }\n\n    assert_eq!(get_header(\"DF_BLOCK_SIZE\", \"111\"), \"111B-blocks\");\n    assert_eq!(get_header(\"BLOCK_SIZE\", \"222\"), \"222B-blocks\");\n    assert_eq!(get_header(\"BLOCKSIZE\", \"333\"), \"333B-blocks\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::get_header", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_block_size_from_env_precedences", "test": "fn test_block_size_from_env_precedences() {\n    fn get_header(one: (&str, &str), two: (&str, &str)) -> String {\n        let (k1, v1) = one;\n        let (k2, v2) = two;\n        let output = new_ucmd!()\n            .arg(\"--output=size\")\n            .env(k1, v1)\n            .env(k2, v2)\n            .succeeds()\n            .stdout_move_str();\n        output.lines().next().unwrap().trim().to_string()\n    }\n\n    let df_block_size = (\"DF_BLOCK_SIZE\", \"111\");\n    let block_size = (\"BLOCK_SIZE\", \"222\");\n    let blocksize = (\"BLOCKSIZE\", \"333\");\n\n    assert_eq!(get_header(df_block_size, block_size), \"111B-blocks\");\n    assert_eq!(get_header(df_block_size, blocksize), \"111B-blocks\");\n    assert_eq!(get_header(block_size, blocksize), \"222B-blocks\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::get_header", "code": "fn get_header(s: &str) -> String {\n        s.lines()\n            .next()\n            .unwrap()\n            .to_string()\n            .split_whitespace()\n            .nth(1)\n            .unwrap()\n            .trim()\n            .to_string()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_output_selects_columns", "test": "fn test_output_selects_columns() {\n    let output = new_ucmd!()\n        .args(&[\"--output=source\"])\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(output.lines().next().unwrap(), \"Filesystem\");\n\n    let output = new_ucmd!()\n        .args(&[\"--output=source,target\"])\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(\n        output\n            .lines()\n            .next()\n            .unwrap()\n            .split_whitespace()\n            .collect::<Vec<_>>(),\n        vec![\"Filesystem\", \"Mounted\", \"on\"]\n    );\n\n    let output = new_ucmd!()\n        .args(&[\"--output=source,target,used\"])\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(\n        output\n            .lines()\n            .next()\n            .unwrap()\n            .split_whitespace()\n            .collect::<Vec<_>>(),\n        vec![\"Filesystem\", \"Mounted\", \"on\", \"Used\"]\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/cut/src/searcher.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.matcher.next_match(&self.haystack[self.position..]) {\n            Some((first, last)) => {\n                let result = (first + self.position, last + self.position);\n                self.position += last;\n                Some(result)\n            }\n            None => None,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_output_file_all_filesystems", "test": "fn test_output_file_all_filesystems() {\n    // When run with no positional arguments, `df` lets \"-\" represent\n    // the \"File\" entry for each row.\n    let output = new_ucmd!()\n        .arg(\"--output=file\")\n        .succeeds()\n        .stdout_move_str();\n    let mut lines = output.lines();\n    assert_eq!(lines.next().unwrap(), \"File\");\n    for line in lines {\n        assert_eq!(line, \"-\");\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uucore/src/lib/features/lines.rs::next", "code": "fn next(&mut self) -> Option<std::io::Result<Vec<u8>>> {\n        let mut buf = Vec::new();\n        match self.buf.read_until(self.sep, &mut buf) {\n            Ok(0) => None,\n            Ok(_n) => Some(Ok(buf)),\n            Err(e) => Some(Err(e)),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_shell_syntax", "test": "fn test_shell_syntax() {\n    use std::env;\n    let last = env::var(\"SHELL\");\n    env::set_var(\"SHELL\", \"/path/csh\");\n    assert_eq!(OutputFmt::CShell, guess_syntax());\n    env::set_var(\"SHELL\", \"csh\");\n    assert_eq!(OutputFmt::CShell, guess_syntax());\n    env::set_var(\"SHELL\", \"/path/bash\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"bash\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"/asd/bar\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"foo\");\n    assert_eq!(OutputFmt::Shell, guess_syntax());\n    env::set_var(\"SHELL\", \"\");\n    assert_eq!(OutputFmt::Unknown, guess_syntax());\n    env::remove_var(\"SHELL\");\n    assert_eq!(OutputFmt::Unknown, guess_syntax());\n\n    if let Ok(s) = last {\n        env::set_var(\"SHELL\", s);\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dircolors/src/dircolors.rs::guess_syntax", "code": "pub fn guess_syntax() -> OutputFmt {\n    match env::var(\"SHELL\") {\n        Ok(ref s) if !s.is_empty() => {\n            let shell_path: &Path = s.as_ref();\n            if let Some(name) = shell_path.file_name() {\n                if name == \"csh\" || name == \"tcsh\" {\n                    OutputFmt::CShell\n                } else {\n                    OutputFmt::Shell\n                }\n            } else {\n                OutputFmt::Shell\n            }\n        }\n        _ => OutputFmt::Unknown,\n    }\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_str_utils", "test": "fn test_str_utils() {\n    let s = \"  asd#zcv #hk\\t\\n  \";\n    assert_eq!(\"asd#zcv\", s.purify());\n\n    let s = \"con256asd\";\n    assert!(s.fnmatch(\"*[2][3-6][5-9]?sd\")); // spell-checker:disable-line\n\n    let s = \"zxc \\t\\nqwe jlk    hjl\"; // spell-checker:disable-line\n    let (k, v) = s.split_two();\n    assert_eq!(\"zxc\", k);\n    assert_eq!(\"qwe jlk    hjl\", v);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dircolors/src/dircolors.rs::purify", "code": "fn purify(&self) -> &Self {\n        let mut line = self;\n        for (n, _) in self\n            .as_bytes()\n            .iter()\n            .enumerate()\n            .filter(|(_, c)| **c == b'#')\n        {\n            // Ignore the content after '#'\n            // only if it is preceded by at least one whitespace\n            match self[..n].chars().last() {\n                Some(c) if c.is_whitespace() => {\n                    line = &self[..n - c.len_utf8()];\n                    break;\n                }\n                None => {\n                    // n == 0\n                    line = &self[..0];\n                    break;\n                }\n                _ => (),\n            }\n        }\n        line.trim()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_basics_subdir", "test": "fn test_du_basics_subdir() {\n    let ts = TestScenario::new(util_name!());\n\n    let result = ts.ucmd().arg(SUB_DIR).succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[SUB_DIR]));\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n    _du_basics_subdir(result.stdout_str());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_soft_link", "test": "fn test_du_soft_link() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.symlink_file(SUB_FILE, SUB_LINK);\n\n    let result = ts.ucmd().arg(SUB_DIR_LINKS).succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[SUB_DIR_LINKS]));\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n    _du_soft_link(result.stdout_str());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_hard_link", "test": "fn test_du_hard_link() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.hard_link(SUB_FILE, SUB_LINK);\n\n    let result = ts.ucmd().arg(SUB_DIR_LINKS).succeeds();\n\n    #[cfg(target_os = \"linux\")]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[SUB_DIR_LINKS]));\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n    // We do not double count hard links as the inodes are identical\n    _du_hard_link(result.stdout_str());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_d_flag", "test": "fn test_du_d_flag() {\n    let ts = TestScenario::new(util_name!());\n\n    let result = ts.ucmd().arg(\"-d1\").succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[\"-d1\"]));\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n    _du_d_flag(result.stdout_str());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_dereference", "test": "fn test_du_dereference() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.symlink_dir(SUB_DEEPER_DIR, SUB_DIR_LINKS_DEEPER_SYM_DIR);\n\n    let result = ts.ucmd().arg(\"-L\").arg(SUB_DIR_LINKS).succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[\"-L\", SUB_DIR_LINKS]));\n\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n\n    _du_dereference(result.stdout_str());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_inodes_basic", "test": "fn test_du_inodes_basic() {\n    let ts = TestScenario::new(util_name!());\n    let result = ts.ucmd().arg(\"--inodes\").succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[\"--inodes\"]));\n        assert_eq!(result.stdout_str(), result_reference.stdout_str());\n    }\n\n    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n    _du_inodes_basic(result.stdout_str());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_inodes", "test": "fn test_du_inodes() {\n    let ts = TestScenario::new(util_name!());\n\n    ts.ucmd()\n        .arg(\"--summarize\")\n        .arg(\"--inodes\")\n        .succeeds()\n        .stdout_only(\"11\\t.\\n\");\n\n    let result = ts.ucmd().arg(\"--separate-dirs\").arg(\"--inodes\").succeeds();\n\n    #[cfg(target_os = \"windows\")]\n    result.stdout_contains(\"3\\t.\\\\subdir\\\\links\\n\");\n    #[cfg(not(target_os = \"windows\"))]\n    result.stdout_contains(\"3\\t./subdir/links\\n\");\n    result.stdout_contains(\"3\\t.\\n\");\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference =\n            unwrap_or_return!(expected_result(&ts, &[\"--separate-dirs\", \"--inodes\"]));\n        assert_eq!(result.stdout_str(), result_reference.stdout_str());\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_no_permission", "test": "fn test_du_no_permission() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.mkdir_all(SUB_DIR_LINKS);\n\n    ts.ccmd(\"chmod\").arg(\"-r\").arg(SUB_DIR_LINKS).succeeds();\n\n    let result = ts.ucmd().arg(SUB_DIR_LINKS).fails();\n    result.stderr_contains(\"du: cannot read directory 'subdir/links': Permission denied\");\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[SUB_DIR_LINKS]));\n        if result_reference\n            .stderr_str()\n            .contains(\"du: cannot read directory 'subdir/links': Permission denied\")\n        {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n\n    _du_no_permission(result.stdout_str());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_one_file_system", "test": "fn test_du_one_file_system() {\n    let ts = TestScenario::new(util_name!());\n\n    let result = ts.ucmd().arg(\"-x\").arg(SUB_DIR).succeeds();\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    {\n        let result_reference = unwrap_or_return!(expected_result(&ts, &[\"-x\", SUB_DIR]));\n        if result_reference.succeeded() {\n            assert_eq!(result.stdout_str(), result_reference.stdout_str());\n            return;\n        }\n    }\n    _du_basics_subdir(result.stdout_str());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_symlink_multiple_fail", "test": "fn test_du_symlink_multiple_fail() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.symlink_file(\"non-existing.txt\", \"target.txt\");\n    let mut file1 = at.make_file(\"file1\");\n    file1.write_all(b\"azeaze\").unwrap();\n\n    let result = ts.ucmd().arg(\"-L\").arg(\"target.txt\").arg(\"file1\").fails();\n    assert_eq!(result.code(), 1);\n    result.stdout_contains(\"4\\tfile1\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uucore/src/lib/features/backup_control.rs::code", "code": "fn code(&self) -> i32 {\n        match self {\n            Self::BackupImpossible() => 2,\n            _ => 1,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_file_option", "test": "fn test_file_option() {\n    let out = new_ucmd!()\n        .arg(\"-f\")\n        .arg(\"vars.conf.txt\")\n        .run()\n        .stdout_move_str();\n\n    assert_eq!(\n        out.lines()\n            .filter(|&line| line == \"FOO=bar\" || line == \"BAR=bamf this\")\n            .count(),\n        2\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_combined_file_set", "test": "fn test_combined_file_set() {\n    let out = new_ucmd!()\n        .arg(\"-f\")\n        .arg(\"vars.conf.txt\")\n        .arg(\"FOO=bar.alt\")\n        .run()\n        .stdout_move_str();\n\n    assert_eq!(out.lines().filter(|&line| line == \"FOO=bar.alt\").count(), 1);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_combined_file_set_unset", "test": "fn test_combined_file_set_unset() {\n    let out = new_ucmd!()\n        .arg(\"-u\")\n        .arg(\"BAR\")\n        .arg(\"-f\")\n        .arg(\"vars.conf.txt\")\n        .arg(\"FOO=bar.alt\")\n        .succeeds()\n        .stdout_move_str();\n\n    assert_eq!(\n        out.lines()\n            .filter(|&line| line == \"FOO=bar.alt\" || line.starts_with(\"BAR=\"))\n            .count(),\n        1\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_multiple_name_value_pairs", "test": "fn test_multiple_name_value_pairs() {\n    let out = new_ucmd!().arg(\"FOO=bar\").arg(\"ABC=xyz\").run();\n\n    assert_eq!(\n        out.stdout_str()\n            .lines()\n            .filter(|&line| line == \"FOO=bar\" || line == \"ABC=xyz\")\n            .count(),\n        2\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_null_delimiter", "test": "fn test_null_delimiter() {\n    let out = new_ucmd!()\n        .arg(\"-i\")\n        .arg(\"--null\")\n        .arg(\"FOO=bar\")\n        .arg(\"ABC=xyz\")\n        .succeeds()\n        .stdout_move_str();\n\n    let mut vars: Vec<_> = out.split('\\0').collect();\n    assert_eq!(vars.len(), 3);\n    vars.sort_unstable();\n    assert_eq!(vars[0], \"\");\n    assert_eq!(vars[1], \"ABC=xyz\");\n    assert_eq!(vars[2], \"FOO=bar\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::len", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hostname.rs::test_hostname", "test": "fn test_hostname() {\n    let ls_default_res = new_ucmd!().succeeds();\n    let ls_short_res = new_ucmd!().arg(\"-s\").succeeds();\n    let ls_domain_res = new_ucmd!().arg(\"-d\").succeeds();\n\n    assert!(ls_default_res.stdout().len() >= ls_short_res.stdout().len());\n    assert!(ls_default_res.stdout().len() >= ls_domain_res.stdout().len());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::len", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hostname.rs::test_hostname_ip", "test": "fn test_hostname_ip() {\n    let result = new_ucmd!().arg(\"-i\").succeeds();\n    assert!(!result.stdout_str().trim().is_empty());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_hostname.rs::test_hostname_full", "test": "fn test_hostname_full() {\n    let ls_short_res = new_ucmd!().arg(\"-s\").succeeds();\n    assert!(!ls_short_res.stdout_str().trim().is_empty());\n\n    new_ucmd!()\n        .arg(\"-f\")\n        .succeeds()\n        .stdout_contains(ls_short_res.stdout_str().trim());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_basic", "test": "fn test_install_basic() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"target_dir\";\n    let file1 = \"source_file1\";\n    let file2 = \"source_file2\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.mkdir(dir);\n    ucmd.arg(file1).arg(file2).arg(dir).succeeds().no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n    assert!(at.file_exists(format!(\"{dir}/{file1}\")));\n    assert!(at.file_exists(format!(\"{dir}/{file2}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_twice_dir", "test": "fn test_install_twice_dir() {\n    let dir = \"dir\";\n    let scene = TestScenario::new(util_name!());\n\n    scene.ucmd().arg(\"-d\").arg(dir).succeeds();\n    scene.ucmd().arg(\"-d\").arg(dir).succeeds();\n    let at = &scene.fixtures;\n\n    assert!(at.dir_exists(dir));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_unimplemented_arg", "test": "fn test_install_unimplemented_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"target_dir\";\n    let file = \"source_file\";\n    let context_arg = \"--context\";\n\n    at.touch(file);\n    at.mkdir(dir);\n    ucmd.arg(context_arg)\n        .arg(file)\n        .arg(dir)\n        .fails()\n        .stderr_contains(\"Unimplemented\");\n\n    assert!(!at.file_exists(format!(\"{dir}/{file}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_ancestors_directories", "test": "fn test_install_ancestors_directories() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ancestor1 = \"ancestor1\";\n    let ancestor2 = \"ancestor1/ancestor2\";\n    let target_dir = \"ancestor1/ancestor2/target_dir\";\n    let directories_arg = \"-d\";\n\n    ucmd.args(&[directories_arg, target_dir])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(ancestor1));\n    assert!(at.dir_exists(ancestor2));\n    assert!(at.dir_exists(target_dir));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_ancestors_mode_directories", "test": "fn test_install_ancestors_mode_directories() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ancestor1 = \"ancestor1\";\n    let ancestor2 = \"ancestor1/ancestor2\";\n    let target_dir = \"ancestor1/ancestor2/target_dir\";\n    let directories_arg = \"-d\";\n    let mode_arg = \"--mode=200\";\n    let probe = \"probe\";\n\n    at.mkdir(probe);\n    let default_perms = at.metadata(probe).permissions().mode();\n\n    ucmd.args(&[mode_arg, directories_arg, target_dir])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(ancestor1));\n    assert!(at.dir_exists(ancestor2));\n    assert!(at.dir_exists(target_dir));\n\n    assert_eq!(default_perms, at.metadata(ancestor1).permissions().mode());\n    assert_eq!(default_perms, at.metadata(ancestor2).permissions().mode());\n\n    // Expected mode only on the target_dir.\n    assert_eq!(0o40_200_u32, at.metadata(target_dir).permissions().mode());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_ancestors_mode_directories_with_file", "test": "fn test_install_ancestors_mode_directories_with_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ancestor1 = \"ancestor1\";\n    let ancestor2 = \"ancestor1/ancestor2\";\n    let target_file = \"ancestor1/ancestor2/target_file\";\n    let directories_arg = \"-D\";\n    let mode_arg = \"--mode=200\";\n    let file = \"file\";\n    let probe = \"probe\";\n\n    at.mkdir(probe);\n    let default_perms = at.metadata(probe).permissions().mode();\n\n    at.touch(file);\n\n    ucmd.args(&[mode_arg, directories_arg, file, target_file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(ancestor1));\n    assert!(at.dir_exists(ancestor2));\n    assert!(at.file_exists(target_file));\n\n    assert_eq!(default_perms, at.metadata(ancestor1).permissions().mode());\n    assert_eq!(default_perms, at.metadata(ancestor2).permissions().mode());\n\n    // Expected mode only on the target_file.\n    assert_eq!(0o100_200_u32, at.metadata(target_file).permissions().mode());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_parent_directories", "test": "fn test_install_parent_directories() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ancestor1 = \"ancestor1\";\n    let ancestor2 = \"ancestor1/ancestor2\";\n    let target_dir = \"ancestor1/ancestor2/target_dir\";\n    let directories_arg = \"-d\";\n\n    // Here one of the ancestors already exist and only the target_dir and\n    // its parent must be created.\n    at.mkdir(ancestor1);\n\n    ucmd.args(&[directories_arg, target_dir])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(ancestor2));\n    assert!(at.dir_exists(target_dir));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_several_directories", "test": "fn test_install_several_directories() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir1 = \"dir1\";\n    let dir2 = \"dir2\";\n    let dir3 = \"dir3\";\n    let directories_arg = \"-d\";\n\n    ucmd.args(&[directories_arg, dir1, dir2, dir3])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(dir1));\n    assert!(at.dir_exists(dir2));\n    assert!(at.dir_exists(dir3));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_mode_numeric", "test": "fn test_install_mode_numeric() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"dir1\";\n    let dir2 = \"dir2\";\n\n    let file = \"file\";\n    let mode_arg = \"--mode=333\";\n\n    at.touch(file);\n    at.mkdir(dir);\n    scene\n        .ucmd()\n        .arg(file)\n        .arg(dir)\n        .arg(mode_arg)\n        .succeeds()\n        .no_stderr();\n\n    let dest_file = &format!(\"{dir}/{file}\");\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(dest_file));\n    let permissions = at.metadata(dest_file).permissions();\n    assert_eq!(0o100_333_u32, PermissionsExt::mode(&permissions));\n\n    let mode_arg = \"-m 0333\";\n    at.mkdir(dir2);\n\n    scene.ucmd().arg(mode_arg).arg(file).arg(dir2).succeeds();\n\n    let dest_file = &format!(\"{dir2}/{file}\");\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(dest_file));\n    let permissions = at.metadata(dest_file).permissions();\n    assert_eq!(0o100_333_u32, PermissionsExt::mode(&permissions));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_mode_symbolic", "test": "fn test_install_mode_symbolic() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"target_dir\";\n    let file = \"source_file\";\n    let mode_arg = \"--mode=o+wx\";\n\n    at.touch(file);\n    at.mkdir(dir);\n    ucmd.arg(file).arg(dir).arg(mode_arg).succeeds().no_stderr();\n\n    let dest_file = &format!(\"{dir}/{file}\");\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(dest_file));\n    let permissions = at.metadata(dest_file).permissions();\n    assert_eq!(0o100_003_u32, PermissionsExt::mode(&permissions));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_mode_failing", "test": "fn test_install_mode_failing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"target_dir\";\n    let file = \"source_file\";\n    let mode_arg = \"--mode=999\";\n\n    at.touch(file);\n    at.mkdir(dir);\n    ucmd.arg(file)\n        .arg(dir)\n        .arg(mode_arg)\n        .fails()\n        .stderr_contains(\"Invalid mode string: invalid digit found in string\");\n\n    let dest_file = &format!(\"{dir}/{file}\");\n    assert!(at.file_exists(file));\n    assert!(!at.file_exists(dest_file));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_mode_directories", "test": "fn test_install_mode_directories() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let component = \"component\";\n    let directories_arg = \"-d\";\n    let mode_arg = \"--mode=333\";\n\n    ucmd.arg(directories_arg)\n        .arg(component)\n        .arg(mode_arg)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(component));\n    let permissions = at.metadata(component).permissions();\n    assert_eq!(0o040_333_u32, PermissionsExt::mode(&permissions));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_target_file", "test": "fn test_install_target_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let file2 = \"target_file\";\n\n    at.touch(file1);\n    at.touch(file2);\n    ucmd.arg(file1).arg(file2).succeeds().no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_target_new_file", "test": "fn test_install_target_new_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"file\";\n    let dir = \"target_dir\";\n\n    at.touch(file);\n    at.mkdir(dir);\n    ucmd.arg(file)\n        .arg(format!(\"{dir}/{file}\"))\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_target_new_file_with_group", "test": "fn test_install_target_new_file_with_group() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"file\";\n    let dir = \"target_dir\";\n    let gid = getegid();\n\n    at.touch(file);\n    at.mkdir(dir);\n    let result = ucmd\n        .arg(file)\n        .arg(\"--group\")\n        .arg(gid.to_string())\n        .arg(format!(\"{dir}/{file}\"))\n        .run();\n\n    if is_ci() && result.stderr_str().contains(\"no such group:\") {\n        // In the CI, some server are failing to return the group.\n        // As seems to be a configuration issue, ignoring it\n        return;\n    }\n\n    result.success();\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_target_new_file_with_owner", "test": "fn test_install_target_new_file_with_owner() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"file\";\n    let dir = \"target_dir\";\n    let uid = geteuid();\n\n    at.touch(file);\n    at.mkdir(dir);\n    let result = ucmd\n        .arg(file)\n        .arg(\"--owner\")\n        .arg(uid.to_string())\n        .arg(format!(\"{dir}/{file}\"))\n        .run();\n\n    if is_ci() && result.stderr_str().contains(\"no such user:\") {\n        // In the CI, some server are failing to return the user id.\n        // As seems to be a configuration issue, ignoring it\n        return;\n    }\n\n    result.success();\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_preserve_timestamps", "test": "fn test_install_preserve_timestamps() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let file2 = \"target_file\";\n    at.touch(file1);\n\n    ucmd.arg(file1).arg(file2).arg(\"-p\").succeeds().no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n\n    let file1_metadata = at.metadata(file1);\n    let file2_metadata = at.metadata(file2);\n\n    assert_eq!(\n        file1_metadata.accessed().ok(),\n        file2_metadata.accessed().ok()\n    );\n    assert_eq!(\n        file1_metadata.modified().ok(),\n        file2_metadata.modified().ok()\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_copy_file", "test": "fn test_install_copy_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let file2 = \"target_file\";\n\n    at.touch(file1);\n    ucmd.arg(file1).arg(file2).succeeds().no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_nested_paths_copy_file", "test": "fn test_install_nested_paths_copy_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"source_file\";\n    let dir1 = \"source_dir\";\n    let dir2 = \"target_dir\";\n\n    at.mkdir(dir1);\n    at.mkdir(dir2);\n    at.touch(format!(\"{dir1}/{file1}\"));\n\n    ucmd.arg(format!(\"{dir1}/{file1}\"))\n        .arg(dir2)\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(format!(\"{dir2}/{file1}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_failing_omitting_directory", "test": "fn test_install_failing_omitting_directory() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file1 = \"file1\";\n    let dir1 = \"dir1\";\n    let no_dir2 = \"no-dir2\";\n    let dir3 = \"dir3\";\n\n    at.mkdir(dir1);\n    at.mkdir(dir3);\n    at.touch(file1);\n\n    // GNU install checks for existing target dir first before checking on source params\n    scene\n        .ucmd()\n        .arg(file1)\n        .arg(dir1)\n        .arg(no_dir2)\n        .fails()\n        .stderr_contains(\"is not a directory\");\n\n    // file1 will be copied before install fails on dir1\n    scene\n        .ucmd()\n        .arg(file1)\n        .arg(dir1)\n        .arg(dir3)\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"omitting directory\");\n    assert!(at.file_exists(format!(\"{dir3}/{file1}\")));\n\n    // install also fails, when only one source param is given\n    scene\n        .ucmd()\n        .arg(dir1)\n        .arg(dir3)\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"omitting directory\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_creating_leading_dirs", "test": "fn test_install_creating_leading_dirs() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let source = \"create_leading_test_file\";\n    let target = \"dir1/dir2/dir3/test_file\";\n\n    at.touch(source);\n\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source)\n        .arg(at.plus(target))\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(target));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_creating_leading_dirs_verbose", "test": "fn test_install_creating_leading_dirs_verbose() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let source = \"create_leading_test_file\";\n    let target = \"dir1/no-dir2/no-dir3/test_file\";\n\n    at.touch(source);\n    at.mkdir(\"dir1\");\n\n    let creating_dir1 = regex::Regex::new(\"(?m)^install: creating directory.*dir1'$\").unwrap();\n    let creating_nodir23 =\n        regex::Regex::new(r\"(?m)^install: creating directory.*no-dir[23]'$\").unwrap();\n\n    scene\n        .ucmd()\n        .arg(\"-Dv\")\n        .arg(source)\n        .arg(at.plus(target))\n        .succeeds()\n        .stdout_matches(&creating_nodir23)\n        .stdout_does_not_match(&creating_dir1)\n        .no_stderr();\n\n    assert!(at.file_exists(target));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_creating_leading_dirs_with_single_source_and_target_dir", "test": "fn test_install_creating_leading_dirs_with_single_source_and_target_dir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let source1 = \"source_file_1\";\n    let target_dir = \"missing_target_dir/\";\n\n    at.touch(source1);\n\n    // installing a single file into a missing directory will fail, when -D is used w/o -t parameter\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source1)\n        .arg(at.plus(target_dir))\n        .fails()\n        .stderr_contains(\"missing_target_dir/' is not a directory\");\n\n    assert!(!at.dir_exists(target_dir));\n\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source1)\n        .arg(\"-t\")\n        .arg(at.plus(target_dir))\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(format!(\"{target_dir}/{source1}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_creating_leading_dirs_with_multiple_sources_and_target_dir", "test": "fn test_install_creating_leading_dirs_with_multiple_sources_and_target_dir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let source1 = \"source_file_1\";\n    let source2 = \"source_file_2\";\n    let target_dir = \"missing_target_dir\";\n\n    at.touch(source1);\n    at.touch(source2);\n\n    // installing multiple files into a missing directory will fail, when -D is used w/o -t parameter\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source1)\n        .arg(source2)\n        .arg(at.plus(target_dir))\n        .fails()\n        .stderr_contains(\"missing_target_dir' is not a directory\");\n\n    assert!(!at.dir_exists(target_dir));\n\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(source1)\n        .arg(source2)\n        .arg(\"-t\")\n        .arg(at.plus(target_dir))\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(target_dir));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_dir", "test": "fn test_install_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"target_dir\";\n    let file1 = \"source_file1\";\n    let file2 = \"source_file2\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.mkdir(dir);\n    ucmd.arg(file1)\n        .arg(file2)\n        .arg(&format!(\"--target-directory={dir}\"))\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n    assert!(at.file_exists(format!(\"{dir}/{file1}\")));\n    assert!(at.file_exists(format!(\"{dir}/{file2}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_no_args_files", "test": "fn test_install_backup_short_no_args_files() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_simple_backup_file_a\";\n    let file_b = \"test_install_simple_backup_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_no_args_file_to_dir", "test": "fn test_install_backup_short_no_args_file_to_dir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file = \"test_install_simple_backup_file_a\";\n    let dest_dir = \"test_install_dest/\";\n    let expect = format!(\"{dest_dir}{file}\");\n\n    at.touch(file);\n    at.mkdir(dest_dir);\n    at.touch(&expect);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .arg(file)\n        .arg(dest_dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(&expect));\n    assert!(at.file_exists(format!(\"{expect}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_long_no_args_files", "test": "fn test_install_backup_long_no_args_files() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_simple_backup_file_a\";\n    let file_b = \"test_install_simple_backup_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_long_no_args_file_to_dir", "test": "fn test_install_backup_long_no_args_file_to_dir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file = \"test_install_simple_backup_file_a\";\n    let dest_dir = \"test_install_dest/\";\n    let expect = format!(\"{dest_dir}{file}\");\n\n    at.touch(file);\n    at.mkdir(dest_dir);\n    at.touch(&expect);\n    scene\n        .ucmd()\n        .arg(\"--backup\")\n        .arg(file)\n        .arg(dest_dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(&expect));\n    assert!(at.file_exists(format!(\"{expect}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_custom_suffix", "test": "fn test_install_backup_short_custom_suffix() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_custom_suffix_file_a\";\n    let file_b = \"test_install_backup_custom_suffix_file_b\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .arg(format!(\"--suffix={suffix}\"))\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_short_custom_suffix_hyphen_value", "test": "fn test_install_backup_short_custom_suffix_hyphen_value() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_custom_suffix_file_a\";\n    let file_b = \"test_install_backup_custom_suffix_file_b\";\n    let suffix = \"-v\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .arg(format!(\"--suffix={suffix}\"))\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_custom_suffix_via_env", "test": "fn test_install_backup_custom_suffix_via_env() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_custom_suffix_file_a\";\n    let file_b = \"test_install_backup_custom_suffix_file_b\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"-b\")\n        .env(\"SIMPLE_BACKUP_SUFFIX\", suffix)\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_numbered_with_t", "test": "fn test_install_backup_numbered_with_t() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=t\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}.~1~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_numbered_with_numbered", "test": "fn test_install_backup_numbered_with_numbered() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=numbered\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}.~1~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_existing", "test": "fn test_install_backup_existing() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=existing\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_nil", "test": "fn test_install_backup_nil() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=nil\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_numbered_if_existing_backup_existing", "test": "fn test_install_backup_numbered_if_existing_backup_existing() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n    let file_b_backup = \"test_install_backup_numbering_file_b.~1~\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.touch(file_b_backup);\n    scene\n        .ucmd()\n        .arg(\"--backup=existing\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(file_b_backup));\n    assert!(at.file_exists(format!(\"{file_b}.~2~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_numbered_if_existing_backup_nil", "test": "fn test_install_backup_numbered_if_existing_backup_nil() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n    let file_b_backup = \"test_install_backup_numbering_file_b.~1~\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.touch(file_b_backup);\n    scene\n        .ucmd()\n        .arg(\"--backup=nil\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(file_b_backup));\n    assert!(at.file_exists(format!(\"{file_b}.~2~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_simple", "test": "fn test_install_backup_simple() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=simple\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_never", "test": "fn test_install_backup_never() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=never\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_none", "test": "fn test_install_backup_none() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=none\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(!at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_backup_off", "test": "fn test_install_backup_off() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_install_backup_numbering_file_a\";\n    let file_b = \"test_install_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    scene\n        .ucmd()\n        .arg(\"--backup=off\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(!at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_missing_arguments", "test": "fn test_install_missing_arguments() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let no_target_dir = \"no-target_dir\";\n\n    scene\n        .ucmd()\n        .fails()\n        .code_is(1)\n        .usage_error(\"missing file operand\");\n\n    scene\n        .ucmd()\n        .arg(\"-D\")\n        .arg(format!(\"-t {no_target_dir}\"))\n        .fails()\n        .usage_error(\"missing file operand\");\n    assert!(!at.dir_exists(no_target_dir));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_install.rs::test_install_dir_dot", "test": "fn test_install_dir_dot() {\n    // To match tests/install/d-slashdot.sh\n    let scene = TestScenario::new(util_name!());\n\n    scene.ucmd().arg(\"-d\").arg(\"dir1/.\").succeeds();\n    scene.ucmd().arg(\"-d\").arg(\"dir2/..\").succeeds();\n    // Tests that we don't have dir3/. in the output\n    // but only 'dir3'\n    scene\n        .ucmd()\n        .arg(\"-d\")\n        .arg(\"dir3/.\")\n        .arg(\"-v\")\n        .succeeds()\n        .stdout_contains(\"creating directory 'dir3'\");\n    scene\n        .ucmd()\n        .arg(\"-d\")\n        .arg(\"dir4/./cal\")\n        .arg(\"-v\")\n        .succeeds()\n        .stdout_contains(\"creating directory 'dir4/./cal'\");\n    scene\n        .ucmd()\n        .arg(\"-d\")\n        .arg(\"dir5/./cali/.\")\n        .arg(\"-v\")\n        .succeeds()\n        .stdout_contains(\"creating directory 'dir5/cali'\");\n\n    let at = &scene.fixtures;\n\n    assert!(at.dir_exists(\"dir1\"));\n    assert!(at.dir_exists(\"dir2\"));\n    assert!(at.dir_exists(\"dir3\"));\n    assert!(at.dir_exists(\"dir4/cal\"));\n    assert!(at.dir_exists(\"dir5/cali\"));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_list_final_new_line", "test": "fn test_kill_list_final_new_line() {\n    let re = Regex::new(\"\\\\n$\").unwrap();\n    assert!(re.is_match(new_ucmd!().arg(\"-l\").succeeds().stdout_str()));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_default_signal", "test": "fn test_kill_with_default_signal() {\n    let mut target = Target::new();\n    new_ucmd!().arg(format!(\"{}\", target.pid())).succeeds();\n    assert_eq!(target.wait_for_signal(), Some(libc::SIGTERM));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::wait_for_signal", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_signal_number_old_form", "test": "fn test_kill_with_signal_number_old_form() {\n    let mut target = Target::new();\n    new_ucmd!()\n        .arg(\"-9\")\n        .arg(format!(\"{}\", target.pid()))\n        .succeeds();\n    assert_eq!(target.wait_for_signal(), Some(9));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::wait_for_signal", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_signal_name_old_form", "test": "fn test_kill_with_signal_name_old_form() {\n    let mut target = Target::new();\n    new_ucmd!()\n        .arg(\"-KILL\")\n        .arg(format!(\"{}\", target.pid()))\n        .succeeds();\n    assert_eq!(target.wait_for_signal(), Some(libc::SIGKILL));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::wait_for_signal", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_signal_prefixed_name_old_form", "test": "fn test_kill_with_signal_prefixed_name_old_form() {\n    let mut target = Target::new();\n    new_ucmd!()\n        .arg(\"-SIGKILL\")\n        .arg(format!(\"{}\", target.pid()))\n        .succeeds();\n    assert_eq!(target.wait_for_signal(), Some(libc::SIGKILL));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::wait_for_signal", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_signal_number_new_form", "test": "fn test_kill_with_signal_number_new_form() {\n    let mut target = Target::new();\n    new_ucmd!()\n        .arg(\"-s\")\n        .arg(\"9\")\n        .arg(format!(\"{}\", target.pid()))\n        .succeeds();\n    assert_eq!(target.wait_for_signal(), Some(9));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::wait_for_signal", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_signal_name_new_form", "test": "fn test_kill_with_signal_name_new_form() {\n    let mut target = Target::new();\n    new_ucmd!()\n        .arg(\"-s\")\n        .arg(\"KILL\")\n        .arg(format!(\"{}\", target.pid()))\n        .succeeds();\n    assert_eq!(target.wait_for_signal(), Some(libc::SIGKILL));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::wait_for_signal", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::test_kill_with_signal_prefixed_name_new_form", "test": "fn test_kill_with_signal_prefixed_name_new_form() {\n    let mut target = Target::new();\n    new_ucmd!()\n        .arg(\"-s\")\n        .arg(\"SIGKILL\")\n        .arg(format!(\"{}\", target.pid()))\n        .succeeds();\n    assert_eq!(target.wait_for_signal(), Some(libc::SIGKILL));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_kill.rs::wait_for_signal", "code": "fn wait_for_signal(&mut self) -> Option<i32> {\n        let sig = self.child.wait().expect(\"cannot wait on target\").signal();\n        self.killed = true;\n        sig\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_link.rs::test_link_existing_file", "test": "fn test_link_existing_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_link_existing_file\";\n    let link = \"test_link_existing_file_link\";\n\n    at.touch(file);\n    at.write(file, \"foobar\");\n    assert!(at.file_exists(file));\n\n    ucmd.args(&[file, link]).succeeds().no_stderr();\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(link));\n    assert_eq!(at.read(file), at.read(link));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_link.rs::test_link_no_circular", "test": "fn test_link_no_circular() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let link = \"test_link_no_circular\";\n\n    ucmd.args(&[link, link])\n        .fails()\n        .stderr_is(\"link: cannot create link 'test_link_no_circular' to 'test_link_no_circular': No such file or directory\\n\");\n    assert!(!at.file_exists(link));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_link.rs::test_link_nonexistent_file", "test": "fn test_link_nonexistent_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_link_nonexistent_file\";\n    let link = \"test_link_nonexistent_file_link\";\n\n    ucmd.args(&[file, link])\n        .fails()\n        .stderr_only(\"link: cannot create link 'test_link_nonexistent_file_link' to 'test_link_nonexistent_file': No such file or directory\\n\");\n    assert!(!at.file_exists(file));\n    assert!(!at.file_exists(link));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_existing_file", "test": "fn test_symlink_existing_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_existing_file\";\n    let link = \"test_symlink_existing_file_link\";\n\n    at.touch(file);\n\n    ucmd.args(&[\"-s\", file, link]).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_dangling_file", "test": "fn test_symlink_dangling_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_dangling_file\";\n    let link = \"test_symlink_dangling_file_link\";\n\n    ucmd.args(&[\"-s\", file, link]).succeeds().no_stderr();\n    assert!(!at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_existing_directory", "test": "fn test_symlink_existing_directory() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_symlink_existing_dir\";\n    let link = \"test_symlink_existing_dir_link\";\n\n    at.mkdir(dir);\n\n    ucmd.args(&[\"-s\", dir, link]).succeeds().no_stderr();\n    assert!(at.dir_exists(dir));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), dir);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_dangling_directory", "test": "fn test_symlink_dangling_directory() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_symlink_dangling_dir\";\n    let link = \"test_symlink_dangling_dir_link\";\n\n    ucmd.args(&[\"-s\", dir, link]).succeeds().no_stderr();\n    assert!(!at.dir_exists(dir));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), dir);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_circular", "test": "fn test_symlink_circular() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let link = \"test_symlink_circular\";\n\n    ucmd.args(&[\"-s\", link]).succeeds().no_stderr();\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), link);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::is_symlink", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_do_not_overwrite", "test": "fn test_symlink_do_not_overwrite() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_do_not_overwrite\";\n    let link = \"test_symlink_do_not_overwrite_link\";\n\n    at.touch(file);\n    at.touch(link);\n\n    ucmd.args(&[\"-s\", file, link]).fails();\n    assert!(at.file_exists(file));\n    assert!(at.file_exists(link));\n    assert!(!at.is_symlink(link));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_overwrite_force", "test": "fn test_symlink_overwrite_force() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_symlink_overwrite_force_a\";\n    let file_b = \"test_symlink_overwrite_force_b\";\n    let link = \"test_symlink_overwrite_force_link\";\n\n    // Create symlink\n    at.symlink_file(file_a, link);\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file_a);\n\n    // Force overwrite of existing symlink\n    ucmd.args(&[\"--force\", \"-s\", file_b, link]).succeeds();\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file_b);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::is_symlink", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_interactive", "test": "fn test_symlink_interactive() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file = \"test_symlink_interactive_file\";\n    let link = \"test_symlink_interactive_file_link\";\n\n    at.touch(file);\n    at.touch(link);\n\n    scene\n        .ucmd()\n        .args(&[\"-i\", \"-s\", file, link])\n        .pipe_in(\"n\")\n        .fails()\n        .no_stdout();\n\n    assert!(at.file_exists(file));\n    assert!(!at.is_symlink(link));\n\n    scene\n        .ucmd()\n        .args(&[\"-i\", \"-s\", file, link])\n        .pipe_in(\"Yesh\") // spell-checker:disable-line\n        .succeeds()\n        .no_stdout();\n\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_simple_backup", "test": "fn test_symlink_simple_backup() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_simple_backup\";\n    let link = \"test_symlink_simple_backup_link\";\n\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    ucmd.args(&[\"-b\", \"-s\", file, link]).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let backup = &format!(\"{link}~\");\n    assert!(at.is_symlink(backup));\n    assert_eq!(at.resolve_link(backup), file);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_custom_backup_suffix", "test": "fn test_symlink_custom_backup_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_custom_backup_suffix\";\n    let link = \"test_symlink_custom_backup_suffix_link\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let arg = &format!(\"--suffix={suffix}\");\n    ucmd.args(&[\"-b\", arg, \"-s\", file, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let backup = &format!(\"{link}{suffix}\");\n    assert!(at.is_symlink(backup));\n    assert_eq!(at.resolve_link(backup), file);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_custom_backup_suffix_hyphen_value", "test": "fn test_symlink_custom_backup_suffix_hyphen_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_custom_backup_suffix\";\n    let link = \"test_symlink_custom_backup_suffix_link\";\n    let suffix = \"-v\";\n\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let arg = &format!(\"--suffix={suffix}\");\n    ucmd.args(&[\"-b\", arg, \"-s\", file, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let backup = &format!(\"{link}{suffix}\");\n    assert!(at.is_symlink(backup));\n    assert_eq!(at.resolve_link(backup), file);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_backup_numbering", "test": "fn test_symlink_backup_numbering() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_backup_numbering\";\n    let link = \"test_symlink_backup_numbering_link\";\n\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    ucmd.args(&[\"-s\", \"--backup=t\", file, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    let backup = &format!(\"{link}.~1~\");\n    assert!(at.is_symlink(backup));\n    assert_eq!(at.resolve_link(backup), file);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_existing_backup", "test": "fn test_symlink_existing_backup() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_symlink_existing_backup\";\n    let link = \"test_symlink_existing_backup_link\";\n    let link_backup = \"test_symlink_existing_backup_link.~1~\";\n    let resulting_backup = \"test_symlink_existing_backup_link.~2~\";\n\n    // Create symlink and verify\n    at.touch(file);\n    at.symlink_file(file, link);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file);\n\n    // Create backup symlink and verify\n    at.symlink_file(file, link_backup);\n    assert!(at.file_exists(file));\n    assert!(at.is_symlink(link_backup));\n    assert_eq!(at.resolve_link(link_backup), file);\n\n    ucmd.args(&[\"-s\", \"--backup=nil\", file, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file));\n\n    assert!(at.is_symlink(link_backup));\n    assert_eq!(at.resolve_link(link_backup), file);\n\n    assert!(at.is_symlink(resulting_backup));\n    assert_eq!(at.resolve_link(resulting_backup), file);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_target_dir", "test": "fn test_symlink_target_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_ln_target_dir_dir\";\n    let file_a = \"test_ln_target_dir_file_a\";\n    let file_b = \"test_ln_target_dir_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.mkdir(dir);\n\n    ucmd.args(&[\"-s\", \"-t\", dir, file_a, file_b])\n        .succeeds()\n        .no_stderr();\n\n    let file_a_link = &format!(\"{dir}/{file_a}\");\n    assert!(at.is_symlink(file_a_link));\n    assert_eq!(at.resolve_link(file_a_link), file_a);\n\n    let file_b_link = &format!(\"{dir}/{file_b}\");\n    assert!(at.is_symlink(file_b_link));\n    assert_eq!(at.resolve_link(file_b_link), file_b);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::is_symlink", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_target_dir_from_dir", "test": "fn test_symlink_target_dir_from_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_ln_target_dir_dir\";\n    let from_dir = \"test_ln_target_dir_from_dir\";\n    let filename_a = \"test_ln_target_dir_file_a\";\n    let filename_b = \"test_ln_target_dir_file_b\";\n    let file_a = &format!(\"{from_dir}/{filename_a}\");\n    let file_b = &format!(\"{from_dir}/{filename_b}\");\n\n    at.mkdir(from_dir);\n    at.touch(file_a);\n    at.touch(file_b);\n    at.mkdir(dir);\n\n    ucmd.args(&[\"-s\", \"-t\", dir, file_a, file_b])\n        .succeeds()\n        .no_stderr();\n\n    let file_a_link = &format!(\"{dir}/{filename_a}\");\n    assert!(at.is_symlink(file_a_link));\n    assert_eq!(&at.resolve_link(file_a_link), file_a);\n\n    let file_b_link = &format!(\"{dir}/{filename_b}\");\n    assert!(at.is_symlink(file_b_link));\n    assert_eq!(&at.resolve_link(file_b_link), file_b);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::is_symlink", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_overwrite_dir_fail", "test": "fn test_symlink_overwrite_dir_fail() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let path_a = \"test_symlink_overwrite_dir_a\";\n    let path_b = \"test_symlink_overwrite_dir_b\";\n\n    at.touch(path_a);\n    at.mkdir(path_b);\n\n    assert!(!ucmd\n        .args(&[\"-s\", \"-T\", path_a, path_b])\n        .fails()\n        .stderr_str()\n        .is_empty());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_target_only", "test": "fn test_symlink_target_only() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_symlink_target_only\";\n\n    at.mkdir(dir);\n\n    assert!(!ucmd\n        .args(&[\"-s\", \"-t\", dir])\n        .fails()\n        .stderr_str()\n        .is_empty());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_implicit_target_dir", "test": "fn test_symlink_implicit_target_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_symlink_implicit_target_dir\";\n    // On windows, slashes aren't allowed in symlink targets, so use\n    // PathBuf to construct `file` instead of simple \"dir/file\".\n    let filename = \"test_symlink_implicit_target_file\";\n    let path = PathBuf::from(dir).join(filename);\n    let file = &path.to_string_lossy();\n\n    at.mkdir(dir);\n    at.touch(&path);\n\n    ucmd.args(&[\"-s\", file]).succeeds().no_stderr();\n\n    assert!(at.file_exists(filename));\n    assert!(at.is_symlink(filename));\n    assert_eq!(at.resolve_link(filename), *file);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_to_dir_2args", "test": "fn test_symlink_to_dir_2args() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let filename = \"test_symlink_to_dir_2args_file\";\n    let from_file = &format!(\"{}/{}\", at.as_string(), filename);\n    let to_dir = \"test_symlink_to_dir_2args_to_dir\";\n    let to_file = &format!(\"{to_dir}/{filename}\");\n\n    at.mkdir(to_dir);\n    at.touch(from_file);\n\n    ucmd.args(&[\"-s\", from_file, to_dir]).succeeds().no_stderr();\n\n    assert!(at.file_exists(to_file));\n    assert!(at.is_symlink(to_file));\n    assert_eq!(at.resolve_link(to_file), filename);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_relative", "test": "fn test_symlink_relative() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_symlink_relative_a\";\n    let link = \"test_symlink_relative_link\";\n\n    at.touch(file_a);\n\n    // relative symlink\n    ucmd.args(&[\"-r\", \"-s\", file_a, link]).succeeds();\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file_a);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::is_symlink", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_relative_path", "test": "fn test_symlink_relative_path() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_symlink_existing_dir\";\n    let file_a = \"test_symlink_relative_a\";\n    let link = \"test_symlink_relative_link\";\n    let multi_dir =\n        \"test_symlink_existing_dir/../test_symlink_existing_dir/../test_symlink_existing_dir/../\";\n    let p = PathBuf::from(multi_dir).join(file_a);\n    at.mkdir(dir);\n\n    // relative symlink\n    // Thanks to -r, all the ../ should be resolved to a single file\n    ucmd.args(&[\"-r\", \"-s\", \"-v\", &p.to_string_lossy(), link])\n        .succeeds()\n        .stdout_only(format!(\"'{link}' -> '{file_a}'\\n\"));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file_a);\n\n    // Run the same command without -r to verify that we keep the full\n    // crazy path\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-s\", \"-v\", &p.to_string_lossy(), link])\n        .succeeds()\n        .stdout_only(format!(\"'{}' -> '{}'\\n\", link, &p.to_string_lossy()));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), p.to_string_lossy());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::is_symlink", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_relative_dir", "test": "fn test_symlink_relative_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let dir = \"test_symlink_existing_dir\";\n    let link = \"test_symlink_existing_dir_link\";\n\n    at.mkdir(dir);\n\n    ucmd.args(&[\"-s\", \"-r\", dir, link]).succeeds().no_stderr();\n    assert!(at.dir_exists(dir));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), dir);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_no_deref_dir", "test": "fn test_symlink_no_deref_dir() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let dir1 = \"foo\";\n    let dir2 = \"bar\";\n    let link = \"baz\";\n\n    at.mkdir(dir1);\n    at.mkdir(dir2);\n    scene\n        .ucmd()\n        .args(&[\"-s\", dir2, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.dir_exists(dir1));\n    assert!(at.dir_exists(dir2));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), dir2);\n\n    // try the normal behavior\n    scene\n        .ucmd()\n        .args(&[\"-sf\", dir1, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.dir_exists(dir1));\n    assert!(at.dir_exists(dir2));\n    assert!(at.is_symlink(\"baz/foo\"));\n    assert_eq!(at.resolve_link(\"baz/foo\"), dir1);\n\n    // Doesn't work without the force\n    scene.ucmd().args(&[\"-sn\", dir1, link]).fails();\n\n    // Try with the no-deref\n    scene.ucmd().args(&[\"-sfn\", dir1, link]).succeeds();\n    assert!(at.dir_exists(dir1));\n    assert!(at.dir_exists(dir2));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), dir1);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_no_deref_file", "test": "fn test_symlink_no_deref_file() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file1 = \"foo\";\n    let file2 = \"bar\";\n    let link = \"baz\";\n\n    at.touch(file1);\n    at.touch(file2);\n    scene\n        .ucmd()\n        .args(&[\"-s\", file2, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file2);\n\n    // try the normal behavior\n    scene\n        .ucmd()\n        .args(&[\"-sf\", file1, link])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n    assert!(at.is_symlink(\"baz\"));\n    assert_eq!(at.resolve_link(\"baz\"), file1);\n\n    // Doesn't work without the force\n    scene.ucmd().args(&[\"-sn\", file1, link]).fails();\n\n    // Try with the no-deref\n    scene.ucmd().args(&[\"-sfn\", file1, link]).succeeds();\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n    assert!(at.is_symlink(link));\n    assert_eq!(at.resolve_link(link), file1);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_relative_recursive", "test": "fn test_relative_recursive() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.mkdir(\"dir\");\n    ucmd.args(&[\"-sr\", \"dir\", \"dir/recursive\"]).succeeds();\n    assert_eq!(at.resolve_link(\"dir/recursive\"), \".\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::resolve_link", "code": "pub fn resolve_link(&self, path: &str) -> String {\n        log_info(\"resolve_link\", self.plus_as_string(path));\n        match fs::read_link(self.plus(path)) {\n            Ok(p) => self.minus_as_string(p.to_str().unwrap()),\n            Err(_) => String::new(),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_backup_force", "test": "fn test_backup_force() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.write(\"a\", \"a\\n\");\n    at.write(\"b\", \"b2\\n\");\n\n    scene.ucmd().args(&[\"-s\", \"b\", \"b~\"]).succeeds().no_stderr();\n    assert!(at.file_exists(\"a\"));\n    assert!(at.file_exists(\"b\"));\n    assert!(at.file_exists(\"b~\"));\n    scene\n        .ucmd()\n        .args(&[\"-s\", \"-f\", \"--b=simple\", \"a\", \"b\"])\n        .succeeds()\n        .no_stderr();\n    assert!(at.file_exists(\"a\"));\n    assert!(at.file_exists(\"b\"));\n    assert!(at.file_exists(\"b~\"));\n    assert_eq!(at.read(\"a\"), \"a\\n\");\n    assert_eq!(at.read(\"b\"), \"a\\n\");\n    // we should have the same content as b as we had time to do a backup\n    assert_eq!(at.read(\"b~\"), \"b2\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_hard_logical", "test": "fn test_hard_logical() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"file1\";\n    let link = \"symlink1\";\n    let target = \"hard-to-a\";\n    let target2 = \"hard-to-a2\";\n    at.touch(file_a);\n    at.symlink_file(file_a, link);\n\n    ucmd.args(&[\"-P\", \"-L\", link, target]);\n    assert!(!at.is_symlink(target));\n\n    ucmd.args(&[\"-P\", \"-L\", \"-s\", link, target2]);\n    assert!(!at.is_symlink(target2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::is_symlink", "code": "pub fn is_symlink(&self, path: &str) -> bool {\n        log_info(\"is_symlink\", self.plus_as_string(path));\n        match fs::symlink_metadata(self.plus(path)) {\n            Ok(m) => m.file_type().is_symlink(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_symlink_remove_existing_same_src_and_dest", "test": "fn test_symlink_remove_existing_same_src_and_dest() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.touch(\"a\");\n    at.write(\"a\", \"sample\");\n    ucmd.args(&[\"-sf\", \"a\", \"a\"])\n        .fails()\n        .code_is(1)\n        .stderr_contains(\"'a' and 'a' are the same file\");\n    assert!(at.file_exists(\"a\") && !at.symlink_exists(\"a\"));\n    assert_eq!(at.read(\"a\"), \"sample\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_logname.rs::test_normal", "test": "fn test_normal() {\n    let result = new_ucmd!().run();\n    println!(\"env::var(CI).is_ok() = {}\", env::var(\"CI\").is_ok());\n\n    for (key, value) in env::vars() {\n        println!(\"{key}: {value}\");\n    }\n    if (is_ci() || uucore::os::is_wsl_1()) && result.stderr_str().contains(\"no login name\") {\n        // ToDO: investigate WSL failure\n        // In the CI, some server are failing to return logname.\n        // As seems to be a configuration issue, ignoring it\n        return;\n    }\n\n    result.success();\n    assert!(!result.stdout_str().trim().is_empty());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_mkdir_parent_mode", "test": "fn test_mkdir_parent_mode() {\n    let _guard = TEST_MUTEX.lock();\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let default_umask: mode_t = 0o160;\n    let original_umask = unsafe { umask(default_umask) };\n\n    ucmd.arg(\"-p\").arg(\"a/b\").succeeds().no_stderr().no_stdout();\n\n    assert!(at.dir_exists(\"a\"));\n    // parents created by -p have permissions set to \"=rwx,u+wx\"\n    assert_eq!(\n        at.metadata(\"a\").permissions().mode() as mode_t,\n        ((!default_umask & 0o777) | 0o300) + 0o40000\n    );\n    assert!(at.dir_exists(\"a/b\"));\n    // sub directory's permission is determined only by the umask\n    assert_eq!(\n        at.metadata(\"a/b\").permissions().mode() as mode_t,\n        (!default_umask & 0o777) + 0o40000\n    );\n\n    unsafe {\n        umask(original_umask);\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mkdir.rs::test_mkdir_parent_mode_check_existing_parent", "test": "fn test_mkdir_parent_mode_check_existing_parent() {\n    let _guard = TEST_MUTEX.lock();\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(\"a\");\n\n    let default_umask: mode_t = 0o160;\n    let original_umask = unsafe { umask(default_umask) };\n\n    ucmd.arg(\"-p\")\n        .arg(\"a/b/c\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert!(at.dir_exists(\"a\"));\n    // parent dirs that already exist do not get their permissions modified\n    assert_eq!(\n        at.metadata(\"a\").permissions().mode() as mode_t,\n        (!original_umask & 0o777) + 0o40000\n    );\n    assert!(at.dir_exists(\"a/b\"));\n    assert_eq!(\n        at.metadata(\"a/b\").permissions().mode() as mode_t,\n        ((!default_umask & 0o777) | 0o300) + 0o40000\n    );\n    assert!(at.dir_exists(\"a/b/c\"));\n    assert_eq!(\n        at.metadata(\"a/b/c\").permissions().mode() as mode_t,\n        (!default_umask & 0o777) + 0o40000\n    );\n\n    unsafe {\n        umask(original_umask);\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_rename_dir", "test": "fn test_mv_rename_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir1 = \"test_mv_rename_dir\";\n    let dir2 = \"test_mv_rename_dir2\";\n\n    at.mkdir(dir1);\n\n    ucmd.arg(dir1).arg(dir2).succeeds().no_stderr();\n\n    assert!(at.dir_exists(dir2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_rename_file", "test": "fn test_mv_rename_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"test_mv_rename_file\";\n    let file2 = \"test_mv_rename_file2\";\n\n    at.touch(file1);\n\n    ucmd.arg(file1).arg(file2).succeeds().no_stderr();\n    assert!(at.file_exists(file2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_file_into_dir", "test": "fn test_mv_move_file_into_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_mv_move_file_into_dir_dir\";\n    let file = \"test_mv_move_file_into_dir_file\";\n\n    at.mkdir(dir);\n    at.touch(file);\n\n    ucmd.arg(file).arg(dir).succeeds().no_stderr();\n\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_file_into_dir_with_target_arg", "test": "fn test_mv_move_file_into_dir_with_target_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_mv_move_file_into_dir_with_target_arg_dir\";\n    let file = \"test_mv_move_file_into_dir_with_target_arg_file\";\n\n    at.mkdir(dir);\n    at.touch(file);\n\n    ucmd.arg(\"--target\")\n        .arg(dir)\n        .arg(file)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_file_into_file_with_target_arg", "test": "fn test_mv_move_file_into_file_with_target_arg() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"test_mv_move_file_into_file_with_target_arg_file1\";\n    let file2 = \"test_mv_move_file_into_file_with_target_arg_file2\";\n\n    at.touch(file1);\n    at.touch(file2);\n\n    ucmd.arg(\"--target\")\n        .arg(file1)\n        .arg(file2)\n        .fails()\n        .stderr_is(format!(\"mv: target directory '{file1}': Not a directory\\n\"));\n\n    assert!(at.file_exists(file1));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_multiple_files_into_file", "test": "fn test_mv_move_multiple_files_into_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file1 = \"test_mv_move_multiple_files_into_file1\";\n    let file2 = \"test_mv_move_multiple_files_into_file2\";\n    let file3 = \"test_mv_move_multiple_files_into_file3\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.touch(file3);\n\n    ucmd.arg(file1)\n        .arg(file2)\n        .arg(file3)\n        .fails()\n        .stderr_is(format!(\"mv: target '{file3}': Not a directory\\n\"));\n\n    assert!(at.file_exists(file1));\n    assert!(at.file_exists(file2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_move_file_between_dirs", "test": "fn test_mv_move_file_between_dirs() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir1 = \"test_mv_move_file_between_dirs_dir1\";\n    let dir2 = \"test_mv_move_file_between_dirs_dir2\";\n    let file = \"test_mv_move_file_between_dirs_file\";\n\n    at.mkdir(dir1);\n    at.mkdir(dir2);\n    at.touch(format!(\"{dir1}/{file}\"));\n\n    assert!(at.file_exists(format!(\"{dir1}/{file}\")));\n\n    ucmd.arg(&format!(\"{dir1}/{file}\"))\n        .arg(dir2)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(format!(\"{dir1}/{file}\")));\n    assert!(at.file_exists(format!(\"{dir2}/{file}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_strip_slashes", "test": "fn test_mv_strip_slashes() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"test_mv_strip_slashes_dir\";\n    let file = \"test_mv_strip_slashes_file\";\n    let mut source = file.to_owned();\n    source.push('/');\n\n    at.mkdir(dir);\n    at.touch(file);\n\n    scene.ucmd().arg(&source).arg(dir).fails();\n\n    assert!(!at.file_exists(format!(\"{dir}/{file}\")));\n\n    scene\n        .ucmd()\n        .arg(\"--strip-trailing-slashes\")\n        .arg(source)\n        .arg(dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_multiple_files", "test": "fn test_mv_multiple_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let target_dir = \"test_mv_multiple_files_dir\";\n    let file_a = \"test_mv_multiple_file_a\";\n    let file_b = \"test_mv_multiple_file_b\";\n\n    at.mkdir(target_dir);\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(file_a)\n        .arg(file_b)\n        .arg(target_dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(format!(\"{target_dir}/{file_a}\")));\n    assert!(at.file_exists(format!(\"{target_dir}/{file_b}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_multiple_folders", "test": "fn test_mv_multiple_folders() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let target_dir = \"test_mv_multiple_dirs_dir\";\n    let dir_a = \"test_mv_multiple_dir_a\";\n    let dir_b = \"test_mv_multiple_dir_b\";\n\n    at.mkdir(target_dir);\n    at.mkdir(dir_a);\n    at.mkdir(dir_b);\n\n    ucmd.arg(dir_a)\n        .arg(dir_b)\n        .arg(target_dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(&format!(\"{target_dir}/{dir_a}\")));\n    assert!(at.dir_exists(&format!(\"{target_dir}/{dir_b}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive", "test": "fn test_mv_interactive() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file_a = \"test_mv_interactive_file_a\";\n    let file_b = \"test_mv_interactive_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    scene\n        .ucmd()\n        .arg(\"-i\")\n        .arg(file_a)\n        .arg(file_b)\n        .pipe_in(\"n\")\n        .fails()\n        .no_stdout();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    scene\n        .ucmd()\n        .arg(\"-i\")\n        .arg(file_a)\n        .arg(file_b)\n        .pipe_in(\"Yesh\") // spell-checker:disable-line\n        .succeeds()\n        .no_stdout();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive_dir_to_file_not_affirmative", "test": "fn test_mv_interactive_dir_to_file_not_affirmative() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let dir = \"test_mv_interactive_dir_to_file_not_affirmative_dir\";\n    let file = \"test_mv_interactive_dir_to_file_not_affirmative_file\";\n\n    at.mkdir(dir);\n    at.touch(file);\n\n    ucmd.arg(dir)\n        .arg(file)\n        .arg(\"-i\")\n        .pipe_in(\"n\")\n        .fails()\n        .no_stdout();\n\n    assert!(at.dir_exists(dir));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive_no_clobber_force_last_arg_wins", "test": "fn test_mv_interactive_no_clobber_force_last_arg_wins() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"a.txt\";\n    let file_b = \"b.txt\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    scene\n        .ucmd()\n        .args(&[file_a, file_b, \"-f\", \"-i\", \"-n\"])\n        .fails()\n        .stderr_is(format!(\"mv: not replacing '{file_b}'\\n\"));\n\n    scene\n        .ucmd()\n        .args(&[file_a, file_b, \"-n\", \"-f\", \"-i\"])\n        .fails()\n        .stderr_is(format!(\"mv: overwrite '{file_b}'? \"));\n\n    at.write(file_a, \"aa\");\n\n    scene\n        .ucmd()\n        .args(&[file_a, file_b, \"-i\", \"-n\", \"-f\"])\n        .succeeds()\n        .no_output();\n\n    assert!(!at.file_exists(file_a));\n    assert_eq!(\"aa\", at.read(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_no_clobber", "test": "fn test_mv_no_clobber() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_no_clobber_file_a\";\n    let file_b = \"test_mv_no_clobber_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(\"-n\")\n        .arg(file_a)\n        .arg(file_b)\n        .fails()\n        .code_is(1)\n        .stderr_only(format!(\"mv: not replacing '{file_b}'\\n\"));\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_replace_file", "test": "fn test_mv_replace_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_replace_file_a\";\n    let file_b = \"test_mv_replace_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(file_a).arg(file_b).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_force_replace_file", "test": "fn test_mv_force_replace_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_force_replace_file_a\";\n    let file_b = \"test_mv_force_replace_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(\"--force\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_simple_backup", "test": "fn test_mv_simple_backup() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_simple_backup_file_a\";\n    let file_b = \"test_mv_simple_backup_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"-b\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_simple_backup_with_file_extension", "test": "fn test_mv_simple_backup_with_file_extension() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_simple_backup_file_a.txt\";\n    let file_b = \"test_mv_simple_backup_file_b.txt\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"-b\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_backup_arg_first", "test": "fn test_mv_arg_backup_arg_first() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_simple_backup_file_a\";\n    let file_b = \"test_mv_simple_backup_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup\").arg(file_a).arg(file_b).succeeds();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_custom_backup_suffix", "test": "fn test_mv_custom_backup_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_custom_backup_suffix_file_a\";\n    let file_b = \"test_mv_custom_backup_suffix_file_b\";\n    let suffix = \"super-suffix-of-the-century\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"-b\")\n        .arg(format!(\"--suffix={suffix}\"))\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_custom_backup_suffix_hyphen_value", "test": "fn test_mv_custom_backup_suffix_hyphen_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_custom_backup_suffix_file_a\";\n    let file_b = \"test_mv_custom_backup_suffix_file_b\";\n    let suffix = \"-v\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"-b\")\n        .arg(format!(\"--suffix={suffix}\"))\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_custom_backup_suffix_via_env", "test": "fn test_mv_custom_backup_suffix_via_env() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_custom_backup_suffix_file_a\";\n    let file_b = \"test_mv_custom_backup_suffix_file_b\";\n    let suffix = \"super-suffix-of-the-century\";\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"-b\")\n        .env(\"SIMPLE_BACKUP_SUFFIX\", suffix)\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}{suffix}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_numbered_with_t", "test": "fn test_mv_backup_numbered_with_t() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=t\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}.~1~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_numbered", "test": "fn test_mv_backup_numbered() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=numbered\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}.~1~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_existing", "test": "fn test_mv_backup_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=existing\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_nil", "test": "fn test_mv_backup_nil() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=nil\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_numbered_if_existing_backup_existing", "test": "fn test_mv_numbered_if_existing_backup_existing() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n    let file_b_backup = \"test_mv_backup_numbering_file_b.~1~\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.touch(file_b_backup);\n    ucmd.arg(\"--backup=existing\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(file_b_backup));\n    assert!(at.file_exists(format!(\"{file_b}.~2~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_numbered_if_existing_backup_nil", "test": "fn test_mv_numbered_if_existing_backup_nil() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n    let file_b_backup = \"test_mv_backup_numbering_file_b.~1~\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.touch(file_b_backup);\n    ucmd.arg(\"--backup=nil\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(file_b_backup));\n    assert!(at.file_exists(format!(\"{file_b}.~2~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_simple", "test": "fn test_mv_backup_simple() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=simple\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_never", "test": "fn test_mv_backup_never() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=never\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_none", "test": "fn test_mv_backup_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=none\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(!at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_off", "test": "fn test_mv_backup_off() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_mv_backup_numbering_file_a\";\n    let file_b = \"test_mv_backup_numbering_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    ucmd.arg(\"--backup=off\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n    assert!(!at.file_exists(format!(\"{file_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_update_option", "test": "fn test_mv_update_option() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file_a = \"test_mv_update_option_file_a\";\n    let file_b = \"test_mv_update_option_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    let ts = time::OffsetDateTime::now_utc();\n    let now = FileTime::from_unix_time(ts.unix_timestamp(), ts.nanosecond());\n    let later = FileTime::from_unix_time(ts.unix_timestamp() + 3600, ts.nanosecond());\n    filetime::set_file_times(at.plus_as_string(file_a), now, now).unwrap();\n    filetime::set_file_times(at.plus_as_string(file_b), now, later).unwrap();\n\n    scene.ucmd().arg(\"--update\").arg(file_a).arg(file_b).run();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    scene\n        .ucmd()\n        .arg(\"--update\")\n        .arg(file_b)\n        .arg(file_a)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_none", "test": "fn test_mv_arg_update_none() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_mv_arg_update_none_file1\";\n    let file2 = \"test_mv_arg_update_none_file2\";\n    let file1_content = \"file1 content\\n\";\n    let file2_content = \"file2 content\\n\";\n\n    at.write(file1, file1_content);\n    at.write(file2, file2_content);\n\n    ucmd.arg(file1)\n        .arg(file2)\n        .arg(\"--update=none\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(file2), file2_content);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_all", "test": "fn test_mv_arg_update_all() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_mv_arg_update_none_file1\";\n    let file2 = \"test_mv_arg_update_none_file2\";\n    let file1_content = \"file1 content\\n\";\n    let file2_content = \"file2 content\\n\";\n\n    at.write(file1, file1_content);\n    at.write(file2, file2_content);\n\n    ucmd.arg(file1)\n        .arg(file2)\n        .arg(\"--update=all\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(file2), file1_content);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_older_dest_not_older", "test": "fn test_mv_arg_update_older_dest_not_older() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_none_file1\";\n    let new = \"test_mv_arg_update_none_file2\";\n    let old_content = \"file1 content\\n\";\n    let new_content = \"file2 content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"--update=older\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), new_content);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_none_then_all", "test": "fn test_mv_arg_update_none_then_all() {\n    // take last if multiple update args are supplied,\n    // update=all wins in this case\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_none_then_all_file1\";\n    let new = \"test_mv_arg_update_none_then_all_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"--update=none\")\n        .arg(\"--update=all\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"old content\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_all_then_none", "test": "fn test_mv_arg_update_all_then_none() {\n    // take last if multiple update args are supplied,\n    // update=none wins in this case\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_all_then_none_file1\";\n    let new = \"test_mv_arg_update_all_then_none_file2\";\n    let old_content = \"old content\\n\";\n    let new_content = \"new content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"--update=all\")\n        .arg(\"--update=none\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), \"new content\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_older_dest_older", "test": "fn test_mv_arg_update_older_dest_older() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_none_file1\";\n    let new = \"test_mv_arg_update_none_file2\";\n    let old_content = \"file1 content\\n\";\n    let new_content = \"file2 content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(new)\n        .arg(old)\n        .arg(\"--update=all\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(old), new_content);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_short_overwrite", "test": "fn test_mv_arg_update_short_overwrite() {\n    // same as --update=older\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_none_file1\";\n    let new = \"test_mv_arg_update_none_file2\";\n    let old_content = \"file1 content\\n\";\n    let new_content = \"file2 content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(new)\n        .arg(old)\n        .arg(\"-u\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(old), new_content);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_arg_update_short_no_overwrite", "test": "fn test_mv_arg_update_short_no_overwrite() {\n    // same as --update=older\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let old = \"test_mv_arg_update_none_file1\";\n    let new = \"test_mv_arg_update_none_file2\";\n    let old_content = \"file1 content\\n\";\n    let new_content = \"file2 content\\n\";\n\n    at.write(old, old_content);\n\n    sleep(Duration::from_secs(1));\n\n    at.write(new, new_content);\n\n    ucmd.arg(old)\n        .arg(new)\n        .arg(\"-u\")\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n\n    assert_eq!(at.read(new), new_content);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_target_dir", "test": "fn test_mv_target_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_mv_target_dir_dir\";\n    let file_a = \"test_mv_target_dir_file_a\";\n    let file_b = \"test_mv_target_dir_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    at.mkdir(dir);\n    ucmd.arg(\"-t\")\n        .arg(dir)\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n    assert!(at.file_exists(format!(\"{dir}/{file_a}\")));\n    assert!(at.file_exists(format!(\"{dir}/{file_b}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_target_dir_single_source", "test": "fn test_mv_target_dir_single_source() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_mv_target_dir_single_source_dir\";\n    let file = \"test_mv_target_dir_single_source_file\";\n\n    at.touch(file);\n    at.mkdir(dir);\n    ucmd.arg(\"-t\").arg(dir).arg(file).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file));\n    assert!(at.file_exists(format!(\"{dir}/{file}\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_overwrite_dir", "test": "fn test_mv_overwrite_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir_a = \"test_mv_overwrite_dir_a\";\n    let dir_b = \"test_mv_overwrite_dir_b\";\n\n    at.mkdir(dir_a);\n    at.mkdir(dir_b);\n    ucmd.arg(\"-T\").arg(dir_a).arg(dir_b).succeeds().no_stderr();\n\n    assert!(!at.dir_exists(dir_a));\n    assert!(at.dir_exists(dir_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_overwrite_nonempty_dir", "test": "fn test_mv_overwrite_nonempty_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir_a = \"test_mv_overwrite_nonempty_dir_a\";\n    let dir_b = \"test_mv_overwrite_nonempty_dir_b\";\n    let dummy = \"test_mv_overwrite_nonempty_dir_b/file\";\n\n    at.mkdir(dir_a);\n    at.mkdir(dir_b);\n    at.touch(dummy);\n    // Not same error as GNU; the error message is a rust builtin\n    // TODO: test (and implement) correct error message (or at least decide whether to do so)\n    // Current: \"mv: couldn't rename path (Directory not empty; from=a; to=b)\"\n    // GNU:     \"mv: cannot move 'a' to 'b': Directory not empty\"\n\n    // Verbose output for the move should not be shown on failure\n    let result = ucmd.arg(\"-vT\").arg(dir_a).arg(dir_b).fails();\n    result.no_stdout();\n    assert!(!result.stderr_str().is_empty());\n\n    assert!(at.dir_exists(dir_a));\n    assert!(at.dir_exists(dir_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_backup_dir", "test": "fn test_mv_backup_dir() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir_a = \"test_mv_backup_dir_dir_a\";\n    let dir_b = \"test_mv_backup_dir_dir_b\";\n\n    at.mkdir(dir_a);\n    at.mkdir(dir_b);\n    ucmd.arg(\"-vbT\")\n        .arg(dir_a)\n        .arg(dir_b)\n        .succeeds()\n        .stdout_only(format!(\n            \"renamed '{dir_a}' -> '{dir_b}' (backup: '{dir_b}~')\\n\"\n        ));\n\n    assert!(!at.dir_exists(dir_a));\n    assert!(at.dir_exists(dir_b));\n    assert!(at.dir_exists(&format!(\"{dir_b}~\")));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_errors", "test": "fn test_mv_errors() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"test_mv_errors_dir\";\n    let file_a = \"test_mv_errors_file_a\";\n    let file_b = \"test_mv_errors_file_b\";\n    at.mkdir(dir);\n    at.touch(file_a);\n    at.touch(file_b);\n\n    // $ mv -T -t a b\n    // mv: cannot combine --target-directory (-t) and --no-target-directory (-T)\n    scene\n        .ucmd()\n        .arg(\"-T\")\n        .arg(\"-t\")\n        .arg(dir)\n        .arg(file_a)\n        .arg(file_b)\n        .fails()\n        .stderr_contains(\"cannot be used with\");\n\n    // $ at.touch file && at.mkdir dir\n    // $ mv -T file dir\n    // err == mv: cannot overwrite directory 'dir' with non-directory\n    scene\n        .ucmd()\n        .arg(\"-T\")\n        .arg(file_a)\n        .arg(dir)\n        .fails()\n        .stderr_is(format!(\n            \"mv: cannot overwrite directory '{dir}' with non-directory\\n\"\n        ));\n\n    // $ at.mkdir dir && at.touch file\n    // $ mv dir file\n    // err == mv: cannot overwrite non-directory 'file' with directory 'dir'\n    assert!(!scene\n        .ucmd()\n        .arg(dir)\n        .arg(file_a)\n        .fails()\n        .stderr_str()\n        .is_empty());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_interactive_error", "test": "fn test_mv_interactive_error() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let dir = \"test_mv_errors_dir\";\n    let file_a = \"test_mv_errors_file_a\";\n    at.mkdir(dir);\n    at.touch(file_a);\n\n    // $ at.mkdir dir && at.touch file\n    // $ mv -i dir file\n    // err == mv: cannot overwrite non-directory 'file' with directory 'dir'\n    assert!(!scene\n        .ucmd()\n        .arg(\"-i\")\n        .arg(dir)\n        .arg(file_a)\n        .pipe_in(\"y\")\n        .fails()\n        .stderr_str()\n        .is_empty());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mv.rs::test_mv_into_self_data", "test": "fn test_mv_into_self_data() {\n    let scene = TestScenario::new(util_name!());\n\n    let at = &scene.fixtures;\n    let sub_dir = \"sub_folder\";\n    let file1 = \"t1.test\";\n    let file2 = \"sub_folder/t2.test\";\n\n    let file1_result_location = \"sub_folder/t1.test\";\n\n    at.mkdir(sub_dir);\n    at.touch(file1);\n    at.touch(file2);\n\n    let result = scene.ucmd().arg(file1).arg(sub_dir).arg(sub_dir).run();\n\n    // sub_dir exists, file1 has been moved, file2 still exists.\n    result.code_is(1);\n\n    assert!(at.dir_exists(sub_dir));\n    assert!(at.file_exists(file1_result_location));\n    assert!(at.file_exists(file2));\n    assert!(!at.file_exists(file1));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pinky.rs::test_capitalize", "test": "fn test_capitalize() {\n    assert_eq!(\"Zbnmasd\", \"zbnmasd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"Abnmasd\", \"Abnmasd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"1masd\", \"1masd\".capitalize()); // spell-checker:disable-line\n    assert_eq!(\"\", \"\".capitalize());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/pinky/src/pinky.rs::capitalize", "code": "fn capitalize(&self) -> String {\n        self.char_indices()\n            .fold(String::with_capacity(self.len()), |mut acc, x| {\n                if x.0 == 0 {\n                    acc.push(x.1.to_ascii_uppercase());\n                } else {\n                    acc.push(x.1);\n                }\n                acc\n            })\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_printenv.rs::test_get_var", "test": "fn test_get_var() {\n    let result = TestScenario::new(util_name!())\n        .ucmd()\n        .env(\"KEY\", \"VALUE\")\n        .arg(\"KEY\")\n        .succeeds();\n\n    assert!(!result.stdout_str().is_empty());\n    assert_eq!(result.stdout_str().trim(), \"VALUE\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_printenv.rs::test_ignore_equal_var", "test": "fn test_ignore_equal_var() {\n    let scene = TestScenario::new(util_name!());\n    // tested by gnu/tests/misc/printenv.sh\n    let result = scene.ucmd().env(\"a=b\", \"c\").arg(\"a=b\").fails();\n\n    assert!(result.stdout_str().is_empty());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_pwd.rs::test_deleted_dir", "test": "fn test_deleted_dir() {\n    use std::process::Command;\n\n    let ts = TestScenario::new(util_name!());\n    let at = ts.fixtures;\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(format!(\n            \"cd '{}'; mkdir foo; cd foo; rmdir ../foo; exec '{}' {}\",\n            at.root_dir_resolved(),\n            ts.bin_path.to_str().unwrap(),\n            ts.util_name,\n        ))\n        .output()\n        .unwrap();\n    assert!(!output.status.success());\n    assert!(output.stdout.is_empty());\n    assert_eq!(\n        output.stderr,\n        b\"pwd: failed to get current directory: No such file or directory\\n\"\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::success", "code": "pub fn success(&self) -> &Self {\n        assert!(\n            self.succeeded(),\n            \"Command was expected to succeed.\\nstdout = {}\\n stderr = {}\",\n            self.stdout_str(),\n            self.stderr_str()\n        );\n        self\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_one_file", "test": "fn test_rm_one_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_rm_one_file\";\n\n    at.touch(file);\n\n    ucmd.arg(file).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_multiple_files", "test": "fn test_rm_multiple_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_rm_multiple_file_a\";\n    let file_b = \"test_rm_multiple_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(file_a).arg(file_b).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_interactive", "test": "fn test_rm_interactive() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_rm_interactive_file_a\";\n    let file_b = \"test_rm_interactive_file_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    scene\n        .ucmd()\n        .arg(\"-i\")\n        .arg(file_a)\n        .arg(file_b)\n        .pipe_in(\"n\")\n        .succeeds();\n\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    scene\n        .ucmd()\n        .arg(\"-i\")\n        .arg(file_a)\n        .arg(file_b)\n        .pipe_in(\"Yesh\") // spell-checker:disable-line\n        .succeeds();\n\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_force", "test": "fn test_rm_force() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_rm_force_a\";\n    let file_b = \"test_rm_force_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    ucmd.arg(\"-f\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_force_multiple", "test": "fn test_rm_force_multiple() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_a = \"test_rm_force_a\";\n    let file_b = \"test_rm_force_b\";\n\n    at.touch(file_a);\n    at.touch(file_b);\n    assert!(at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n\n    ucmd.arg(\"-f\")\n        .arg(\"-f\")\n        .arg(\"-f\")\n        .arg(file_a)\n        .arg(file_b)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_empty_directory", "test": "fn test_rm_empty_directory() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_empty_directory\";\n\n    at.mkdir(dir);\n\n    ucmd.arg(\"-d\").arg(dir).succeeds().no_stderr();\n\n    assert!(!at.dir_exists(dir));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_empty_directory_verbose", "test": "fn test_rm_empty_directory_verbose() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_empty_directory_verbose\";\n\n    at.mkdir(dir);\n\n    ucmd.arg(\"-d\")\n        .arg(\"-v\")\n        .arg(dir)\n        .succeeds()\n        .stdout_only(format!(\"removed directory '{dir}'\\n\"));\n\n    assert!(!at.dir_exists(dir));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_non_empty_directory", "test": "fn test_rm_non_empty_directory() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_non_empty_dir\";\n    let file_a = &format!(\"{dir}/test_rm_non_empty_file_a\");\n\n    at.mkdir(dir);\n    at.touch(file_a);\n\n    ucmd.arg(\"-d\")\n        .arg(dir)\n        .fails()\n        .stderr_contains(&format!(\"cannot remove '{dir}': Directory not empty\"));\n    assert!(at.file_exists(file_a));\n    assert!(at.dir_exists(dir));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_recursive", "test": "fn test_rm_recursive() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_recursive_directory\";\n    let file_a = \"test_rm_recursive_directory/test_rm_recursive_file_a\";\n    let file_b = \"test_rm_recursive_directory/test_rm_recursive_file_b\";\n\n    at.mkdir(dir);\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(\"-r\").arg(dir).succeeds().no_stderr();\n\n    assert!(!at.dir_exists(dir));\n    assert!(!at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_recursive_multiple", "test": "fn test_rm_recursive_multiple() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_recursive_directory\";\n    let file_a = \"test_rm_recursive_directory/test_rm_recursive_file_a\";\n    let file_b = \"test_rm_recursive_directory/test_rm_recursive_file_b\";\n\n    at.mkdir(dir);\n    at.touch(file_a);\n    at.touch(file_b);\n\n    ucmd.arg(\"-r\")\n        .arg(\"-r\")\n        .arg(\"-r\")\n        .arg(dir)\n        .succeeds()\n        .no_stderr();\n\n    assert!(!at.dir_exists(dir));\n    assert!(!at.file_exists(file_a));\n    assert!(!at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_verbose_slash", "test": "fn test_rm_verbose_slash() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let dir = \"test_rm_verbose_slash_directory\";\n    let file_a = &format!(\"{dir}/test_rm_verbose_slash_file_a\");\n\n    at.mkdir(dir);\n    at.touch(file_a);\n\n    let file_a_normalized = &format!(\n        \"{}{}test_rm_verbose_slash_file_a\",\n        dir,\n        std::path::MAIN_SEPARATOR\n    );\n\n    ucmd.arg(\"-r\")\n        .arg(\"-f\")\n        .arg(\"-v\")\n        .arg(&format!(\"{dir}///\"))\n        .succeeds()\n        .stdout_only(format!(\n            \"removed '{file_a_normalized}'\\nremoved directory '{dir}'\\n\"\n        ));\n\n    assert!(!at.dir_exists(dir));\n    assert!(!at.file_exists(file_a));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_silently_accepts_presume_input_tty2", "test": "fn test_rm_silently_accepts_presume_input_tty2() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_2 = \"test_rm_silently_accepts_presume_input_tty2\";\n\n    at.touch(file_2);\n\n    ucmd.arg(\"---presume-input-tty\").arg(file_2).succeeds();\n\n    assert!(!at.file_exists(file_2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_interactive_never", "test": "fn test_rm_interactive_never() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_2 = \"test_rm_interactive\";\n\n    at.touch(file_2);\n    #[cfg(feature = \"chmod\")]\n    scene.ccmd(\"chmod\").arg(\"0\").arg(file_2).succeeds();\n\n    scene\n        .ucmd()\n        .arg(\"--interactive=never\")\n        .arg(file_2)\n        .succeeds()\n        .stdout_is(\"\");\n\n    assert!(!at.file_exists(file_2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_interactive_missing_value", "test": "fn test_rm_interactive_missing_value() {\n    // `--interactive` is equivalent to `--interactive=always` or `-i`\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_rm_interactive_missing_value_file1\";\n    let file2 = \"test_rm_interactive_missing_value_file2\";\n\n    at.touch(file1);\n    at.touch(file2);\n\n    ucmd.arg(\"--interactive\")\n        .arg(file1)\n        .arg(file2)\n        .pipe_in(\"y\\ny\")\n        .succeeds();\n\n    assert!(!at.file_exists(file1));\n    assert!(!at.file_exists(file2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_interactive_once_prompt", "test": "fn test_rm_interactive_once_prompt() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_rm_interactive_once_recursive_prompt_file1\";\n    let file2 = \"test_rm_interactive_once_recursive_prompt_file2\";\n    let file3 = \"test_rm_interactive_once_recursive_prompt_file3\";\n    let file4 = \"test_rm_interactive_once_recursive_prompt_file4\";\n\n    at.touch(file1);\n    at.touch(file2);\n    at.touch(file3);\n    at.touch(file4);\n\n    ucmd.arg(\"--interactive=once\")\n        .arg(file1)\n        .arg(file2)\n        .arg(file3)\n        .arg(file4)\n        .pipe_in(\"y\")\n        .succeeds()\n        .stderr_contains(\"remove 4 arguments?\");\n\n    assert!(!at.file_exists(file1));\n    assert!(!at.file_exists(file2));\n    assert!(!at.file_exists(file3));\n    assert!(!at.file_exists(file4));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_interactive_once_recursive_prompt", "test": "fn test_rm_interactive_once_recursive_prompt() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file1 = \"test_rm_interactive_once_recursive_prompt_file1\";\n\n    at.touch(file1);\n\n    ucmd.arg(\"--interactive=once\")\n        .arg(\"-r\")\n        .arg(file1)\n        .pipe_in(\"y\")\n        .succeeds()\n        .stderr_contains(\"remove 1 argument recursively?\");\n\n    assert!(!at.file_exists(file1));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_descend_directory", "test": "fn test_rm_descend_directory() {\n    // This test descends into each directory and deletes the files and folders inside of them\n    // This test will have the rm process asks 6 question and us answering Y to them will delete all the files and folders\n\n    // Needed for talking with stdin on platforms where CRLF or LF matters\n    const END_OF_LINE: &str = if cfg!(windows) { \"\\r\\n\" } else { \"\\n\" };\n\n    let yes = format!(\"y{END_OF_LINE}\");\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_1 = \"a/at.txt\";\n    let file_2 = \"a/b/bt.txt\";\n\n    at.mkdir_all(\"a/b/\");\n    at.touch(file_1);\n    at.touch(file_2);\n\n    let mut child = scene\n        .ucmd()\n        .set_stdin(Stdio::piped())\n        .arg(\"-ri\")\n        .arg(\"a\")\n        .run_no_wait();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n    child.try_write_in(yes.as_bytes()).unwrap();\n\n    child.wait().unwrap();\n\n    assert!(!at.dir_exists(\"a/b\"));\n    assert!(!at.dir_exists(\"a\"));\n    assert!(!at.file_exists(file_1));\n    assert!(!at.file_exists(file_2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_prompts", "test": "fn test_rm_prompts() {\n    use std::io::Write;\n\n    // Needed for talking with stdin on platforms where CRLF or LF matters\n    const END_OF_LINE: &str = if cfg!(windows) { \"\\r\\n\" } else { \"\\n\" };\n\n    let mut answers = [\n        \"rm: descend into directory 'a'?\",\n        \"rm: remove write-protected regular empty file 'a/empty-no-write'?\",\n        \"rm: remove symbolic link 'a/slink'?\",\n        \"rm: remove symbolic link 'a/slink-dot'?\",\n        \"rm: remove write-protected regular file 'a/f-no-write'?\",\n        \"rm: remove regular empty file 'a/empty'?\",\n        \"rm: remove directory 'a/b'?\",\n        \"rm: remove write-protected directory 'a/b-no-write'?\",\n        \"rm: remove directory 'a'?\",\n    ];\n\n    answers.sort();\n\n    let yes = format!(\"y{END_OF_LINE}\");\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.mkdir(\"a/\");\n\n    let file_1 = \"a/empty\";\n    let file_2 = \"a/empty-no-write\";\n    let file_3 = \"a/f-no-write\";\n\n    at.touch(file_1);\n    at.touch(file_2);\n    at.make_file(file_3)\n        .write_all(b\"not-empty\")\n        .expect(\"Couldn't write to a/f-no-write\");\n\n    at.symlink_dir(\"a/empty-f\", \"a/slink\");\n    at.symlink_dir(\".\", \"a/slink-dot\");\n\n    let dir_1 = \"a/b/\";\n    let dir_2 = \"a/b-no-write/\";\n\n    at.mkdir(dir_1);\n    at.mkdir(dir_2);\n\n    scene\n        .ccmd(\"chmod\")\n        .arg(\"u-w\")\n        .arg(file_3)\n        .arg(dir_2)\n        .arg(file_2)\n        .succeeds();\n\n    let mut child = scene\n        .ucmd()\n        .set_stdin(Stdio::piped())\n        .arg(\"-ri\")\n        .arg(\"a\")\n        .run_no_wait();\n    for _ in 0..9 {\n        child.try_write_in(yes.as_bytes()).unwrap();\n    }\n\n    let result = child.wait().unwrap();\n\n    let mut trimmed_output = Vec::new();\n    for string in result.stderr_str().split(\"rm: \") {\n        if !string.is_empty() {\n            let trimmed_string = format!(\"rm: {string}\").trim().to_string();\n            trimmed_output.push(trimmed_string);\n        }\n    }\n\n    trimmed_output.sort();\n\n    assert_eq!(trimmed_output.len(), answers.len());\n\n    for (i, checking_string) in trimmed_output.iter().enumerate() {\n        assert_eq!(checking_string, answers[i]);\n    }\n\n    assert!(!at.dir_exists(\"a\"));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::len", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_rm_force_prompts_order", "test": "fn test_rm_force_prompts_order() {\n    // Needed for talking with stdin on platforms where CRLF or LF matters\n    const END_OF_LINE: &str = if cfg!(windows) { \"\\r\\n\" } else { \"\\n\" };\n\n    let yes = format!(\"y{END_OF_LINE}\");\n\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let empty_file = \"empty\";\n\n    at.touch(empty_file);\n\n    // This should cause rm to prompt to remove regular empty file\n    let mut child = scene\n        .ucmd()\n        .set_stdin(Stdio::piped())\n        .arg(\"-fi\")\n        .arg(empty_file)\n        .run_no_wait();\n    child.try_write_in(yes.as_bytes()).unwrap();\n\n    let result = child.wait().unwrap();\n    result.stderr_only(\"rm: remove regular empty file 'empty'? \");\n\n    assert!(!at.file_exists(empty_file));\n\n    at.touch(empty_file);\n\n    // This should not cause rm to prompt to remove regular empty file\n    scene\n        .ucmd()\n        .arg(\"-if\")\n        .arg(empty_file)\n        .succeeds()\n        .no_stderr();\n    assert!(!at.file_exists(empty_file));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_prompt_write_protected_yes", "test": "fn test_prompt_write_protected_yes() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file_1 = \"test_rm_prompt_write_protected_1\";\n\n    at.touch(file_1);\n\n    scene.ccmd(\"chmod\").arg(\"0\").arg(file_1).succeeds();\n\n    scene.ucmd().arg(file_1).pipe_in(\"y\").succeeds();\n    assert!(!at.file_exists(file_1));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rm.rs::test_prompt_write_protected_no", "test": "fn test_prompt_write_protected_no() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let file_2 = \"test_rm_prompt_write_protected_2\";\n\n    at.touch(file_2);\n\n    scene.ccmd(\"chmod\").arg(\"0\").arg(file_2).succeeds();\n\n    scene.ucmd().arg(file_2).pipe_in(\"n\").succeeds();\n    assert!(at.file_exists(file_2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_empty_directory_no_parents", "test": "fn test_rmdir_empty_directory_no_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(DIR);\n\n    ucmd.arg(DIR).succeeds().no_stderr();\n\n    assert!(!at.dir_exists(DIR));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_empty_directory_with_parents", "test": "fn test_rmdir_empty_directory_with_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir_all(NESTED_DIR);\n\n    ucmd.arg(\"-p\").arg(NESTED_DIR).succeeds().no_stderr();\n\n    assert!(!at.dir_exists(NESTED_DIR));\n    assert!(!at.dir_exists(DIR));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_nonempty_directory_no_parents", "test": "fn test_rmdir_nonempty_directory_no_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(DIR);\n    at.touch(DIR_FILE);\n\n    ucmd.arg(DIR)\n        .fails()\n        .stderr_is(format!(\"rmdir: failed to remove 'dir': {NOT_EMPTY}\\n\"));\n\n    assert!(at.dir_exists(DIR));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_nonempty_directory_with_parents", "test": "fn test_rmdir_nonempty_directory_with_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir_all(NESTED_DIR);\n    at.touch(NESTED_DIR_FILE);\n\n    ucmd.arg(\"-p\").arg(NESTED_DIR).fails().stderr_is(format!(\n        \"rmdir: failed to remove 'dir/ect/ory': {NOT_EMPTY}\\n\"\n    ));\n\n    assert!(at.dir_exists(NESTED_DIR));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_ignore_nonempty_directory_no_parents", "test": "fn test_rmdir_ignore_nonempty_directory_no_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(DIR);\n    at.touch(DIR_FILE);\n\n    ucmd.arg(\"--ignore-fail-on-non-empty\")\n        .arg(DIR)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(DIR));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_ignore_nonempty_directory_with_parents", "test": "fn test_rmdir_ignore_nonempty_directory_with_parents() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir_all(NESTED_DIR);\n    at.touch(NESTED_DIR_FILE);\n\n    ucmd.arg(\"--ignore-fail-on-non-empty\")\n        .arg(\"-p\")\n        .arg(NESTED_DIR)\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(NESTED_DIR));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_rmdir.rs::test_rmdir_ignore_nonempty_no_permissions", "test": "fn test_rmdir_ignore_nonempty_no_permissions() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    // We make the *parent* dir read-only to prevent deleting the dir in it.\n    at.mkdir_all(\"dir/ect/ory\");\n    at.touch(\"dir/ect/ory/file\");\n    at.set_mode(\"dir/ect\", 0o555);\n\n    // rmdir should now get a permissions error that it interprets as\n    // a non-empty error.\n    ucmd.arg(\"--ignore-fail-on-non-empty\")\n        .arg(\"dir/ect/ory\")\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.dir_exists(\"dir/ect/ory\"));\n\n    // Politely restore permissions for cleanup\n    at.set_mode(\"dir/ect\", 0o755);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::dir_exists", "code": "pub fn dir_exists(&self, path: &str) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_dir(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_runcon.rs::custom_context", "test": "fn custom_context() {\n    let t_ud = \"unconfined_t\";\n    let u_ud = \"unconfined_u\";\n    let r_ud = \"unconfined_r\";\n\n    new_ucmd!().args(&[\"--compute\", \"/bin/true\"]).succeeds();\n\n    let args = &[\"--compute\", \"/bin/false\"];\n    new_ucmd!().args(args).fails().code_is(1);\n\n    let args = &[\"--type\", t_ud, \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--compute\", \"--type\", t_ud, \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--user=system_u\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--compute\", \"--user=system_u\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--role=system_r\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    let args = &[\"--compute\", \"--role=system_r\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    new_ucmd!().args(&[\"--range=s0\", \"/bin/true\"]).succeeds();\n\n    let args = &[\"--compute\", \"--range=s0\", \"/bin/true\"];\n    new_ucmd!().args(args).succeeds();\n\n    for (ctx, u, r) in [\n        (\"unconfined_u:unconfined_r:unconfined_t:s0\", u_ud, r_ud),\n        (\"system_u:unconfined_r:unconfined_t:s0\", \"system_u\", r_ud),\n        (\"unconfined_u:system_r:unconfined_t:s0\", u_ud, \"system_r\"),\n        (\"system_u:system_r:unconfined_t:s0\", \"system_u\", \"system_r\"),\n    ] {\n        let args = &[\"-t\", t_ud, \"-u\", u, \"-r\", r, \"-l\", \"s0\", \"sestatus\", \"-v\"];\n\n        let output = new_ucmd!().args(args).succeeds();\n        assert_eq!(get_sestatus_context(output.stdout()), ctx);\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout", "code": "pub fn stdout(&self) -> &[u8] {\n        &self.stdout\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shred.rs::test_shred_remove", "test": "fn test_shred_remove() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file_a = \"test_shred_remove_a\";\n    let file_b = \"test_shred_remove_b\";\n\n    // Create file_a and file_b.\n    at.touch(file_a);\n    at.touch(file_b);\n\n    // Shred file_a.\n    scene.ucmd().arg(\"-u\").arg(file_a).succeeds();\n\n    // file_a was deleted, file_b exists.\n    assert!(!at.file_exists(file_a));\n    assert!(at.file_exists(file_b));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shred.rs::test_shred_force", "test": "fn test_shred_force() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    let file = \"test_shred_force\";\n\n    // Create file_a.\n    at.touch(file);\n    assert!(at.file_exists(file));\n\n    // Make file_a readonly.\n    at.set_readonly(file);\n\n    // Try shred -u.\n    scene.ucmd().arg(\"-u\").arg(file).run();\n\n    // file_a was not deleted because it is readonly.\n    assert!(at.file_exists(file));\n\n    // Try shred -u -f.\n    scene.ucmd().arg(\"-u\").arg(\"-f\").arg(file).run();\n\n    // file_a was deleted.\n    assert!(!at.file_exists(file));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_output_is_random_permutation", "test": "fn test_output_is_random_permutation() {\n    let input_seq = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let input = input_seq\n        .iter()\n        .map(ToString::to_string)\n        .collect::<Vec<String>>()\n        .join(\"\\n\");\n\n    let result = new_ucmd!().pipe_in(input.as_bytes()).succeeds();\n    result.no_stderr();\n\n    let mut result_seq: Vec<i32> = result\n        .stdout_str()\n        .split('\\n')\n        .filter(|x| !x.is_empty())\n        .map(|x| x.parse().unwrap())\n        .collect();\n    result_seq.sort_unstable();\n    assert_ne!(result.stdout_str(), input, \"Output is not randomized\");\n    assert_eq!(result_seq, input_seq, \"Output is not a permutation\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_head_count", "test": "fn test_head_count() {\n    let repeat_limit = 5;\n    let input_seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let input = input_seq\n        .iter()\n        .map(ToString::to_string)\n        .collect::<Vec<String>>()\n        .join(\"\\n\");\n\n    let result = new_ucmd!()\n        .args(&[\"-n\", &repeat_limit.to_string()])\n        .pipe_in(input.as_bytes())\n        .succeeds();\n    result.no_stderr();\n\n    let mut result_seq: Vec<i32> = result\n        .stdout_str()\n        .split('\\n')\n        .filter(|x| !x.is_empty())\n        .map(|x| x.parse().unwrap())\n        .collect();\n    result_seq.sort_unstable();\n    assert_eq!(result_seq.len(), repeat_limit, \"Output is not limited\");\n    assert!(\n        result_seq.iter().all(|x| input_seq.contains(x)),\n        \"Output includes element not from input: {}\",\n        result.stdout_str()\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::len", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_shuf.rs::test_repeat", "test": "fn test_repeat() {\n    let repeat_limit = 15000;\n    let input_seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let input = input_seq\n        .iter()\n        .map(ToString::to_string)\n        .collect::<Vec<String>>()\n        .join(\"\\n\");\n\n    let result = new_ucmd!()\n        .arg(\"-r\")\n        .args(&[\"-n\", &repeat_limit.to_string()])\n        .pipe_in(input.as_bytes())\n        .succeeds();\n    result.no_stderr();\n\n    let result_seq: Vec<i32> = result\n        .stdout_str()\n        .split('\\n')\n        .filter(|x| !x.is_empty())\n        .map(|x| x.parse().unwrap())\n        .collect();\n    assert_eq!(\n        result_seq.len(),\n        repeat_limit,\n        \"Output is not repeating forever\"\n    );\n    assert!(\n        result_seq.iter().all(|x| input_seq.contains(x)),\n        \"Output includes element not from input: {:?}\",\n        result_seq\n            .iter()\n            .filter(|x| !input_seq.contains(x))\n            .collect::<Vec<&i32>>()\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::len", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_default", "test": "fn test_split_default() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_default\";\n    RandomFile::new(&at, name).add_lines(2000);\n    ucmd.args(&[name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_numeric_prefixed_chunks_by_bytes", "test": "fn test_split_numeric_prefixed_chunks_by_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_num_prefixed_chunks_by_bytes\";\n    RandomFile::new(&at, name).add_bytes(10000);\n    ucmd.args(&[\n        \"-d\", // --numeric-suffixes\n        \"-b\", // --bytes\n        \"1000\", name, \"a\",\n    ])\n    .succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"a\\d\\d$\");\n    assert_eq!(glob.count(), 10);\n    for filename in glob.collect() {\n        assert_eq!(glob.directory.metadata(&filename).len(), 1000);\n    }\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_str_prefixed_chunks_by_bytes", "test": "fn test_split_str_prefixed_chunks_by_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_str_prefixed_chunks_by_bytes\";\n    RandomFile::new(&at, name).add_bytes(10000);\n    // Important that this is less than 1024 since that's our internal buffer\n    // size. Good to test that we don't overshoot.\n    ucmd.args(&[\"-b\", \"1000\", name, \"b\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"b[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 10);\n    for filename in glob.collect() {\n        assert_eq!(glob.directory.metadata(&filename).len(), 1000);\n    }\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_by_bytes_short_concatenated_with_value", "test": "fn test_split_by_bytes_short_concatenated_with_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_by_bytes_short_concatenated_with_value\";\n    RandomFile::new(&at, name).add_bytes(10000);\n    ucmd.args(&[\"-b1000\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 10);\n    for filename in glob.collect() {\n        assert_eq!(glob.directory.metadata(&filename).len(), 1000);\n    }\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_bytes_prime_part_size", "test": "fn test_split_bytes_prime_part_size() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"test_split_bytes_prime_part_size\";\n    RandomFile::new(&at, name).add_bytes(10000);\n    // 1753 is prime and greater than the buffer size, 1024.\n    ucmd.args(&[\"-b\", \"1753\", name, \"b\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"b[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 6);\n    let mut fns = glob.collect();\n    // glob.collect() is not guaranteed to return in sorted order, so we sort.\n    fns.sort();\n    #[allow(clippy::needless_range_loop)]\n    for i in 0..5 {\n        assert_eq!(glob.directory.metadata(&fns[i]).len(), 1753);\n    }\n    assert_eq!(glob.directory.metadata(&fns[5]).len(), 1235);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_num_prefixed_chunks_by_lines", "test": "fn test_split_num_prefixed_chunks_by_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_num_prefixed_chunks_by_lines\";\n    RandomFile::new(&at, name).add_lines(10000);\n    ucmd.args(&[\"-d\", \"-l\", \"1000\", name, \"c\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"c\\d\\d$\");\n    assert_eq!(glob.count(), 10);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_str_prefixed_chunks_by_lines", "test": "fn test_split_str_prefixed_chunks_by_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_str_prefixed_chunks_by_lines\";\n    RandomFile::new(&at, name).add_lines(10000);\n    ucmd.args(&[\"-l\", \"1000\", name, \"d\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"d[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 10);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_additional_suffix", "test": "fn test_split_additional_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_additional_suffix\";\n    RandomFile::new(&at, name).add_lines(2000);\n    ucmd.args(&[\"--additional-suffix\", \".txt\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]].txt$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_additional_suffix_hyphen_value", "test": "fn test_split_additional_suffix_hyphen_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_additional_suffix\";\n    RandomFile::new(&at, name).add_lines(2000);\n    ucmd.args(&[\"--additional-suffix\", \"-300\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]-300$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_lines_short_concatenated_with_value", "test": "fn test_split_lines_short_concatenated_with_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_num_prefixed_chunks_by_lines\";\n    RandomFile::new(&at, name).add_lines(10000);\n    ucmd.args(&[\"-l1000\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 10);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_standalone", "test": "fn test_split_obs_lines_standalone() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"obs-lines-standalone\";\n    RandomFile::new(&at, name).add_lines(4);\n    ucmd.args(&[\"-2\", name]).succeeds().no_stderr().no_stdout();\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_standalone_overflow", "test": "fn test_split_obs_lines_standalone_overflow() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"obs-lines-standalone\";\n    RandomFile::new(&at, name).add_lines(4);\n    ucmd.args(&[\"-99999999999999999991\", name])\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 1);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_within_combined_shorts", "test": "fn test_split_obs_lines_within_combined_shorts() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let name = \"obs-lines-within-shorts\";\n    RandomFile::new(at, name).add_lines(400);\n\n    scene\n        .ucmd()\n        .args(&[\"-x200de\", name])\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n    let glob = Glob::new(at, \".\", r\"x\\d\\d$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_within_combined_shorts_tailing_suffix_length", "test": "fn test_split_obs_lines_within_combined_shorts_tailing_suffix_length() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"obs-lines-combined-shorts-tailing-suffix-length\";\n    RandomFile::new(&at, name).add_lines(1000);\n    ucmd.args(&[\"-d200a4\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x\\d\\d\\d\\d$\");\n    assert_eq!(glob.count(), 5);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_obs_lines_starts_combined_shorts", "test": "fn test_split_obs_lines_starts_combined_shorts() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let name = \"obs-lines-starts-shorts\";\n    RandomFile::new(at, name).add_lines(400);\n\n    scene\n        .ucmd()\n        .args(&[\"-200xd\", name])\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n    let glob = Glob::new(at, \".\", r\"x\\d\\d$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_multiple_obs_lines_standalone", "test": "fn test_split_multiple_obs_lines_standalone() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let name = \"multiple-obs-lines\";\n    RandomFile::new(at, name).add_lines(400);\n\n    scene\n        .ucmd()\n        .args(&[\"-3000\", \"-200\", name])\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n    let glob = Glob::new(at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_multiple_obs_lines_within_combined", "test": "fn test_split_multiple_obs_lines_within_combined() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let name = \"multiple-obs-lines\";\n    RandomFile::new(at, name).add_lines(400);\n\n    scene\n        .ucmd()\n        .args(&[\"-d5000x\", \"-e200d\", name])\n        .succeeds()\n        .no_stderr()\n        .no_stdout();\n    let glob = Glob::new(at, \".\", r\"x\\d\\d$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_overflow_bytes_size", "test": "fn test_split_overflow_bytes_size() {\n    #[cfg(not(target_pointer_width = \"128\"))]\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"test_split_overflow_bytes_size\";\n    RandomFile::new(&at, name).add_bytes(1000);\n    ucmd.args(&[\"-b\", \"1Y\", name]).succeeds();\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 1);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_number_n", "test": "fn test_number_n() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_read = |f| {\n        let mut s = String::new();\n        at.open(f).read_to_string(&mut s).unwrap();\n        s\n    };\n    ucmd.args(&[\"-n\", \"5\", \"asciilowercase.txt\"]).succeeds();\n    assert_eq!(file_read(\"xaa\"), \"abcde\");\n    assert_eq!(file_read(\"xab\"), \"fghij\");\n    assert_eq!(file_read(\"xac\"), \"klmno\");\n    assert_eq!(file_read(\"xad\"), \"pqrst\");\n    assert_eq!(file_read(\"xae\"), \"uvwxyz\\n\");\n    #[cfg(unix)]\n    new_ucmd!()\n        .args(&[\"--number=100\", \"/dev/null\"])\n        .succeeds()\n        .stdout_only(\"\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_number_with_io_blksize", "test": "fn test_split_number_with_io_blksize() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file_read = |f| {\n        let mut s = String::new();\n        at.open(f).read_to_string(&mut s).unwrap();\n        s\n    };\n    ucmd.args(&[\"-n\", \"5\", \"asciilowercase.txt\", \"---io-blksize\", \"1024\"])\n        .succeeds();\n    assert_eq!(file_read(\"xaa\"), \"abcde\");\n    assert_eq!(file_read(\"xab\"), \"fghij\");\n    assert_eq!(file_read(\"xac\"), \"klmno\");\n    assert_eq!(file_read(\"xad\"), \"pqrst\");\n    assert_eq!(file_read(\"xae\"), \"uvwxyz\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_default_with_io_blksize", "test": "fn test_split_default_with_io_blksize() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_default_with_io_blksize\";\n    RandomFile::new(&at, name).add_lines(2000);\n    ucmd.args(&[name, \"---io-blksize\", \"2M\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_suffix_length_short_concatenated_with_value", "test": "fn test_split_suffix_length_short_concatenated_with_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"split_num_prefixed_chunks_by_lines\";\n    RandomFile::new(&at, name).add_lines(10000);\n    ucmd.args(&[\"-a4\", name]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"x[[:alpha:]][[:alpha:]][[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 10);\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_number_chunks_short_concatenated_with_value", "test": "fn test_split_number_chunks_short_concatenated_with_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-n3\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"a\");\n    assert_eq!(at.read(\"xab\"), \"b\");\n    assert_eq!(at.read(\"xac\"), \"c\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_allow_empty_files", "test": "fn test_allow_empty_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-n\", \"4\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"a\");\n    assert_eq!(at.read(\"xab\"), \"b\");\n    assert_eq!(at.read(\"xac\"), \"c\");\n    assert_eq!(at.read(\"xad\"), \"\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_elide_empty_files", "test": "fn test_elide_empty_files() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-e\", \"-n\", \"4\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"a\");\n    assert_eq!(at.read(\"xab\"), \"b\");\n    assert_eq!(at.read(\"xac\"), \"c\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_lines", "test": "fn test_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file_read = |f| {\n        let mut s = String::new();\n        at.open(f).read_to_string(&mut s).unwrap();\n        s\n    };\n\n    // Split into two files without splitting up lines.\n    ucmd.args(&[\"-n\", \"l/2\", \"fivelines.txt\"]).succeeds();\n\n    assert_eq!(file_read(\"xaa\"), \"1\\n2\\n3\\n\");\n    assert_eq!(file_read(\"xab\"), \"4\\n5\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes", "test": "fn test_line_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C\", \"8\", \"letters.txt\"]).succeeds();\n    assert_eq!(at.read(\"xaa\"), \"aaaaaaaa\");\n    assert_eq!(at.read(\"xab\"), \"a\\nbbbb\\n\");\n    assert_eq!(at.read(\"xac\"), \"cccc\\ndd\\n\");\n    assert_eq!(at.read(\"xad\"), \"ee\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes_concatenated_with_value", "test": "fn test_line_bytes_concatenated_with_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C8\", \"letters.txt\"]).succeeds();\n    assert_eq!(at.read(\"xaa\"), \"aaaaaaaa\");\n    assert_eq!(at.read(\"xab\"), \"a\\nbbbb\\n\");\n    assert_eq!(at.read(\"xac\"), \"cccc\\ndd\\n\");\n    assert_eq!(at.read(\"xad\"), \"ee\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes_no_final_newline", "test": "fn test_line_bytes_no_final_newline() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C\", \"2\"])\n        .pipe_in(\"1\\n2222\\n3\\n4\")\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"1\\n\");\n    assert_eq!(at.read(\"xab\"), \"22\");\n    assert_eq!(at.read(\"xac\"), \"22\");\n    assert_eq!(at.read(\"xad\"), \"\\n\");\n    assert_eq!(at.read(\"xae\"), \"3\\n\");\n    assert_eq!(at.read(\"xaf\"), \"4\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes_no_empty_file", "test": "fn test_line_bytes_no_empty_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C\", \"1\"])\n        .pipe_in(\"1\\n2222\\n3\\n4\")\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"1\");\n    assert_eq!(at.read(\"xab\"), \"\\n\");\n    assert_eq!(at.read(\"xac\"), \"2\");\n    assert_eq!(at.read(\"xad\"), \"2\");\n    assert_eq!(at.read(\"xae\"), \"2\");\n    assert_eq!(at.read(\"xaf\"), \"2\");\n    assert_eq!(at.read(\"xag\"), \"\\n\");\n    assert_eq!(at.read(\"xah\"), \"3\");\n    assert_eq!(at.read(\"xai\"), \"\\n\");\n    assert_eq!(at.read(\"xaj\"), \"4\");\n    assert!(!at.plus(\"xak\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_line_bytes_no_eof", "test": "fn test_line_bytes_no_eof() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-C\", \"3\"])\n        .pipe_in(\"1\\n2222\\n3\\n4\")\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"1\\n\");\n    assert_eq!(at.read(\"xab\"), \"222\");\n    assert_eq!(at.read(\"xac\"), \"2\\n\");\n    assert_eq!(at.read(\"xad\"), \"3\\n\");\n    assert_eq!(at.read(\"xae\"), \"4\");\n    assert!(!at.plus(\"xaf\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_guard_input", "test": "fn test_guard_input() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    ts.ucmd()\n        .args(&[\"-C\", \"6\"])\n        .pipe_in(\"1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10\\n\")\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"1\\n2\\n3\\n\");\n\n    ts.ucmd()\n        .args(&[\"-C\", \"6\"])\n        .pipe_in(\"1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10\\n\")\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"xaa\"), \"1\\n2\\n3\\n\");\n\n    ts.ucmd()\n        .args(&[\"-C\", \"6\", \"xaa\"])\n        .fails()\n        .stderr_only(\"split: 'xaa' would overwrite input; aborting\\n\");\n    assert_eq!(at.read(\"xaa\"), \"1\\n2\\n3\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_multiple_of_input_chunk", "test": "fn test_multiple_of_input_chunk() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let name = \"multiple_of_input_chunk\";\n    RandomFile::new(&at, name).add_bytes(16 * 1024);\n    ucmd.args(&[\"-b\", \"8K\", name, \"b\"]).succeeds();\n\n    let glob = Glob::new(&at, \".\", r\"b[[:alpha:]][[:alpha:]]$\");\n    assert_eq!(glob.count(), 2);\n    for filename in glob.collect() {\n        assert_eq!(glob.directory.metadata(&filename).len(), 8 * 1024);\n    }\n    assert_eq!(glob.collate(), at.read_bytes(name));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::count", "code": "fn count(&self) -> usize {\n        self.collect().len()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_numeric_suffix", "test": "fn test_numeric_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-n\", \"4\", \"--numeric-suffixes=9\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x10\"), \"b\");\n    assert_eq!(at.read(\"x11\"), \"c\");\n    assert_eq!(at.read(\"x12\"), \"\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_numeric_suffix_alias", "test": "fn test_numeric_suffix_alias() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-n\", \"4\", \"--numeric=9\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x10\"), \"b\");\n    assert_eq!(at.read(\"x11\"), \"c\");\n    assert_eq!(at.read(\"x12\"), \"\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_hex_suffix", "test": "fn test_hex_suffix() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-n\", \"4\", \"--hex-suffixes=9\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x0a\"), \"b\");\n    assert_eq!(at.read(\"x0b\"), \"c\");\n    assert_eq!(at.read(\"x0c\"), \"\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_hex_suffix_alias", "test": "fn test_hex_suffix_alias() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-n\", \"4\", \"--hex=9\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x0a\"), \"b\");\n    assert_eq!(at.read(\"x0b\"), \"c\");\n    assert_eq!(at.read(\"x0c\"), \"\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_short_numeric_suffix_no_value", "test": "fn test_short_numeric_suffix_no_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-l\", \"9\", \"-d\", \"onehundredlines.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x00\"), \"00\\n01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n\");\n    assert_eq!(at.read(\"x01\"), \"09\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n\");\n    assert_eq!(at.read(\"x02\"), \"18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n\");\n    assert_eq!(at.read(\"x03\"), \"27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n\");\n    assert_eq!(at.read(\"x04\"), \"36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n\");\n    assert_eq!(at.read(\"x05\"), \"45\\n46\\n47\\n48\\n49\\n50\\n51\\n52\\n53\\n\");\n    assert_eq!(at.read(\"x06\"), \"54\\n55\\n56\\n57\\n58\\n59\\n60\\n61\\n62\\n\");\n    assert_eq!(at.read(\"x07\"), \"63\\n64\\n65\\n66\\n67\\n68\\n69\\n70\\n71\\n\");\n    assert_eq!(at.read(\"x08\"), \"72\\n73\\n74\\n75\\n76\\n77\\n78\\n79\\n80\\n\");\n    assert_eq!(at.read(\"x09\"), \"81\\n82\\n83\\n84\\n85\\n86\\n87\\n88\\n89\\n\");\n    assert_eq!(at.read(\"x10\"), \"90\\n91\\n92\\n93\\n94\\n95\\n96\\n97\\n98\\n\");\n    assert_eq!(at.read(\"x11\"), \"99\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_numeric_suffix_no_value", "test": "fn test_numeric_suffix_no_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-l\", \"9\", \"--numeric-suffixes\", \"onehundredlines.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x00\"), \"00\\n01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n\");\n    assert_eq!(at.read(\"x01\"), \"09\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n\");\n    assert_eq!(at.read(\"x02\"), \"18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n\");\n    assert_eq!(at.read(\"x03\"), \"27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n\");\n    assert_eq!(at.read(\"x04\"), \"36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n\");\n    assert_eq!(at.read(\"x05\"), \"45\\n46\\n47\\n48\\n49\\n50\\n51\\n52\\n53\\n\");\n    assert_eq!(at.read(\"x06\"), \"54\\n55\\n56\\n57\\n58\\n59\\n60\\n61\\n62\\n\");\n    assert_eq!(at.read(\"x07\"), \"63\\n64\\n65\\n66\\n67\\n68\\n69\\n70\\n71\\n\");\n    assert_eq!(at.read(\"x08\"), \"72\\n73\\n74\\n75\\n76\\n77\\n78\\n79\\n80\\n\");\n    assert_eq!(at.read(\"x09\"), \"81\\n82\\n83\\n84\\n85\\n86\\n87\\n88\\n89\\n\");\n    assert_eq!(at.read(\"x10\"), \"90\\n91\\n92\\n93\\n94\\n95\\n96\\n97\\n98\\n\");\n    assert_eq!(at.read(\"x11\"), \"99\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_short_hex_suffix_no_value", "test": "fn test_short_hex_suffix_no_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-l\", \"9\", \"-x\", \"onehundredlines.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x00\"), \"00\\n01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n\");\n    assert_eq!(at.read(\"x01\"), \"09\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n\");\n    assert_eq!(at.read(\"x02\"), \"18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n\");\n    assert_eq!(at.read(\"x03\"), \"27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n\");\n    assert_eq!(at.read(\"x04\"), \"36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n\");\n    assert_eq!(at.read(\"x05\"), \"45\\n46\\n47\\n48\\n49\\n50\\n51\\n52\\n53\\n\");\n    assert_eq!(at.read(\"x06\"), \"54\\n55\\n56\\n57\\n58\\n59\\n60\\n61\\n62\\n\");\n    assert_eq!(at.read(\"x07\"), \"63\\n64\\n65\\n66\\n67\\n68\\n69\\n70\\n71\\n\");\n    assert_eq!(at.read(\"x08\"), \"72\\n73\\n74\\n75\\n76\\n77\\n78\\n79\\n80\\n\");\n    assert_eq!(at.read(\"x09\"), \"81\\n82\\n83\\n84\\n85\\n86\\n87\\n88\\n89\\n\");\n    assert_eq!(at.read(\"x0a\"), \"90\\n91\\n92\\n93\\n94\\n95\\n96\\n97\\n98\\n\");\n    assert_eq!(at.read(\"x0b\"), \"99\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_hex_suffix_no_value", "test": "fn test_hex_suffix_no_value() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-l\", \"9\", \"--hex-suffixes\", \"onehundredlines.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x00\"), \"00\\n01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n\");\n    assert_eq!(at.read(\"x01\"), \"09\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n\");\n    assert_eq!(at.read(\"x02\"), \"18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n\");\n    assert_eq!(at.read(\"x03\"), \"27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n\");\n    assert_eq!(at.read(\"x04\"), \"36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n\");\n    assert_eq!(at.read(\"x05\"), \"45\\n46\\n47\\n48\\n49\\n50\\n51\\n52\\n53\\n\");\n    assert_eq!(at.read(\"x06\"), \"54\\n55\\n56\\n57\\n58\\n59\\n60\\n61\\n62\\n\");\n    assert_eq!(at.read(\"x07\"), \"63\\n64\\n65\\n66\\n67\\n68\\n69\\n70\\n71\\n\");\n    assert_eq!(at.read(\"x08\"), \"72\\n73\\n74\\n75\\n76\\n77\\n78\\n79\\n80\\n\");\n    assert_eq!(at.read(\"x09\"), \"81\\n82\\n83\\n84\\n85\\n86\\n87\\n88\\n89\\n\");\n    assert_eq!(at.read(\"x0a\"), \"90\\n91\\n92\\n93\\n94\\n95\\n96\\n97\\n98\\n\");\n    assert_eq!(at.read(\"x0b\"), \"99\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_short_combination", "test": "fn test_short_combination() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-dxen\", \"4\", \"threebytes.txt\"])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert_eq!(at.read(\"x00\"), \"a\");\n    assert_eq!(at.read(\"x01\"), \"b\");\n    assert_eq!(at.read(\"x02\"), \"c\");\n    assert!(!at.file_exists(\"x03\"));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_effective_suffix_numeric_last", "test": "fn test_effective_suffix_numeric_last() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\n        \"-n\",\n        \"4\",\n        \"--numeric-suffixes=7\",\n        \"--hex-suffixes=4\",\n        \"-d\",\n        \"-x\",\n        \"--numeric-suffixes=9\",\n        \"threebytes.txt\",\n    ])\n    .succeeds()\n    .no_stdout()\n    .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x10\"), \"b\");\n    assert_eq!(at.read(\"x11\"), \"c\");\n    assert_eq!(at.read(\"x12\"), \"\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_effective_suffix_hex_last", "test": "fn test_effective_suffix_hex_last() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\n        \"-n\",\n        \"4\",\n        \"--hex-suffixes=7\",\n        \"--numeric-suffixes=4\",\n        \"-x\",\n        \"-d\",\n        \"--hex-suffixes=9\",\n        \"threebytes.txt\",\n    ])\n    .succeeds()\n    .no_stdout()\n    .no_stderr();\n    assert_eq!(at.read(\"x09\"), \"a\");\n    assert_eq!(at.read(\"x0a\"), \"b\");\n    assert_eq!(at.read(\"x0b\"), \"c\");\n    assert_eq!(at.read(\"x0c\"), \"\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_round_robin", "test": "fn test_round_robin() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let file_read = |f| {\n        let mut s = String::new();\n        at.open(f).read_to_string(&mut s).unwrap();\n        s\n    };\n\n    ucmd.args(&[\"-n\", \"r/2\", \"fivelines.txt\"]).succeeds();\n\n    assert_eq!(file_read(\"xaa\"), \"1\\n3\\n5\\n\");\n    assert_eq!(file_read(\"xab\"), \"2\\n4\\n\");\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nl_lines", "test": "fn test_split_separator_nl_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--lines=2\", \"-t\", \"\\n\"])\n        .pipe_in(\"1\\n2\\n3\\n4\\n5\\n\")\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\n2\\n\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\n4\\n\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\n\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nl_line_bytes", "test": "fn test_split_separator_nl_line_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--line-bytes=4\", \"-t\", \"\\n\"])\n        .pipe_in(\"1\\n2\\n3\\n4\\n5\\n\")\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\n2\\n\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\n4\\n\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\n\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nl_number_l", "test": "fn test_split_separator_nl_number_l() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=l/3\", \"--separator=\\n\", \"fivelines.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\n2\\n\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\n4\\n\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\n\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nl_number_r", "test": "fn test_split_separator_nl_number_r() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=r/3\", \"--separator\", \"\\n\", \"fivelines.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\n4\\n\");\n    assert_eq!(file_read(&at, \"xab\"), \"2\\n5\\n\");\n    assert_eq!(file_read(&at, \"xac\"), \"3\\n\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nul_lines", "test": "fn test_split_separator_nul_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--lines=2\", \"-t\", \"\\\\0\", \"separator_nul.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\x002\\0\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\x004\\0\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\0\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nul_line_bytes", "test": "fn test_split_separator_nul_line_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--line-bytes=4\", \"-t\", \"\\\\0\", \"separator_nul.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\x002\\0\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\x004\\0\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\0\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nul_number_l", "test": "fn test_split_separator_nul_number_l() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=l/3\", \"--separator=\\\\0\", \"separator_nul.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\x002\\0\");\n    assert_eq!(file_read(&at, \"xab\"), \"3\\x004\\0\");\n    assert_eq!(file_read(&at, \"xac\"), \"5\\0\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_nul_number_r", "test": "fn test_split_separator_nul_number_r() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=r/3\", \"--separator=\\\\0\", \"separator_nul.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1\\x004\\0\");\n    assert_eq!(file_read(&at, \"xab\"), \"2\\x005\\0\");\n    assert_eq!(file_read(&at, \"xac\"), \"3\\0\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_lines", "test": "fn test_split_separator_semicolon_lines() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--lines=2\", \"-t\", \";\", \"separator_semicolon.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1;2;\");\n    assert_eq!(file_read(&at, \"xab\"), \"3;4;\");\n    assert_eq!(file_read(&at, \"xac\"), \"5;\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_line_bytes", "test": "fn test_split_separator_semicolon_line_bytes() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--line-bytes=4\", \"-t\", \";\", \"separator_semicolon.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1;2;\");\n    assert_eq!(file_read(&at, \"xab\"), \"3;4;\");\n    assert_eq!(file_read(&at, \"xac\"), \"5;\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_number_l", "test": "fn test_split_separator_semicolon_number_l() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=l/3\", \"--separator=;\", \"separator_semicolon.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1;2;\");\n    assert_eq!(file_read(&at, \"xab\"), \"3;4;\");\n    assert_eq!(file_read(&at, \"xac\"), \"5;\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::test_split_separator_semicolon_number_r", "test": "fn test_split_separator_semicolon_number_r() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"--number=r/3\", \"--separator=;\", \"separator_semicolon.txt\"])\n        .succeeds();\n\n    assert_eq!(file_read(&at, \"xaa\"), \"1;4;\");\n    assert_eq!(file_read(&at, \"xab\"), \"2;5;\");\n    assert_eq!(file_read(&at, \"xac\"), \"3;\");\n    assert!(!at.plus(\"xad\").exists());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_split.rs::file_read", "code": "fn file_read(at: &AtPath, filename: &str) -> String {\n    let mut s = String::new();\n    at.open(filename).read_to_string(&mut s).unwrap();\n    s\n}", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_terse_normal_format", "test": "fn test_terse_normal_format() {\n    // note: contains birth/creation date which increases test fragility\n    // * results may vary due to built-in `stat` limitations as well as linux kernel and rust version capability variations\n    let args = [\"-t\", \"/\"];\n    let ts = TestScenario::new(util_name!());\n    let actual = ts.ucmd().args(&args).succeeds().stdout_move_str();\n    let expect = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    println!(\"actual: {actual:?}\");\n    println!(\"expect: {expect:?}\");\n    let v_actual: Vec<&str> = actual.trim().split(' ').collect();\n    let mut v_expect: Vec<&str> = expect.trim().split(' ').collect();\n    assert!(!v_expect.is_empty());\n\n    // uu_stat does not support selinux\n    if v_actual.len() == v_expect.len() - 1 && v_expect[v_expect.len() - 1].contains(':') {\n        // assume last element contains: `SELinux security context string`\n        v_expect.pop();\n    }\n\n    // * allow for inequality if `stat` (aka, expect) returns \"0\" (unknown value)\n    assert!(\n        expect == \"0\"\n            || expect == \"0\\n\"\n            || v_actual\n                .iter()\n                .zip(v_expect.iter())\n                .all(|(a, e)| a == e || *e == \"0\" || *e == \"0\\n\")\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_format_created_time", "test": "fn test_format_created_time() {\n    let args = [\"-c\", \"%w\", \"/bin\"];\n    let ts = TestScenario::new(util_name!());\n    let actual = ts.ucmd().args(&args).succeeds().stdout_move_str();\n    let expect = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    println!(\"actual: {actual:?}\");\n    println!(\"expect: {expect:?}\");\n    // note: using a regex instead of `split_whitespace()` in order to detect whitespace differences\n    let re = regex::Regex::new(r\"\\s\").unwrap();\n    let v_actual: Vec<&str> = re.split(&actual).collect();\n    let v_expect: Vec<&str> = re.split(&expect).collect();\n    assert!(!v_expect.is_empty());\n    // * allow for inequality if `stat` (aka, expect) returns \"-\" (unknown value)\n    assert!(\n        expect == \"-\"\n            || expect == \"-\\n\"\n            || v_actual\n                .iter()\n                .zip(v_expect.iter())\n                .all(|(a, e)| a == e || *e == \"-\" || *e == \"-\\n\")\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_stat.rs::test_format_created_seconds", "test": "fn test_format_created_seconds() {\n    let args = [\"-c\", \"%W\", \"/bin\"];\n    let ts = TestScenario::new(util_name!());\n    let actual = ts.ucmd().args(&args).succeeds().stdout_move_str();\n    let expect = unwrap_or_return!(expected_result(&ts, &args)).stdout_move_str();\n    println!(\"actual: {actual:?}\");\n    println!(\"expect: {expect:?}\");\n    // note: using a regex instead of `split_whitespace()` in order to detect whitespace differences\n    let re = regex::Regex::new(r\"\\s\").unwrap();\n    let v_actual: Vec<&str> = re.split(&actual).collect();\n    let v_expect: Vec<&str> = re.split(&expect).collect();\n    assert!(!v_expect.is_empty());\n    // * allow for inequality if `stat` (aka, expect) returns \"0\" (unknown value)\n    assert!(\n        expect == \"0\"\n            || expect == \"0\\n\"\n            || v_actual\n                .iter()\n                .zip(v_expect.iter())\n                .all(|(a, e)| a == e || *e == \"0\" || *e == \"0\\n\")\n    );\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_bytes_big", "test": "fn test_bytes_big() {\n    const FILE: &str = \"test_bytes_big.txt\";\n    const EXPECTED_FILE: &str = \"test_bytes_big_expected.txt\";\n    const BYTES: usize = 1_000_000;\n    const N_ARG: usize = 100_000;\n\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    let mut big_input = at.make_file(FILE);\n    for i in 0..BYTES {\n        let digit = from_digit((i % 10) as u32, 10).unwrap();\n        write!(big_input, \"{digit}\").expect(\"Could not write to FILE\");\n    }\n    big_input.flush().expect(\"Could not flush FILE\");\n\n    let mut big_expected = at.make_file(EXPECTED_FILE);\n    for i in (BYTES - N_ARG)..BYTES {\n        let digit = from_digit((i % 10) as u32, 10).unwrap();\n        write!(big_expected, \"{digit}\").expect(\"Could not write to EXPECTED_FILE\");\n    }\n    big_expected.flush().expect(\"Could not flush EXPECTED_FILE\");\n\n    let result = ucmd\n        .arg(FILE)\n        .arg(\"-c\")\n        .arg(format!(\"{N_ARG}\"))\n        .succeeds()\n        .stdout_move_str();\n    let expected = at.read(EXPECTED_FILE);\n\n    assert_eq!(result.len(), expected.len());\n    for (actual_char, expected_char) in result.chars().zip(expected.chars()) {\n        assert_eq!(actual_char, expected_char);\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/dd.rs::len", "code": "fn len(&self) -> std::io::Result<i64> {\n        match self {\n            Self::File(f) => Ok(f.metadata()?.len().try_into().unwrap_or(i64::MAX)),\n            _ => Ok(0),\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tail.rs::test_negative_indexing", "test": "fn test_negative_indexing() {\n    let positive_lines_index = new_ucmd!().arg(\"-n\").arg(\"5\").arg(FOOBAR_TXT).run();\n\n    let negative_lines_index = new_ucmd!().arg(\"-n\").arg(\"-5\").arg(FOOBAR_TXT).run();\n\n    let positive_bytes_index = new_ucmd!().arg(\"-c\").arg(\"20\").arg(FOOBAR_TXT).run();\n\n    let negative_bytes_index = new_ucmd!().arg(\"-c\").arg(\"-20\").arg(FOOBAR_TXT).run();\n\n    assert_eq!(positive_lines_index.stdout(), negative_lines_index.stdout());\n    assert_eq!(positive_bytes_index.stdout(), negative_bytes_index.stdout());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout", "code": "pub fn stdout(&self) -> &[u8] {\n        &self.stdout\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tee.rs::test_tee_processing_multiple_operands", "test": "fn test_tee_processing_multiple_operands() {\n    // POSIX says: \"Processing of at least 13 file operands shall be supported.\"\n\n    let content = \"tee_sample_content\";\n    for n in [1, 2, 12, 13] {\n        let files = (1..=n).map(|x| x.to_string()).collect::<Vec<_>>();\n        let (at, mut ucmd) = at_and_ucmd!();\n\n        ucmd.args(&files)\n            .pipe_in(content)\n            .succeeds()\n            .stdout_is(content);\n\n        for file in &files {\n            assert!(at.file_exists(file));\n            assert_eq!(at.read(file), content);\n        }\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tee.rs::test_tee_treat_minus_as_filename", "test": "fn test_tee_treat_minus_as_filename() {\n    // Ensure tee treats '-' as the name of a file, as mandated by POSIX.\n\n    let (at, mut ucmd) = at_and_ucmd!();\n    let content = \"tee_sample_content\";\n    let file = \"-\";\n\n    ucmd.arg(\"-\").pipe_in(content).succeeds().stdout_is(content);\n\n    assert!(at.file_exists(file));\n    assert_eq!(at.read(file), content);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tee.rs::test_tee_append", "test": "fn test_tee_append() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let content = \"tee_sample_content\";\n    let file = \"tee_out\";\n\n    at.touch(file);\n    at.write(file, content);\n    assert_eq!(at.read(file), content);\n\n    ucmd.arg(\"-a\")\n        .arg(file)\n        .pipe_in(content)\n        .succeeds()\n        .stdout_is(content);\n    assert!(at.file_exists(file));\n    assert_eq!(at.read(file), content.repeat(2));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/parseargs.rs::read", "code": "pub(crate) fn read(mut self, operands: &[&str]) -> Result<Self, ParseError> {\n        for operand in operands {\n            self.parse_operand(operand)?;\n        }\n\n        Ok(self)\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_test.rs::test_non_existing_files", "test": "fn test_non_existing_files() {\n    let scenario = TestScenario::new(util_name!());\n\n    let result = scenario\n        .ucmd()\n        .args(&[\"newer_file\", \"-nt\", \"regular_file\"])\n        .fails();\n    assert!(result.stderr().is_empty());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/src/uu/dd/src/progress.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        self.reads_complete == 0 && self.reads_partial == 0\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_default", "test": "fn test_touch_default() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_default_file\";\n\n    ucmd.arg(file).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_no_create_file_absent", "test": "fn test_touch_no_create_file_absent() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_no_create_file_absent\";\n\n    ucmd.arg(\"-c\").arg(file).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_no_create_file_exists", "test": "fn test_touch_no_create_file_exists() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_no_create_file_exists\";\n\n    at.touch(file);\n    assert!(at.file_exists(file));\n\n    ucmd.arg(\"-c\").arg(file).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_mdhm_time", "test": "fn test_touch_set_mdhm_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_mdhm_time\";\n\n    ucmd.args(&[\"-t\", \"01011234\", file]).succeeds().no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\n        \"%Y%m%d%H%M\",\n        &format!(\"{}01010000\", time::OffsetDateTime::now_utc().year()),\n    );\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_mdhms_time", "test": "fn test_touch_set_mdhms_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_mdhms_time\";\n\n    ucmd.args(&[\"-t\", \"01011234.56\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\n        \"%Y%m%d%H%M.%S\",\n        &format!(\"{}01010000.00\", time::OffsetDateTime::now_utc().year()),\n    );\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_ymdhm_time", "test": "fn test_touch_set_ymdhm_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_ymdhm_time\";\n\n    ucmd.args(&[\"-t\", \"1501011234\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_ymdhms_time", "test": "fn test_touch_set_ymdhms_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_ymdhms_time\";\n\n    ucmd.args(&[\"-t\", \"1501011234.56\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M.%S\", \"201501010000.00\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_cymdhm_time", "test": "fn test_touch_set_cymdhm_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_cymdhm_time\";\n\n    ucmd.args(&[\"-t\", \"201501011234\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_cymdhms_time", "test": "fn test_touch_set_cymdhms_time() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_cymdhms_time\";\n\n    ucmd.args(&[\"-t\", \"201501011234.56\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M.%S\", \"201501010000.00\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45296);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_only_atime", "test": "fn test_touch_set_only_atime() {\n    let atime_args = [\"-a\", \"--time=access\", \"--time=atime\", \"--time=use\"];\n    let file = \"test_touch_set_only_atime\";\n\n    for atime_arg in atime_args {\n        let (at, mut ucmd) = at_and_ucmd!();\n\n        ucmd.args(&[\"-t\", \"201501011234\", atime_arg, file])\n            .succeeds()\n            .no_stderr();\n\n        assert!(at.file_exists(file));\n\n        let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n        let (atime, mtime) = get_file_times(&at, file);\n        assert!(atime != mtime);\n        assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_both_time_and_reference", "test": "fn test_touch_set_both_time_and_reference() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ref_file = \"test_touch_reference\";\n    let file = \"test_touch_set_both_time_and_reference\";\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n\n    at.touch(ref_file);\n    set_file_times(&at, ref_file, start_of_year, start_of_year);\n    assert!(at.file_exists(ref_file));\n\n    ucmd.args(&[\"-t\", \"2015010112342\", \"-r\", ref_file, file])\n        .fails();\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_both_date_and_reference", "test": "fn test_touch_set_both_date_and_reference() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ref_file = \"test_touch_reference\";\n    let file = \"test_touch_set_both_date_and_reference\";\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501011234\");\n\n    at.touch(ref_file);\n    set_file_times(&at, ref_file, start_of_year, start_of_year);\n    assert!(at.file_exists(ref_file));\n\n    ucmd.args(&[\"-d\", \"Thu Jan 01 12:34:00 2015\", \"-r\", ref_file, file])\n        .succeeds()\n        .no_stderr();\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, start_of_year);\n    assert_eq!(mtime, start_of_year);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_both_offset_date_and_reference", "test": "fn test_touch_set_both_offset_date_and_reference() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let ref_file = \"test_touch_reference\";\n    let file = \"test_touch_set_both_date_and_reference\";\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501011234\");\n    let five_days_later = str_to_filetime(\"%Y%m%d%H%M\", \"201501061234\");\n\n    at.touch(ref_file);\n    set_file_times(&at, ref_file, start_of_year, start_of_year);\n    assert!(at.file_exists(ref_file));\n\n    ucmd.args(&[\"-d\", \"+5 days\", \"-r\", ref_file, file])\n        .succeeds()\n        .no_stderr();\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, five_days_later);\n    assert_eq!(mtime, five_days_later);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_only_mtime", "test": "fn test_touch_set_only_mtime() {\n    let mtime_args = [\"-m\", \"--time=modify\", \"--time=mtime\"];\n    let file = \"test_touch_set_only_mtime\";\n\n    for mtime_arg in mtime_args {\n        let (at, mut ucmd) = at_and_ucmd!();\n\n        ucmd.args(&[\"-t\", \"201501011234\", mtime_arg, file])\n            .succeeds()\n            .no_stderr();\n\n        assert!(at.file_exists(file));\n\n        let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n        let (atime, mtime) = get_file_times(&at, file);\n        assert!(atime != mtime);\n        assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_both", "test": "fn test_touch_set_both() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_both\";\n\n    ucmd.args(&[\"-t\", \"201501011234\", \"-a\", \"-m\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n    assert_eq!(mtime.unix_seconds() - start_of_year.unix_seconds(), 45240);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_reference", "test": "fn test_touch_reference() {\n    let scenario = TestScenario::new(\"touch\");\n    let (at, mut _ucmd) = (scenario.fixtures.clone(), scenario.ucmd());\n    let file_a = \"test_touch_reference_a\";\n    let file_b = \"test_touch_reference_b\";\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501010000\");\n\n    at.touch(file_a);\n    set_file_times(&at, file_a, start_of_year, start_of_year);\n    assert!(at.file_exists(file_a));\n    for opt in [\"-r\", \"--ref\", \"--reference\"] {\n        scenario\n            .ccmd(\"touch\")\n            .args(&[opt, file_a, file_b])\n            .succeeds()\n            .no_stderr();\n\n        assert!(at.file_exists(file_b));\n\n        let (atime, mtime) = get_file_times(&at, file_b);\n        assert_eq!(atime, mtime);\n        assert_eq!(atime, start_of_year);\n        assert_eq!(mtime, start_of_year);\n        let _ = remove_file(file_b);\n    }\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date", "test": "fn test_touch_set_date() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"Thu Jan 01 12:34:00 2015\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"201501011234\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, start_of_year);\n    assert_eq!(mtime, start_of_year);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date2", "test": "fn test_touch_set_date2() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"2000-01-23\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let start_of_year = str_to_filetime(\"%Y%m%d%H%M\", \"200001230000\");\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, start_of_year);\n    assert_eq!(mtime, start_of_year);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date3", "test": "fn test_touch_set_date3() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"@1623786360\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let expected = FileTime::from_unix_time(1_623_786_360, 0);\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, expected);\n    assert_eq!(mtime, expected);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date4", "test": "fn test_touch_set_date4() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"1970-01-01 18:43:33\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let expected = FileTime::from_unix_time(67413, 0);\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, expected);\n    assert_eq!(mtime, expected);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date5", "test": "fn test_touch_set_date5() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"1970-01-01 18:43:33.023456789\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    // Slightly different result on Windows for nano seconds\n    // TODO: investigate\n    #[cfg(windows)]\n    let expected = FileTime::from_unix_time(67413, 23_456_700);\n    #[cfg(not(windows))]\n    let expected = FileTime::from_unix_time(67413, 23_456_789);\n\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, expected);\n    assert_eq!(mtime, expected);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date6", "test": "fn test_touch_set_date6() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"2000-01-01 00:00\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let expected = FileTime::from_unix_time(946_684_800, 0);\n\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, expected);\n    assert_eq!(mtime, expected);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_touch.rs::test_touch_set_date7", "test": "fn test_touch_set_date7() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_touch_set_date\";\n\n    ucmd.args(&[\"-d\", \"2004-01-16 12:00 +0000\", file])\n        .succeeds()\n        .no_stderr();\n\n    assert!(at.file_exists(file));\n\n    let expected = FileTime::from_unix_time(1_074_254_400, 0);\n\n    let (atime, mtime) = get_file_times(&at, file);\n    assert_eq!(atime, mtime);\n    assert_eq!(atime, expected);\n    assert_eq!(mtime, expected);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_new_file", "test": "fn test_new_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let filename = \"new_file_that_does_not_exist_yet\";\n    ucmd.args(&[\"-s\", \"8\", filename])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert!(at.file_exists(filename));\n    assert_eq!(at.read_bytes(filename), vec![b'\\0'; 8]);\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_new_file_no_create", "test": "fn test_new_file_no_create() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let filename = \"new_file_that_does_not_exist_yet\";\n    ucmd.args(&[\"-s\", \"8\", \"-c\", filename])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert!(!at.file_exists(filename));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_truncate.rs::test_underflow_relative_size", "test": "fn test_underflow_relative_size() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    ucmd.args(&[\"-s-1\", FILE1])\n        .succeeds()\n        .no_stdout()\n        .no_stderr();\n    assert!(at.file_exists(FILE1));\n    assert!(at.read_bytes(FILE1).is_empty());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_version_flag", "test": "fn test_version_flag() {\n    let version_short = new_ucmd!().arg(\"-V\").succeeds();\n    let version_long = new_ucmd!().arg(\"--version\").succeeds();\n\n    assert_eq!(version_short.stdout_str(), version_long.stdout_str());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_tsort.rs::test_help_flag", "test": "fn test_help_flag() {\n    let help_short = new_ucmd!().arg(\"-h\").succeeds();\n    let help_long = new_ucmd!().arg(\"--help\").succeeds();\n\n    assert_eq!(help_short.stdout_str(), help_long.stdout_str());\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::stdout_str", "code": "pub fn stdout_str(&self) -> &str {\n        std::str::from_utf8(&self.stdout).unwrap()\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unlink.rs::test_unlink_file", "test": "fn test_unlink_file() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    let file = \"test_unlink_file\";\n\n    at.touch(file);\n\n    ucmd.arg(file).succeeds().no_stderr();\n\n    assert!(!at.file_exists(file));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_unlink.rs::test_unlink_symlink", "test": "fn test_unlink_symlink() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.touch(\"foo\");\n    at.symlink_file(\"foo\", \"bar\");\n\n    ucmd.arg(\"bar\").succeeds().no_stderr();\n\n    assert!(at.file_exists(\"foo\"));\n    assert!(!at.file_exists(\"bar\"));\n}", "code_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/common/util.rs::file_exists", "code": "pub fn file_exists<P: AsRef<Path>>(&self, path: P) -> bool {\n        match fs::metadata(self.plus(path)) {\n            Ok(m) => m.is_file(),\n            Err(_) => false,\n        }\n    }", "docstring": null}
