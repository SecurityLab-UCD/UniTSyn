{"test_id": "str4d-rage/str4d-rage-e6180f1/tests-gen/age_stanza.rs::test_something", "test": "fn test_something() {\n    let data = [];\n    if let Ok((leftover, stanza)) = read::age_stanza(data) {\n        let mut buf = Vec::with_capacity(data.len());\n        gen(\n            write::age_stanza(stanza.tag, &stanza.args, &stanza.body()),\n            &mut buf,\n        )\n        .expect(\"can write to Vec\");\n        assert_eq!(buf, &data[0..data.len() - leftover.len()]);\n    }\n}", "code_id": "str4d-rage/str4d-rage-e6180f1/age/src/primitives/stream.rs::len", "code": "fn len(&mut self) -> io::Result<u64> {\n        match self.plaintext_len {\n            None => {\n                // Cache the current position and nonce, and then grab the start and end\n                // ciphertext positions.\n                let cur_pos = self.inner.seek(SeekFrom::Current(0))?;\n                let cur_nonce = self.stream.nonce.0;\n                let ct_start = self.start()?;\n                let ct_end = self.inner.seek(SeekFrom::End(0))?;\n                let ct_len = ct_end - ct_start;\n\n                // Use ceiling division to determine the number of chunks.\n                let num_chunks =\n                    (ct_len + (ENCRYPTED_CHUNK_SIZE as u64 - 1)) / ENCRYPTED_CHUNK_SIZE as u64;\n\n                // Authenticate the ciphertext length by checking that we can successfully\n                // decrypt the last chunk _as_ a last chunk.\n                let last_chunk_start = ct_start + ((num_chunks - 1) * ENCRYPTED_CHUNK_SIZE as u64);\n                let mut last_chunk = Vec::with_capacity((ct_end - last_chunk_start) as usize);\n                self.inner.seek(SeekFrom::Start(last_chunk_start))?;\n                self.inner.read_to_end(&mut last_chunk)?;\n                self.stream.nonce.set_counter(num_chunks - 1);\n                self.stream.decrypt_chunk(&last_chunk, true).map_err(|_| {\n                    io::Error::new(\n                        io::ErrorKind::InvalidData,\n                        \"Last chunk is invalid, stream might be truncated\",\n                    )\n                })?;\n\n                // Now that we have authenticated the ciphertext length, we can use it to\n                // calculate the plaintext length.\n                let total_tag_size = num_chunks * TAG_SIZE as u64;\n                let pt_len = ct_len - total_tag_size;\n\n                // Return to the original position and restore the nonce.\n                self.inner.seek(SeekFrom::Start(cur_pos))?;\n                self.stream.nonce = Nonce(cur_nonce);\n\n                // Cache the length for future calls.\n                self.plaintext_len = Some(pt_len);\n\n                Ok(pt_len)\n            }\n            Some(pt_len) => Ok(pt_len),\n        }\n    }", "docstring": null}
