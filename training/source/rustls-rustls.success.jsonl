{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_client_data_sent", "test": "fn buffered_client_data_sent() {\n    let server_config = Arc::new(make_server_config(KeyType::Rsa));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n        assert_eq!(5, client.writer().write(b\"hello\").unwrap());\n\n        do_handshake(&mut client, &mut server);\n        transfer(&mut client, &mut server);\n        server.process_new_packets().unwrap();\n\n        check_read(&mut server.reader(), b\"hello\");\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/examples/src/bin/tlsclient-mio.rs::write", "code": "fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_server_data_sent", "test": "fn buffered_server_data_sent() {\n    let server_config = Arc::new(make_server_config(KeyType::Rsa));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n        assert_eq!(5, server.writer().write(b\"hello\").unwrap());\n\n        do_handshake(&mut client, &mut server);\n        transfer(&mut server, &mut client);\n        client.process_new_packets().unwrap();\n\n        check_read(&mut client.reader(), b\"hello\");\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/stream.rs::write", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_both_data_sent", "test": "fn buffered_both_data_sent() {\n    let server_config = Arc::new(make_server_config(KeyType::Rsa));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n        assert_eq!(\n            12,\n            server\n                .writer()\n                .write(b\"from-server!\")\n                .unwrap()\n        );\n        assert_eq!(\n            12,\n            client\n                .writer()\n                .write(b\"from-client!\")\n                .unwrap()\n        );\n\n        do_handshake(&mut client, &mut server);\n\n        transfer(&mut server, &mut client);\n        client.process_new_packets().unwrap();\n        transfer(&mut client, &mut server);\n        server.process_new_packets().unwrap();\n\n        check_read(&mut client.reader(), b\"from-server!\");\n        check_read(&mut server.reader(), b\"from-client!\");\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/stream.rs::write", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_close_notify", "test": "fn server_close_notify() {\n    let kt = KeyType::Rsa;\n    let server_config = Arc::new(make_server_config_with_mandatory_client_auth(kt));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions_with_auth(kt, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n        do_handshake(&mut client, &mut server);\n\n        // check that alerts don't overtake appdata\n        assert_eq!(\n            12,\n            server\n                .writer()\n                .write(b\"from-server!\")\n                .unwrap()\n        );\n        assert_eq!(\n            12,\n            client\n                .writer()\n                .write(b\"from-client!\")\n                .unwrap()\n        );\n        server.send_close_notify();\n\n        transfer(&mut server, &mut client);\n        let io_state = client.process_new_packets().unwrap();\n        assert!(io_state.peer_has_closed());\n        check_read_and_close(&mut client.reader(), b\"from-server!\");\n\n        transfer(&mut client, &mut server);\n        server.process_new_packets().unwrap();\n        check_read(&mut server.reader(), b\"from-client!\");\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/stream.rs::write", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_close_notify", "test": "fn client_close_notify() {\n    let kt = KeyType::Rsa;\n    let server_config = Arc::new(make_server_config_with_mandatory_client_auth(kt));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions_with_auth(kt, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n        do_handshake(&mut client, &mut server);\n\n        // check that alerts don't overtake appdata\n        assert_eq!(\n            12,\n            server\n                .writer()\n                .write(b\"from-server!\")\n                .unwrap()\n        );\n        assert_eq!(\n            12,\n            client\n                .writer()\n                .write(b\"from-client!\")\n                .unwrap()\n        );\n        client.send_close_notify();\n\n        transfer(&mut client, &mut server);\n        let io_state = server.process_new_packets().unwrap();\n        assert!(io_state.peer_has_closed());\n        check_read_and_close(&mut server.reader(), b\"from-client!\");\n\n        transfer(&mut server, &mut client);\n        client.process_new_packets().unwrap();\n        check_read(&mut client.reader(), b\"from-server!\");\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/stream.rs::write", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_closes_uncleanly", "test": "fn server_closes_uncleanly() {\n    let kt = KeyType::Rsa;\n    let server_config = Arc::new(make_server_config(kt));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n        do_handshake(&mut client, &mut server);\n\n        // check that unclean EOF reporting does not overtake appdata\n        assert_eq!(\n            12,\n            server\n                .writer()\n                .write(b\"from-server!\")\n                .unwrap()\n        );\n        assert_eq!(\n            12,\n            client\n                .writer()\n                .write(b\"from-client!\")\n                .unwrap()\n        );\n\n        transfer(&mut server, &mut client);\n        transfer_eof(&mut client);\n        let io_state = client.process_new_packets().unwrap();\n        assert!(!io_state.peer_has_closed());\n        check_read(&mut client.reader(), b\"from-server!\");\n\n        check_read_err(\n            &mut client.reader() as &mut dyn io::Read,\n            io::ErrorKind::UnexpectedEof,\n        );\n\n        // may still transmit pending frames\n        transfer(&mut client, &mut server);\n        server.process_new_packets().unwrap();\n        check_read(&mut server.reader(), b\"from-client!\");\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/stream.rs::write", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_closes_uncleanly", "test": "fn client_closes_uncleanly() {\n    let kt = KeyType::Rsa;\n    let server_config = Arc::new(make_server_config(kt));\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n        do_handshake(&mut client, &mut server);\n\n        // check that unclean EOF reporting does not overtake appdata\n        assert_eq!(\n            12,\n            server\n                .writer()\n                .write(b\"from-server!\")\n                .unwrap()\n        );\n        assert_eq!(\n            12,\n            client\n                .writer()\n                .write(b\"from-client!\")\n                .unwrap()\n        );\n\n        transfer(&mut client, &mut server);\n        transfer_eof(&mut server);\n        let io_state = server.process_new_packets().unwrap();\n        assert!(!io_state.peer_has_closed());\n        check_read(&mut server.reader(), b\"from-client!\");\n\n        check_read_err(\n            &mut server.reader() as &mut dyn io::Read,\n            io::ErrorKind::UnexpectedEof,\n        );\n\n        // may still transmit pending frames\n        transfer(&mut server, &mut client);\n        client.process_new_packets().unwrap();\n        check_read(&mut client.reader(), b\"from-server!\");\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/stream.rs::write", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_cert_resolve", "test": "fn client_cert_resolve() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let server_config = Arc::new(make_server_config_with_mandatory_client_auth(*kt));\n\n        let expected_issuers = match *kt {\n            KeyType::Rsa => vec![\n                b\"0,1*0(\\x06\\x03U\\x04\\x03\\x0c!ponytown RSA level 2 intermediate\".to_vec(),\n                b\"0\\x1a1\\x180\\x16\\x06\\x03U\\x04\\x03\\x0c\\x0fponytown RSA CA\".to_vec(),\n            ],\n            KeyType::Ecdsa => vec![\n                b\"0.1,0*\\x06\\x03U\\x04\\x03\\x0c#ponytown ECDSA level 2 intermediate\".to_vec(),\n                b\"0\\x1c1\\x1a0\\x18\\x06\\x03U\\x04\\x03\\x0c\\x11ponytown ECDSA CA\".to_vec(),\n            ],\n            KeyType::Ed25519 => vec![\n                b\"0.1,0*\\x06\\x03U\\x04\\x03\\x0c#ponytown EdDSA level 2 intermediate\".to_vec(),\n                b\"0\\x1c1\\x1a0\\x18\\x06\\x03U\\x04\\x03\\x0c\\x11ponytown EdDSA CA\".to_vec(),\n            ],\n        };\n\n        for version in rustls::ALL_VERSIONS {\n            let expected_sigschemes = match version.version {\n                ProtocolVersion::TLSv1_2 => vec![\n                    SignatureScheme::ECDSA_NISTP384_SHA384,\n                    SignatureScheme::ECDSA_NISTP256_SHA256,\n                    SignatureScheme::ED25519,\n                    SignatureScheme::RSA_PSS_SHA512,\n                    SignatureScheme::RSA_PSS_SHA384,\n                    SignatureScheme::RSA_PSS_SHA256,\n                    SignatureScheme::RSA_PKCS1_SHA512,\n                    SignatureScheme::RSA_PKCS1_SHA384,\n                    SignatureScheme::RSA_PKCS1_SHA256,\n                ],\n                ProtocolVersion::TLSv1_3 => vec![\n                    SignatureScheme::ECDSA_NISTP384_SHA384,\n                    SignatureScheme::ECDSA_NISTP256_SHA256,\n                    SignatureScheme::ED25519,\n                    SignatureScheme::RSA_PSS_SHA512,\n                    SignatureScheme::RSA_PSS_SHA384,\n                    SignatureScheme::RSA_PSS_SHA256,\n                ],\n                _ => unreachable!(),\n            };\n\n            println!(\"{:?} {:?}:\", version.version, *kt);\n\n            let mut client_config = make_client_config_with_versions(*kt, &[version]);\n            client_config.client_auth_cert_resolver = Arc::new(ClientCheckCertResolve::new(\n                1,\n                expected_issuers.clone(),\n                expected_sigschemes,\n            ));\n\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n            assert_eq!(\n                do_handshake_until_error(&mut client, &mut server),\n                Err(ErrorFromPeer::Server(Error::NoCertificatesPresented))\n            );\n        }\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/common/mod.rs::do_handshake_until_error", "code": "pub fn do_handshake_until_error(\n    client: &mut ClientConnection,\n    server: &mut ServerConnection,\n) -> Result<(), ErrorFromPeer> {\n    while server.is_handshaking() || client.is_handshaking() {\n        transfer(client, server);\n        server\n            .process_new_packets()\n            .map_err(ErrorFromPeer::Server)?;\n        transfer(server, client);\n        client\n            .process_new_packets()\n            .map_err(ErrorFromPeer::Client)?;\n    }\n\n    Ok(())\n}", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_respects_buffer_limit_pre_handshake", "test": "fn server_respects_buffer_limit_pre_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    server.set_buffer_limit(Some(32));\n\n    assert_eq!(\n        server\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        20\n    );\n    assert_eq!(\n        server\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        12\n    );\n\n    do_handshake(&mut client, &mut server);\n    transfer(&mut server, &mut client);\n    client.process_new_packets().unwrap();\n\n    check_read(&mut client.reader(), b\"01234567890123456789012345678901\");\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/stream.rs::write", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_respects_buffer_limit_pre_handshake_with_vectored_write", "test": "fn server_respects_buffer_limit_pre_handshake_with_vectored_write() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    server.set_buffer_limit(Some(32));\n\n    assert_eq!(\n        server\n            .writer()\n            .write_vectored(&[\n                IoSlice::new(b\"01234567890123456789\"),\n                IoSlice::new(b\"01234567890123456789\")\n            ])\n            .unwrap(),\n        32\n    );\n\n    do_handshake(&mut client, &mut server);\n    transfer(&mut server, &mut client);\n    client.process_new_packets().unwrap();\n\n    check_read(&mut client.reader(), b\"01234567890123456789012345678901\");\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/stream.rs::write_vectored", "code": "fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self\n            .conn\n            .writer()\n            .write_vectored(bufs)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_respects_buffer_limit_post_handshake", "test": "fn server_respects_buffer_limit_post_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    // this test will vary in behaviour depending on the default suites\n    do_handshake(&mut client, &mut server);\n    server.set_buffer_limit(Some(48));\n\n    assert_eq!(\n        server\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        20\n    );\n    assert_eq!(\n        server\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        6\n    );\n\n    transfer(&mut server, &mut client);\n    client.process_new_packets().unwrap();\n\n    check_read(&mut client.reader(), b\"01234567890123456789012345\");\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/stream.rs::write", "code": "fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.complete_prior_io()?;\n\n        let len = self.conn.writer().write(buf)?;\n\n        // Try to write the underlying transport here, but don't let\n        // any errors mask the fact we've consumed `len` bytes.\n        // Callers will learn of permanent errors on the next call.\n        let _ = self.conn.complete_io(self.sock);\n\n        Ok(len)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_respects_buffer_limit_pre_handshake", "test": "fn client_respects_buffer_limit_pre_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    client.set_buffer_limit(Some(32));\n\n    assert_eq!(\n        client\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        20\n    );\n    assert_eq!(\n        client\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        12\n    );\n\n    do_handshake(&mut client, &mut server);\n    transfer(&mut client, &mut server);\n    server.process_new_packets().unwrap();\n\n    check_read(&mut server.reader(), b\"01234567890123456789012345678901\");\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/examples/src/bin/tlsclient-mio.rs::write", "code": "fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_respects_buffer_limit_pre_handshake_with_vectored_write", "test": "fn client_respects_buffer_limit_pre_handshake_with_vectored_write() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    client.set_buffer_limit(Some(32));\n\n    assert_eq!(\n        client\n            .writer()\n            .write_vectored(&[\n                IoSlice::new(b\"01234567890123456789\"),\n                IoSlice::new(b\"01234567890123456789\")\n            ])\n            .unwrap(),\n        32\n    );\n\n    do_handshake(&mut client, &mut server);\n    transfer(&mut client, &mut server);\n    server.process_new_packets().unwrap();\n\n    check_read(&mut server.reader(), b\"01234567890123456789012345678901\");\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/conn.rs::write_vectored", "code": "fn write_vectored(&mut self, bufs: &[io::IoSlice<'_>]) -> io::Result<usize> {\n        let mut sz = 0;\n        for buf in bufs {\n            sz += self.send_some_plaintext(buf);\n        }\n        Ok(sz)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_respects_buffer_limit_post_handshake", "test": "fn client_respects_buffer_limit_post_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    do_handshake(&mut client, &mut server);\n    client.set_buffer_limit(Some(48));\n\n    assert_eq!(\n        client\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        20\n    );\n    assert_eq!(\n        client\n            .writer()\n            .write(b\"01234567890123456789\")\n            .unwrap(),\n        6\n    );\n\n    transfer(&mut client, &mut server);\n    server.process_new_packets().unwrap();\n\n    check_read(&mut server.reader(), b\"01234567890123456789012345\");\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/examples/src/bin/tlsclient-mio.rs::write", "code": "fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::new_server_returns_initial_io_state", "test": "fn new_server_returns_initial_io_state() {\n    let (_, mut server) = make_pair(KeyType::Rsa);\n    let io_state = server.process_new_packets().unwrap();\n    println!(\"IoState is Debug {:?}\", io_state);\n    assert_eq!(io_state.plaintext_bytes_to_read(), 0);\n    assert!(!io_state.peer_has_closed());\n    assert_eq!(io_state.tls_bytes_to_write(), 0);\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/common_state.rs::plaintext_bytes_to_read", "code": "pub fn plaintext_bytes_to_read(&self) -> usize {\n        self.plaintext_bytes_to_read\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::new_client_returns_initial_io_state", "test": "fn new_client_returns_initial_io_state() {\n    let (mut client, _) = make_pair(KeyType::Rsa);\n    let io_state = client.process_new_packets().unwrap();\n    println!(\"IoState is Debug {:?}\", io_state);\n    assert_eq!(io_state.plaintext_bytes_to_read(), 0);\n    assert!(!io_state.peer_has_closed());\n    assert!(io_state.tls_bytes_to_write() > 200);\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/common_state.rs::plaintext_bytes_to_read", "code": "pub fn plaintext_bytes_to_read(&self) -> usize {\n        self.plaintext_bytes_to_read\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_complete_io_for_handshake", "test": "fn client_complete_io_for_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    assert!(client.is_handshaking());\n    let (rdlen, wrlen) = client\n        .complete_io(&mut OtherSession::new(&mut server))\n        .unwrap();\n    assert!(rdlen > 0 && wrlen > 0);\n    assert!(!client.is_handshaking());\n    assert!(!client.wants_write());\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/common_state.rs::is_handshaking", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::buffered_client_complete_io_for_handshake", "test": "fn buffered_client_complete_io_for_handshake() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n\n    assert!(client.is_handshaking());\n    let (rdlen, wrlen) = client\n        .complete_io(&mut OtherSession::new_buffered(&mut server))\n        .unwrap();\n    assert!(rdlen > 0 && wrlen > 0);\n    assert!(!client.is_handshaking());\n    assert!(!client.wants_write());\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/common_state.rs::is_handshaking", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_complete_io_for_handshake_eof", "test": "fn client_complete_io_for_handshake_eof() {\n    let (mut client, _) = make_pair(KeyType::Rsa);\n    let mut input = io::Cursor::new(Vec::new());\n\n    assert!(client.is_handshaking());\n    let err = client\n        .complete_io(&mut input)\n        .unwrap_err();\n    assert_eq!(io::ErrorKind::UnexpectedEof, err.kind());\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/common_state.rs::is_handshaking", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_complete_io_for_handshake", "test": "fn server_complete_io_for_handshake() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let (mut client, mut server) = make_pair(*kt);\n\n        assert!(server.is_handshaking());\n        let (rdlen, wrlen) = server\n            .complete_io(&mut OtherSession::new(&mut client))\n            .unwrap();\n        assert!(rdlen > 0 && wrlen > 0);\n        assert!(!server.is_handshaking());\n        assert!(!server.wants_write());\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/common_state.rs::is_handshaking", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_complete_io_for_handshake_eof", "test": "fn server_complete_io_for_handshake_eof() {\n    let (_, mut server) = make_pair(KeyType::Rsa);\n    let mut input = io::Cursor::new(Vec::new());\n\n    assert!(server.is_handshaking());\n    let err = server\n        .complete_io(&mut input)\n        .unwrap_err();\n    assert_eq!(io::ErrorKind::UnexpectedEof, err.kind());\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/common_state.rs::is_handshaking", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_complete_io_for_handshake_ending_with_alert", "test": "fn server_complete_io_for_handshake_ending_with_alert() {\n    let (client_config, server_config) = make_disjoint_suite_configs();\n    let (mut client, mut server) = make_pair_for_configs(client_config, server_config);\n\n    assert!(server.is_handshaking());\n\n    let mut pipe = OtherSession::new_fails(&mut client);\n    let rc = server.complete_io(&mut pipe);\n    assert!(rc.is_err(), \"server io failed due to handshake failure\");\n    assert!(!server.wants_write(), \"but server did send its alert\");\n    assert_eq!(\n        format!(\"{:?}\", pipe.last_error),\n        \"Some(AlertReceived(HandshakeFailure))\",\n        \"which was received by client\"\n    );\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/common_state.rs::is_handshaking", "code": "pub fn is_handshaking(&self) -> bool {\n        !(self.may_send_application_data && self.may_receive_application_data)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_exposes_offered_sni", "test": "fn server_exposes_offered_sni() {\n    let kt = KeyType::Rsa;\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"second.testserver.com\"))\n                .unwrap();\n        let mut server = ServerConnection::new(Arc::new(make_server_config(kt))).unwrap();\n\n        assert_eq!(None, server.server_name());\n        do_handshake(&mut client, &mut server);\n        assert_eq!(Some(\"second.testserver.com\"), server.server_name());\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/server/server_conn.rs::server_name", "code": "pub fn server_name(&self) -> Option<&str> {\n        self.server_name\n            .as_ref()\n            .map(<DnsName as AsRef<str>>::as_ref)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_exposes_offered_sni_smashed_to_lowercase", "test": "fn server_exposes_offered_sni_smashed_to_lowercase() {\n    // webpki actually does this for us in its DnsName type\n    let kt = KeyType::Rsa;\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"SECOND.TESTServer.com\"))\n                .unwrap();\n        let mut server = ServerConnection::new(Arc::new(make_server_config(kt))).unwrap();\n\n        assert_eq!(None, server.server_name());\n        do_handshake(&mut client, &mut server);\n        assert_eq!(Some(\"second.testserver.com\"), server.server_name());\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/server/server_conn.rs::server_name", "code": "pub fn server_name(&self) -> Option<&str> {\n        self.server_name\n            .as_ref()\n            .map(<DnsName as AsRef<str>>::as_ref)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_exposes_offered_sni_even_if_resolver_fails", "test": "fn server_exposes_offered_sni_even_if_resolver_fails() {\n    let kt = KeyType::Rsa;\n    let resolver = rustls::server::ResolvesServerCertUsingSni::new();\n\n    let mut server_config = make_server_config(kt);\n    server_config.cert_resolver = Arc::new(resolver);\n    let server_config = Arc::new(server_config);\n\n    for version in rustls::ALL_VERSIONS {\n        let client_config = make_client_config_with_versions(kt, &[version]);\n        let mut server = ServerConnection::new(Arc::clone(&server_config)).unwrap();\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"thisdoesNOTexist.com\"))\n                .unwrap();\n\n        assert_eq!(None, server.server_name());\n        transfer(&mut client, &mut server);\n        assert_eq!(\n            server.process_new_packets(),\n            Err(Error::General(\n                \"no server certificate chain resolved\".to_string()\n            ))\n        );\n        assert_eq!(Some(\"thisdoesnotexist.com\"), server.server_name());\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/server/server_conn.rs::server_name", "code": "pub fn server_name(&self) -> Option<&str> {\n        self.server_name\n            .as_ref()\n            .map(<DnsName as AsRef<str>>::as_ref)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/key_log_file_env.rs::exercise_key_log_file_for_client", "test": "fn exercise_key_log_file_for_client() {\n    serialized(|| {\n        let server_config = Arc::new(make_server_config(KeyType::Rsa));\n        env::set_var(\"SSLKEYLOGFILE\", \"./sslkeylogfile.txt\");\n\n        for version in rustls::ALL_VERSIONS {\n            let mut client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n            client_config.key_log = Arc::new(rustls::KeyLogFile::new());\n\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n            assert_eq!(5, client.writer().write(b\"hello\").unwrap());\n\n            do_handshake(&mut client, &mut server);\n            transfer(&mut client, &mut server);\n            server.process_new_packets().unwrap();\n        }\n    })\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/examples/src/bin/tlsclient-mio.rs::write", "code": "fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/key_log_file_env.rs::exercise_key_log_file_for_server", "test": "fn exercise_key_log_file_for_server() {\n    serialized(|| {\n        let mut server_config = make_server_config(KeyType::Rsa);\n\n        env::set_var(\"SSLKEYLOGFILE\", \"./sslkeylogfile.txt\");\n        server_config.key_log = Arc::new(rustls::KeyLogFile::new());\n\n        let server_config = Arc::new(server_config);\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n\n            assert_eq!(5, client.writer().write(b\"hello\").unwrap());\n\n            do_handshake(&mut client, &mut server);\n            transfer(&mut client, &mut server);\n            server.process_new_packets().unwrap();\n        }\n    })\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/examples/src/bin/tlsclient-mio.rs::write", "code": "fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n        self.tls_conn.writer().write(bytes)\n    }", "docstring": null}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/tests-gen/message.rs::test_something", "test": "fn test_something() {\n    let data = [];\n    let mut rdr = Reader::init(data);\n    if let Ok(m) = OpaqueMessage::read(&mut rdr) {\n        let msg = match Message::try_from(m.into_plain_message()) {\n            Ok(msg) => msg,\n            Err(_) => return,\n        };\n        let enc = PlainMessage::from(msg)\n            .into_unencrypted_opaque()\n            .encode();\n        assert_eq!(enc, data[..rdr.used()]);\n    }\n}", "code_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/src/msgs/codec.rs::used", "code": "pub fn used(&self) -> usize {\n        self.cursor\n    }", "docstring": null}
