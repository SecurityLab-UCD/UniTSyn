{"test_id": "tormol-encode_unicode/tormol-encode_unicode-b764bc1/tests-gen/utf8char_decoding_iterators.rs::test_something", "test": "fn test_something() {\n    let data = [];\n    let from_bytes: Vec<_> = data.iter().to_utf8chars().collect();\n    let mut byte_start = 0;\n    let mut item_start = 0;\n    loop {\n        let (valid_up_to, error_length) = match str::from_utf8(&data[byte_start..]) {\n            Ok(s) => (s.len(), None),\n            Err(e) => (e.valid_up_to(), e.error_len()),\n        };\n        let valid_range = byte_start..byte_start + valid_up_to;\n        let good_part = str::from_utf8(&data[valid_range]).unwrap();\n        let mut chars = 0;\n        for (i, c) in good_part.chars().enumerate() {\n            chars += 1;\n            assert_eq!(from_bytes.get(item_start + i), Some(&Ok(Utf8Char::from(c))));\n        }\n        let error_start = item_start + chars;\n        if let Some(error_length) = error_length {\n            let error_end = error_start + error_length;\n            assert!(from_bytes[error_start..error_end]\n                .iter()\n                .all(|r| r.is_err()));\n            item_start = error_end;\n            byte_start = byte_start + valid_up_to + error_length;\n        } else if byte_start + valid_up_to == data.len() {\n            assert_eq!(from_bytes.len(), error_start);\n            break;\n        } else {\n            data[byte_start + valid_up_to].extra_utf8_bytes().unwrap();\n            assert_eq!(\n                from_bytes.len() - error_start,\n                data.len() - valid_up_to - byte_start\n            );\n            assert_eq!(\n                from_bytes[error_start].map_err(|e| e.kind()),\n                Err(TooFewBytes)\n            );\n            break;\n        }\n    }\n    let from_slice: Vec<_> = data.utf8char_indices().map(|(_, r, _)| r).collect();\n    for (i, (&br, &sr)) in from_bytes.iter().zip(&from_slice).enumerate() {\n        match sr {\n            Err(e) if e.kind() == TooFewBytes || e.kind() == InterruptedSequence => {\n                assert!(br.is_err(), \"byte {}\", i)\n            }\n            _ => assert_eq!(sr, br, \"byte {}\", i),\n        }\n    }\n    assert_eq!(from_slice.len(), from_bytes.len());\n}", "error": "Not Definition Found"}
{"test_id": "tormol-encode_unicode/tormol-encode_unicode-b764bc1/tests-gen/utf8char_from_slice_start.rs::test_something", "test": "fn test_something() {\n    let data = [];\n    if data.len() > 0 {\n        match Utf8Char::from_slice_start(data) {\n            Err(_) => assert!(std::str::from_utf8(data).is_err()),\n            Ok((c, len)) => assert_eq!(c.as_str(), std::str::from_utf8(&data[..len]).unwrap()),\n        }\n    }\n}", "error": "Not Definition Found"}
