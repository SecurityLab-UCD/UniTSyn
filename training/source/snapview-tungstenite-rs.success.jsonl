{"test_id": "snapview-tungstenite-rs/snapview-tungstenite-rs-219075e/tests/connection_reset.rs::test_server_close", "test": "fn test_server_close() {\n    do_test(\n        3012,\n        |mut cli_sock| {\n            cli_sock.send(Message::Text(\"Hello WebSocket\".into())).unwrap();\n\n            let message = cli_sock.read().unwrap(); // receive close from server\n            assert!(message.is_close());\n\n            let err = cli_sock.read().unwrap_err(); // now we should get ConnectionClosed\n            match err {\n                Error::ConnectionClosed => {}\n                _ => panic!(\"unexpected error: {:?}\", err),\n            }\n        },\n        |mut srv_sock| {\n            let message = srv_sock.read().unwrap();\n            assert_eq!(message.into_data(), b\"Hello WebSocket\");\n\n            srv_sock.close(None).unwrap(); // send close to client\n\n            let message = srv_sock.read().unwrap(); // receive acknowledgement\n            assert!(message.is_close());\n\n            let err = srv_sock.read().unwrap_err(); // now we should get ConnectionClosed\n            match err {\n                Error::ConnectionClosed => {}\n                _ => panic!(\"unexpected error: {:?}\", err),\n            }\n        },\n    );\n}", "code_id": "snapview-tungstenite-rs/snapview-tungstenite-rs-219075e/src/protocol/message.rs::is_close", "code": "pub fn is_close(&self) -> bool {\n        matches!(*self, Message::Close(_))\n    }", "docstring": null}
{"test_id": "snapview-tungstenite-rs/snapview-tungstenite-rs-219075e/tests/connection_reset.rs::test_evil_server_close", "test": "fn test_evil_server_close() {\n    do_test(\n        3013,\n        |mut cli_sock| {\n            cli_sock.send(Message::Text(\"Hello WebSocket\".into())).unwrap();\n\n            sleep(Duration::from_secs(1));\n\n            let message = cli_sock.read().unwrap(); // receive close from server\n            assert!(message.is_close());\n\n            let err = cli_sock.read().unwrap_err(); // now we should get ConnectionClosed\n            match err {\n                Error::ConnectionClosed => {}\n                _ => panic!(\"unexpected error: {:?}\", err),\n            }\n        },\n        |mut srv_sock| {\n            let message = srv_sock.read().unwrap();\n            assert_eq!(message.into_data(), b\"Hello WebSocket\");\n\n            srv_sock.close(None).unwrap(); // send close to client\n\n            let message = srv_sock.read().unwrap(); // receive acknowledgement\n            assert!(message.is_close());\n            // and now just drop the connection without waiting for `ConnectionClosed`\n            srv_sock.get_mut().set_linger(Some(Duration::from_secs(0))).unwrap();\n            drop(srv_sock);\n        },\n    );\n}", "code_id": "snapview-tungstenite-rs/snapview-tungstenite-rs-219075e/src/protocol/message.rs::is_close", "code": "pub fn is_close(&self) -> bool {\n        matches!(*self, Message::Close(_))\n    }", "docstring": null}
{"test_id": "snapview-tungstenite-rs/snapview-tungstenite-rs-219075e/tests/connection_reset.rs::test_client_close", "test": "fn test_client_close() {\n    do_test(\n        3014,\n        |mut cli_sock| {\n            cli_sock.send(Message::Text(\"Hello WebSocket\".into())).unwrap();\n\n            let message = cli_sock.read().unwrap(); // receive answer from server\n            assert_eq!(message.into_data(), b\"From Server\");\n\n            cli_sock.close(None).unwrap(); // send close to server\n\n            let message = cli_sock.read().unwrap(); // receive acknowledgement from server\n            assert!(message.is_close());\n\n            let err = cli_sock.read().unwrap_err(); // now we should get ConnectionClosed\n            match err {\n                Error::ConnectionClosed => {}\n                _ => panic!(\"unexpected error: {:?}\", err),\n            }\n        },\n        |mut srv_sock| {\n            let message = srv_sock.read().unwrap();\n            assert_eq!(message.into_data(), b\"Hello WebSocket\");\n\n            srv_sock.send(Message::Text(\"From Server\".into())).unwrap();\n\n            let message = srv_sock.read().unwrap(); // receive close from client\n            assert!(message.is_close());\n\n            let err = srv_sock.read().unwrap_err(); // now we should get ConnectionClosed\n            match err {\n                Error::ConnectionClosed => {}\n                _ => panic!(\"unexpected error: {:?}\", err),\n            }\n        },\n    );\n}", "code_id": "snapview-tungstenite-rs/snapview-tungstenite-rs-219075e/src/protocol/message.rs::into_data", "code": "pub fn into_data(self) -> Vec<u8> {\n        match self {\n            Message::Text(string) => string.into_bytes(),\n            Message::Binary(data) | Message::Ping(data) | Message::Pong(data) => data,\n            Message::Close(None) => Vec::new(),\n            Message::Close(Some(frame)) => frame.reason.into_owned().into_bytes(),\n            Message::Frame(frame) => frame.into_data(),\n        }\n    }", "docstring": null}
{"test_id": "snapview-tungstenite-rs/snapview-tungstenite-rs-219075e/tests/write.rs::write_flush_behaviour", "test": "fn write_flush_behaviour() {\n    const SEND_ME_LEN: usize = 10;\n    const BATCH_ME_LEN: usize = 11;\n    const WRITE_BUFFER_SIZE: usize = 600;\n\n    let mut ws = WebSocket::from_raw_socket(\n        MockWrite::default(),\n        tungstenite::protocol::Role::Server,\n        Some(WebSocketConfig { write_buffer_size: WRITE_BUFFER_SIZE, ..<_>::default() }),\n    );\n\n    assert_eq!(ws.get_ref().written_bytes, 0);\n    assert_eq!(ws.get_ref().write_count, 0);\n    assert_eq!(ws.get_ref().flush_count, 0);\n\n    // `send` writes & flushes immediately\n    ws.send(Message::Text(\"Send me!\".into())).unwrap();\n    assert_eq!(ws.get_ref().written_bytes, SEND_ME_LEN);\n    assert_eq!(ws.get_ref().write_count, 1);\n    assert_eq!(ws.get_ref().flush_count, 1);\n\n    // send a batch of messages\n    for msg in (0..100).map(|_| Message::Text(\"Batch me!\".into())) {\n        ws.write(msg).unwrap();\n    }\n    // after 55 writes the out_buffer will exceed write_buffer_size=600\n    // and so do a single underlying write (not flushing).\n    assert_eq!(ws.get_ref().written_bytes, 55 * BATCH_ME_LEN + SEND_ME_LEN);\n    assert_eq!(ws.get_ref().write_count, 2);\n    assert_eq!(ws.get_ref().flush_count, 1);\n\n    // flushing will perform a single write for the remaining out_buffer & flush.\n    ws.flush().unwrap();\n    assert_eq!(ws.get_ref().written_bytes, 100 * BATCH_ME_LEN + SEND_ME_LEN);\n    assert_eq!(ws.get_ref().write_count, 3);\n    assert_eq!(ws.get_ref().flush_count, 2);\n}", "code_id": "snapview-tungstenite-rs/snapview-tungstenite-rs-219075e/src/handshake/machine.rs::get_ref", "code": "pub fn get_ref(&self) -> &Stream {\n        &self.stream\n    }", "docstring": null}
