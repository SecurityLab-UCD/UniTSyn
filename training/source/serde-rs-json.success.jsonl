{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_serialize_char", "test": "fn test_serialize_char() {\n    let value = json!(\n        ({\n            let mut map = BTreeMap::new();\n            map.insert('c', ());\n            map\n        })\n    );\n    assert_eq!(&Value::Null, value.get(\"c\").unwrap());\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/map.rs::get", "code": "pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_serialize_rejects_adt_keys", "test": "fn test_serialize_rejects_adt_keys() {\n    let map = treemap!(\n        Some(\"a\") => 2,\n        Some(\"b\") => 4,\n        None => 6,\n    );\n\n    let err = to_vec(&map).unwrap_err();\n    assert_eq!(err.to_string(), \"key must be a string\");\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/ser.rs::to_string", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_bytes_ser", "test": "fn test_bytes_ser() {\n    let buf = vec![];\n    let bytes = Bytes::new(&buf);\n    assert_eq!(to_string(&bytes).unwrap(), \"[]\".to_string());\n\n    let buf = vec![1, 2, 3];\n    let bytes = Bytes::new(&buf);\n    assert_eq!(to_string(&bytes).unwrap(), \"[1,2,3]\".to_string());\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/ser.rs::to_string", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_byte_buf_ser", "test": "fn test_byte_buf_ser() {\n    let bytes = ByteBuf::new();\n    assert_eq!(to_string(&bytes).unwrap(), \"[]\".to_string());\n\n    let bytes = ByteBuf::from(vec![1, 2, 3]);\n    assert_eq!(to_string(&bytes).unwrap(), \"[1,2,3]\".to_string());\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/ser.rs::to_string", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_integer_key", "test": "fn test_integer_key() {\n    // map with integer keys\n    let map = treemap!(\n        1 => 2,\n        -1 => 6,\n    );\n    let j = r#\"{\"-1\":6,\"1\":2}\"#;\n    test_encode_ok(&[(&map, j)]);\n    test_parse_ok(vec![(j, map)]);\n\n    test_parse_err::<BTreeMap<i32, ()>>(&[\n        (\n            r#\"{\"x\":null}\"#,\n            \"invalid value: expected key to be a number in quotes at line 1 column 2\",\n        ),\n        (\n            r#\"{\" 123\":null}\"#,\n            \"invalid value: expected key to be a number in quotes at line 1 column 2\",\n        ),\n        (r#\"{\"123 \":null}\"#, \"expected `\\\"` at line 1 column 6\"),\n    ]);\n\n    let err = from_value::<BTreeMap<i32, ()>>(json!({\" 123\":null})).unwrap_err();\n    assert_eq!(\n        err.to_string(),\n        \"invalid value: expected key to be a number in quotes\",\n    );\n\n    let err = from_value::<BTreeMap<i32, ()>>(json!({\"123 \":null})).unwrap_err();\n    assert_eq!(\n        err.to_string(),\n        \"invalid value: expected key to be a number in quotes\",\n    );\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/ser.rs::to_string", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_integer128_key", "test": "fn test_integer128_key() {\n    let map = treemap! {\n        100000000000000000000000000000000000000u128 => (),\n    };\n    let j = r#\"{\"100000000000000000000000000000000000000\":null}\"#;\n    assert_eq!(to_string(&map).unwrap(), j);\n    assert_eq!(from_str::<BTreeMap<u128, ()>>(j).unwrap(), map);\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/ser.rs::to_string", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_category", "test": "fn test_category() {\n    assert!(from_str::<String>(\"123\").unwrap_err().is_data());\n\n    assert!(from_str::<String>(\"]\").unwrap_err().is_syntax());\n\n    assert!(from_str::<String>(\"\").unwrap_err().is_eof());\n    assert!(from_str::<String>(\"\\\"\").unwrap_err().is_eof());\n    assert!(from_str::<String>(\"\\\"\\\\\").unwrap_err().is_eof());\n    assert!(from_str::<String>(\"\\\"\\\\u\").unwrap_err().is_eof());\n    assert!(from_str::<String>(\"\\\"\\\\u0\").unwrap_err().is_eof());\n    assert!(from_str::<String>(\"\\\"\\\\u00\").unwrap_err().is_eof());\n    assert!(from_str::<String>(\"\\\"\\\\u000\").unwrap_err().is_eof());\n\n    assert!(from_str::<Vec<usize>>(\"[\").unwrap_err().is_eof());\n    assert!(from_str::<Vec<usize>>(\"[0\").unwrap_err().is_eof());\n    assert!(from_str::<Vec<usize>>(\"[0,\").unwrap_err().is_eof());\n\n    assert!(from_str::<BTreeMap<String, usize>>(\"{\")\n        .unwrap_err()\n        .is_eof());\n    assert!(from_str::<BTreeMap<String, usize>>(\"{\\\"k\\\"\")\n        .unwrap_err()\n        .is_eof());\n    assert!(from_str::<BTreeMap<String, usize>>(\"{\\\"k\\\":\")\n        .unwrap_err()\n        .is_eof());\n    assert!(from_str::<BTreeMap<String, usize>>(\"{\\\"k\\\":0\")\n        .unwrap_err()\n        .is_eof());\n    assert!(from_str::<BTreeMap<String, usize>>(\"{\\\"k\\\":0,\")\n        .unwrap_err()\n        .is_eof());\n\n    let fail = FailReader(io::ErrorKind::NotConnected);\n    assert!(from_reader::<_, String>(fail).unwrap_err().is_io());\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/error.rs::is_data", "code": "pub fn is_data(&self) -> bool {\n        self.classify() == Category::Data\n    }", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_integer128", "test": "fn test_integer128() {\n    let signed = &[i128::min_value(), -1, 0, 1, i128::max_value()];\n    let unsigned = &[0, 1, u128::max_value()];\n\n    for integer128 in signed {\n        let expected = integer128.to_string();\n        assert_eq!(to_string(integer128).unwrap(), expected);\n        assert_eq!(from_str::<i128>(&expected).unwrap(), *integer128);\n    }\n\n    for integer128 in unsigned {\n        let expected = integer128.to_string();\n        assert_eq!(to_string(integer128).unwrap(), expected);\n        assert_eq!(from_str::<u128>(&expected).unwrap(), *integer128);\n    }\n\n    test_parse_err::<i128>(&[\n        (\n            \"-170141183460469231731687303715884105729\",\n            \"number out of range at line 1 column 40\",\n        ),\n        (\n            \"170141183460469231731687303715884105728\",\n            \"number out of range at line 1 column 39\",\n        ),\n    ]);\n\n    test_parse_err::<u128>(&[\n        (\"-1\", \"number out of range at line 1 column 1\"),\n        (\n            \"340282366920938463463374607431768211456\",\n            \"number out of range at line 1 column 39\",\n        ),\n    ]);\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/ser.rs::to_string", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_integer128_to_value", "test": "fn test_integer128_to_value() {\n    let signed = &[i128::from(i64::min_value()), i128::from(u64::max_value())];\n    let unsigned = &[0, u128::from(u64::max_value())];\n\n    for integer128 in signed {\n        let expected = integer128.to_string();\n        assert_eq!(to_value(integer128).unwrap().to_string(), expected);\n    }\n\n    for integer128 in unsigned {\n        let expected = integer128.to_string();\n        assert_eq!(to_value(integer128).unwrap().to_string(), expected);\n    }\n\n    if !cfg!(feature = \"arbitrary_precision\") {\n        let err = to_value(u128::from(u64::max_value()) + 1).unwrap_err();\n        assert_eq!(err.to_string(), \"number out of range\");\n    }\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/ser.rs::to_string", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_borrowed_raw_value", "test": "fn test_borrowed_raw_value() {\n    #[derive(Serialize, Deserialize)]\n    struct Wrapper<'a> {\n        a: i8,\n        #[serde(borrow)]\n        b: &'a RawValue,\n        c: i8,\n    }\n\n    let wrapper_from_str: Wrapper =\n        serde_json::from_str(r#\"{\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3}\"#).unwrap();\n    assert_eq!(r#\"{\"foo\": 2}\"#, wrapper_from_str.b.get());\n\n    let wrapper_to_string = serde_json::to_string(&wrapper_from_str).unwrap();\n    assert_eq!(r#\"{\"a\":1,\"b\":{\"foo\": 2},\"c\":3}\"#, wrapper_to_string);\n\n    let wrapper_to_value = serde_json::to_value(&wrapper_from_str).unwrap();\n    assert_eq!(json!({\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3}), wrapper_to_value);\n\n    let array_from_str: Vec<&RawValue> =\n        serde_json::from_str(r#\"[\"a\", 42, {\"foo\": \"bar\"}, null]\"#).unwrap();\n    assert_eq!(r#\"\"a\"\"#, array_from_str[0].get());\n    assert_eq!(r#\"42\"#, array_from_str[1].get());\n    assert_eq!(r#\"{\"foo\": \"bar\"}\"#, array_from_str[2].get());\n    assert_eq!(r#\"null\"#, array_from_str[3].get());\n\n    let array_to_string = serde_json::to_string(&array_from_str).unwrap();\n    assert_eq!(r#\"[\"a\",42,{\"foo\": \"bar\"},null]\"#, array_to_string);\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/map.rs::get", "code": "pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_raw_value_in_map_key", "test": "fn test_raw_value_in_map_key() {\n    #[derive(RefCast)]\n    #[repr(transparent)]\n    struct RawMapKey(RawValue);\n\n    impl<'de> Deserialize<'de> for &'de RawMapKey {\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: serde::Deserializer<'de>,\n        {\n            let raw_value = <&RawValue>::deserialize(deserializer)?;\n            Ok(RawMapKey::ref_cast(raw_value))\n        }\n    }\n\n    impl PartialEq for RawMapKey {\n        fn eq(&self, other: &Self) -> bool {\n            self.0.get() == other.0.get()\n        }\n    }\n\n    impl Eq for RawMapKey {}\n\n    impl Hash for RawMapKey {\n        fn hash<H: Hasher>(&self, hasher: &mut H) {\n            self.0.get().hash(hasher);\n        }\n    }\n\n    let map_from_str: HashMap<&RawMapKey, &RawValue> =\n        serde_json::from_str(r#\" {\"\\\\k\":\"\\\\v\"} \"#).unwrap();\n    let (map_k, map_v) = map_from_str.into_iter().next().unwrap();\n    assert_eq!(\"\\\"\\\\\\\\k\\\"\", map_k.0.get());\n    assert_eq!(\"\\\"\\\\\\\\v\\\"\", map_v.get());\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/map.rs::get", "code": "pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_boxed_raw_value", "test": "fn test_boxed_raw_value() {\n    #[derive(Serialize, Deserialize)]\n    struct Wrapper {\n        a: i8,\n        b: Box<RawValue>,\n        c: i8,\n    }\n\n    let wrapper_from_str: Wrapper =\n        serde_json::from_str(r#\"{\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3}\"#).unwrap();\n    assert_eq!(r#\"{\"foo\": 2}\"#, wrapper_from_str.b.get());\n\n    let wrapper_from_reader: Wrapper =\n        serde_json::from_reader(br#\"{\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3}\"#.as_ref()).unwrap();\n    assert_eq!(r#\"{\"foo\": 2}\"#, wrapper_from_reader.b.get());\n\n    let wrapper_from_value: Wrapper =\n        serde_json::from_value(json!({\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3})).unwrap();\n    assert_eq!(r#\"{\"foo\":2}\"#, wrapper_from_value.b.get());\n\n    let wrapper_to_string = serde_json::to_string(&wrapper_from_str).unwrap();\n    assert_eq!(r#\"{\"a\":1,\"b\":{\"foo\": 2},\"c\":3}\"#, wrapper_to_string);\n\n    let wrapper_to_value = serde_json::to_value(&wrapper_from_str).unwrap();\n    assert_eq!(json!({\"a\": 1, \"b\": {\"foo\": 2}, \"c\": 3}), wrapper_to_value);\n\n    let array_from_str: Vec<Box<RawValue>> =\n        serde_json::from_str(r#\"[\"a\", 42, {\"foo\": \"bar\"}, null]\"#).unwrap();\n    assert_eq!(r#\"\"a\"\"#, array_from_str[0].get());\n    assert_eq!(r#\"42\"#, array_from_str[1].get());\n    assert_eq!(r#\"{\"foo\": \"bar\"}\"#, array_from_str[2].get());\n    assert_eq!(r#\"null\"#, array_from_str[3].get());\n\n    let array_from_reader: Vec<Box<RawValue>> =\n        serde_json::from_reader(br#\"[\"a\", 42, {\"foo\": \"bar\"}, null]\"#.as_ref()).unwrap();\n    assert_eq!(r#\"\"a\"\"#, array_from_reader[0].get());\n    assert_eq!(r#\"42\"#, array_from_reader[1].get());\n    assert_eq!(r#\"{\"foo\": \"bar\"}\"#, array_from_reader[2].get());\n    assert_eq!(r#\"null\"#, array_from_reader[3].get());\n\n    let array_to_string = serde_json::to_string(&array_from_str).unwrap();\n    assert_eq!(r#\"[\"a\",42,{\"foo\": \"bar\"},null]\"#, array_to_string);\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/map.rs::get", "code": "pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_raw_invalid_utf8", "test": "fn test_raw_invalid_utf8() {\n    let j = &[b'\"', b'\\xCE', b'\\xF8', b'\"'];\n    let value_err = serde_json::from_slice::<Value>(j).unwrap_err();\n    let raw_value_err = serde_json::from_slice::<Box<RawValue>>(j).unwrap_err();\n\n    assert_eq!(\n        value_err.to_string(),\n        \"invalid unicode code point at line 1 column 4\",\n    );\n    assert_eq!(\n        raw_value_err.to_string(),\n        \"invalid unicode code point at line 1 column 4\",\n    );\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/ser.rs::to_string", "code": "pub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,\n{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_serialize_unsized_value_to_raw_value", "test": "fn test_serialize_unsized_value_to_raw_value() {\n    assert_eq!(\n        serde_json::value::to_raw_value(\"foobar\").unwrap().get(),\n        r#\"\"foobar\"\"#,\n    );\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/map.rs::get", "code": "pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/exponent.rs::scientific_exponent_test", "test": "fn scientific_exponent_test() {\n    // 0 digits in the integer\n    assert_eq!(scientific_exponent(0, 0, 5), -6);\n    assert_eq!(scientific_exponent(10, 0, 5), 4);\n    assert_eq!(scientific_exponent(-10, 0, 5), -16);\n\n    // >0 digits in the integer\n    assert_eq!(scientific_exponent(0, 1, 5), 0);\n    assert_eq!(scientific_exponent(0, 2, 5), 1);\n    assert_eq!(scientific_exponent(0, 2, 20), 1);\n    assert_eq!(scientific_exponent(10, 2, 20), 11);\n    assert_eq!(scientific_exponent(-10, 2, 20), -9);\n\n    // Underflow\n    assert_eq!(\n        scientific_exponent(i32::min_value(), 0, 0),\n        i32::min_value()\n    );\n    assert_eq!(\n        scientific_exponent(i32::min_value(), 0, 5),\n        i32::min_value()\n    );\n\n    // Overflow\n    assert_eq!(\n        scientific_exponent(i32::max_value(), 0, 0),\n        i32::max_value() - 1\n    );\n    assert_eq!(\n        scientific_exponent(i32::max_value(), 5, 0),\n        i32::max_value()\n    );\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/lexical/exponent.rs::scientific_exponent", "code": "pub(crate) fn scientific_exponent(\n    exponent: i32,\n    integer_digits: usize,\n    fraction_start: usize,\n) -> i32 {\n    if integer_digits == 0 {\n        let fraction_start = into_i32(fraction_start);\n        exponent.saturating_sub(fraction_start).saturating_sub(1)\n    } else {\n        let integer_shift = into_i32(integer_digits - 1);\n        exponent.saturating_add(integer_shift)\n    }\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/exponent.rs::mantissa_exponent_test", "test": "fn mantissa_exponent_test() {\n    assert_eq!(mantissa_exponent(10, 5, 0), 5);\n    assert_eq!(mantissa_exponent(0, 5, 0), -5);\n    assert_eq!(\n        mantissa_exponent(i32::max_value(), 5, 0),\n        i32::max_value() - 5\n    );\n    assert_eq!(mantissa_exponent(i32::max_value(), 0, 5), i32::max_value());\n    assert_eq!(mantissa_exponent(i32::min_value(), 5, 0), i32::min_value());\n    assert_eq!(\n        mantissa_exponent(i32::min_value(), 0, 5),\n        i32::min_value() + 5\n    );\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/lexical/exponent.rs::mantissa_exponent", "code": "pub(crate) fn mantissa_exponent(exponent: i32, fraction_digits: usize, truncated: usize) -> i32 {\n    if fraction_digits > truncated {\n        exponent.saturating_sub(into_i32(fraction_digits - truncated))\n    } else {\n        exponent.saturating_add(into_i32(truncated - fraction_digits))\n    }\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::compare_test", "test": "fn compare_test() {\n    // Simple\n    let x = Bigint {\n        data: from_u32(&[1]),\n    };\n    let y = Bigint {\n        data: from_u32(&[2]),\n    };\n    assert_eq!(x.compare(&y), cmp::Ordering::Less);\n    assert_eq!(x.compare(&x), cmp::Ordering::Equal);\n    assert_eq!(y.compare(&x), cmp::Ordering::Greater);\n\n    // Check asymmetric\n    let x = Bigint {\n        data: from_u32(&[5, 1]),\n    };\n    let y = Bigint {\n        data: from_u32(&[2]),\n    };\n    assert_eq!(x.compare(&y), cmp::Ordering::Greater);\n    assert_eq!(x.compare(&x), cmp::Ordering::Equal);\n    assert_eq!(y.compare(&x), cmp::Ordering::Less);\n\n    // Check when we use reverse ordering properly.\n    let x = Bigint {\n        data: from_u32(&[5, 1, 9]),\n    };\n    let y = Bigint {\n        data: from_u32(&[6, 2, 8]),\n    };\n    assert_eq!(x.compare(&y), cmp::Ordering::Greater);\n    assert_eq!(x.compare(&x), cmp::Ordering::Equal);\n    assert_eq!(y.compare(&x), cmp::Ordering::Less);\n\n    // Complex scenario, check it properly uses reverse ordering.\n    let x = Bigint {\n        data: from_u32(&[0, 1, 9]),\n    };\n    let y = Bigint {\n        data: from_u32(&[4294967295, 0, 9]),\n    };\n    assert_eq!(x.compare(&y), cmp::Ordering::Greater);\n    assert_eq!(x.compare(&x), cmp::Ordering::Equal);\n    assert_eq!(y.compare(&x), cmp::Ordering::Less);\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/lexical/math.rs::compare", "code": "pub fn compare(x: &[Limb], y: &[Limb]) -> cmp::Ordering {\n        if x.len() > y.len() {\n            cmp::Ordering::Greater\n        } else if x.len() < y.len() {\n            cmp::Ordering::Less\n        } else {\n            let iter = x.iter().rev().zip(y.iter().rev());\n            for (&xi, &yi) in iter {\n                if xi > yi {\n                    return cmp::Ordering::Greater;\n                } else if xi < yi {\n                    return cmp::Ordering::Less;\n                }\n            }\n            // Equal case.\n            cmp::Ordering::Equal\n        }\n    }", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::hi64_test", "test": "fn hi64_test() {\n    assert_eq!(Bigint::from_u64(0xA).hi64(), (0xA000000000000000, false));\n    assert_eq!(Bigint::from_u64(0xAB).hi64(), (0xAB00000000000000, false));\n    assert_eq!(\n        Bigint::from_u64(0xAB00000000).hi64(),\n        (0xAB00000000000000, false)\n    );\n    assert_eq!(\n        Bigint::from_u64(0xA23456789A).hi64(),\n        (0xA23456789A000000, false)\n    );\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/lexical/math.rs::hi64", "code": "fn hi64(&self) -> (u64, bool) {\n        match self.as_ref().len() {\n            0 => (0, false),\n            1 => self.hi64_1(),\n            2 => self.hi64_2(),\n            _ => self.hi64_3(),\n        }\n    }", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::bit_length_test", "test": "fn bit_length_test() {\n    let x = Bigint {\n        data: from_u32(&[0, 0, 0, 1]),\n    };\n    assert_eq!(x.bit_length(), 97);\n\n    let x = Bigint {\n        data: from_u32(&[0, 0, 0, 3]),\n    };\n    assert_eq!(x.bit_length(), 98);\n\n    let x = Bigint {\n        data: from_u32(&[1 << 31]),\n    };\n    assert_eq!(x.bit_length(), 32);\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/lexical/math.rs::bit_length", "code": "pub fn bit_length(x: &[Limb]) -> usize {\n        let bits = mem::size_of::<Limb>() * 8;\n        // Avoid overflowing, calculate via total number of bits\n        // minus leading zero bits.\n        let nlz = leading_zeros(x);\n        bits.checked_mul(x.len())\n            .map_or_else(usize::max_value, |v| v - nlz)\n    }", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::iadd_small_test", "test": "fn iadd_small_test() {\n    // Overflow check (single)\n    // This should set all the internal data values to 0, the top\n    // value to (1<<31), and the bottom value to (4>>1).\n    // This is because the max_value + 1 leads to all 0s, we set the\n    // topmost bit to 1.\n    let mut x = Bigint {\n        data: from_u32(&[4294967295]),\n    };\n    x.iadd_small(5);\n    assert_eq!(x.data, from_u32(&[4, 1]));\n\n    // No overflow, single value\n    let mut x = Bigint {\n        data: from_u32(&[5]),\n    };\n    x.iadd_small(7);\n    assert_eq!(x.data, from_u32(&[12]));\n\n    // Single carry, internal overflow\n    let mut x = Bigint::from_u64(0x80000000FFFFFFFF);\n    x.iadd_small(7);\n    assert_eq!(x.data, from_u32(&[6, 0x80000001]));\n\n    // Double carry, overflow\n    let mut x = Bigint::from_u64(0xFFFFFFFFFFFFFFFF);\n    x.iadd_small(7);\n    assert_eq!(x.data, from_u32(&[6, 0, 1]));\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::from_u32", "code": "pub(crate) fn from_u32(x: &[u32]) -> Vec<Limb> {\n    x.iter().cloned().collect()\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::imul_small_test", "test": "fn imul_small_test() {\n    // No overflow check, 1-int.\n    let mut x = Bigint {\n        data: from_u32(&[5]),\n    };\n    x.imul_small(7);\n    assert_eq!(x.data, from_u32(&[35]));\n\n    // No overflow check, 2-ints.\n    let mut x = Bigint::from_u64(0x4000000040000);\n    x.imul_small(5);\n    assert_eq!(x.data, from_u32(&[0x00140000, 0x140000]));\n\n    // Overflow, 1 carry.\n    let mut x = Bigint {\n        data: from_u32(&[0x33333334]),\n    };\n    x.imul_small(5);\n    assert_eq!(x.data, from_u32(&[4, 1]));\n\n    // Overflow, 1 carry, internal.\n    let mut x = Bigint::from_u64(0x133333334);\n    x.imul_small(5);\n    assert_eq!(x.data, from_u32(&[4, 6]));\n\n    // Overflow, 2 carries.\n    let mut x = Bigint::from_u64(0x3333333333333334);\n    x.imul_small(5);\n    assert_eq!(x.data, from_u32(&[4, 0, 1]));\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::from_u32", "code": "pub(crate) fn from_u32(x: &[u32]) -> Vec<Limb> {\n    x.iter().cloned().collect()\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::shl_test", "test": "fn shl_test() {\n    // Pattern generated via `''.join([\"1\" +\"0\"*i for i in range(20)])`\n    let mut big = Bigint {\n        data: from_u32(&[0xD2210408]),\n    };\n    big.ishl(5);\n    assert_eq!(big.data, from_u32(&[0x44208100, 0x1A]));\n    big.ishl(32);\n    assert_eq!(big.data, from_u32(&[0, 0x44208100, 0x1A]));\n    big.ishl(27);\n    assert_eq!(big.data, from_u32(&[0, 0, 0xD2210408]));\n\n    // 96-bits of previous pattern\n    let mut big = Bigint {\n        data: from_u32(&[0x20020010, 0x8040100, 0xD2210408]),\n    };\n    big.ishl(5);\n    assert_eq!(big.data, from_u32(&[0x400200, 0x802004, 0x44208101, 0x1A]));\n    big.ishl(32);\n    assert_eq!(\n        big.data,\n        from_u32(&[0, 0x400200, 0x802004, 0x44208101, 0x1A])\n    );\n    big.ishl(27);\n    assert_eq!(\n        big.data,\n        from_u32(&[0, 0, 0x20020010, 0x8040100, 0xD2210408])\n    );\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/math.rs::from_u32", "code": "pub(crate) fn from_u32(x: &[u32]) -> Vec<Limb> {\n    x.iter().cloned().collect()\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::lower_n_mask_test", "test": "fn lower_n_mask_test() {\n    assert_eq!(lower_n_mask(0u64), 0b0);\n    assert_eq!(lower_n_mask(1u64), 0b1);\n    assert_eq!(lower_n_mask(2u64), 0b11);\n    assert_eq!(lower_n_mask(10u64), 0b1111111111);\n    assert_eq!(lower_n_mask(32u64), 0b11111111111111111111111111111111);\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/lexical/rounding.rs::lower_n_mask", "code": "pub(crate) fn lower_n_mask(n: u64) -> u64 {\n    let bits: u64 = mem::size_of::<u64>() as u64 * 8;\n    debug_assert!(n <= bits, \"lower_n_mask() overflow in shl.\");\n\n    if n == bits {\n        u64::max_value()\n    } else {\n        (1 << n) - 1\n    }\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::lower_n_halfway_test", "test": "fn lower_n_halfway_test() {\n    assert_eq!(lower_n_halfway(0u64), 0b0);\n    assert_eq!(lower_n_halfway(1u64), 0b1);\n    assert_eq!(lower_n_halfway(2u64), 0b10);\n    assert_eq!(lower_n_halfway(10u64), 0b1000000000);\n    assert_eq!(lower_n_halfway(32u64), 0b10000000000000000000000000000000);\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/lexical/rounding.rs::lower_n_halfway", "code": "pub(crate) fn lower_n_halfway(n: u64) -> u64 {\n    let bits: u64 = mem::size_of::<u64>() as u64 * 8;\n    debug_assert!(n <= bits, \"lower_n_halfway() overflow in shl.\");\n\n    if n == 0 {\n        0\n    } else {\n        nth_bit(n - 1)\n    }\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::nth_bit_test", "test": "fn nth_bit_test() {\n    assert_eq!(nth_bit(0u64), 0b1);\n    assert_eq!(nth_bit(1u64), 0b10);\n    assert_eq!(nth_bit(2u64), 0b100);\n    assert_eq!(nth_bit(10u64), 0b10000000000);\n    assert_eq!(nth_bit(31u64), 0b10000000000000000000000000000000);\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/lexical/rounding.rs::nth_bit", "code": "pub(crate) fn nth_bit(n: u64) -> u64 {\n    let bits: u64 = mem::size_of::<u64>() as u64 * 8;\n    debug_assert!(n < bits, \"nth_bit() overflow in shl.\");\n\n    1 << n\n}", "docstring": null}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/rounding.rs::internal_n_mask_test", "test": "fn internal_n_mask_test() {\n    assert_eq!(internal_n_mask(1u64, 0u64), 0b0);\n    assert_eq!(internal_n_mask(1u64, 1u64), 0b1);\n    assert_eq!(internal_n_mask(2u64, 1u64), 0b10);\n    assert_eq!(internal_n_mask(4u64, 2u64), 0b1100);\n    assert_eq!(internal_n_mask(10u64, 2u64), 0b1100000000);\n    assert_eq!(internal_n_mask(10u64, 4u64), 0b1111000000);\n    assert_eq!(\n        internal_n_mask(32u64, 4u64),\n        0b11110000000000000000000000000000\n    );\n}", "code_id": "serde-rs-json/serde-rs-json-66f862f/src/lexical/rounding.rs::internal_n_mask", "code": "pub(crate) fn internal_n_mask(bit: u64, n: u64) -> u64 {\n    let bits: u64 = mem::size_of::<u64>() as u64 * 8;\n    debug_assert!(bit <= bits, \"internal_n_halfway() overflow in shl.\");\n    debug_assert!(n <= bits, \"internal_n_halfway() overflow in shl.\");\n    debug_assert!(bit >= n, \"internal_n_halfway() overflow in sub.\");\n\n    lower_n_mask(bit) ^ lower_n_mask(bit - n)\n}", "docstring": null}
