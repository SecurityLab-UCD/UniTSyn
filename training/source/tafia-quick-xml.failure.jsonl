{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/issues.rs::issue299", "test": "fn issue299() -> Result<(), Error> {\n    let xml = r#\"\n<?xml version=\"1.0\" encoding=\"utf8\"?>\n<MICEX_DOC xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <SECURITY SecurityId=\"PLZL\" ISIN=\"RU000A0JNAA8\" SecShortName=\"Short Name\" PriceType=\"CASH\">\n    <RECORDS RecNo=\"1\" TradeNo=\"1111\" TradeDate=\"2021-07-08\" TradeTime=\"15:00:00\" BuySell=\"S\" SettleCode=\"Y1Dt\" Decimals=\"3\" Price=\"13057.034\" Quantity=\"766\" Value=\"10001688.29\" AccInt=\"0\" Amount=\"10001688.29\" Balance=\"766\" TrdAccId=\"X0011\" ClientDetails=\"2222\" CPFirmId=\"3333\" CPFirmShortName=\"Firm Short Name\" Price2=\"13057.034\" RepoPart=\"2\" ReportTime=\"16:53:27\" SettleTime=\"17:47:06\" ClientCode=\"4444\" DueDate=\"2021-07-09\" EarlySettleStatus=\"N\" RepoRate=\"5.45\" RateType=\"FIX\"/>\n  </SECURITY>\n</MICEX_DOC>\n\"#;\n    let mut reader = Reader::from_str(xml);\n    loop {\n        match reader.read_event()? {\n            Event::Start(e) | Event::Empty(e) => {\n                let attr_count = match e.name().as_ref() {\n                    b\"MICEX_DOC\" => 1,\n                    b\"SECURITY\" => 4,\n                    b\"RECORDS\" => 26,\n                    _ => unreachable!(),\n                };\n                assert_eq!(\n                    attr_count,\n                    e.attributes().filter(Result::is_ok).count(),\n                    \"mismatch att count on '{:?}'\",\n                    reader.decoder().decode(e.name().as_ref())\n                );\n            }\n            Event::Eof => break,\n            _ => (),\n        }\n    }\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/namespaces.rs::default_namespace_reset", "test": "fn default_namespace_reset() {\n    let mut r = NsReader::from_str(r#\"<a xmlns=\"www1\"><b xmlns=\"\"></b></a>\"#);\n    r.trim_text(true);\n\n    // <a>\n    match r.read_resolved_event() {\n        Ok((ns, Start(_))) => assert_eq!(ns, Bound(Namespace(b\"www1\"))),\n        e => panic!(\n            \"expecting outer start element with to resolve to 'www1', got {:?}\",\n            e\n        ),\n    }\n\n    // <b>\n    match r.read_resolved_event() {\n        Ok((ns, Start(_))) => assert_eq!(ns, Unbound),\n        e => panic!(\n            \"expecting inner start element with no namespace, got {:?}\",\n            e\n        ),\n    }\n    // </b>\n    match r.read_resolved_event() {\n        Ok((ns, End(_))) => assert_eq!(ns, Unbound),\n        e => panic!(\"expecting inner end element with no namespace, got {:?}\", e),\n    }\n\n    // </a>\n    match r.read_resolved_event() {\n        Ok((ns, End(_))) => assert_eq!(ns, Bound(Namespace(b\"www1\"))),\n        e => panic!(\n            \"expecting outer end element with to resolve to 'www1', got {:?}\",\n            e\n        ),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/namespaces.rs::default_ns_shadowing_empty", "test": "fn default_ns_shadowing_empty() {\n    let src = \"<e xmlns='urn:example:o'><e att1='a' xmlns='urn:example:i' /></e>\";\n\n    let mut r = NsReader::from_str(src);\n    r.trim_text(true);\n\n    // <outer xmlns='urn:example:o'>\n    {\n        match r.read_resolved_event() {\n            Ok((ns, Start(e))) => {\n                assert_eq!(ns, Bound(Namespace(b\"urn:example:o\")));\n                assert_eq!(e.name(), QName(b\"e\"));\n            }\n            e => panic!(\"Expected Start event (<outer>), got {:?}\", e),\n        }\n    }\n\n    // <inner att1='a' xmlns='urn:example:i' />\n    {\n        let e = match r.read_resolved_event() {\n            Ok((ns, Empty(e))) => {\n                assert_eq!(ns, Bound(Namespace(b\"urn:example:i\")));\n                assert_eq!(e.name(), QName(b\"e\"));\n                e\n            }\n            e => panic!(\"Expecting Empty event, got {:?}\", e),\n        };\n\n        let mut attrs = e\n            .attributes()\n            .map(|ar| ar.expect(\"Expecting attribute parsing to succeed.\"))\n            // we don't care about xmlns attributes for this test\n            .filter(|kv| kv.key.as_namespace_binding().is_none())\n            .map(|Attribute { key: name, value }| {\n                let (opt_ns, local_name) = r.resolve_attribute(name);\n                (opt_ns, local_name.into_inner(), value)\n            });\n        // the attribute should _not_ have a namespace name. The default namespace does not\n        // apply to attributes.\n        assert_eq!(\n            attrs.next(),\n            Some((Unbound, &b\"att1\"[..], Cow::Borrowed(&b\"a\"[..])))\n        );\n        assert_eq!(attrs.next(), None);\n    }\n\n    // </outer>\n    match r.read_resolved_event() {\n        Ok((ns, End(e))) => {\n            assert_eq!(ns, Bound(Namespace(b\"urn:example:o\")));\n            assert_eq!(e.name(), QName(b\"e\"));\n        }\n        e => panic!(\"Expected End event (<outer>), got {:?}\", e),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/namespaces.rs::default_ns_shadowing_expanded", "test": "fn default_ns_shadowing_expanded() {\n    let src = \"<e xmlns='urn:example:o'><e att1='a' xmlns='urn:example:i' /></e>\";\n\n    let mut r = NsReader::from_str(src);\n    r.trim_text(true).expand_empty_elements(true);\n\n    // <outer xmlns='urn:example:o'>\n    {\n        match r.read_resolved_event() {\n            Ok((ns, Start(e))) => {\n                assert_eq!(ns, Bound(Namespace(b\"urn:example:o\")));\n                assert_eq!(e.name(), QName(b\"e\"));\n            }\n            e => panic!(\"Expected Start event (<outer>), got {:?}\", e),\n        }\n    }\n\n    // <inner att1='a' xmlns='urn:example:i' />\n    {\n        let e = match r.read_resolved_event() {\n            Ok((ns, Start(e))) => {\n                assert_eq!(ns, Bound(Namespace(b\"urn:example:i\")));\n                assert_eq!(e.name(), QName(b\"e\"));\n                e\n            }\n            e => panic!(\"Expecting Start event (<inner>), got {:?}\", e),\n        };\n        let mut attrs = e\n            .attributes()\n            .map(|ar| ar.expect(\"Expecting attribute parsing to succeed.\"))\n            // we don't care about xmlns attributes for this test\n            .filter(|kv| kv.key.as_namespace_binding().is_none())\n            .map(|Attribute { key: name, value }| {\n                let (opt_ns, local_name) = r.resolve_attribute(name);\n                (opt_ns, local_name.into_inner(), value)\n            });\n        // the attribute should _not_ have a namespace name. The default namespace does not\n        // apply to attributes.\n        assert_eq!(\n            attrs.next(),\n            Some((Unbound, &b\"att1\"[..], Cow::Borrowed(&b\"a\"[..])))\n        );\n        assert_eq!(attrs.next(), None);\n    }\n\n    // virtual </inner>\n    match r.read_resolved_event() {\n        Ok((ns, End(e))) => {\n            assert_eq!(ns, Bound(Namespace(b\"urn:example:i\")));\n            assert_eq!(e.name(), QName(b\"e\"));\n        }\n        e => panic!(\"Expected End event (</inner>), got {:?}\", e),\n    }\n    // </outer>\n    match r.read_resolved_event() {\n        Ok((ns, End(e))) => {\n            assert_eq!(ns, Bound(Namespace(b\"urn:example:o\")));\n            assert_eq!(e.name(), QName(b\"e\"));\n        }\n        e => panic!(\"Expected End event (</outer>), got {:?}\", e),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/namespaces.rs::reserved_name", "test": "fn reserved_name() {\n    // Name \"xmlns-something\" is reserved according to spec, because started with \"xml\"\n    let mut r =\n        NsReader::from_str(r#\"<a xmlns-something=\"reserved attribute name\" xmlns=\"www1\"/>\"#);\n    r.trim_text(true);\n\n    // <a />\n    match r.read_resolved_event() {\n        Ok((ns, Empty(_))) => assert_eq!(ns, Bound(Namespace(b\"www1\"))),\n        e => panic!(\n            \"Expected empty element bound to namespace 'www1', got {:?}\",\n            e\n        ),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue349", "test": "fn issue349() {\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct Entity {\n        id: Id,\n    }\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct Id {\n        #[serde(rename = \"$value\")]\n        content: Enum,\n    }\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    #[serde(rename_all = \"kebab-case\")]\n    enum Enum {\n        A(String),\n        B(String),\n    }\n\n    assert_eq!(\n        from_str::<Entity>(\"<entity><id><a>Id</a></id></entity>\").unwrap(),\n        Entity {\n            id: Id {\n                content: Enum::A(\"Id\".to_string()),\n            }\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue429", "test": "fn issue429() {\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    enum State {\n        A,\n        B,\n        C,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct StateOuter {\n        #[serde(rename = \"$text\")]\n        state: State,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    pub struct Root {\n        state: StateOuter,\n    }\n\n    assert_eq!(\n        from_str::<Root>(\"<root><state>B</state></root>\").unwrap(),\n        Root {\n            state: StateOuter { state: State::B }\n        }\n    );\n\n    assert_eq!(\n        to_string(&Root {\n            state: StateOuter { state: State::B }\n        })\n        .unwrap(),\n        \"<Root><state>B</state></Root>\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue567", "test": "fn issue567() {\n    #[derive(Debug, Deserialize, PartialEq)]\n    struct Root {\n        #[serde(rename = \"$value\")]\n        items: Vec<Enum>,\n    }\n\n    #[derive(Debug, Deserialize, PartialEq)]\n    enum Enum {\n        List(Vec<()>),\n    }\n\n    assert_eq!(\n        from_str::<Root>(\"<root><List/></root>\").unwrap(),\n        Root {\n            items: vec![Enum::List(vec![])],\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue580", "test": "fn issue580() {\n    #[derive(Debug, Deserialize, PartialEq, Eq)]\n    struct Seq {\n        #[serde(rename = \"$value\")]\n        items: Vec<Wrapper>,\n    }\n\n    #[derive(Debug, Deserialize, PartialEq, Eq)]\n    struct Wrapper(#[serde(deserialize_with = \"Item::parse\")] Item);\n\n    #[derive(Debug, PartialEq, Eq)]\n    struct Item;\n    impl Item {\n        fn parse<'de, D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            // We should consume something from the deserializer, otherwise this\n            // leads to infinity loop\n            IgnoredAny::deserialize(deserializer)?;\n            Ok(Item)\n        }\n    }\n\n    assert_eq!(\n        from_str::<Seq>(\n            r#\"\n        <Seq>\n            <One/>\n            <Two/>\n        </Seq>\"#\n        )\n        .unwrap(),\n        Seq {\n            items: vec![Wrapper(Item), Wrapper(Item)],\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_xml_decl", "test": "fn test_xml_decl() {\n    let mut r = Reader::from_str(\"<?xml version=\\\"1.0\\\" encoding='utf-8'?>\");\n    r.trim_text(true);\n    match r.read_event().unwrap() {\n        Decl(ref e) => {\n            match e.version() {\n                Ok(v) => assert_eq!(\n                    &*v,\n                    b\"1.0\",\n                    \"expecting version '1.0', got '{:?}\",\n                    from_utf8(&v)\n                ),\n                Err(e) => panic!(\"{:?}\", e),\n            }\n            match e.encoding() {\n                Some(Ok(v)) => assert_eq!(\n                    &*v,\n                    b\"utf-8\",\n                    \"expecting encoding 'utf-8', got '{:?}\",\n                    from_utf8(&v)\n                ),\n                Some(Err(e)) => panic!(\"{:?}\", e),\n                None => panic!(\"cannot find encoding\"),\n            }\n            match e.standalone() {\n                None => (),\n                e => panic!(\"doesn't expect standalone, got {:?}\", e),\n            }\n        }\n        _ => panic!(\"unable to parse XmlDecl\"),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_writer", "test": "fn test_writer() -> Result<()> {\n    let txt = include_str!(\"../tests/documents/test_writer.xml\").trim();\n    let mut reader = Reader::from_str(txt);\n    reader.trim_text(true);\n    let mut writer = Writer::new(Cursor::new(Vec::new()));\n    loop {\n        match reader.read_event()? {\n            Eof => break,\n            e => assert!(writer.write_event(e).is_ok()),\n        }\n    }\n\n    let result = writer.into_inner().into_inner();\n    assert_eq!(result, txt.as_bytes());\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_writer_borrow", "test": "fn test_writer_borrow() -> Result<()> {\n    let txt = include_str!(\"../tests/documents/test_writer.xml\").trim();\n    let mut reader = Reader::from_str(txt);\n    reader.trim_text(true);\n    let mut writer = Writer::new(Cursor::new(Vec::new()));\n    loop {\n        match reader.read_event()? {\n            Eof => break,\n            e => assert!(writer.write_event(&e).is_ok()), // either `e` or `&e`\n        }\n    }\n\n    let result = writer.into_inner().into_inner();\n    assert_eq!(result, txt.as_bytes());\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_writer_indent", "test": "fn test_writer_indent() -> Result<()> {\n    let txt = include_str!(\"../tests/documents/test_writer_indent.xml\");\n    let mut reader = Reader::from_str(txt);\n    reader.trim_text(true);\n    let mut writer = Writer::new_with_indent(Cursor::new(Vec::new()), b' ', 4);\n    loop {\n        match reader.read_event()? {\n            Eof => break,\n            e => assert!(writer.write_event(e).is_ok()),\n        }\n    }\n\n    let result = writer.into_inner().into_inner();\n    assert_eq!(result, txt.as_bytes());\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_writer_indent_cdata", "test": "fn test_writer_indent_cdata() -> Result<()> {\n    let txt = include_str!(\"../tests/documents/test_writer_indent_cdata.xml\");\n    let mut reader = Reader::from_str(txt);\n    reader.trim_text(true);\n    let mut writer = Writer::new_with_indent(Cursor::new(Vec::new()), b' ', 4);\n    loop {\n        match reader.read_event()? {\n            Eof => break,\n            e => assert!(writer.write_event(e).is_ok()),\n        }\n    }\n\n    let result = writer.into_inner().into_inner();\n    assert_eq!(result, txt.as_bytes());\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_write_empty_element_attrs", "test": "fn test_write_empty_element_attrs() -> Result<()> {\n    let str_from = r#\"<source attr=\"val\"/>\"#;\n    let expected = r#\"<source attr=\"val\"/>\"#;\n    let mut reader = Reader::from_str(str_from);\n    let mut writer = Writer::new(Cursor::new(Vec::new()));\n    loop {\n        match reader.read_event()? {\n            Eof => break,\n            e => assert!(writer.write_event(e).is_ok()),\n        }\n    }\n\n    let result = writer.into_inner().into_inner();\n    assert_eq!(String::from_utf8(result).unwrap(), expected);\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_write_attrs", "test": "fn test_write_attrs() -> Result<()> {\n    type AttrResult<T> = std::result::Result<T, AttrError>;\n\n    let str_from = r#\"<source attr=\"val\"></source>\"#;\n    let expected = r#\"<copy attr=\"val\" a=\"b\" c=\"d\" x=\"y&quot;z\"></copy>\"#;\n    let mut reader = Reader::from_str(str_from);\n    reader.trim_text(true);\n    let mut writer = Writer::new(Cursor::new(Vec::new()));\n    loop {\n        let event = match reader.read_event()? {\n            Eof => break,\n            Start(elem) => {\n                let mut attrs = elem.attributes().collect::<AttrResult<Vec<_>>>()?;\n                attrs.extend_from_slice(&[(\"a\", \"b\").into(), (\"c\", \"d\").into()]);\n                let mut elem = BytesStart::new(\"copy\");\n                elem.extend_attributes(attrs);\n                elem.push_attribute((\"x\", \"y\\\"z\"));\n                Start(elem)\n            }\n            End(_) => End(BytesEnd::new(\"copy\")),\n            e => e,\n        };\n        assert!(writer.write_event(event).is_ok());\n    }\n\n    let result = writer.into_inner().into_inner();\n    assert_eq!(result, expected.as_bytes());\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_new_xml_decl_full", "test": "fn test_new_xml_decl_full() {\n    let mut writer = Writer::new(Vec::new());\n    writer\n        .write_event(Decl(BytesDecl::new(\"1.2\", Some(\"utf-X\"), Some(\"yo\"))))\n        .expect(\"writing xml decl should succeed\");\n\n    let result = writer.into_inner();\n    assert_eq!(\n        String::from_utf8(result).expect(\"utf-8 output\"),\n        \"<?xml version=\\\"1.2\\\" encoding=\\\"utf-X\\\" standalone=\\\"yo\\\"?>\",\n        \"writer output (LHS)\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_new_xml_decl_standalone", "test": "fn test_new_xml_decl_standalone() {\n    let mut writer = Writer::new(Vec::new());\n    writer\n        .write_event(Decl(BytesDecl::new(\"1.2\", None, Some(\"yo\"))))\n        .expect(\"writing xml decl should succeed\");\n\n    let result = writer.into_inner();\n    assert_eq!(\n        String::from_utf8(result).expect(\"utf-8 output\"),\n        \"<?xml version=\\\"1.2\\\" standalone=\\\"yo\\\"?>\",\n        \"writer output (LHS)\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_new_xml_decl_encoding", "test": "fn test_new_xml_decl_encoding() {\n    let mut writer = Writer::new(Vec::new());\n    writer\n        .write_event(Decl(BytesDecl::new(\"1.2\", Some(\"utf-X\"), None)))\n        .expect(\"writing xml decl should succeed\");\n\n    let result = writer.into_inner();\n    assert_eq!(\n        String::from_utf8(result).expect(\"utf-8 output\"),\n        \"<?xml version=\\\"1.2\\\" encoding=\\\"utf-X\\\"?>\",\n        \"writer output (LHS)\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_new_xml_decl_version", "test": "fn test_new_xml_decl_version() {\n    let mut writer = Writer::new(Vec::new());\n    writer\n        .write_event(Decl(BytesDecl::new(\"1.2\", None, None)))\n        .expect(\"writing xml decl should succeed\");\n\n    let result = writer.into_inner();\n    assert_eq!(\n        String::from_utf8(result).expect(\"utf-8 output\"),\n        \"<?xml version=\\\"1.2\\\"?>\",\n        \"writer output (LHS)\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_new_xml_decl_empty", "test": "fn test_new_xml_decl_empty() {\n    let mut writer = Writer::new(Vec::new());\n    // An empty version should arguably be an error, but we don't expect anyone to actually supply\n    // an empty version.\n    writer\n        .write_event(Decl(BytesDecl::new(\"\", Some(\"\"), Some(\"\"))))\n        .expect(\"writing xml decl should succeed\");\n\n    let result = writer.into_inner();\n    assert_eq!(\n        String::from_utf8(result).expect(\"utf-8 output\"),\n        \"<?xml version=\\\"\\\" encoding=\\\"\\\" standalone=\\\"\\\"?>\",\n        \"writer output (LHS)\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_escaped_content", "test": "fn test_escaped_content() {\n    let mut r = Reader::from_str(\"<a>&lt;test&gt;</a>\");\n    r.trim_text(true);\n    next_eq!(r, Start, b\"a\");\n    match r.read_event() {\n        Ok(Text(e)) => {\n            assert_eq!(\n                &*e,\n                b\"&lt;test&gt;\",\n                \"content unexpected: expecting '&lt;test&gt;', got '{:?}'\",\n                from_utf8(&e)\n            );\n            match e.unescape() {\n                Ok(c) => assert_eq!(c, \"<test>\"),\n                Err(e) => panic!(\n                    \"cannot escape content at position {}: {:?}\",\n                    r.buffer_position(),\n                    e\n                ),\n            }\n        }\n        Ok(e) => panic!(\"Expecting text event, got {:?}\", e),\n        Err(e) => panic!(\n            \"Cannot get next event at position {}: {:?}\",\n            r.buffer_position(),\n            e\n        ),\n    }\n    next_eq!(r, End, b\"a\");\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_read_write_roundtrip_results_in_identity", "test": "fn test_read_write_roundtrip_results_in_identity() -> Result<()> {\n    let input = r#\"\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <section ns:label=\"header\">\n            <section ns:label=\"empty element section\" />\n            <section ns:label=\"start/end section\"></section>\n            <section ns:label=\"with text\">data</section>\n            </section>\n    \"#;\n\n    let mut reader = Reader::from_str(input);\n    let mut writer = Writer::new(Cursor::new(Vec::new()));\n    loop {\n        match reader.read_event()? {\n            Eof => break,\n            e => assert!(writer.write_event(e).is_ok()),\n        }\n    }\n\n    let result = writer.into_inner().into_inner();\n    assert_eq!(String::from_utf8(result).unwrap(), input);\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_read_write_roundtrip", "test": "fn test_read_write_roundtrip() -> Result<()> {\n    let input = r#\"\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <section ns:label=\"header\">\n            <section ns:label=\"empty element section\" />\n            <section ns:label=\"start/end section\"></section>\n            <section ns:label=\"with text\">data &lt;escaped&gt;</section>\n            </section>\n    \"#;\n\n    let mut reader = Reader::from_str(input);\n    let mut writer = Writer::new(Cursor::new(Vec::new()));\n    loop {\n        match reader.read_event()? {\n            Eof => break,\n            e => assert!(writer.write_event(e).is_ok()),\n        }\n    }\n\n    let result = writer.into_inner().into_inner();\n    assert_eq!(String::from_utf8(result).unwrap(), input);\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_read_write_roundtrip_escape_text", "test": "fn test_read_write_roundtrip_escape_text() -> Result<()> {\n    let input = r#\"\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <section ns:label=\"header\">\n            <section ns:label=\"empty element section\" />\n            <section ns:label=\"start/end section\"></section>\n            <section ns:label=\"with text\">data &lt;escaped&gt;</section>\n            </section>\n    \"#;\n\n    let mut reader = Reader::from_str(input);\n    let mut writer = Writer::new(Cursor::new(Vec::new()));\n    loop {\n        match reader.read_event()? {\n            Eof => break,\n            Text(e) => {\n                let t = e.unescape().unwrap();\n                assert!(writer.write_event(Text(BytesText::new(&t))).is_ok());\n            }\n            e => assert!(writer.write_event(e).is_ok()),\n        }\n    }\n\n    let result = writer.into_inner().into_inner();\n    assert_eq!(String::from_utf8(result).unwrap(), input);\n    Ok(())\n}", "error": "Not Definition Found"}
