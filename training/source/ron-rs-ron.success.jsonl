{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/240_array_pretty.rs::small_array", "test": "fn small_array() {\n    let arr = &[(), (), ()][..];\n    assert_eq!(\n        to_string_pretty(&arr, PrettyConfig::new().new_line(\"\\n\".to_string())).unwrap(),\n        \"[\n    (),\n    (),\n    (),\n]\"\n    );\n    assert_eq!(\n        to_string_pretty(\n            &arr,\n            PrettyConfig::new()\n                .new_line(\"\\n\".to_string())\n                .compact_arrays(true)\n        )\n        .unwrap(),\n        \"[(), (), ()]\"\n    );\n    assert_eq!(\n        to_string_pretty(\n            &arr,\n            PrettyConfig::new()\n                .new_line(\"\\n\".to_string())\n                .compact_arrays(true)\n                .separator(\"\".to_string())\n        )\n        .unwrap(),\n        \"[(),(),()]\"\n    );\n    assert_eq!(\n        to_string_pretty(\n            &vec![(1, 2), (3, 4)],\n            PrettyConfig::new()\n                .new_line(\"\\n\".to_string())\n                .separate_tuple_members(true)\n                .compact_arrays(true)\n        )\n        .unwrap(),\n        \"[(\n    1,\n    2,\n), (\n    3,\n    4,\n)]\"\n    );\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::to_string", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/comments.rs::test_simple", "test": "fn test_simple() {\n    assert_eq!(\n        from_str(\n            \"/*\n * We got a hexadecimal number here!\n *\n */0x507\"\n        ),\n        Ok(0x507)\n    );\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::from_str", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/depth_limit.rs::depth_limit", "test": "fn depth_limit() {\n    let data = Config {\n        float: (2.18, -1.1),\n        tuple: TupleStruct((), false),\n        map: vec![(8, '1')].into_iter().collect(),\n        nested: Nested {\n            a: \"a\".to_owned(),\n            b: 'b',\n        },\n        var: Variant::A(!0, \"\"),\n        array: vec![(); 3],\n    };\n\n    let pretty = ron::ser::PrettyConfig::new()\n        .depth_limit(1)\n        .separate_tuple_members(true)\n        .enumerate_arrays(true)\n        .new_line(\"\\n\".to_string());\n    let s = ron::ser::to_string_pretty(&data, pretty);\n\n    assert_eq!(s, Ok(EXPECTED.to_string()));\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::to_string", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/escape.rs::test_escape_basic", "test": "fn test_escape_basic() {\n    assert_eq!(to_string(&\"\\x07\").unwrap(), \"\\\"\\\\u{7}\\\"\");\n\n    assert_eq!(from_str::<String>(\"\\\"\\\\x07\\\"\").unwrap(), \"\\x07\");\n    assert_eq!(from_str::<String>(\"\\\"\\\\u{7}\\\"\").unwrap(), \"\\x07\");\n\n    assert_eq!(from_str::<char>(\"\\'\\\\x07\\'\").unwrap(), '\\x07');\n    assert_eq!(from_str::<char>(\"\\'\\\\u{7}\\'\").unwrap(), '\\x07');\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::to_string", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/escape.rs::test_non_ascii", "test": "fn test_non_ascii() {\n    assert_eq!(to_string(&\"♠\").unwrap(), \"\\\"♠\\\"\");\n    assert_eq!(to_string(&\"ß\").unwrap(), \"\\\"ß\\\"\");\n    assert_eq!(to_string(&\"ä\").unwrap(), \"\\\"ä\\\"\");\n    assert_eq!(to_string(&\"ö\").unwrap(), \"\\\"ö\\\"\");\n    assert_eq!(to_string(&\"ü\").unwrap(), \"\\\"ü\\\"\");\n}\n\n#[test]\nfn", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::to_string", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/floats.rs::test_inf_and_nan", "test": "fn test_inf_and_nan() {\n    assert_eq!(from_str(\"inf\"), Ok(std::f64::INFINITY));\n    assert_eq!(from_str(\"-inf\"), Ok(std::f64::NEG_INFINITY));\n    assert_eq!(from_str::<f64>(\"NaN\").map(|n| n.is_nan()), Ok(true))\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::from_str", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/large_number.rs::test_large_integer_to_float", "test": "fn test_large_integer_to_float() {\n    use ron::value::Float;\n    let test_var = std::i64::MAX as u64 + 1;\n    let expected = test_var as f64; // Is exactly representable by f64\n    let test_ser = ron::ser::to_string(&test_var).unwrap();\n    assert_eq!(test_ser, test_var.to_string());\n    let test_deser = ron::de::from_str::<Value>(&test_ser);\n\n    assert_eq!(\n        test_deser.unwrap(),\n        Value::Number(Number::Float(Float::new(expected))),\n    );\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::to_string", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/numbers.rs::test_hex", "test": "fn test_hex() {\n    assert_eq!(from_str(\"0x507\"), Ok(0x507));\n    assert_eq!(from_str(\"0x1A5\"), Ok(0x1A5));\n    assert_eq!(from_str(\"0x53C537\"), Ok(0x53C537));\n\n    assert_eq!(\n        from_str::<u8>(\"0x\"),\n        Err(SpannedError {\n            code: Error::ExpectedInteger,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0x_1\"),\n        Err(SpannedError {\n            code: Error::UnderscoreAtBeginning,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0xFFF\"),\n        Err(SpannedError {\n            code: Error::IntegerOutOfBounds,\n            position: Position { line: 1, col: 6 },\n        })\n    );\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::from_str", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/numbers.rs::test_bin", "test": "fn test_bin() {\n    assert_eq!(from_str(\"0b101\"), Ok(0b101));\n    assert_eq!(from_str(\"0b001\"), Ok(0b001));\n    assert_eq!(from_str(\"0b100100\"), Ok(0b100100));\n\n    assert_eq!(\n        from_str::<u8>(\"0b\"),\n        Err(SpannedError {\n            code: Error::ExpectedInteger,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0b_1\"),\n        Err(SpannedError {\n            code: Error::UnderscoreAtBeginning,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0b111111111\"),\n        Err(SpannedError {\n            code: Error::IntegerOutOfBounds,\n            position: Position { line: 1, col: 12 },\n        })\n    );\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::from_str", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/numbers.rs::test_oct", "test": "fn test_oct() {\n    assert_eq!(from_str(\"0o1461\"), Ok(0o1461));\n    assert_eq!(from_str(\"0o051\"), Ok(0o051));\n    assert_eq!(from_str(\"0o150700\"), Ok(0o150700));\n\n    assert_eq!(\n        from_str::<u8>(\"0o\"),\n        Err(SpannedError {\n            code: Error::ExpectedInteger,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0o_1\"),\n        Err(SpannedError {\n            code: Error::UnderscoreAtBeginning,\n            position: Position { line: 1, col: 3 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"0o77777\"),\n        Err(SpannedError {\n            code: Error::IntegerOutOfBounds,\n            position: Position { line: 1, col: 8 },\n        })\n    );\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::from_str", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/numbers.rs::test_dec", "test": "fn test_dec() {\n    assert_eq!(from_str(\"1461\"), Ok(1461));\n    assert_eq!(from_str(\"51\"), Ok(51));\n    assert_eq!(from_str(\"150700\"), Ok(150700));\n\n    assert_eq!(\n        from_str::<i8>(\"-_1\"),\n        Err(SpannedError {\n            code: Error::UnderscoreAtBeginning,\n            position: Position { line: 1, col: 2 },\n        })\n    );\n    assert_eq!(\n        from_str::<u8>(\"256\"),\n        Err(SpannedError {\n            code: Error::IntegerOutOfBounds,\n            position: Position { line: 1, col: 4 },\n        })\n    );\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::from_str", "code": "pub fn from_str<'a, T>(&self, s: &'a str) -> SpannedResult<T>\n    where\n        T: de::Deserialize<'a>,\n    {\n        self.from_bytes(s.as_bytes())\n    }", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/preserve_sequence.rs::test_sequence_ex1", "test": "fn test_sequence_ex1() {\n    let file = include_str!(\"preserve_sequence_ex1.ron\");\n    assert_eq!(read_original(file), make_roundtrip(file));\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/preserve_sequence.rs::read_original", "code": "fn read_original(source: &str) -> String {\n    source.to_string().replace(\"\\r\\n\", \"\\n\")\n}", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/preserve_sequence.rs::test_sequence_ex2", "test": "fn test_sequence_ex2() {\n    let file = include_str!(\"preserve_sequence_ex2.ron\");\n    assert_eq!(read_original(file), make_roundtrip(file));\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/preserve_sequence.rs::read_original", "code": "fn read_original(source: &str) -> String {\n    source.to_string().replace(\"\\r\\n\", \"\\n\")\n}", "docstring": null}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/to_string_pretty.rs::test_struct_names", "test": "fn test_struct_names() {\n    let value = Point { x: 1.0, y: 2.0 };\n    let struct_name = to_string_pretty(&value, PrettyConfig::default().struct_names(true));\n    assert_eq!(\n        struct_name,\n        Ok(\"Point(\\n    x: 1.0,\\n    y: 2.0,\\n)\".to_string())\n    );\n    let no_struct_name = to_string(&value);\n    assert_eq!(no_struct_name, Ok(\"(x:1.0,y:2.0)\".to_string()));\n}", "code_id": "ron-rs-ron/ron-rs-ron-eafa2b6/src/options.rs::to_string", "code": "pub fn to_string<T>(&self, value: &T) -> Result<String>\n    where\n        T: ?Sized + ser::Serialize,\n    {\n        let mut output = Vec::new();\n        let mut s = Serializer::with_options(&mut output, None, self.clone())?;\n        value.serialize(&mut s)?;\n        Ok(String::from_utf8(output).expect(\"Ron should be utf-8\"))\n    }", "docstring": null}
