{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_minifier/tests/terser/mod.rs::test", "test": "fn test() {\n    let files = WalkDir::new(\"tests/terser/fixtures\")\n        .into_iter()\n        .filter_map(Result::ok)\n        .filter(|e| !e.file_type().is_dir())\n        .collect::<Vec<_>>();\n    assert!(!files.is_empty());\n    for file in files {\n        let path = file.path();\n        let source_text = std::fs::read_to_string(path).unwrap();\n        let source_type = SourceType::from_path(path).unwrap();\n        let allocator = Allocator::default();\n        let parser_return = Parser::new(&allocator, &source_text, source_type).parse();\n        let program = allocator.alloc(parser_return.program);\n        TestSuite::from_program(&source_text, program).execute_tests();\n    }\n}", "code_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_ast/src/ast/js.rs::is_empty", "code": "pub fn is_empty(&self) -> bool {\n        self.body.is_empty() && self.directives.is_empty()\n    }", "docstring": null}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/alias.rs::absolute_path", "test": "fn absolute_path() {\n    let f = super::fixture();\n    let resolver = Resolver::new(ResolveOptions {\n        alias: vec![(f.join(\"foo\").to_str().unwrap().to_string(), vec![AliasValue::Ignore])],\n        modules: vec![f.clone().to_str().unwrap().to_string()],\n        ..ResolveOptions::default()\n    });\n    let resolution = resolver.resolve(&f, \"foo/index\");\n    assert_eq!(resolution, Err(ResolveError::Ignored(f.join(\"foo\"))));\n}", "code_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_linter/src/rules/eslint/array_callback_return/return_checker.rs::join", "code": "pub fn join(self, rhs: Self) -> Self {\n        let must_return = self.must_return() && rhs.must_return();\n        let explicit = self.may_return_explicit() || rhs.may_return_explicit();\n        let implicit = self.may_return_implicit() || rhs.may_return_implicit();\n\n        Self::create(must_return, explicit, implicit)\n    }", "docstring": null}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/browser_field.rs::crypto_js", "test": "fn crypto_js() {\n    let f = super::fixture();\n\n    let resolver = Resolver::new(ResolveOptions {\n        alias_fields: vec![vec![\"browser\".into()]],\n        fallback: vec![(\n            \"crypto\".into(),\n            vec![AliasValue::Path(f.join(\"lib.js\").to_string_lossy().to_string())],\n        )],\n        ..ResolveOptions::default()\n    });\n\n    let resolved_path = resolver.resolve(f.join(\"crypto-js\"), \"crypto\").map(|r| r.full_path());\n    assert_eq!(resolved_path, Err(ResolveError::Ignored(f.join(\"crypto-js\"))));\n}", "code_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_linter/src/rules/eslint/array_callback_return/return_checker.rs::join", "code": "pub fn join(self, rhs: Self) -> Self {\n        let must_return = self.must_return() && rhs.must_return();\n        let explicit = self.may_return_explicit() || rhs.may_return_explicit();\n        let implicit = self.may_return_implicit() || rhs.may_return_implicit();\n\n        Self::create(must_return, explicit, implicit)\n    }", "docstring": null}
