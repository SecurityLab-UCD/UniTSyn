{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_empty_template", "test": "fn parse_empty_template() {\n    let ast = parse(\"\").unwrap();\n    assert_eq!(ast.len(), 0);\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/for_loop.rs::len", "code": "pub fn len(&self) -> usize {\n        match self.values {\n            ForLoopValues::Array(ref values) => values.as_array().expect(\"Value is array\").len(),\n            ForLoopValues::String(ref values) => {\n                values.as_str().expect(\"Value is string\").chars().count()\n            }\n            ForLoopValues::Object(ref values) => values.len(),\n        }\n    }", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::remove_previous_ws_if_single_opening_tag_requires_it", "test": "fn remove_previous_ws_if_single_opening_tag_requires_it() {\n    let ws = WS { left: true, right: false };\n    let ast = vec![\n        Node::Text(\"hey \".to_string()),\n        Node::ImportMacro(ws, \"hey \".to_string(), \"ho\".to_string()),\n    ];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![\n            Node::Text(\"hey\".to_string()), // it removed the trailing space\n            Node::ImportMacro(ws, \"hey \".to_string(), \"ho\".to_string()),\n        ]\n    );\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/parser/whitespace.rs::remove_whitespace", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::remove_next_ws_if_single_opening_tag_requires_it", "test": "fn remove_next_ws_if_single_opening_tag_requires_it() {\n    let ws = WS { left: true, right: true };\n    let ast = vec![\n        Node::ImportMacro(ws, \"hey \".to_string(), \"ho\".to_string()),\n        Node::Text(\"  hey\".to_string()),\n    ];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![\n            Node::ImportMacro(ws, \"hey \".to_string(), \"ho\".to_string()),\n            Node::Text(\"hey\".to_string()), // it removed the leading space\n        ]\n    );\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/parser/whitespace.rs::remove_whitespace", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::handle_ws_both_sides_for_raw_tag", "test": "fn handle_ws_both_sides_for_raw_tag() {\n    let start_ws = WS { left: true, right: false };\n    let end_ws = WS { left: true, right: true };\n    let ast =\n        vec![Node::Raw(start_ws, \"  hey \".to_string(), end_ws), Node::Text(\"  hey\".to_string())];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![\n            // it removed only the space at the end\n            Node::Raw(start_ws, \"  hey\".to_string(), end_ws),\n            Node::Text(\"hey\".to_string()),\n        ]\n    );\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/parser/whitespace.rs::remove_whitespace", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::handle_ws_both_sides_for_macro_definitions", "test": "fn handle_ws_both_sides_for_macro_definitions() {\n    let start_ws = WS { left: true, right: true };\n    let end_ws = WS { left: true, right: true };\n    let ast = vec![Node::MacroDefinition(\n        start_ws,\n        MacroDefinition {\n            name: \"something\".to_string(),\n            args: HashMap::new(),\n            body: vec![\n                Node::Text(\"\\n  \".to_string()),\n                Node::Text(\"hey\".to_string()),\n                Node::Text(\"  \".to_string()),\n            ],\n        },\n        end_ws,\n    )];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![Node::MacroDefinition(\n            start_ws,\n            MacroDefinition {\n                name: \"something\".to_string(),\n                args: HashMap::new(),\n                body: vec![Node::Text(\"hey\".to_string())],\n            },\n            end_ws,\n        ),]\n    );\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/parser/whitespace.rs::remove_whitespace", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::handle_ws_both_sides_for_forloop_tag_and_remove_empty_node", "test": "fn handle_ws_both_sides_for_forloop_tag_and_remove_empty_node() {\n    let start_ws = WS { left: true, right: true };\n    let end_ws = WS { left: true, right: true };\n    let ast = vec![\n        Node::Forloop(\n            start_ws,\n            Forloop {\n                key: None,\n                value: \"item\".to_string(),\n                container: Expr::new(ExprVal::Int(1)),\n                // not valid but we don't care about it here\n                body: vec![Node::Text(\"   \".to_string()), Node::Text(\"hey   \".to_string())],\n                empty_body: None,\n            },\n            end_ws,\n        ),\n        Node::Text(\"  hey\".to_string()),\n    ];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![\n            Node::Forloop(\n                start_ws,\n                Forloop {\n                    key: None,\n                    value: \"item\".to_string(),\n                    container: Expr::new(ExprVal::Int(1)),\n                    // not valid but we don't care about it here\n                    body: vec![Node::Text(\"hey\".to_string())],\n                    empty_body: None,\n                },\n                end_ws,\n            ),\n            Node::Text(\"hey\".to_string()),\n        ]\n    );\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/parser/whitespace.rs::remove_whitespace", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::handle_ws_for_if_nodes", "test": "fn handle_ws_for_if_nodes() {\n    let end_ws = WS { left: false, right: true };\n    let ast = vec![\n        Node::Text(\"C \".to_string()),\n        Node::If(\n            If {\n                conditions: vec![\n                    (\n                        WS { left: true, right: true },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                    (\n                        WS { left: true, right: false },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                    (\n                        WS { left: true, right: true },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                ],\n                otherwise: None,\n            },\n            end_ws,\n        ),\n        Node::Text(\"  hey\".to_string()),\n    ];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![\n            Node::Text(\"C\".to_string()),\n            Node::If(\n                If {\n                    conditions: vec![\n                        (\n                            WS { left: true, right: true },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\"a\".to_string())],\n                        ),\n                        (\n                            WS { left: true, right: false },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\" a\".to_string())],\n                        ),\n                        (\n                            WS { left: true, right: true },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\"a \".to_string())],\n                        ),\n                    ],\n                    otherwise: None,\n                },\n                end_ws,\n            ),\n            Node::Text(\"hey\".to_string()),\n        ]\n    );\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/parser/whitespace.rs::remove_whitespace", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::handle_ws_for_if_nodes_with_else", "test": "fn handle_ws_for_if_nodes_with_else() {\n    let end_ws = WS { left: true, right: true };\n    let ast = vec![\n        Node::Text(\"C \".to_string()),\n        Node::If(\n            If {\n                conditions: vec![\n                    (\n                        WS { left: true, right: true },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                    (\n                        WS { left: true, right: false },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                    (\n                        WS { left: true, right: true },\n                        Expr::new(ExprVal::Int(1)),\n                        vec![Node::Text(\" a \".to_string())],\n                    ),\n                ],\n                otherwise: Some((\n                    WS { left: true, right: true },\n                    vec![Node::Text(\" a \".to_string())],\n                )),\n            },\n            end_ws,\n        ),\n        Node::Text(\"  hey\".to_string()),\n    ];\n\n    assert_eq!(\n        remove_whitespace(ast, None),\n        vec![\n            Node::Text(\"C\".to_string()),\n            Node::If(\n                If {\n                    conditions: vec![\n                        (\n                            WS { left: true, right: true },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\"a\".to_string())],\n                        ),\n                        (\n                            WS { left: true, right: false },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\" a\".to_string())],\n                        ),\n                        (\n                            WS { left: true, right: true },\n                            Expr::new(ExprVal::Int(1)),\n                            vec![Node::Text(\"a\".to_string())],\n                        ),\n                    ],\n                    otherwise: Some((\n                        WS { left: true, right: true },\n                        vec![Node::Text(\"a\".to_string())],\n                    )),\n                },\n                end_ws,\n            ),\n            Node::Text(\"hey\".to_string()),\n        ]\n    );\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/parser/whitespace.rs::remove_whitespace", "code": "pub fn remove_whitespace(nodes: Vec<Node>, body_ws: Option<WS>) -> Vec<Node> {\n    let mut res = Vec::with_capacity(nodes.len());\n\n    // Whether the node we just added to res is a Text node\n    let mut previous_was_text = false;\n    // Whether the previous block ended wth `-%}` and we need to trim left the next text node\n    let mut trim_left_next = body_ws.map_or(false, |ws| ws.left);\n\n    for n in nodes {\n        match n {\n            Node::Text(s) => {\n                previous_was_text = true;\n\n                if !trim_left_next {\n                    res.push(Node::Text(s));\n                    continue;\n                }\n                trim_left_next = false;\n\n                let new_val = s.trim_start();\n                if !new_val.is_empty() {\n                    res.push(Node::Text(new_val.to_string()));\n                }\n                // empty text nodes will be skipped\n                continue;\n            }\n            Node::VariableBlock(ws, _)\n            | Node::ImportMacro(ws, _, _)\n            | Node::Extends(ws, _)\n            | Node::Include(ws, _, _)\n            | Node::Set(ws, _)\n            | Node::Break(ws)\n            | Node::Comment(ws, _)\n            | Node::Continue(ws) => {\n                trim_right_previous!(previous_was_text && ws.left, res);\n                trim_left_next = ws.right;\n            }\n            Node::Raw(start_ws, ref s, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                if start_ws.right || end_ws.left {\n                    let val = if start_ws.right && end_ws.left {\n                        s.trim()\n                    } else if start_ws.right {\n                        s.trim_start()\n                    } else {\n                        s.trim_end()\n                    };\n\n                    res.push(Node::Raw(start_ws, val.to_string(), end_ws));\n                    continue;\n                }\n            }\n            // Those nodes have a body surrounded by 2 tags\n            Node::Forloop(start_ws, _, end_ws)\n            | Node::MacroDefinition(start_ws, _, end_ws)\n            | Node::FilterSection(start_ws, _, end_ws)\n            | Node::Block(start_ws, _, end_ws) => {\n                trim_right_previous!(previous_was_text && start_ws.left, res);\n                previous_was_text = false;\n                trim_left_next = end_ws.right;\n\n                // let's remove ws from the bodies now and append the cleaned up node\n                let body_ws = WS { left: start_ws.right, right: end_ws.left };\n                match n {\n                    Node::Forloop(_, mut forloop, _) => {\n                        forloop.body = remove_whitespace(forloop.body, Some(body_ws));\n                        res.push(Node::Forloop(start_ws, forloop, end_ws));\n                    }\n                    Node::MacroDefinition(_, mut macro_def, _) => {\n                        macro_def.body = remove_whitespace(macro_def.body, Some(body_ws));\n                        res.push(Node::MacroDefinition(start_ws, macro_def, end_ws));\n                    }\n                    Node::FilterSection(_, mut filter_section, _) => {\n                        filter_section.body = remove_whitespace(filter_section.body, Some(body_ws));\n                        res.push(Node::FilterSection(start_ws, filter_section, end_ws));\n                    }\n                    Node::Block(_, mut block, _) => {\n                        block.body = remove_whitespace(block.body, Some(body_ws));\n                        res.push(Node::Block(start_ws, block, end_ws));\n                    }\n                    _ => unreachable!(),\n                };\n                continue;\n            }\n            // The ugly one\n            Node::If(If { conditions, otherwise }, end_ws) => {\n                trim_left_next = end_ws.right;\n                let mut new_conditions: Vec<(_, _, Vec<_>)> = Vec::with_capacity(conditions.len());\n\n                for mut condition in conditions {\n                    if condition.0.left {\n                        // We need to trim the text node before the if tag\n                        if new_conditions.is_empty() && previous_was_text {\n                            trim_right_previous!(res);\n                        } else if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n\n                    // we can't peek at the next one to know whether we need to trim right since\n                    // are consuming conditions. We'll find out at the next iteration.\n                    condition.2 = remove_whitespace(\n                        condition.2,\n                        Some(WS { left: condition.0.right, right: false }),\n                    );\n                    new_conditions.push(condition);\n                }\n\n                previous_was_text = false;\n\n                // We now need to look for the last potential `{%-` bit for if/elif\n\n                // That can be a `{%- else`\n                if let Some((else_ws, body)) = otherwise {\n                    if else_ws.left {\n                        if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                            trim_right_previous!(body);\n                        }\n                    }\n                    let mut else_body =\n                        remove_whitespace(body, Some(WS { left: else_ws.right, right: false }));\n                    // if we have an `else`, the `endif` will affect the else node so we need to check\n                    if end_ws.left {\n                        trim_right_previous!(else_body);\n                    }\n                    res.push(Node::If(\n                        If { conditions: new_conditions, otherwise: Some((else_ws, else_body)) },\n                        end_ws,\n                    ));\n                    continue;\n                }\n\n                // Or `{%- endif`\n                if end_ws.left {\n                    if let Some(&mut (_, _, ref mut body)) = new_conditions.last_mut() {\n                        trim_right_previous!(true, body);\n                    }\n                }\n\n                res.push(Node::If(If { conditions: new_conditions, otherwise }, end_ws));\n                continue;\n            }\n            Node::Super => (),\n        };\n\n        // If we are there, that means it's not a text node and we didn't have to modify the node\n        previous_was_text = false;\n        res.push(n);\n    }\n\n    if let Some(whitespace) = body_ws {\n        trim_right_previous!(whitespace.right, res);\n    }\n\n    res\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_variable_block_lit_expr", "test": "fn render_variable_block_lit_expr() {\n    let inputs = vec![\n        (\"{{ 1 }}\", \"1\"),\n        (\"{{ 3.18 }}\", \"3.18\"),\n        (\"{{ \\\"hey\\\" }}\", \"hey\"),\n        (r#\"{{ \"{{ hey }}\" }}\"#, \"{{ hey }}\"),\n        (\"{{ true }}\", \"true\"),\n        (\"{{ false }}\", \"false\"),\n        (\"{{ false and true or true }}\", \"true\"),\n        (\"{{ 1 + 1 }}\", \"2\"),\n        (\"{{ 1 + 1.1 }}\", \"2.1\"),\n        (\"{{ 3 - 1 }}\", \"2\"),\n        (\"{{ 3 - 1.1 }}\", \"1.9\"),\n        (\"{{ 2 * 5 }}\", \"10\"),\n        (\"{{ 10 / 5 }}\", \"2\"),\n        (\"{{ 2.1 * 5 }}\", \"10.5\"),\n        (\"{{ 2.1 * 5.05 }}\", \"10.605\"),\n        (\"{{ 2 / 0.5 }}\", \"4\"),\n        (\"{{ 2.1 / 0.5 }}\", \"4.2\"),\n        (\"{{ 2 + 1 * 2 }}\", \"4\"),\n        (\"{{ (2 + 1) * 2 }}\", \"6\"),\n        (\"{{ 2 * 4 % 8 }}\", \"0\"),\n        (\"{{ 2.8 * 2 | round }}\", \"6\"),\n        (\"{{ 1 / 0 }}\", \"NaN\"),\n        (\"{{ true and 10 }}\", \"true\"),\n        (\"{{ true and not 10 }}\", \"false\"),\n        (\"{{ not true }}\", \"false\"),\n        (\"{{ [1, 2, 3] }}\", \"[1, 2, 3]\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &Context::new()).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_variable_block_ident", "test": "fn render_variable_block_ident() {\n    let mut context = Context::new();\n    context.insert(\"name\", &\"john\");\n    context.insert(\"malicious\", &\"<html>\");\n    context.insert(\"a\", &2);\n    context.insert(\"b\", &3);\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n    context.insert(\"tuple_list\", &vec![(1, 2, 3), (1, 2, 3)]);\n    context.insert(\"review\", &Review::new());\n    context.insert(\"with_newline\", &\"Animal Alphabets\\nB is for Bee-Eater\");\n\n    let inputs = vec![\n        (\"{{ name }}\", \"john\"),\n        (\"{{ malicious }}\", \"&lt;html&gt;\"),\n        (\"{{ \\\"<html>\\\" }}\", \"&lt;html&gt;\"),\n        (\"{{ \\\" html \\\" | upper | trim }}\", \"HTML\"),\n        (\"{{ 'html' }}\", \"html\"),\n        (\"{{ `html` }}\", \"html\"),\n        // https://github.com/Keats/tera/issues/273\n        (\n            r#\"{{ 'hangar new \"Will Smoth <will_s@example.com>\"' | safe }}\"#,\n            r#\"hangar new \"Will Smoth <will_s@example.com>\"\"#,\n        ),\n        (\"{{ malicious | safe }}\", \"<html>\"),\n        (\"{{ malicious | upper }}\", \"&lt;HTML&gt;\"),\n        (\"{{ malicious | upper | safe }}\", \"<HTML>\"),\n        (\"{{ malicious | safe | upper }}\", \"&lt;HTML&gt;\"),\n        (\"{{ review | length }}\", \"2\"),\n        (\"{{ review.paragraphs.1 }}\", \"B\"),\n        (\"{{ numbers }}\", \"[1, 2, 3]\"),\n        (\"{{ numbers.0 }}\", \"1\"),\n        (\"{{ tuple_list.1.1 }}\", \"2\"),\n        (\"{{ name and true }}\", \"true\"),\n        (\"{{ name | length }}\", \"4\"),\n        (\"{{ name is defined }}\", \"true\"),\n        (\"{{ not name is defined }}\", \"false\"),\n        (\"{{ name is not defined }}\", \"false\"),\n        (\"{{ not name is not defined }}\", \"true\"),\n        (\"{{ a is odd }}\", \"false\"),\n        (\"{{ a is odd or b is odd  }}\", \"true\"),\n        (\"{{ range(start=1, end=4) }}\", \"[1, 2, 3]\"),\n        (\"{{ a + b }}\", \"5\"),\n        (\"{{ a + 1.5 }}\", \"3.5\"),\n        (\"{{ 1 + 1 + 1 }}\", \"3\"),\n        (\"{{ 2 - 2 - 1 }}\", \"-1\"),\n        (\"{{ 1 - 1 + 1 }}\", \"1\"),\n        (\"{{ 1 + get_number() }}\", \"11\"),\n        (\"{{ get_number() + 1 }}\", \"11\"),\n        (\"{{ (1.9 + a) | round }}\", \"4\"),\n        (\"{{ 1.9 + a | round }}\", \"4\"),\n        (\"{{ numbers | length - 1 }}\", \"2\"),\n        (\"{{ 1.9 + a | round - 1 }}\", \"3\"),\n        (\"{{ 1.9 + a | round - 1.8 + a | round }}\", \"0\"),\n        (\"{{ 1.9 + a | round - 1.8 + a | round - 1 }}\", \"-1\"),\n        (\"{{ 4 + 40 / (2 + 8) / 4 }}\", \"5\"),\n        (\"{{ ( ( 2 ) + ( 2 ) ) }}\", \"4\"),\n        (\"{{ ( ( 4 / 1 ) + ( 2 / 1 ) ) }}\", \"6\"),\n        (\"{{ ( ( 4 + 2 ) / ( 2 + 1 ) ) }}\", \"2\"),\n        // https://github.com/Keats/tera/issues/435\n        (\n            \"{{ with_newline | replace(from='\\n', to='<br>') | safe }}\",\n            \"Animal Alphabets<br>B is for Bee-Eater\",\n        ),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_variable_block_logic_expr", "test": "fn render_variable_block_logic_expr() {\n    let mut context = Context::new();\n    context.insert(\"name\", &\"john\");\n    context.insert(\"malicious\", &\"<html>\");\n    context.insert(\"a\", &2);\n    context.insert(\"b\", &3);\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n    context.insert(\"tuple_list\", &vec![(1, 2, 3), (1, 2, 3)]);\n    let mut hashmap = HashMap::new();\n    hashmap.insert(\"a\", 1);\n    hashmap.insert(\"b\", 10);\n    hashmap.insert(\"john\", 100);\n    context.insert(\"object\", &hashmap);\n    context.insert(\"urls\", &vec![\"https://test\"]);\n\n    let inputs = vec![\n        (\"{{ (1.9 + a) | round > 10 }}\", \"false\"),\n        (\"{{ (1.9 + a) | round > 10 or b > a }}\", \"true\"),\n        (\"{{ 1.9 + a | round == 4 and numbers | length == 3}}\", \"true\"),\n        (\"{{ numbers | length > 1 }}\", \"true\"),\n        (\"{{ numbers | length == 1 }}\", \"false\"),\n        (\"{{ numbers | length - 2 == 1 }}\", \"true\"),\n        (\"{{ not name }}\", \"false\"),\n        (\"{{ not true }}\", \"false\"),\n        (\"{{ not undefined }}\", \"true\"),\n        (\"{{ name == 'john' }}\", \"true\"),\n        (\"{{ name != 'john' }}\", \"false\"),\n        (\"{{ name == 'john' | capitalize }}\", \"false\"),\n        (\"{{ name != 'john' | capitalize }}\", \"true\"),\n        (\"{{ 1 in numbers }}\", \"true\"),\n        (\"{{ 1 not in numbers }}\", \"false\"),\n        (\"{{ 40 not in numbers }}\", \"true\"),\n        (\"{{ 'e' in 'hello' }}\", \"true\"),\n        (\"{{ 'e' not in 'hello' }}\", \"false\"),\n        (\"{{ 'x' not in 'hello' }}\", \"true\"),\n        (\"{{ name in 'hello john' }}\", \"true\"),\n        (\"{{ name not in 'hello john' }}\", \"false\"),\n        (\"{{ name not in 'hello' }}\", \"true\"),\n        (\"{{ name in ['bob', 2, 'john'] }}\", \"true\"),\n        (\"{{ a in ['bob', 2, 'john'] }}\", \"true\"),\n        (\"{{ \\\"https://test\\\" in [\\\"https://test\\\"] }}\", \"true\"),\n        (\"{{ \\\"https://test\\\" in urls }}\", \"true\"),\n        (\"{{ 'n' in name }}\", \"true\"),\n        (\"{{ '<' in malicious }}\", \"true\"),\n        (\"{{ 'a' in object }}\", \"true\"),\n        (\"{{ name in object }}\", \"true\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::comments_are_ignored", "test": "fn comments_are_ignored() {\n    let inputs = vec![\n        (\"Hello {# comment #}world\", \"Hello world\"),\n        (\"Hello {# comment {# nested #}world\", \"Hello world\"),\n        (\"My name {# was {{ name }} #}is No One.\", \"My name is No One.\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &Context::new()).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::escaping_happens_at_the_end", "test": "fn escaping_happens_at_the_end() {\n    let inputs = vec![\n        #[cfg(feature = \"builtins\")]\n        (\"{{ url | urlencode | safe }}\", \"https%3A//www.example.org/apples-%26-oranges/\"),\n        (\"{{ '<html>' }}\", \"&lt;html&gt;\"),\n        (\"{{ '<html>' | safe }}\", \"<html>\"),\n        (\"{{ 'hello' | safe | replace(from='h', to='&') }}\", \"&amp;ello\"),\n        (\"{{ 'hello' | replace(from='h', to='&') | safe }}\", \"&ello\"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut context = Context::new();\n        context.insert(\"url\", \"https://www.example.org/apples-&-oranges/\");\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::filter_args_are_not_escaped", "test": "fn filter_args_are_not_escaped() {\n    let mut context = Context::new();\n    context.insert(\"my_var\", &\"hey\");\n    context.insert(\"to\", &\"&\");\n    let input = r#\"{{ my_var | replace(from=\"h\", to=to) }}\"#;\n\n    assert_eq!(render_template(input, &context).unwrap(), \"&amp;ey\");\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_raw_tag", "test": "fn render_raw_tag() {\n    let inputs = vec![\n        (\"{% raw %}hey{% endraw %}\", \"hey\"),\n        (\"{% raw %}{{hey}}{% endraw %}\", \"{{hey}}\"),\n        (\"{% raw %}{% if true %}{% endraw %}\", \"{% if true %}\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &Context::new()).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::add_set_values_in_context", "test": "fn add_set_values_in_context() {\n    let mut context = Context::new();\n    context.insert(\"my_var\", &\"hey\");\n    context.insert(\"malicious\", &\"<html>\");\n    context.insert(\"admin\", &true);\n    context.insert(\"num\", &1);\n\n    let inputs = vec![\n        (\"{% set i = 1 %}{{ i }}\", \"1\"),\n        (\"{% set i = 1 + 2 %}{{ i }}\", \"3\"),\n        (r#\"{% set i = \"hey\" %}{{ i }}\"#, \"hey\"),\n        (r#\"{% set i = \"<html>\" %}{{ i | safe }}\"#, \"<html>\"),\n        (r#\"{% set i = \"<html>\" %}{{ i }}\"#, \"&lt;html&gt;\"),\n        (\"{% set i = my_var %}{{ i }}\", \"hey\"),\n        (\"{% set i = malicious %}{{ i | safe }}\", \"<html>\"),\n        (\"{% set i = malicious %}{{ i }}\", \"&lt;html&gt;\"),\n        (\"{% set i = my_var | upper %}{{ i }}\", \"HEY\"),\n        (\"{% set i = range(end=3) %}{{ i }}\", \"[0, 1, 2]\"),\n        (\"{% set i = admin or true %}{{ i }}\", \"true\"),\n        (\"{% set i = admin and num > 0 %}{{ i }}\", \"true\"),\n        (\"{% set i = 0 / 0 %}{{ i }}\", \"NaN\"),\n        (\"{% set i = [1,2] %}{{ i }}\", \"[1, 2]\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_filter_section", "test": "fn render_filter_section() {\n    let inputs = vec![\n        (\"{% filter upper %}Hello{% endfilter %}\", \"HELLO\"),\n        (\"{% filter upper %}Hello{% if true %} world{% endif %}{% endfilter %}\", \"HELLO WORLD\"),\n        (\"{% filter upper %}Hello {% for i in range(end=3) %}i{% endfor %}{% endfilter %}\", \"HELLO III\"),\n        (\n            \"{% filter upper %}Hello {% for i in range(end=3) %}{% if i == 1 %}{% break %} {% endif %}i{% endfor %}{% endfilter %}\",\n            \"HELLO I\",\n        ),\n        (\"{% filter title %}Hello {% if true %}{{ 'world' | upper | safe }}{% endif %}{% endfilter %}\", \"Hello World\"),\n        (\"{% filter safe %}{% filter upper %}<Hello>{% endfilter %}{% endfilter%}\", \"<HELLO>\")\n    ];\n\n    let context = Context::new();\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_tests", "test": "fn render_tests() {\n    let mut context = Context::new();\n    context.insert(\"is_true\", &true);\n    context.insert(\"is_false\", &false);\n    context.insert(\"age\", &18);\n    context.insert(\"name\", &\"john\");\n    let mut map = HashMap::new();\n    map.insert(0, 1);\n    context.insert(\"map\", &map);\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n    context.insert::<Option<usize>, _>(\"maybe\", &None);\n\n    let inputs = vec![\n        (\"{% if is_true is defined %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if hello is undefined %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if name is string %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if age is number %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if age is even %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if age is odd %}Admin{%else%}even{% endif %}\", \"even\"),\n        (\"{% if age is divisibleby(2) %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if numbers is iterable %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if map is iterable %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if map is object %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if name is starting_with('j') %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if name is ending_with('n') %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if numbers is containing(2) %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if name is matching('^j.*') %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if maybe is defined %}Admin{% endif %}\", \"Admin\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_if_elif_else", "test": "fn render_if_elif_else() {\n    let mut context = Context::new();\n    context.insert(\"is_true\", &true);\n    context.insert(\"is_false\", &false);\n    context.insert(\"age\", &18);\n    context.insert(\"name\", &\"john\");\n    context.insert(\"empty_string\", &\"\");\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (\"{% if is_true %}Admin{% endif %}\", \"Admin\"),\n        (\"{% if is_true or age + 1 > 18 %}Adult{% endif %}\", \"Adult\"),\n        (\"{% if is_true and age == 18 %}Adult{% endif %}\", \"Adult\"),\n        // https://github.com/Keats/tera/issues/187\n        (\"{% if 1 <= 2 %}a{% endif %}\", \"a\"),\n        (\"{% if 2 >= 1 %}a{% endif %}\", \"a\"),\n        (\"{% if 1 < 2 %}a{% endif %}\", \"a\"),\n        (\"{% if 2 > 1 %}a{% endif %}\", \"a\"),\n        (\"{% if 1 == 1 %}a{% endif %}\", \"a\"),\n        (\"{% if 1 != 2 %}a{% endif %}\", \"a\"),\n        // testing string conditions\n        (\"{% if 'true' %}a{% endif %}\", \"a\"),\n        (\"{% if name %}a{% endif %}\", \"a\"),\n        (\"{% if '' %}a{% endif %}\", \"\"),\n        (\"{% if empty_string %}a{% endif %}\", \"\"),\n        (\"{% if '' ~ name %}a{% endif %}\", \"a\"),\n        (\"{% if '' ~ empty_string %}a{% endif %}\", \"\"),\n        // some not conditions\n        (\"{% if not is_false %}a{% endif %}\", \"a\"),\n        (\"{% if not is_true %}a{% endif %}\", \"\"),\n        (\"{% if undefined %}a{% endif %}\", \"\"),\n        (\"{% if not undefined %}a{% endif %}\", \"a\"),\n        (\"{% if not is_false and is_true %}a{% endif %}\", \"a\"),\n        (\"{% if not is_false or numbers | length > 0 %}a{% endif %}\", \"a\"),\n        // doesn't panic with NaN results\n        (\"{% if 0 / 0 %}a{% endif %}\", \"\"),\n        // if and else\n        (\"{% if is_true %}Admin{% else %}User{% endif %}\", \"Admin\"),\n        (\"{% if is_false %}Admin{% else %}User{% endif %}\", \"User\"),\n        // if and elifs\n        (\"{% if is_true %}Admin{% elif is_false %}User{% endif %}\", \"Admin\"),\n        (\"{% if is_true %}Admin{% elif is_true %}User{% endif %}\", \"Admin\"),\n        (\"{% if is_true %}Admin{% elif numbers | length > 0 %}User{% endif %}\", \"Admin\"),\n        // if, elifs and else\n        (\"{% if is_true %}Admin{% elif is_false %}User{% else %}Hmm{% endif %}\", \"Admin\"),\n        (\"{% if false %}Admin{% elif is_false %}User{% else %}Hmm{% endif %}\", \"Hmm\"),\n        // doesn't fallthrough elifs\n        // https://github.com/Keats/tera/issues/188\n        (\"{% if 1 < 4 %}a{% elif 2 < 4 %}b{% elif 3 < 4 %}c{% else %}d{% endif %}\", \"a\"),\n        // with in operator\n        (\n            \"{% if 1 in numbers %}Admin{% elif 100 in numbers %}User{% else %}Hmm{% endif %}\",\n            \"Admin\",\n        ),\n        (\"{% if 100 in numbers %}Admin{% elif 1 in numbers %}User{% else %}Hmm{% endif %}\", \"User\"),\n        (\"{% if 'n' in name %}Admin{% else %}Hmm{% endif %}\", \"Admin\"),\n        // function in if\n        (\"{% if get_true() %}Truth{% endif %}\", \"Truth\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_for", "test": "fn render_for() {\n    let mut context = Context::new();\n    let mut map = BTreeMap::new();\n    map.insert(\"name\", \"bob\");\n    map.insert(\"age\", \"18\");\n\n    context.insert(\"data\", &vec![1, 2, 3]);\n    context.insert(\"notes\", &vec![1, 2, 3]);\n    context.insert(\"vectors\", &vec![vec![0, 3, 6], vec![1, 4, 7]]);\n    context.insert(\"vectors_some_empty\", &vec![vec![0, 3, 6], vec![], vec![1, 4, 7]]);\n    context.insert(\"map\", &map);\n    context.insert(\"truthy\", &2);\n\n    let inputs = vec![\n        (\"{% for i in data %}{{i}}{% endfor %}\", \"123\"),\n        (\"{% for key, val in map %}{{key}}:{{val}} {% endfor %}\", \"age:18 name:bob \"),\n        (\n            \"{% for i in data %}{{loop.index}}{{loop.index0}}{{loop.first}}{{loop.last}}{% endfor %}\",\n            \"10truefalse21falsefalse32falsetrue\"\n        ),\n        (\n            \"{% for vector in vectors %}{% for j in vector %}{{ j }}{% endfor %}{% endfor %}\",\n            \"036147\"\n        ),\n        (\n            \"{% for vector in vectors_some_empty %}{% for j in vector %}{{ j }}{% endfor %}{% endfor %}\",\n            \"036147\"\n        ),\n        (\n            \"{% for val in data %}{% if val == truthy %}on{% else %}off{% endif %}{% endfor %}\",\n            \"offonoff\"\n        ),\n        (\"{% for i in range(end=5) %}{{i}}{% endfor %}\", \"01234\"),\n        (\"{% for i in range(end=5) | reverse %}{{i}}{% endfor %}\", \"43210\"),\n        (\n            \"{% set looped = 0 %}{% for i in range(end=5) %}{% set looped = i %}{{looped}}{% endfor%}{{looped}}\",\n            \"012340\"\n        ),\n        // https://github.com/Keats/tera/issues/184\n        (\"{% for note in notes %}{{ note }}{% endfor %}\", \"123\"),\n        (\"{% for note in notes | reverse %}{{ note }}{% endfor %}\", \"321\"),\n        (\"{% for v in vectors %}{{ v.0 }}{% endfor %}\", \"01\"),\n        // Loop control (`break` and `continue`)\n        // https://github.com/Keats/tera/issues/267\n        (\n            \"{% for i in data %}{{ i }}{% if i == 2 %}{% break %}{% endif %}{% endfor %}\",\n            \"12\"\n        ),\n        (\n            \"{% for i in data %}{% if i == 2 %}{% continue %}{% endif %}{{ i }}{% endfor %}\",\n            \"13\"\n        ),\n        (\n            \"{% for v in vectors %}{% for i in v %}{% if i == 3 %}{% break %}{% endif %}{{ i }}{% endfor %}{% endfor %}\",\n            \"0147\"\n        ),\n        (\n            \"{% for v in vectors %}{% for i in v %}{% if i == 3 %}{% continue %}{% endif %}{{ i }}{% endfor %}{% endfor %}\",\n            \"06147\"\n        ),\n        (\n            \"{% for a in [1, true, 1.1, 'hello'] %}{{a}}{% endfor %}\",\n            \"1true1.1hello\"\n        ),\n        // https://github.com/Keats/tera/issues/301\n        (\n            \"{% set start = 0 %}{% set end = start + 3 %}{% for i in range(start=start, end=end) %}{{ i }}{% endfor%}\",\n            \"012\"\n        ),\n        // https://github.com/Keats/tera/issues/395\n        (\n            \"{% for a in [] %}{{a}}{% else %}hello{% endfor %}\",\n            \"hello\"\n        ),\n        (\n            \"{% for a in undefined_variable | default(value=[]) %}{{a}}{% else %}hello{% endfor %}\",\n            \"hello\"\n        ),\n        (\n            \"{% for a in [] %}{{a}}{% else %}{% if 1 == 2 %}A{% else %}B{% endif %}{% endfor %}\",\n            \"B\"\n        ),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::ok_many_variable_blocks", "test": "fn ok_many_variable_blocks() {\n    let mut context = Context::new();\n    context.insert(\"username\", &\"bob\");\n\n    let mut tpl = String::new();\n    for _ in 0..200 {\n        tpl.push_str(\"{{ username }}\")\n    }\n    let mut expected = String::new();\n    for _ in 0..200 {\n        expected.push_str(\"bob\")\n    }\n    assert_eq!(render_template(&tpl, &context).unwrap(), expected);\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::default_filter_works", "test": "fn default_filter_works() {\n    let mut context = Context::new();\n    let i: Option<usize> = None;\n    context.insert(\"existing\", \"hello\");\n    context.insert(\"null\", &i);\n\n    let inputs = vec![\n        (r#\"{{ existing | default(value=\"hey\") }}\"#, \"hello\"),\n        (r#\"{{ val | default(value=1) }}\"#, \"1\"),\n        (r#\"{{ val | default(value=\"hey\") | capitalize }}\"#, \"Hey\"),\n        (r#\"{{ obj.val | default(value=\"hey\") | capitalize }}\"#, \"Hey\"),\n        (r#\"{{ obj.val | default(value=\"hey\") | capitalize }}\"#, \"Hey\"),\n        (r#\"{{ not admin | default(value=false) }}\"#, \"true\"),\n        (r#\"{{ not admin | default(value=true) }}\"#, \"false\"),\n        (r#\"{{ null | default(value=true) }}\"#, \"true\"),\n        (r#\"{{ null | default(value=\"hey\") | capitalize }}\"#, \"Hey\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::filter_filter_works", "test": "fn filter_filter_works() {\n    #[derive(Debug, Serialize)]\n    struct Author {\n        id: u8,\n    }\n\n    let mut context = Context::new();\n    context.insert(\"authors\", &vec![Author { id: 1 }, Author { id: 2 }, Author { id: 3 }]);\n\n    let inputs =\n        vec![(r#\"{{ authors | filter(attribute=\"id\", value=1) | first | get(key=\"id\") }}\"#, \"1\")];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::filter_on_array_literal_works", "test": "fn filter_on_array_literal_works() {\n    let mut context = Context::new();\n    let i: Option<usize> = None;\n    context.insert(\"existing\", \"hello\");\n    context.insert(\"null\", &i);\n\n    let inputs = vec![\n        (r#\"{{ [1, 2, 3] | length }}\"#, \"3\"),\n        (r#\"{% set a = [1, 2, 3] | length %}{{ a }}\"#, \"3\"),\n        (r#\"{% for a in [1, 2, 3] | slice(start=1) %}{{ a }}{% endfor %}\"#, \"23\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::can_do_string_concat", "test": "fn can_do_string_concat() {\n    let mut context = Context::new();\n    context.insert(\"a_string\", \"hello\");\n    context.insert(\"another_string\", \"xXx\");\n    context.insert(\"an_int\", &1);\n    context.insert(\"a_float\", &3.18);\n\n    let inputs = vec![\n        (r#\"{{ \"hello\" ~ \" world\" }}\"#, \"hello world\"),\n        (r#\"{{ \"hello\" ~ 1 }}\"#, \"hello1\"),\n        (r#\"{{ \"hello\" ~ 3.18 }}\"#, \"hello3.18\"),\n        (r#\"{{ 3.18 ~ \"hello\"}}\"#, \"3.18hello\"),\n        (r#\"{{ \"hello\" ~ get_string() }}\"#, \"helloHello\"),\n        (r#\"{{ get_string() ~ \"hello\" }}\"#, \"Hellohello\"),\n        (r#\"{{ get_string() ~ 3.18 }}\"#, \"Hello3.18\"),\n        (r#\"{{ a_string ~ \" world\" }}\"#, \"hello world\"),\n        (r#\"{{ a_string ~ ' world ' ~ another_string }}\"#, \"hello world xXx\"),\n        (r#\"{{ a_string ~ another_string }}\"#, \"helloxXx\"),\n        (r#\"{{ a_string ~ an_int }}\"#, \"hello1\"),\n        (r#\"{{ a_string ~ a_float }}\"#, \"hello3.18\"),\n    ];\n\n    for (input, expected) in inputs {\n        println!(\"{:?} -> {:?}\", input, expected);\n        assert_eq!(render_template(input, &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::does_render_owned_for_loop_with_objects", "test": "fn does_render_owned_for_loop_with_objects() {\n    let mut context = Context::new();\n    let data = json!([\n        {\"id\": 1, \"year\": 2015},\n        {\"id\": 2, \"year\": 2015},\n        {\"id\": 3, \"year\": 2016},\n        {\"id\": 4, \"year\": 2017},\n        {\"id\": 5, \"year\": 2017},\n        {\"id\": 6, \"year\": 2017},\n        {\"id\": 7, \"year\": 2018},\n        {\"id\": 8},\n        {\"id\": 9, \"year\": null},\n    ]);\n    context.insert(\"something\", &data);\n\n    let tpl =\n        r#\"{% for year, things in something | group_by(attribute=\"year\") %}{{year}},{% endfor %}\"#;\n    let expected = \"2015,2016,2017,2018,\";\n    assert_eq!(render_template(tpl, &context).unwrap(), expected);\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::does_render_owned_for_loop_with_objects_string_keys", "test": "fn does_render_owned_for_loop_with_objects_string_keys() {\n    let mut context = Context::new();\n    let data = json!([\n        {\"id\": 1, \"group\": \"a\"},\n        {\"id\": 2, \"group\": \"b\"},\n        {\"id\": 3, \"group\": \"c\"},\n        {\"id\": 4, \"group\": \"a\"},\n        {\"id\": 5, \"group\": \"b\"},\n        {\"id\": 6, \"group\": \"c\"},\n        {\"id\": 7, \"group\": \"a\"},\n        {\"id\": 8},\n        {\"id\": 9, \"year\": null},\n    ]);\n    context.insert(\"something\", &data);\n\n    let tpl = r#\"{% for group, things in something | group_by(attribute=\"group\") %}{{group}},{% endfor %}\"#;\n    let expected = \"a,b,c,\";\n    assert_eq!(render_template(tpl, &context).unwrap(), expected);\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_template", "code": "fn render_template(content: &str, context: &Context) -> Result<String> {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello.html\", content).unwrap();\n    tera.register_function(\"get_number\", |_: &HashMap<String, Value>| Ok(Value::Number(10.into())));\n    tera.register_function(\"get_true\", |_: &HashMap<String, Value>| Ok(Value::Bool(true)));\n    tera.register_function(\"get_string\", |_: &HashMap<String, Value>| {\n        Ok(Value::String(\"Hello\".to_string()))\n    });\n\n    tera.render(\"hello.html\", context)\n}", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/whitespace.rs::can_remove_whitespace_basic", "test": "fn can_remove_whitespace_basic() {\n    let mut context = Context::new();\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (\"  {%- for n in numbers %}{{n}}{% endfor -%} \", \"123\"),\n        (\"{%- for n in numbers %} {{n}}{%- endfor -%} \", \" 1 2 3\"),\n        (\"{%- for n in numbers -%}\\n {{n}}\\n {%- endfor -%} \", \"123\"),\n        (\"{%- if true -%}\\n {{numbers}}\\n {%- endif -%} \", \"[1, 2, 3]\"),\n        (\"{%- if false -%}\\n {{numbers}}\\n {% else %} Nope{%- endif -%} \", \" Nope\"),\n        (\"  {%- if false -%}\\n {{numbers}}\\n {% else -%} Nope {%- endif -%} \", \"Nope\"),\n        (\"  {%- if false -%}\\n {{numbers}}\\n {% elif true -%} Nope {%- endif -%} \", \"Nope\"),\n        (\"  {%- if false -%}\\n {{numbers}}\\n {% elif false -%} Nope {% else %} else {%- endif -%} \", \" else\"),\n        (\"  {%- set var = 2 -%} {{var}}\", \"2\"),\n        (\"  {% set var = 2 -%} {{var}}\", \"  2\"),\n        (\" {% raw -%} {{2}} {% endraw -%} \", \" {{2}} \"),\n        (\"  {% filter upper -%} hey {%- endfilter -%} \", \"  HEY\"),\n        (\"  {{ \\\"hello\\\" -}} \", \"  hello\"),\n        (\"  {{- \\\"hello\\\" }} \", \"hello \"),\n        (\"  {{- \\\"hello\\\" -}} \", \"hello\"),\n        // Comments are not rendered so it should be just whitespace if anything\n        (\"  {#- \\\"hello\\\" -#} \", \"\"),\n        (\"  {# \\\"hello\\\" -#} \", \"  \"),\n        (\"  {#- \\\"hello\\\" #} \", \" \"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut tera = Tera::default();\n        tera.add_raw_template(\"tpl\", input).unwrap();\n        println!(\"{} -> {:?}\", input, expected);\n        assert_eq!(tera.render(\"tpl\", &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/tera.rs::render", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/whitespace.rs::can_remove_whitespace_include", "test": "fn can_remove_whitespace_include() {\n    let mut context = Context::new();\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (r#\"Hi {%- include \"include\" -%} \"#, \"HiIncluded\"),\n        (r#\"Hi {% include \"include\" -%} \"#, \"Hi Included\"),\n        (r#\"Hi {% include \"include\" %} \"#, \"Hi Included \"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut tera = Tera::default();\n        tera.add_raw_templates(vec![(\"include\", \"Included\"), (\"tpl\", input)]).unwrap();\n        assert_eq!(tera.render(\"tpl\", &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/tera.rs::render", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/whitespace.rs::can_remove_whitespace_macros", "test": "fn can_remove_whitespace_macros() {\n    let mut context = Context::new();\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (r#\" {%- import \"macros\" as macros -%} {{macros::hey()}}\"#, \"Hey!\"),\n        (r#\" {% import \"macros\" as macros %} {{macros::hey()}}\"#, \"Hey!\"),\n        (r#\" {%- import \"macros\" as macros %} {%- set hey = macros::hey() -%} {{hey}}\"#, \"Hey!\"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut tera = Tera::default();\n        tera.add_raw_templates(vec![\n            (\"macros\", \"{% macro hey() -%} Hey! {%- endmacro %}\"),\n            (\"tpl\", input),\n        ])\n        .unwrap();\n        assert_eq!(tera.render(\"tpl\", &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/tera.rs::render", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "docstring": null}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/whitespace.rs::can_remove_whitespace_inheritance", "test": "fn can_remove_whitespace_inheritance() {\n    let mut context = Context::new();\n    context.insert(\"numbers\", &vec![1, 2, 3]);\n\n    let inputs = vec![\n        (r#\"{%- extends \"base\" -%} {% block content %}{{super()}}{% endblock %}\"#, \" Hey! \"),\n        (r#\"{%- extends \"base\" -%} {% block content -%}{{super()}}{%- endblock %}\"#, \" Hey! \"),\n        (r#\"{%- extends \"base\" %} {%- block content -%}{{super()}}{%- endblock -%} \"#, \" Hey! \"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut tera = Tera::default();\n        tera.add_raw_templates(vec![\n            (\"base\", \"{% block content %} Hey! {% endblock %}\"),\n            (\"tpl\", input),\n        ])\n        .unwrap();\n        assert_eq!(tera.render(\"tpl\", &context).unwrap(), expected);\n    }\n}", "code_id": "Keats-tera/Keats-tera-1f95878/src/tera.rs::render", "code": "pub fn render(&self, template_name: &str, context: &Context) -> Result<String> {\n        let template = self.get_template(template_name)?;\n        let renderer = Renderer::new(template, self, context);\n        renderer.render()\n    }", "docstring": null}
