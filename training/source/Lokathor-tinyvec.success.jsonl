{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_push_pop", "test": "fn ArrayVec_push_pop() {\n  let mut av: ArrayVec<[i32; 4]> = Default::default();\n  assert_eq!(av.len(), 0);\n  assert_eq!(av.pop(), None);\n\n  av.push(10_i32);\n  assert_eq!(av.len(), 1);\n  assert_eq!(av[0], 10);\n  assert_eq!(av.pop(), Some(10));\n  assert_eq!(av.len(), 0);\n  assert_eq!(av.pop(), None);\n\n  av.push(10);\n  av.push(11);\n  av.push(12);\n  av.push(13);\n  assert_eq!(av[0], 10);\n  assert_eq!(av[1], 11);\n  assert_eq!(av[2], 12);\n  assert_eq!(av[3], 13);\n  assert_eq!(av.len(), 4);\n  assert_eq!(av.pop(), Some(13));\n  assert_eq!(av.len(), 3);\n  assert_eq!(av.pop(), Some(12));\n  assert_eq!(av.len(), 2);\n  assert_eq!(av.pop(), Some(11));\n  assert_eq!(av.len(), 1);\n  assert_eq!(av.pop(), Some(10));\n  assert_eq!(av.len(), 0);\n  assert_eq!(av.pop(), None);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec.rs::len", "code": "pub fn len(&self) -> usize {\n    self.len as usize\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_iteration", "test": "fn ArrayVec_iteration() {\n  let av = array_vec!([i32; 4] => 10, 11, 12, 13);\n\n  let mut i = av.into_iter();\n  assert_eq!(i.next(), Some(10));\n  assert_eq!(i.next(), Some(11));\n  assert_eq!(i.next(), Some(12));\n  assert_eq!(i.next(), Some(13));\n  assert_eq!(i.next(), None);\n\n  let av = array_vec!([i32; 4] => 10, 11, 12, 13);\n\n  let mut av2: ArrayVec<[i32; 4]> = av.clone().into_iter().collect();\n  assert_eq!(av, av2);\n\n  // IntoIterator for &mut ArrayVec\n  for x in &mut av2 {\n    *x = -*x;\n  }\n\n  // IntoIterator for &ArrayVec\n  assert!(av.iter().zip(&av2).all(|(&a, &b)| a == -b));\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec_drain.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n    self.iter.next().map(take)\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_append", "test": "fn ArrayVec_append() {\n  let mut av = array_vec!([i32; 8] => 1, 2, 3);\n  let mut av2 = array_vec!([i32; 8] => 4, 5, 6);\n  //\n  av.append(&mut av2);\n  assert_eq!(av.as_slice(), &[1_i32, 2, 3, 4, 5, 6]);\n  assert_eq!(av2.as_slice(), &[]);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec.rs::as_slice", "code": "pub fn as_slice(&self) -> &[A::Item] {\n    self.deref()\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_remove", "test": "fn ArrayVec_remove() {\n  let mut av: ArrayVec<[i32; 10]> = Default::default();\n  av.push(1);\n  av.push(2);\n  av.push(3);\n  assert_eq!(av.remove(1), 2);\n  assert_eq!(&av[..], &[1, 3][..]);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec.rs::remove", "code": "pub fn remove(&mut self, index: usize) -> A::Item {\n    let targets: &mut [A::Item] = &mut self.deref_mut()[index..];\n    let item = take(&mut targets[0]);\n\n    // A previous implementation used rotate_left\n    // rotate_right and rotate_left generate a huge amount of code and fail to\n    // inline; calling them here incurs the cost of all the cases they\n    // handle even though we're rotating a usually-small array by a constant\n    // 1 offset. This swap-based implementation benchmarks much better for\n    // small array lengths in particular.\n\n    for i in 0..targets.len() - 1 {\n      targets.swap(i, i + 1);\n    }\n    self.len -= 1;\n    item\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::ArrayVec_swap_remove", "test": "fn ArrayVec_swap_remove() {\n  let mut av: ArrayVec<[i32; 10]> = Default::default();\n  av.push(1);\n  av.push(2);\n  av.push(3);\n  av.push(4);\n  assert_eq!(av.swap_remove(3), 4);\n  assert_eq!(&av[..], &[1, 2, 3][..]);\n  assert_eq!(av.swap_remove(0), 1);\n  assert_eq!(&av[..], &[3, 2][..]);\n  assert_eq!(av.swap_remove(0), 3);\n  assert_eq!(&av[..], &[2][..]);\n  assert_eq!(av.swap_remove(0), 2);\n  assert_eq!(&av[..], &[][..]);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec.rs::swap_remove", "code": "pub fn swap_remove(&mut self, index: usize) -> A::Item {\n    assert!(\n      index < self.len(),\n      \"ArrayVec::swap_remove> index {} is out of bounds {}\",\n      index,\n      self.len\n    );\n    if index == self.len() - 1 {\n      self.pop().unwrap()\n    } else {\n      let i = self.pop().unwrap();\n      replace(&mut self[index], i)\n    }\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/arrayvec.rs::iter_last_nth", "test": "fn iter_last_nth() {\n  let mut av: ArrayVec<[i32; 10]> = Default::default();\n  av.push(1);\n  av.push(2);\n  av.push(3);\n  av.push(4);\n  assert_eq!(av.len(), 4);\n  let mut iter = av.into_iter();\n  assert_eq!(iter.next(), Some(1));\n  assert_eq!(iter.next(), Some(2));\n  assert_eq!(iter.next(), Some(3));\n  assert_eq!(iter.next(), Some(4));\n  assert_eq!(iter.next(), None);\n  assert_eq!(iter.last(), None);\n\n  let mut av: ArrayVec<[i32; 10]> = Default::default();\n  av.push(1);\n  av.push(2);\n  av.push(3);\n\n  assert_eq!(av.into_iter().nth(0), Some(1));\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec.rs::len", "code": "pub fn len(&self) -> usize {\n    self.len as usize\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_swap_remove", "test": "fn TinyVec_swap_remove() {\n  let mut tv: TinyVec<[i32; 10]> = Default::default();\n  tv.push(1);\n  tv.push(2);\n  tv.push(3);\n  tv.push(4);\n  assert_eq!(tv.swap_remove(3), 4);\n  assert_eq!(&tv[..], &[1, 2, 3][..]);\n  assert_eq!(tv.swap_remove(0), 1);\n  assert_eq!(&tv[..], &[3, 2][..]);\n  assert_eq!(tv.swap_remove(0), 3);\n  assert_eq!(&tv[..], &[2][..]);\n  assert_eq!(tv.swap_remove(0), 2);\n  assert_eq!(&tv[..], &[][..]);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec.rs::swap_remove", "code": "pub fn swap_remove(&mut self, index: usize) -> A::Item {\n    assert!(\n      index < self.len(),\n      \"ArrayVec::swap_remove> index {} is out of bounds {}\",\n      index,\n      self.len\n    );\n    if index == self.len() - 1 {\n      self.pop().unwrap()\n    } else {\n      let i = self.pop().unwrap();\n      replace(&mut self[index], i)\n    }\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_capacity", "test": "fn TinyVec_capacity() {\n  let mut tv: TinyVec<[i32; 1]> = Default::default();\n  assert_eq!(tv.capacity(), 1);\n  tv.move_to_the_heap();\n  tv.extend_from_slice(&[1, 2, 3, 4]);\n  assert_eq!(tv.capacity(), 4);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec.rs::capacity", "code": "pub fn capacity(&self) -> usize {\n    // Note: This shouldn't use A::CAPACITY, because unsafe code can't rely on\n    // any Array invariants. This ensures that at the very least, the returned\n    // value is a valid length for a subslice of the backing array.\n    self.data.as_slice().len()\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_reserve", "test": "fn TinyVec_reserve() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert_eq!(tv.capacity(), 4);\n  tv.extend_from_slice(&[1, 2]);\n  assert_eq!(tv.capacity(), 4);\n  tv.reserve(2);\n  assert_eq!(tv.capacity(), 4);\n  tv.reserve(4);\n  assert!(tv.capacity() >= 6);\n  tv.extend_from_slice(&[3, 4, 5, 6]);\n  tv.reserve(4);\n  assert!(tv.capacity() >= 10);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec.rs::capacity", "code": "pub fn capacity(&self) -> usize {\n    // Note: This shouldn't use A::CAPACITY, because unsafe code can't rely on\n    // any Array invariants. This ensures that at the very least, the returned\n    // value is a valid length for a subslice of the backing array.\n    self.data.as_slice().len()\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_try_reserve", "test": "fn TinyVec_try_reserve() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert_eq!(tv.capacity(), 4);\n  tv.extend_from_slice(&[1, 2]);\n  assert_eq!(tv.capacity(), 4);\n  assert!(tv.try_reserve(2).is_ok());\n  assert_eq!(tv.capacity(), 4);\n  assert!(tv.try_reserve(4).is_ok());\n  assert!(tv.capacity() >= 6);\n  tv.extend_from_slice(&[3, 4, 5, 6]);\n  assert!(tv.try_reserve(4).is_ok());\n  assert!(tv.capacity() >= 10);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec.rs::capacity", "code": "pub fn capacity(&self) -> usize {\n    // Note: This shouldn't use A::CAPACITY, because unsafe code can't rely on\n    // any Array invariants. This ensures that at the very least, the returned\n    // value is a valid length for a subslice of the backing array.\n    self.data.as_slice().len()\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_reserve_exact", "test": "fn TinyVec_reserve_exact() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert_eq!(tv.capacity(), 4);\n\n  tv.extend_from_slice(&[1, 2]);\n  assert_eq!(tv.capacity(), 4);\n  tv.reserve_exact(2);\n  assert_eq!(tv.capacity(), 4);\n  tv.reserve_exact(4);\n  assert!(tv.capacity() >= 6);\n  tv.extend_from_slice(&[3, 4, 5, 6]);\n  tv.reserve_exact(4);\n  assert!(tv.capacity() >= 10);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec.rs::capacity", "code": "pub fn capacity(&self) -> usize {\n    // Note: This shouldn't use A::CAPACITY, because unsafe code can't rely on\n    // any Array invariants. This ensures that at the very least, the returned\n    // value is a valid length for a subslice of the backing array.\n    self.data.as_slice().len()\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_try_reserve_exact", "test": "fn TinyVec_try_reserve_exact() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert_eq!(tv.capacity(), 4);\n\n  tv.extend_from_slice(&[1, 2]);\n  assert_eq!(tv.capacity(), 4);\n  assert!(tv.try_reserve_exact(2).is_ok());\n  assert_eq!(tv.capacity(), 4);\n  assert!(tv.try_reserve_exact(4).is_ok());\n  assert!(tv.capacity() >= 6);\n  tv.extend_from_slice(&[3, 4, 5, 6]);\n  assert!(tv.try_reserve_exact(4).is_ok());\n  assert!(tv.capacity() >= 10);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/arrayvec.rs::capacity", "code": "pub fn capacity(&self) -> usize {\n    // Note: This shouldn't use A::CAPACITY, because unsafe code can't rely on\n    // any Array invariants. This ensures that at the very least, the returned\n    // value is a valid length for a subslice of the backing array.\n    self.data.as_slice().len()\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_move_to_heap_and_shrink", "test": "fn TinyVec_move_to_heap_and_shrink() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert!(tv.is_inline());\n  tv.move_to_the_heap();\n  assert!(tv.is_heap());\n  assert_eq!(tv.capacity(), 0);\n\n  tv.push(1);\n  tv.shrink_to_fit();\n  assert!(tv.is_inline());\n  assert_eq!(tv.capacity(), 4);\n\n  tv.move_to_the_heap_and_reserve(3);\n  assert!(tv.is_heap());\n  assert_eq!(tv.capacity(), 4);\n  tv.extend(2..=4);\n  assert_eq!(tv.capacity(), 4);\n  assert_eq!(tv.as_slice(), [1, 2, 3, 4]);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/tinyvec.rs::is_inline", "code": "pub fn is_inline(&self) -> bool {\n    !self.is_heap()\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_try_move_to_heap_and_shrink", "test": "fn TinyVec_try_move_to_heap_and_shrink() {\n  let mut tv: TinyVec<[i32; 4]> = Default::default();\n  assert!(tv.is_inline());\n  assert!(tv.try_move_to_the_heap().is_ok());\n  assert!(tv.is_heap());\n  assert_eq!(tv.capacity(), 0);\n\n  assert!(tv.try_reserve_exact(1).is_ok());\n  assert_eq!(tv.capacity(), 1);\n  tv.push(1);\n  tv.shrink_to_fit();\n  assert!(tv.is_inline());\n  assert_eq!(tv.capacity(), 4);\n\n  assert!(tv.try_move_to_the_heap_and_reserve(3).is_ok());\n  assert!(tv.is_heap());\n  assert_eq!(tv.capacity(), 4);\n  tv.extend(2..=4);\n  assert_eq!(tv.capacity(), 4);\n  assert_eq!(tv.as_slice(), [1, 2, 3, 4]);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/tinyvec.rs::is_inline", "code": "pub fn is_inline(&self) -> bool {\n    !self.is_heap()\n  }", "docstring": null}
{"test_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/tests/tinyvec.rs::TinyVec_std_io_write", "test": "fn TinyVec_std_io_write() {\n  use std::io::Write;\n  let mut tv: TinyVec<[u8; 3]> = TinyVec::new();\n\n  tv.write_all(b\"foo\").ok();\n  assert!(tv.is_inline());\n  assert_eq!(tv, tiny_vec![b'f', b'o', b'o']);\n\n  tv.write_all(b\"bar\").ok();\n  assert!(tv.is_heap());\n  assert_eq!(tv, tiny_vec![b'f', b'o', b'o', b'b', b'a', b'r']);\n}", "code_id": "Lokathor-tinyvec/Lokathor-tinyvec-6e1bbaf/src/tinyvec.rs::is_inline", "code": "pub fn is_inline(&self) -> bool {\n    !self.is_heap()\n  }", "docstring": null}
