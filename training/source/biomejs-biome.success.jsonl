{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/cases/config_extends.rs::extends_config_ok_formatter_no_linter", "test": "fn extends_config_ok_formatter_no_linter() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = Path::new(\"biome.json\");\n    fs.insert(\n        rome_json.into(),\n        r#\"{ \"extends\": [\"format.json\", \"linter.json\"] }\"#,\n    );\n    let format = Path::new(\"format.json\");\n    fs.insert(\n        format.into(),\n        r#\"{ \"javascript\": { \"formatter\": { \"quoteStyle\": \"single\" } } }\"#,\n    );\n    let lint = Path::new(\"linter.json\");\n    fs.insert(lint.into(), r#\"{ \"linter\": { \"enabled\": false } }\"#);\n\n    let test_file = Path::new(\"test.js\");\n    fs.insert(test_file.into(), r#\"debugger; console.log(\"string\"); \"#);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), test_file.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"extends_config_ok_formatter_no_linter\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/cases/config_extends.rs::extends_config_ok_linter_not_formatter", "test": "fn extends_config_ok_linter_not_formatter() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = Path::new(\"biome.json\");\n    fs.insert(\n        rome_json.into(),\n        r#\"{ \"extends\": [\"format.json\", \"linter.json\"] }\"#,\n    );\n    let format = Path::new(\"format.json\");\n    fs.insert(format.into(), r#\"{ \"formatter\": { \"enabled\": true } }\"#);\n    let lint = Path::new(\"linter.json\");\n    fs.insert(\n        lint.into(),\n        r#\"{\n  \"linter\": {\n    \"rules\": {\n      \"all\": false,\n      \"suspicious\": {\n        \"noDebugger\": \"warn\"\n      }\n    }\n  }\n}\n        \"#,\n    );\n\n    let test_file = Path::new(\"test.js\");\n    fs.insert(test_file.into(), r#\"debugger; console.log(\"string\"); \"#);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), test_file.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"extends_config_ok_linter_not_formatter\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/cases/config_extends.rs::extends_should_raise_an_error_for_unresolved_configuration", "test": "fn extends_should_raise_an_error_for_unresolved_configuration() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = Path::new(\"biome.json\");\n    fs.insert(\n        rome_json.into(),\n        r#\"{ \"extends\": [\"formatTYPO.json\", \"linter.json\"] }\"#,\n    );\n    let format = Path::new(\"format.json\");\n    fs.insert(\n        format.into(),\n        r#\"{ \"javascript\": { \"formatter\": { \"quoteStyle\": \"single\" } } }\"#,\n    );\n    let lint = Path::new(\"linter.json\");\n    fs.insert(lint.into(), r#\"{ \"linter\": { \"enabled\": false } }\"#);\n\n    let test_file = Path::new(\"test.js\");\n    fs.insert(test_file.into(), r#\"debugger; console.log(\"string\"); \"#);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), test_file.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"extends_should_raise_an_error_for_unresolved_configuration\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/cases/config_extends.rs::extends_should_raise_an_error_for_unresolved_configuration_and_show_verbose", "test": "fn extends_should_raise_an_error_for_unresolved_configuration_and_show_verbose() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = Path::new(\"biome.json\");\n    fs.insert(\n        rome_json.into(),\n        r#\"{ \"extends\": [\"formatTYPO.json\", \"linter.json\"] }\"#,\n    );\n    let format = Path::new(\"format.json\");\n    fs.insert(\n        format.into(),\n        r#\"{ \"javascript\": { \"formatter\": { \"quoteStyle\": \"single\" } } }\"#,\n    );\n    let lint = Path::new(\"linter.json\");\n    fs.insert(lint.into(), r#\"{ \"linter\": { \"enabled\": false } }\"#);\n\n    let test_file = Path::new(\"test.js\");\n    fs.insert(test_file.into(), r#\"debugger; console.log(\"string\"); \"#);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"check\"),\n                \"--verbose\",\n                test_file.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"extends_should_raise_an_error_for_unresolved_configuration_and_show_verbose\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/cases/config_extends.rs::extends_resolves_when_using_config_path", "test": "fn extends_resolves_when_using_config_path() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = Path::new(\"config/biome.json\");\n    fs.insert(\n        rome_json.into(),\n        r#\"{ \"extends\": [\"format.json\", \"linter.json\"] }\"#,\n    );\n    let format = Path::new(\"config/format.json\");\n    fs.insert(\n        format.into(),\n        r#\"{ \"javascript\": { \"formatter\": { \"quoteStyle\": \"single\" } } }\"#,\n    );\n    let lint = Path::new(\"config/linter.json\");\n    fs.insert(lint.into(), r#\"{ \"linter\": { \"enabled\": true } }\"#);\n\n    let test_file = Path::new(\"test.js\");\n    fs.insert(test_file.into(), r#\"debugger; console.log(\"string\"); \"#);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"check\"),\n                \"--config-path=config/\",\n                test_file.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"extends_resolves_when_using_config_path\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::parse_error", "test": "fn parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), PARSE_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::lint_error", "test": "fn lint_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), LINT_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"lint_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::maximum_diagnostics", "test": "fn maximum_diagnostics() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), ERRORS.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let messages = &console.out_buffer;\n\n    assert_eq!(\n        messages\n            .iter()\n            .filter(|m| m.level == LogLevel::Error)\n            .count(),\n        20_usize\n    );\n\n    assert!(messages\n        .iter()\n        .filter(|m| m.level == LogLevel::Log)\n        .any(|m| {\n            let content = format!(\"{:?}\", m.content);\n            content.contains(\"The number of diagnostics exceeds the number allowed by Biome\")\n                && content.contains(\"Diagnostics not shown\")\n                && content.contains(\"79\")\n        }));\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"maximum_diagnostics\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::apply_suggested_error", "test": "fn apply_suggested_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"fix.js\");\n    fs.insert(file_path.into(), APPLY_SUGGESTED_BEFORE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"check\"),\n                (\"--apply-unsafe\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"apply_suggested_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::apply_unsafe_with_error", "test": "fn apply_unsafe_with_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    // last line doesn't have code fix\n    let source = \"let a = 4;\ndebugger;\nconsole.log(a);\nfunction f() { arguments; }\n\";\n\n    let expected = \"const a = 4;\nconsole.log(a);\nfunction f() {\\n\\targuments;\\n}\n\";\n\n    let test1 = Path::new(\"test1.js\");\n    fs.insert(test1.into(), source.as_bytes());\n\n    let test2 = Path::new(\"test2.js\");\n    fs.insert(test2.into(), source.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"check\"),\n                (\"--apply-unsafe\"),\n                test1.as_os_str().to_str().unwrap(),\n                test2.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(test1)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, expected);\n    drop(file);\n\n    content.clear();\n\n    let mut file = fs\n        .open(test2)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    drop(file);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"apply_unsafe_with_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::no_lint_if_linter_is_disabled", "test": "fn no_lint_if_linter_is_disabled() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"fix.js\");\n    fs.insert(file_path.into(), FIX_BEFORE.as_bytes());\n\n    let config_path = Path::new(\"biome.json\");\n    fs.insert(config_path.into(), CONFIG_LINTER_DISABLED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, FIX_BEFORE);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"no_lint_if_linter_is_disabled\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::downgrade_severity", "test": "fn downgrade_severity() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(\n        file_path.into(),\n        CONFIG_LINTER_DOWNGRADE_DIAGNOSTIC.as_bytes(),\n    );\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), NO_DEBUGGER.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let messages = &console.out_buffer;\n\n    assert_eq!(\n        messages\n            .iter()\n            .filter(|m| m.level == LogLevel::Error)\n            .filter(|m| {\n                let content = format!(\"{:#?}\", m.content);\n                content.contains(\"suspicious/noDebugger\")\n            })\n            .count(),\n        1\n    );\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"downgrade_severity\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::upgrade_severity", "test": "fn upgrade_severity() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(\n        file_path.into(),\n        CONFIG_LINTER_UPGRADE_DIAGNOSTIC.as_bytes(),\n    );\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), UPGRADE_SEVERITY_CODE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let messages = &console.out_buffer;\n\n    let error_count = messages\n        .iter()\n        .filter(|m| m.level == LogLevel::Error)\n        .filter(|m| {\n            let content = format!(\"{:?}\", m.content);\n            content.contains(\"style/noNegationElse\")\n        })\n        .count();\n\n    assert_eq!(\n        error_count, 1,\n        \"expected 1 error-level message in console buffer, found {error_count:?}:\\n{:?}\",\n        console.out_buffer\n    );\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"upgrade_severity\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::fs_error_dereferenced_symlink", "test": "fn fs_error_dereferenced_symlink() {\n    let fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let root_path = temp_dir().join(\"check_rome_test_broken_symlink\");\n    let subdir_path = root_path.join(\"prefix\");\n\n    let _ = remove_dir_all(&root_path);\n    create_dir_all(subdir_path).unwrap();\n\n    #[cfg(target_family = \"unix\")]\n    {\n        symlink(root_path.join(\"null\"), root_path.join(\"broken_symlink\")).unwrap();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        check_windows_symlink!(symlink_file(\n            root_path.join(\"null\"),\n            root_path.join(\"broken_symlink\")\n        ));\n    }\n\n    let result = run_cli(\n        DynRef::Owned(Box::new(OsFileSystem)),\n        &mut console,\n        Args::from([(\"check\"), root_path.display().to_string().as_str()].as_slice()),\n    );\n\n    remove_dir_all(root_path).unwrap();\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_dereferenced_symlink\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::fs_error_infinite_symlink_expansion_to_dirs", "test": "fn fs_error_infinite_symlink_expansion_to_dirs() {\n    let fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let root_path = temp_dir().join(\"check_rome_test_infinite_symlink_expansion_to_dirs\");\n    let subdir1_path = root_path.join(\"prefix\");\n    let subdir2_path = root_path.join(\"foo\").join(\"bar\");\n\n    let _ = remove_dir_all(&root_path);\n    create_dir_all(&subdir1_path).unwrap();\n    create_dir_all(&subdir2_path).unwrap();\n\n    #[cfg(target_family = \"unix\")]\n    {\n        symlink(&subdir2_path, subdir1_path.join(\"symlink1\")).unwrap();\n        symlink(subdir1_path, subdir2_path.join(\"symlink2\")).unwrap();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        check_windows_symlink!(symlink_dir(&subdir2_path, &subdir1_path.join(\"symlink1\")));\n        check_windows_symlink!(symlink_dir(subdir1_path, subdir2_path.join(\"symlink2\")));\n    }\n\n    let result = run_cli(\n        DynRef::Owned(Box::new(OsFileSystem)),\n        &mut console,\n        Args::from([(\"check\"), (root_path.display().to_string().as_str())].as_slice()),\n    );\n\n    remove_dir_all(root_path).unwrap();\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_infinite_symlink_expansion_to_dirs\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::fs_error_infinite_symlink_expansion_to_files", "test": "fn fs_error_infinite_symlink_expansion_to_files() {\n    let mut console = BufferConsole::default();\n\n    let root_path = temp_dir().join(\"check_rome_test_infinite_symlink_expansion_to_files\");\n    let subdir1_path = root_path.join(\"prefix\");\n    let subdir2_path = root_path.join(\"foo\").join(\"bar\");\n\n    let _ = remove_dir_all(&root_path);\n    create_dir_all(&subdir1_path).unwrap();\n    create_dir_all(&subdir2_path).unwrap();\n\n    let symlink1_path = subdir1_path.join(\"symlink1\");\n    let symlink2_path = subdir2_path.join(\"symlink2\");\n\n    #[cfg(target_family = \"unix\")]\n    {\n        symlink(&symlink2_path, &symlink1_path).unwrap();\n        symlink(&symlink1_path, &symlink2_path).unwrap();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        check_windows_symlink!(symlink_dir(&symlink2_path, &symlink1_path));\n        check_windows_symlink!(symlink_dir(&symlink1_path, &symlink2_path));\n    }\n\n    let result = run_cli(\n        DynRef::Owned(Box::new(OsFileSystem)),\n        &mut console,\n        Args::from([(\"check\"), (root_path.display().to_string().as_str())].as_slice()),\n    );\n\n    remove_dir_all(root_path).unwrap();\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Don't use a snapshot here, since the diagnostics can be reported in\n    // arbitrary order:\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(\"Deeply nested symlink expansion\")));\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(&symlink1_path.display().to_string())));\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(&symlink2_path.display().to_string())));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::fs_error_read_only", "test": "fn fs_error_read_only() {\n    let mut fs = MemoryFileSystem::new_read_only();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"test.js\");\n    fs.insert(file_path.into(), *b\"content\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"check\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Do not store the content of the file in the snapshot\n    fs.remove(file_path);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_read_only\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/check.rs::fs_error_unknown", "test": "fn fs_error_unknown() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    fs.insert_error(PathBuf::from(\"prefix/ci.js\"), ErrorEntry::UnknownFileType);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"check\"), (\"prefix\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_unknown\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::formatting_error", "test": "fn formatting_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), UNFORMATTED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"formatting_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_parse_error", "test": "fn ci_parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), PARSE_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_lint_error", "test": "fn ci_lint_error() {\n    let mut fs = MemoryFileSystem::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), LINT_ERROR.as_bytes());\n\n    let mut console = BufferConsole::default();\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_lint_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_does_not_run_linter", "test": "fn ci_does_not_run_linter() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    fs.insert(\n        PathBuf::from(\"biome.json\"),\n        CONFIG_LINTER_DISABLED.as_bytes(),\n    );\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), CUSTOM_FORMAT_BEFORE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, CUSTOM_FORMAT_BEFORE);\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_does_not_run_linter\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_does_not_run_linter_via_cli", "test": "fn ci_does_not_run_linter_via_cli() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), UNFORMATTED_AND_INCORRECT.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--linter-enabled=false\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, UNFORMATTED_AND_INCORRECT);\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_does_not_run_linter_via_cli\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_errors_for_all_disabled_checks", "test": "fn ci_errors_for_all_disabled_checks() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), CI_CONFIGURATION.as_bytes());\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), UNFORMATTED_AND_INCORRECT.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--linter-enabled=false\"),\n                (\"--formatter-enabled=false\"),\n                (\"--organize-imports-enabled=false\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, UNFORMATTED_AND_INCORRECT);\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_errors_for_all_disabled_checks\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::file_too_large", "test": "fn file_too_large() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), \"statement();\\n\".repeat(80660).as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Do not store the content of the file in the snapshot\n    fs.remove(file_path);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::file_too_large_config_limit", "test": "fn file_too_large_config_limit() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    fs.insert(PathBuf::from(\"biome.json\"), CONFIG_FILE_SIZE_LIMIT);\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large_config_limit\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::file_too_large_cli_limit", "test": "fn file_too_large_cli_limit() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--files-max-size=16\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large_cli_limit\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::files_max_size_parse_error", "test": "fn files_max_size_parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--files-max-size=-1\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"files_max_size_parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_runs_linter_not_formatter_issue_3495", "test": "fn ci_runs_linter_not_formatter_issue_3495() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), CONFIG_DISABLED_FORMATTER.as_bytes());\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), INCORRECT_CODE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"ci target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_runs_linter_not_formatter_issue_3495\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::max_diagnostics_default", "test": "fn max_diagnostics_default() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    for i in 0..60 {\n        let file_path = PathBuf::from(format!(\"src/file_{i}.js\"));\n        fs.insert(file_path, UNFORMATTED.as_bytes());\n    }\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), (\"src\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut diagnostic_count = 0;\n    let mut filtered_messages = Vec::new();\n\n    for msg in console.out_buffer {\n        let MarkupBuf(nodes) = &msg.content;\n        let is_diagnostic = nodes.iter().any(|node| {\n            node.content\n                .contains(\"File content differs from formatting output\")\n                || node.content.contains(\"format\")\n                || node.content.contains(\"lint\")\n                || node.content.contains(\"ci\")\n        });\n\n        if is_diagnostic {\n            diagnostic_count += 1;\n        } else {\n            filtered_messages.push(msg);\n        }\n    }\n\n    console.out_buffer = filtered_messages;\n\n    for i in 0..60 {\n        let file_path = format!(\"src/file_{i}.js\");\n        fs.remove(Path::new(&file_path));\n    }\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"max_diagnostics_default\",\n        fs,\n        console,\n        result,\n    ));\n\n    assert_eq!(diagnostic_count, 20);\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::max_diagnostics", "test": "fn max_diagnostics() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    for i in 0..60 {\n        let file_path = PathBuf::from(format!(\"src/file_{i}.js\"));\n        fs.insert(file_path, UNFORMATTED.as_bytes());\n    }\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), (\"--max-diagnostics\"), (\"10\"), (\"src\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut diagnostic_count = 0;\n    let mut filtered_messages = Vec::new();\n\n    for msg in console.out_buffer {\n        let MarkupBuf(nodes) = &msg.content;\n        let is_diagnostic = nodes.iter().any(|node| {\n            node.content\n                .contains(\"File content differs from formatting output\")\n                || node.content.contains(\"format\")\n                || node.content.contains(\"ci\")\n        });\n\n        if is_diagnostic {\n            diagnostic_count += 1;\n        } else {\n            filtered_messages.push(msg);\n        }\n    }\n\n    console.out_buffer = filtered_messages;\n\n    for i in 0..60 {\n        let file_path = format!(\"src/file_{i}.js\");\n        fs.remove(Path::new(&file_path));\n    }\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"max_diagnostics\",\n        fs,\n        console,\n        result,\n    ));\n\n    assert_eq!(diagnostic_count, 10);\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::print_verbose", "test": "fn print_verbose() {\n    let mut fs = MemoryFileSystem::default();\n\n    let file_path = Path::new(\"ci.js\");\n    fs.insert(file_path.into(), LINT_ERROR.as_bytes());\n\n    let mut console = BufferConsole::default();\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--verbose\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"print_verbose\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ci_formatter_linter_organize_imports", "test": "fn ci_formatter_linter_organize_imports() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = r#\"{\n    \"linter\": {\n        \"enabled\": true,\n        \"rules\": {\n            \"recommended\": true\n        }\n    },\n    \"organizeImports\": {\n        \"enabled\": true\n    }\n}\"#;\n\n    let input = r#\"\nimport { B, C } from \"b.js\"\nimport A from \"a.js\"\n\n\nsomething( )\n    \"#;\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), rome_json.as_bytes());\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), input.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"ci\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"ci target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ci_formatter_linter_organize_imports\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ignore_vcs_ignored_file", "test": "fn ignore_vcs_ignored_file() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let rome_json = r#\"{\n        \"vcs\": {\n            \"enabled\": true,\n            \"clientKind\": \"git\",\n            \"useIgnoreFile\": true\n        }\n    }\"#;\n\n    let git_ignore = r#\"\nfile2.js\n\"#;\n\n    let code2 = r#\"foo.call(); bar.call();\"#;\n    let code1 = r#\"array.map(sentence => sentence.split(' ')).flat();\"#;\n\n    // ignored files\n    let file_path1 = Path::new(\"file1.js\");\n    fs.insert(file_path1.into(), code1.as_bytes());\n    let file_path2 = Path::new(\"file2.js\");\n    fs.insert(file_path2.into(), code2.as_bytes());\n\n    // configuration\n    let config_path = Path::new(\"biome.json\");\n    fs.insert(config_path.into(), rome_json.as_bytes());\n\n    // git ignore file\n    let ignore_file = Path::new(\".gitignore\");\n    fs.insert(ignore_file.into(), git_ignore.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                file_path1.as_os_str().to_str().unwrap(),\n                file_path2.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ignore_vcs_ignored_file\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::ignore_vcs_ignored_file_via_cli", "test": "fn ignore_vcs_ignored_file_via_cli() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let git_ignore = r#\"\nfile2.js\n\"#;\n\n    let code2 = r#\"foo.call();\n\n\n    bar.call();\"#;\n    let code1 = r#\"array.map(sentence => sentence.split(' ')).flat();\"#;\n\n    // ignored files\n    let file_path1 = Path::new(\"file1.js\");\n    fs.insert(file_path1.into(), code1.as_bytes());\n    let file_path2 = Path::new(\"file2.js\");\n    fs.insert(file_path2.into(), code2.as_bytes());\n\n    // git folder\n    let git_folder = Path::new(\"./.git\");\n    fs.insert(git_folder.into(), \"\".as_bytes());\n\n    // git ignore file\n    let ignore_file = Path::new(\"./.gitignore\");\n    fs.insert(ignore_file.into(), git_ignore.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"ci\"),\n                (\"--vcs-enabled=true\"),\n                (\"--vcs-client-kind=git\"),\n                (\"--vcs-use-ignore-file=true\"),\n                (\"--vcs-root=.\"),\n                file_path1.as_os_str().to_str().unwrap(),\n                file_path2.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"ignore_vcs_ignored_file_via_cli\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/ci.rs::does_error_with_only_warnings", "test": "fn does_error_with_only_warnings() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(\n        file_path.into(),\n        r#\"\n{\n    \"formatter\": { \"enabled\": false},\n  \"linter\": {\n    \"rules\": {\n        \"recommended\": true,\n        \"suspicious\": {\n            \"noClassAssign\": \"warn\"\n        }\n    }\n  }\n}\n        \"#\n        .as_bytes(),\n    );\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(\n        file_path.into(),\n        r#\"class A {};\nA = 0;\n\"#\n        .as_bytes(),\n    );\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                \"ci\",\n                \"--error-on-warnings\",\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"does_error_with_only_warnings\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::trailing_comma_parse_errors", "test": "fn trailing_comma_parse_errors() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--trailing-comma\"), (\"NONE\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"trailing_comma_parse_errors\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::with_invalid_semicolons_option", "test": "fn with_invalid_semicolons_option() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--semicolons\"), (\"asneed\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"with_invalid_semicolons_option\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::indent_style_parse_errors", "test": "fn indent_style_parse_errors() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--indent-style\"), (\"invalid\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"indent_style_parse_errors\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::indent_size_parse_errors_negative", "test": "fn indent_size_parse_errors_negative() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--indent-size=-1\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"indent_size_parse_errors_negative\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::indent_size_parse_errors_overflow", "test": "fn indent_size_parse_errors_overflow() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--indent-size=257\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"indent_size_parse_errors_overflow\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::line_width_parse_errors_negative", "test": "fn line_width_parse_errors_negative() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([\"format\", \"--line-width=-1\", \"file.js\"].as_slice()),\n    );\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"line_width_parse_errors_negative\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::line_width_parse_errors_overflow", "test": "fn line_width_parse_errors_overflow() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--line-width\"), (\"321\"), (\"file.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"line_width_parse_errors_overflow\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::quote_properties_parse_errors_letter_case", "test": "fn quote_properties_parse_errors_letter_case() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                (\"--quote-properties\"),\n                (\"As-needed\"),\n                (\"file.js\"),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"quote_properties_parse_errors_letter_case\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::format_is_disabled", "test": "fn format_is_disabled() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), CONFIG_DISABLED_FORMATTER.as_bytes());\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), CUSTOM_FORMAT_BEFORE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"file.js\"), (\"--write\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, CUSTOM_FORMAT_BEFORE);\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"format_is_disabled\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::format_stdin_with_errors", "test": "fn format_stdin_with_errors() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"--stdin-file-path\"), (\"mock.js\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"format_stdin_with_errors\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::does_not_format_ignored_files", "test": "fn does_not_format_ignored_files() {\n    let mut console = BufferConsole::default();\n    let mut fs = MemoryFileSystem::default();\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), CONFIG_FORMATTER_IGNORED_FILES.as_bytes());\n\n    let file_path = Path::new(\"test.js\");\n    fs.insert(file_path.into(), UNFORMATTED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), (\"test.js\"), (\"--write\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(file_path)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, UNFORMATTED);\n\n    drop(file);\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"does_not_format_ignored_files\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::does_not_format_if_files_are_listed_in_ignore_option", "test": "fn does_not_format_if_files_are_listed_in_ignore_option() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(\n        file_path.into(),\n        CONFIG_FORMATTER_AND_FILES_IGNORE.as_bytes(),\n    );\n\n    let file_path_test1 = Path::new(\"test1.js\");\n    fs.insert(file_path_test1.into(), UNFORMATTED.as_bytes());\n\n    let file_path_test2 = Path::new(\"test2.js\");\n    fs.insert(file_path_test2.into(), UNFORMATTED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                file_path_test1.as_os_str().to_str().unwrap(),\n                file_path_test2.as_os_str().to_str().unwrap(),\n                (\"--write\"),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path_test1)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, UNFORMATTED);\n\n    let mut buffer = String::new();\n    fs.open(file_path_test2)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, UNFORMATTED);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"does_not_format_if_files_are_listed_in_ignore_option\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::fs_error_read_only", "test": "fn fs_error_read_only() {\n    let mut fs = MemoryFileSystem::new_read_only();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"test.js\");\n    fs.insert(file_path.into(), *b\"content\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                (\"--write\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Do not store the content of the file in the snapshot\n    fs.remove(file_path);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_read_only\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::file_too_large", "test": "fn file_too_large() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"format.js\");\n    fs.insert(file_path.into(), \"statement();\\n\".repeat(80660).as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                file_path.as_os_str().to_str().unwrap(),\n                (\"--write\"),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Do not store the content of the file in the snapshot\n    fs.remove(file_path);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::file_too_large_config_limit", "test": "fn file_too_large_config_limit() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    fs.insert(PathBuf::from(\"biome.json\"), CONFIG_FILE_SIZE_LIMIT);\n\n    let file_path = Path::new(\"format.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"format\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large_config_limit\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::file_too_large_cli_limit", "test": "fn file_too_large_cli_limit() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"format.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                (\"--files-max-size=16\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"file_too_large_cli_limit\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/format.rs::files_max_size_parse_error", "test": "fn files_max_size_parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"format.js\");\n    fs.insert(file_path.into(), \"statement1();\\nstatement2();\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"format\"),\n                (\"--files-max-size=-1\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"files_max_size_parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::parse_error", "test": "fn parse_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), PARSE_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"parse_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::lint_error", "test": "fn lint_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), LINT_ERROR.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"lint_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::maximum_diagnostics", "test": "fn maximum_diagnostics() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n    let file_path = Path::new(\"check.js\");\n    fs.insert(file_path.into(), ERRORS.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let messages = &console.out_buffer;\n\n    assert_eq!(\n        messages\n            .iter()\n            .filter(|m| m.level == LogLevel::Error)\n            .count(),\n        20_usize\n    );\n\n    assert!(messages\n        .iter()\n        .filter(|m| m.level == LogLevel::Log)\n        .any(|m| {\n            let content = format!(\"{:?}\", m.content);\n            content.contains(\"The number of diagnostics exceeds the number allowed by Biome\")\n                && content.contains(\"Diagnostics not shown\")\n                && content.contains(\"77\")\n        }));\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"maximum_diagnostics\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::apply_suggested_error", "test": "fn apply_suggested_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"fix.js\");\n    fs.insert(file_path.into(), APPLY_SUGGESTED_BEFORE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply-unsafe\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"apply_suggested_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::apply_unsafe_with_error", "test": "fn apply_unsafe_with_error() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    // last line doesn't have code fix\n    let source = \"let a = 4;\ndebugger;\nconsole.log(a);\nfunction f() { arguments; }\n\";\n\n    let expected = \"const a = 4;\nconsole.log(a);\nfunction f() { arguments; }\n\";\n\n    let test1 = Path::new(\"test1.js\");\n    fs.insert(test1.into(), source.as_bytes());\n\n    let test2 = Path::new(\"test2.js\");\n    fs.insert(test2.into(), source.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply-unsafe\"),\n                test1.as_os_str().to_str().unwrap(),\n                test2.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut file = fs\n        .open(test1)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    assert_eq!(content, expected);\n    drop(file);\n\n    content.clear();\n\n    let mut file = fs\n        .open(test2)\n        .expect(\"formatting target file was removed by the CLI\");\n\n    file.read_to_string(&mut content)\n        .expect(\"failed to read file from memory FS\");\n\n    drop(file);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"apply_unsafe_with_error\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::no_lint_if_linter_is_disabled_when_run_apply", "test": "fn no_lint_if_linter_is_disabled_when_run_apply() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"fix.js\");\n    fs.insert(file_path.into(), FIX_BEFORE.as_bytes());\n\n    let config_path = Path::new(\"biome.json\");\n    fs.insert(config_path.into(), CONFIG_LINTER_DISABLED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, FIX_BEFORE);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"no_lint_if_linter_is_disabled_when_run_apply\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::no_lint_if_linter_is_disabled", "test": "fn no_lint_if_linter_is_disabled() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"fix.js\");\n    fs.insert(file_path.into(), FIX_BEFORE.as_bytes());\n\n    let config_path = Path::new(\"biome.json\");\n    fs.insert(config_path.into(), CONFIG_LINTER_DISABLED.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, FIX_BEFORE);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"no_lint_if_linter_is_disabled\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::upgrade_severity", "test": "fn upgrade_severity() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(\n        file_path.into(),\n        CONFIG_LINTER_UPGRADE_DIAGNOSTIC.as_bytes(),\n    );\n\n    let file_path = Path::new(\"file.js\");\n    fs.insert(file_path.into(), UPGRADE_SEVERITY_CODE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), file_path.as_os_str().to_str().unwrap()].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let messages = &console.out_buffer;\n\n    let error_count = messages\n        .iter()\n        .filter(|m| m.level == LogLevel::Error)\n        .filter(|m| {\n            let content = format!(\"{:?}\", m.content);\n            content.contains(\"style/noNegationElse\")\n        })\n        .count();\n\n    assert_eq!(\n        error_count, 1,\n        \"expected 1 error-level message in console buffer, found {error_count:?}:\\n{:?}\",\n        console.out_buffer\n    );\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"upgrade_severity\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::no_lint_when_file_is_ignored", "test": "fn no_lint_when_file_is_ignored() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), CONFIG_LINTER_IGNORED_FILES.as_bytes());\n\n    let file_path = Path::new(\"test.js\");\n    fs.insert(file_path.into(), FIX_BEFORE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, FIX_BEFORE);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"no_lint_when_file_is_ignored\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::no_lint_if_files_are_listed_in_ignore_option", "test": "fn no_lint_if_files_are_listed_in_ignore_option() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"biome.json\");\n    fs.insert(file_path.into(), CONFIG_LINTER_AND_FILES_IGNORE.as_bytes());\n\n    let file_path_test1 = Path::new(\"test1.js\");\n    fs.insert(file_path_test1.into(), FIX_BEFORE.as_bytes());\n\n    let file_path_test2 = Path::new(\"test2.js\");\n    fs.insert(file_path_test2.into(), FIX_BEFORE.as_bytes());\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply\"),\n                file_path_test1.as_os_str().to_str().unwrap(),\n                file_path_test2.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    let mut buffer = String::new();\n    fs.open(file_path_test1)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, FIX_BEFORE);\n\n    let mut buffer = String::new();\n    fs.open(file_path_test2)\n        .unwrap()\n        .read_to_string(&mut buffer)\n        .unwrap();\n\n    assert_eq!(buffer, FIX_BEFORE);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"no_lint_if_files_are_listed_in_ignore_option\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::fs_error_dereferenced_symlink", "test": "fn fs_error_dereferenced_symlink() {\n    let fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let root_path = temp_dir().join(\"lint_rome_test_broken_symlink\");\n    let subdir_path = root_path.join(\"prefix\");\n\n    let _ = remove_dir_all(&root_path);\n    create_dir(&root_path).unwrap();\n    create_dir(subdir_path).unwrap();\n\n    #[cfg(target_family = \"unix\")]\n    {\n        symlink(root_path.join(\"null\"), root_path.join(\"broken_symlink\")).unwrap();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        check_windows_symlink!(symlink_file(\n            root_path.join(\"null\"),\n            root_path.join(\"broken_symlink\")\n        ));\n    }\n\n    let result = run_cli(\n        DynRef::Owned(Box::new(OsFileSystem)),\n        &mut console,\n        Args::from([(\"lint\"), root_path.display().to_string().as_str()].as_slice()),\n    );\n\n    remove_dir_all(root_path).unwrap();\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_dereferenced_symlink\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::fs_error_infinite_symlink_expansion_to_dirs", "test": "fn fs_error_infinite_symlink_expansion_to_dirs() {\n    let fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let root_path = temp_dir().join(\"lint_rome_test_infinite_symlink_expansion_to_dirs\");\n    let subdir1_path = root_path.join(\"prefix\");\n    let subdir2_path = root_path.join(\"foo\").join(\"bar\");\n\n    let _ = remove_dir_all(&root_path);\n    create_dir_all(&subdir1_path).unwrap();\n    create_dir_all(&subdir2_path).unwrap();\n\n    #[cfg(target_family = \"unix\")]\n    {\n        symlink(&subdir2_path, subdir1_path.join(\"symlink1\")).unwrap();\n        symlink(subdir1_path, subdir2_path.join(\"symlink2\")).unwrap();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        check_windows_symlink!(symlink_dir(&subdir2_path, &subdir1_path.join(\"symlink1\")));\n        check_windows_symlink!(symlink_dir(subdir1_path, subdir2_path.join(\"symlink2\")));\n    }\n\n    let result = run_cli(\n        DynRef::Owned(Box::new(OsFileSystem)),\n        &mut console,\n        Args::from([(\"lint\"), (root_path.display().to_string().as_str())].as_slice()),\n    );\n\n    remove_dir_all(root_path).unwrap();\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_infinite_symlink_expansion_to_dirs\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::fs_error_infinite_symlink_expansion_to_files", "test": "fn fs_error_infinite_symlink_expansion_to_files() {\n    let mut console = BufferConsole::default();\n\n    let root_path = temp_dir().join(\"lint_rome_test_infinite_symlink_expansion_to_files\");\n    let subdir1_path = root_path.join(\"prefix\");\n    let subdir2_path = root_path.join(\"foo\").join(\"bar\");\n\n    let _ = remove_dir_all(&root_path);\n    create_dir_all(&subdir1_path).unwrap();\n    create_dir_all(&subdir2_path).unwrap();\n\n    let symlink1_path = subdir1_path.join(\"symlink1\");\n    let symlink2_path = subdir2_path.join(\"symlink2\");\n\n    #[cfg(target_family = \"unix\")]\n    {\n        symlink(&symlink2_path, &symlink1_path).unwrap();\n        symlink(&symlink1_path, &symlink2_path).unwrap();\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        check_windows_symlink!(symlink_dir(&symlink2_path, &symlink1_path));\n        check_windows_symlink!(symlink_dir(&symlink1_path, &symlink2_path));\n    }\n\n    let result = run_cli(\n        DynRef::Owned(Box::new(OsFileSystem)),\n        &mut console,\n        Args::from([(\"lint\"), (root_path.display().to_string().as_str())].as_slice()),\n    );\n\n    remove_dir_all(root_path).unwrap();\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Don't use a snapshot here, since the diagnostics can be reported in\n    // arbitrary order:\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(\"Deeply nested symlink expansion\")));\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(&symlink1_path.display().to_string())));\n    assert!(console\n        .out_buffer\n        .iter()\n        .flat_map(|msg| msg.content.0.iter())\n        .any(|node| node.content.contains(&symlink2_path.display().to_string())));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::fs_error_read_only", "test": "fn fs_error_read_only() {\n    let mut fs = MemoryFileSystem::new_read_only();\n    let mut console = BufferConsole::default();\n\n    let file_path = Path::new(\"test.js\");\n    fs.insert(file_path.into(), *b\"content\");\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from(\n            [\n                (\"lint\"),\n                (\"--apply\"),\n                file_path.as_os_str().to_str().unwrap(),\n            ]\n            .as_slice(),\n        ),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    // Do not store the content of the file in the snapshot\n    fs.remove(file_path);\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_read_only\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/lint.rs::fs_error_unknown", "test": "fn fs_error_unknown() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    fs.insert_error(PathBuf::from(\"prefix/ci.js\"), ErrorEntry::UnknownFileType);\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"lint\"), (\"prefix\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"fs_error_unknown\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_cli/tests/commands/migrate.rs::missing_configuration_file", "test": "fn missing_configuration_file() {\n    let mut fs = MemoryFileSystem::default();\n    let mut console = BufferConsole::default();\n\n    let result = run_cli(\n        DynRef::Borrowed(&mut fs),\n        &mut console,\n        Args::from([(\"migrate\")].as_slice()),\n    );\n\n    assert!(result.is_err(), \"run_cli returned {result:?}\");\n\n    assert_cli_snapshot(SnapshotPayload::new(\n        module_path!(),\n        \"missing_configuration_file\",\n        fs,\n        console,\n        result,\n    ));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/src/configuration/linter/mod.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        if let Self::WithOptions(rule) = self {\n            rule.level == RulePlainConfiguration::Error\n        } else {\n            matches!(self, Self::Plain(RulePlainConfiguration::Error))\n        }\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_service/tests/spec_tests.rs::quick_test", "test": "fn quick_test() {\n    let source = r#\"{\n        \"javascript\": {\n            \"formatter\": {\n                \"overrides\": [\n                {}]\n            }\n        }\n    }\"#;\n    let result = deserialize_from_json_str::<Configuration>(source, JsonParserOptions::default());\n\n    dbg!(result.diagnostics());\n    assert!(!result.has_errors());\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_css_parser/src/lib.rs::has_errors", "code": "pub fn has_errors(&self) -> bool {\n        self.diagnostics\n            .iter()\n            .any(|diagnostic| diagnostic.is_error())\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_text_size/tests/main.rs::math", "test": "fn math() {\n    assert_eq!(size(10) + size(5), size(15));\n    assert_eq!(size(10) - size(5), size(5));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_text_size/tests/main.rs::size", "code": "fn size(x: u32) -> TextSize {\n    TextSize::from(x)\n}", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_text_size/tests/main.rs::checked_math", "test": "fn checked_math() {\n    assert_eq!(size(1).checked_add(size(1)), Some(size(2)));\n    assert_eq!(size(1).checked_sub(size(1)), Some(size(0)));\n    assert_eq!(size(1).checked_sub(size(2)), None);\n    assert_eq!(size(!0).checked_add(size(1)), None);\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_text_size/src/range.rs::checked_add", "code": "pub fn checked_add(self, offset: TextSize) -> Option<TextRange> {\n        Some(TextRange {\n            start: self.start.checked_add(offset)?,\n            end: self.end.checked_add(offset)?,\n        })\n    }", "docstring": null}
{"test_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_text_size/tests/main.rs::cover_offset", "test": "fn cover_offset() {\n    assert_eq!(range(1..3).cover_offset(size(0)), range(0..3));\n    assert_eq!(range(1..3).cover_offset(size(1)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(2)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(3)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(4)), range(1..4));\n}", "code_id": "biomejs-biome/biomejs-biome-af24597/crates/biome_text_size/src/range.rs::cover_offset", "code": "pub fn cover_offset(self, offset: TextSize) -> TextRange {\n        self.cover(TextRange::empty(offset))\n    }", "docstring": null}
