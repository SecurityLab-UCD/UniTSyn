{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_datetimeformat", "test": "fn test_datetimeformat() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"Europe/Vienna\");\n    env.add_global(\"DATETIME_FORMAT\", \"[hour]:[minute]\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"1687624642.5|datetimeformat(format=format)\")\n        .unwrap();\n\n    assert_eq!(\n        expr.eval(context!(format => \"short\")).unwrap().to_string(),\n        \"2023-06-24 18:37\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"medium\")).unwrap().to_string(),\n        \"Jun 24 2023 18:37\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"long\")).unwrap().to_string(),\n        \"June 24 2023 18:37:22\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"full\")).unwrap().to_string(),\n        \"Saturday, June 24 2023 18:37:22.5\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"unix\")).unwrap().to_string(),\n        \"1687624642\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"iso\")).unwrap().to_string(),\n        \"2023-06-24T18:37:22+02:00\"\n    );\n\n    let expr = env\n        .compile_expression(\"1687624642|datetimeformat(tz='Europe/Moscow')\")\n        .unwrap();\n    assert_eq!(expr.eval(()).unwrap().to_string(), \"19:37\");\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_datetimeformat_iso_negative", "test": "fn test_datetimeformat_iso_negative() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"America/Chicago\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"1687624642.5|datetimeformat(format='iso')\")\n        .unwrap();\n    assert_eq!(\n        expr.eval(()).unwrap().to_string(),\n        \"2023-06-24T11:37:22-05:00\"\n    )\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_datetimeformat_time_rs", "test": "fn test_datetimeformat_time_rs() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"Europe/Vienna\");\n    env.add_global(\"DATETIME_FORMAT\", \"[hour]:[minute]\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"d|datetimeformat(format=format)\")\n        .unwrap();\n\n    let d = time::OffsetDateTime::from_unix_timestamp(1687624642).unwrap();\n    assert_eq!(\n        expr.eval(context!(d, format => \"short\"))\n            .unwrap()\n            .to_string(),\n        \"2023-06-24 18:37\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_datetimeformat_chrono", "test": "fn test_datetimeformat_chrono() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"Europe/Vienna\");\n    env.add_global(\"DATETIME_FORMAT\", \"[hour]:[minute]\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"d|datetimeformat(format=format)\")\n        .unwrap();\n\n    let d = chrono::DateTime::parse_from_rfc3339(\"2023-06-24T16:37:00Z\").unwrap();\n    assert_eq!(\n        expr.eval(context!(d, format => \"short\"))\n            .unwrap()\n            .to_string(),\n        \"2023-06-24 18:37\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_dateformat", "test": "fn test_dateformat() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"Europe/Vienna\");\n    env.add_global(\"DATE_FORMAT\", \"[year]-[month]\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"1687624642.5|dateformat(format=format)\")\n        .unwrap();\n\n    assert_eq!(\n        expr.eval(context!(format => \"short\")).unwrap().to_string(),\n        \"2023-06-24\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"medium\")).unwrap().to_string(),\n        \"Jun 24 2023\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"long\")).unwrap().to_string(),\n        \"June 24 2023\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"full\")).unwrap().to_string(),\n        \"Saturday, June 24 2023\"\n    );\n\n    let expr = env\n        .compile_expression(\"1687624642|dateformat(tz='Europe/Moscow')\")\n        .unwrap();\n    assert_eq!(expr.eval(()).unwrap().to_string(), \"2023-06\");\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_dateformat_time_rs", "test": "fn test_dateformat_time_rs() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"Europe/Vienna\");\n    env.add_global(\"DATE_FORMAT\", \"[year]-[month]\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"d|dateformat(format=format)\")\n        .unwrap();\n\n    let d = time::Date::from_ordinal_date(2023, 42).unwrap();\n    assert_eq!(\n        expr.eval(context!(d, format => \"short\"))\n            .unwrap()\n            .to_string(),\n        \"2023-02-11\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_dateformat_chrono_rs", "test": "fn test_dateformat_chrono_rs() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"Europe/Vienna\");\n    env.add_global(\"DATE_FORMAT\", \"[year]-[month]\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"d|dateformat(format=format)\")\n        .unwrap();\n\n    let d = chrono::NaiveDate::from_num_days_from_ce_opt(739073);\n    assert_eq!(\n        expr.eval(context!(d, format => \"short\"))\n            .unwrap()\n            .to_string(),\n        \"2024-07-06\"\n    );\n\n    assert_eq!(\n        expr.eval(context!(d => \"2024-07-06\", format => \"short\"))\n            .unwrap()\n            .to_string(),\n        \"2024-07-06\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/datetime.rs::test_timeformat", "test": "fn test_timeformat() {\n    let mut env = minijinja::Environment::new();\n    env.add_global(\"TIMEZONE\", \"Europe/Vienna\");\n    env.add_global(\"TIME_FORMAT\", \"[hour]:[minute]\");\n    minijinja_contrib::add_to_environment(&mut env);\n\n    let expr = env\n        .compile_expression(\"1687624642.5|timeformat(format=format)\")\n        .unwrap();\n\n    assert_eq!(\n        expr.eval(context!(format => \"short\")).unwrap().to_string(),\n        \"18:37\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"medium\")).unwrap().to_string(),\n        \"18:37\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"long\")).unwrap().to_string(),\n        \"18:37:22\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"full\")).unwrap().to_string(),\n        \"18:37:22.5\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"unix\")).unwrap().to_string(),\n        \"1687624642\"\n    );\n    assert_eq!(\n        expr.eval(context!(format => \"iso\")).unwrap().to_string(),\n        \"2023-06-24T18:37:22+02:00\"\n    );\n\n    let expr = env\n        .compile_expression(\"1687624642|timeformat(tz='Europe/Moscow')\")\n        .unwrap();\n    assert_eq!(expr.eval(()).unwrap().to_string(), \"19:37\");\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-contrib/tests/filters.rs::test_pluralize", "test": "fn test_pluralize() {\n    use minijinja::context;\n\n    let mut env = minijinja::Environment::new();\n\n    env.add_filter(\"pluralize\", pluralize);\n    for (num, s) in [\n        (0, \"You have 0 messages.\"),\n        (1, \"You have 1 message.\"),\n        (10, \"You have 10 messages.\"),\n    ] {\n        assert_eq!(\n            env.render_str(\n                \"You have {{ num_messages }} message{{ num_messages|pluralize }}.\",\n                context! {\n                    num_messages => num,\n                }\n            )\n            .unwrap(),\n            s\n        );\n    }\n\n    for (num, s) in [\n        (0, \"You have 0 walruses.\"),\n        (1, \"You have 1 walrus.\"),\n        (10, \"You have 10 walruses.\"),\n    ] {\n        assert_eq!(\n            env.render_str(\n                r#\"You have {{ num_walruses }} walrus{{ num_walruses|pluralize(None, \"es\") }}.\"#,\n                context! {\n                    num_walruses => num,\n                }\n            )\n            .unwrap(),\n            s\n        );\n    }\n\n    for (num, s) in [\n        (0, \"You have 0 cherries.\"),\n        (1, \"You have 1 cherry.\"),\n        (10, \"You have 10 cherries.\"),\n    ] {\n        assert_eq!(\n            env.render_str(\n                r#\"You have {{ num_cherries }} cherr{{ num_cherries|pluralize(\"y\", \"ies\") }}.\"#,\n                context! {\n                    num_cherries => num,\n                }\n            )\n            .unwrap(),\n            s\n        );\n    }\n\n    assert_eq!(\n        env.render_str(\n            r#\"You have {{ num_cherries|length }} cherr{{ num_cherries|pluralize(\"y\", \"ies\") }}.\"#,\n            context! {\n                num_cherries => vec![(); 5],\n            }\n        )\n        .unwrap(),\n        \"You have 5 cherries.\"\n    );\n    assert_eq!(\n        env.render_str(\n            r#\"You have {{ num_cherries }} cherr{{ num_cherries|pluralize(\"y\", \"ies\") }}.\"#,\n            context! {\n                num_cherries => 5,\n            }\n        )\n        .unwrap(),\n        \"You have 5 cherries.\"\n    );\n    assert_eq!(\n        env.render_str(\n            r#\"You have {{ num_cherries }} cherr{{ num_cherries|pluralize(\"y\", \"ies\") }}.\"#,\n            context! {\n                num_cherries => 0.5f32,\n            }\n        )\n        .unwrap_err()\n        .to_string(),\n        \"invalid operation: Pluralize argument is not an integer, or a sequence / object with \\\n            a length but of type number (in <string>:1)\",\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_deserialization.rs::test_map", "test": "fn test_map() {\n    let v = BTreeMap::<String, i32>::deserialize(Value::from_iter([\n        (\"foo\", Value::from(1)),\n        (\"bar\", Value::from(2)),\n    ]))\n    .unwrap();\n    assert_eq!(\n        v,\n        BTreeMap::from_iter([(\"foo\".to_string(), 1), (\"bar\".to_string(), 2)])\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_deserialization.rs::test_struct_object", "test": "fn test_struct_object() {\n    struct X;\n\n    impl StructObject for X {\n        fn get_field(&self, name: &str) -> Option<Value> {\n            match name {\n                \"a\" => Some(Value::from(1)),\n                \"b\" => Some(Value::from(2)),\n                _ => None,\n            }\n        }\n        fn static_fields(&self) -> Option<&'static [&'static str]> {\n            Some(&[\"a\", \"b\"])\n        }\n    }\n\n    let v = BTreeMap::<String, i32>::deserialize(Value::from_struct_object(X)).unwrap();\n    assert_eq!(\n        v,\n        BTreeMap::from_iter([(\"a\".to_string(), 1), (\"b\".to_string(), 2)])\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_deserialization.rs::test_basics", "test": "fn test_basics() {\n    assert_eq!(bool::deserialize(Value::from(true)).unwrap(), true);\n    assert_eq!(bool::deserialize(Value::from(false)).unwrap(), false);\n    assert_eq!(f32::deserialize(Value::from(1.0)).unwrap(), 1.0);\n    assert_eq!(i32::deserialize(Value::from(2)).unwrap(), 2);\n    assert_eq!(String::deserialize(Value::from(\"foo\")).unwrap(), \"foo\");\n    assert_eq!(Option::<i32>::deserialize(Value::from(2)).unwrap(), Some(2));\n    assert_eq!(Option::<i32>::deserialize(Value::from(())).unwrap(), None);\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_deserialization.rs::test_enum", "test": "fn test_enum() {\n    #[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]\n    enum Foo {\n        A,\n        B,\n        C(i32),\n    }\n\n    assert_eq!(Foo::deserialize(Value::from(\"A\")).unwrap(), Foo::A);\n    assert_eq!(Foo::deserialize(Value::from(\"B\")).unwrap(), Foo::B);\n    assert_eq!(\n        Foo::deserialize(Value::from(BTreeMap::from_iter([(\"C\", 42)]))).unwrap(),\n        Foo::C(42)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_deserialization.rs::test_invalid", "test": "fn test_invalid() {\n    struct X;\n\n    impl Serialize for X {\n        fn serialize<S>(&self, _serializer: S) -> Result<S::Ok, S::Error>\n        where\n            S: serde::Serializer,\n        {\n            Err(serde::ser::Error::custom(\"meh\"))\n        }\n    }\n\n    let v = Value::from_serializable(&X);\n    assert_eq!(v.to_string(), \"<invalid value: meh>\");\n\n    let err = bool::deserialize(v).unwrap_err();\n    assert_eq!(err.to_string(), \"cannot deserialize: meh\");\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_expression_bug", "test": "fn test_expression_bug() {\n    let env = Environment::new();\n    assert!(env.compile_expression(\"42.blahadsf()\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_expression_lifetimes", "test": "fn test_expression_lifetimes() {\n    let mut env = Environment::new();\n    let s = String::new();\n    env.add_template(\"test\", &s).unwrap();\n    {\n        let x = String::from(\"1 + 1\");\n        let expr = env.compile_expression(&x).unwrap();\n        assert_eq!(expr.eval(()).unwrap().to_string(), \"2\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_expression_undeclared_variables", "test": "fn test_expression_undeclared_variables() {\n    let env = Environment::new();\n    let expr = env.compile_expression(\"[foo, bar.baz]\").unwrap();\n    let undeclared = expr.undeclared_variables(false);\n    assert_eq!(\n        undeclared,\n        [\"bar\", \"foo\"].into_iter().map(|x| x.to_string()).collect()\n    );\n    let undeclared = expr.undeclared_variables(true);\n    assert_eq!(\n        undeclared,\n        [\"foo\", \"bar.baz\"]\n            .into_iter()\n            .map(|x| x.to_string())\n            .collect()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_template_removal", "test": "fn test_template_removal() {\n    let mut env = Environment::new();\n    env.add_template(\"test\", \"{{ a }}\").unwrap();\n    env.remove_template(\"test\");\n    assert!(env.get_template(\"test\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_filters.rs::test_filter_with_non", "test": "fn test_filter_with_non() {\n    fn filter(value: Option<String>) -> String {\n        format!(\"[{}]\", value.unwrap_or_default())\n    }\n\n    let mut env = Environment::new();\n    env.add_filter(\"filter\", filter);\n    let state = env.empty_state();\n\n    let rv = state\n        .apply_filter(\"filter\", args!(Value::UNDEFINED))\n        .unwrap();\n    assert_eq!(rv, Value::from(\"[]\"));\n\n    let rv = state\n        .apply_filter(\"filter\", args!(Value::from(())))\n        .unwrap();\n    assert_eq!(rv, Value::from(\"[]\"));\n\n    let rv = state\n        .apply_filter(\"filter\", args!(Value::from(\"wat\")))\n        .unwrap();\n    assert_eq!(rv, Value::from(\"[wat]\"));\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_filters.rs::test_indent_one_empty_line", "test": "fn test_indent_one_empty_line() {\n    let teststring = String::from(\"\\n\");\n    assert_eq!(indent(teststring, 2, None, None), String::from(\"\"));\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_filters.rs::test_indent_one_line", "test": "fn test_indent_one_line() {\n    let teststring = String::from(\"test\\n\");\n    assert_eq!(indent(teststring, 2, None, None), String::from(\"test\"));\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_filters.rs::test_indent", "test": "fn test_indent() {\n    let teststring = String::from(\"test\\ntest1\\n\\ntest2\\n\");\n    assert_eq!(\n        indent(teststring, 2, None, None),\n        String::from(\"test\\n  test1\\n\\n  test2\")\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_filters.rs::test_indent_with_indented_first_line", "test": "fn test_indent_with_indented_first_line() {\n    let teststring = String::from(\"test\\ntest1\\n\\ntest2\\n\");\n    assert_eq!(\n        indent(teststring, 2, Some(true), None),\n        String::from(\"  test\\n  test1\\n\\n  test2\")\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_filters.rs::test_indent_with_indented_blank_line", "test": "fn test_indent_with_indented_blank_line() {\n    let teststring = String::from(\"test\\ntest1\\n\\ntest2\\n\");\n    assert_eq!(\n        indent(teststring, 2, None, Some(true)),\n        String::from(\"test\\n  test1\\n  \\n  test2\")\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_filters.rs::test_indent_with_all_indented", "test": "fn test_indent_with_all_indented() {\n    let teststring = String::from(\"test\\ntest1\\n\\ntest2\\n\");\n    assert_eq!(\n        indent(teststring, 2, Some(true), Some(true)),\n        String::from(\"  test\\n  test1\\n  \\n  test2\")\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_filters.rs::test_abs_overflow", "test": "fn test_abs_overflow() {\n    let ok = abs(Value::from(i64::MIN)).unwrap();\n    assert_eq!(ok, Value::from(-(i64::MIN as i128)));\n    let err = abs(Value::from(i128::MIN)).unwrap_err();\n    assert_eq!(err.to_string(), \"invalid operation: overflow on abs\");\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_undeclared_variables", "test": "fn test_undeclared_variables() {\n    let mut env = Environment::new();\n    env.add_template(\n        \"demo\",\n        \"{% set x = foo %}{{ x }}{{ bar.baz }}{{ bar.blub }}\",\n    )\n    .unwrap();\n    let tmpl = env.get_template(\"demo\").unwrap();\n    let undeclared = tmpl.undeclared_variables(false);\n    assert_eq!(\n        undeclared,\n        [\"foo\", \"bar\"].into_iter().map(|x| x.to_string()).collect()\n    );\n    let undeclared = tmpl.undeclared_variables(true);\n    dbg!(&undeclared);\n    assert_eq!(\n        undeclared,\n        [\"foo\", \"bar.baz\", \"bar.blub\"]\n            .into_iter()\n            .map(|x| x.to_string())\n            .collect()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_state", "test": "fn test_state() {\n    let mut env = Environment::new();\n    env.add_template(\n        \"foo.html\",\n        r#\"\n        {% set global = variable * 2 %}\n        {% macro something() %}{{ global }}{% endmacro %}\n        {% block baz %}[{{ global }}]{% endblock %}\n    \"#,\n    )\n    .unwrap();\n    let template = env.get_template(\"foo.html\").unwrap();\n    let mut state = template\n        .eval_to_state(context! {\n            variable => 23\n        })\n        .unwrap();\n    assert!(state.lookup(\"range\").is_some());\n    assert!(!state.exports().contains(&\"range\"));\n    assert_eq!(state.lookup(\"global\"), Some(Value::from(23 * 2)));\n    assert_eq!(state.call_macro(\"something\", &[]).unwrap(), \"46\");\n    assert_eq!(state.render_block(\"baz\").unwrap(), \"[46]\");\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_templates.rs::test_render_to_write_state", "test": "fn test_render_to_write_state() {\n    let env = Environment::new();\n    let tmpl = env\n        .template_from_str(\"{% set foo = 42 %}{% macro bar() %}x{% endmacro %}root\")\n        .unwrap();\n    let mut out = Vec::<u8>::new();\n    let state = tmpl.render_to_write((), &mut out).unwrap();\n    assert_eq!(String::from_utf8_lossy(&out), \"root\");\n    assert_eq!(state.lookup(\"foo\"), Some(Value::from(42)));\n    assert_eq!(state.call_macro(\"bar\", &[]).ok().as_deref(), Some(\"x\"));\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_value_serialization", "test": "fn test_value_serialization() {\n    // make sure if we serialize to json we get regular values\n    assert_eq!(serde_json::to_string(&Value::UNDEFINED).unwrap(), \"null\");\n    assert_eq!(\n        serde_json::to_string(&Value::from_safe_string(\"foo\".to_string())).unwrap(),\n        \"\\\"foo\\\"\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_float_to_string", "test": "fn test_float_to_string() {\n    assert_eq!(Value::from(42.4242f64).to_string(), \"42.4242\");\n    assert_eq!(Value::from(42.0f32).to_string(), \"42.0\");\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_obj_downcast", "test": "fn test_obj_downcast() {\n    #[derive(Debug)]\n    struct Thing {\n        id: usize,\n    }\n\n    impl fmt::Display for Thing {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            fmt::Debug::fmt(self, f)\n        }\n    }\n\n    impl Object for Thing {}\n\n    let x_value = Value::from_object(Thing { id: 42 });\n    let value_as_obj = x_value.as_object().unwrap();\n    assert!(value_as_obj.is::<Thing>());\n    let thing = value_as_obj.downcast_ref::<Thing>().unwrap();\n    assert_eq!(thing.id, 42);\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_value_cmp", "test": "fn test_value_cmp() {\n    assert_eq!(Value::from(&[1][..]), Value::from(&[1][..]));\n    assert_ne!(Value::from(&[1][..]), Value::from(&[2][..]));\n    assert_eq!(Value::UNDEFINED, Value::UNDEFINED);\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_call_kwargs", "test": "fn test_call_kwargs() {\n    let mut env = Environment::new();\n    env.add_template(\"foo\", \"\").unwrap();\n    let tmpl = env.get_template(\"foo\").unwrap();\n    let state = tmpl.new_state();\n    let val = Value::from_function(|kwargs: Kwargs| kwargs.get::<i32>(\"foo\"));\n    let rv = val\n        .call(\n            &state,\n            &[Kwargs::from_iter([(\"foo\", Value::from(42))]).into()],\n        )\n        .unwrap();\n    assert_eq!(rv, Value::from(42));\n}", "error": "Not Definition Found"}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_complex_key", "test": "fn test_complex_key() {\n    let value = Value::from_iter([\n        (Value::from_iter([0u32, 0u32]), \"origin\"),\n        (Value::from_iter([0u32, 1u32]), \"right\"),\n    ]);\n\n    assert_eq!(\n        value.get_item(&Value::from_iter([0, 0])).ok(),\n        Some(Value::from(\"origin\"))\n    );\n    assert_eq!(\n        value.get_item(&Value::from_iter([0, 42])).ok(),\n        Some(Value::UNDEFINED)\n    );\n}", "error": "Not Definition Found"}
