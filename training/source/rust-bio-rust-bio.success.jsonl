{"test_id": "rust-bio-rust-bio/rust-bio-rust-bio-319a0d8/tests-gen/banded_aligner.rs::test_something", "test": "fn test_something() {\n    let data = [];\n    if data.len() < 50 || data.len() > 300 {\n        return;\n    }\n    let (split_byte, data) = data.split_first().unwrap();\n    let (kmer_byte, data) = data.split_first().unwrap();\n    let (window_byte, data) = data.split_first().unwrap();\n    let (match_score_byte, data) = data.split_first().unwrap();\n    let (mismatch_score_byte, data) = data.split_first().unwrap();\n    let (gap_open_byte, data) = data.split_first().unwrap();\n    let (gap_extend_byte, data) = data.split_first().unwrap();\n    let (xclip_prefix_byte, data) = data.split_first().unwrap();\n    let (xclip_suffix_byte, data) = data.split_first().unwrap();\n    let (yclip_prefix_byte, data) = data.split_first().unwrap();\n    let (yclip_suffix_byte, data) = data.split_first().unwrap();\n    let alphabets = b\"ACGT\";\n    let v: Vec<_> = data\n        .iter()\n        .map(|i| alphabets[(*i as usize) % alphabets.len()])\n        .collect();\n    let kmer_len: usize = 5 + (*kmer_byte as usize) % 10;\n    let window_size: usize = 5 + (*window_byte as usize) % 10;\n    let split_pos: usize = min(data.len() - 1, max(*split_byte as usize, 1));\n    let match_score = 1 + (*match_score_byte as i32) % 5;\n    let mismatch_score = -((*mismatch_score_byte as i32) % 10);\n    let gap_open = -((*gap_open_byte as i32) % 20);\n    let gap_extend = -((*gap_extend_byte as i32) % 10);\n    let (x, y) = v.split_at(split_pos);\n    println!(\n        \"x: {}, y: {}, k: {}, w: {}, scoring ({}, {}, {}, {})\",\n        String::from_utf8(x.to_vec()).unwrap(),\n        String::from_utf8(y.to_vec()).unwrap(),\n        kmer_len,\n        window_size,\n        gap_open,\n        gap_extend,\n        match_score,\n        mismatch_score\n    );\n    let base_score = Scoring::from_scores(gap_open, gap_extend, match_score, mismatch_score);\n    {\n        println!(\n            \"Clip scores ({}, {}, {}, {})\",\n            xclip_prefix_byte, xclip_suffix_byte, yclip_prefix_byte, yclip_suffix_byte\n        );\n        let scoring = Scoring {\n            xclip_prefix: -(*xclip_prefix_byte as i32),\n            xclip_suffix: -(*xclip_suffix_byte as i32),\n            yclip_prefix: -(*yclip_prefix_byte as i32),\n            yclip_suffix: -(*yclip_suffix_byte as i32),\n            ..base_score.clone()\n        };\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert!(validate_alignment_score(&b_alignment, x, y, &scoring));\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert!(validate_alignment_score(&f_alignment, x, y, &scoring));\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, &Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n    {\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_suffix: 0,\n            ..base_score.clone()\n        };\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.ystart, 0);\n        assert!(validate_alignment_score(&b_alignment, x, y, &scoring));\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.ystart, 0);\n        assert!(validate_alignment_score(&f_alignment, x, y, &scoring));\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, &Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n    {\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            xclip_suffix: 0,\n            yclip_prefix: 0,\n            ..base_score.clone()\n        };\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.yend, b_alignment.ylen);\n        assert!(validate_alignment_score(&b_alignment, x, y, &scoring));\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.yend, f_alignment.ylen);\n        assert!(validate_alignment_score(&f_alignment, x, y, &scoring));\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, &Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n    {\n        let scoring = Scoring {\n            xclip_suffix: 0,\n            yclip_prefix: 0,\n            yclip_suffix: 0,\n            ..base_score.clone()\n        };\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.xstart, 0);\n        assert!(validate_alignment_score(&b_alignment, x, y, &scoring));\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.xstart, 0);\n        assert!(validate_alignment_score(&f_alignment, x, y, &scoring));\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, &Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n    {\n        let scoring = Scoring {\n            xclip_prefix: 0,\n            yclip_prefix: 0,\n            yclip_suffix: 0,\n            ..base_score.clone()\n        };\n        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);\n        let b_alignment = b_aligner.custom(x, y);\n        assert_eq!(b_alignment.xend, b_alignment.xlen);\n        assert!(validate_alignment_score(&b_alignment, x, y, &scoring));\n        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());\n        let f_alignment = f_aligner.custom(x, y);\n        assert_eq!(f_alignment.xend, f_alignment.xlen);\n        assert!(validate_alignment_score(&f_alignment, x, y, &scoring));\n        let band_all_alignment = b_aligner.custom_with_matches(x, y, &Vec::new());\n        assert_eq!(band_all_alignment.score, f_alignment.score);\n    }\n    {\n        let mut aligner = banded::Aligner::with_scoring(base_score.clone(), kmer_len, window_size);\n        let alignment = aligner.local(x, y);\n        assert!(alignment.score >= 0);\n        assert!(validate_alignment_score(&alignment, x, y, &base_score));\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert!(validate_alignment_score(&alignment, x, y, &base_score));\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.yend, alignment.ylen);\n        assert!(validate_alignment_score(&alignment, x, y, &base_score));\n    }\n    {\n        let mut aligner = pairwise::Aligner::with_scoring(base_score.clone());\n        let alignment = aligner.local(x, y);\n        assert!(alignment.score >= 0);\n        assert!(validate_alignment_score(&alignment, x, y, &base_score));\n        let alignment = aligner.semiglobal(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert!(validate_alignment_score(&alignment, x, y, &base_score));\n        let alignment = aligner.global(x, y);\n        assert_eq!(alignment.xstart, 0);\n        assert_eq!(alignment.xend, alignment.xlen);\n        assert_eq!(alignment.ystart, 0);\n        assert_eq!(alignment.yend, alignment.ylen);\n        assert!(validate_alignment_score(&alignment, x, y, &base_score));\n    }\n}", "code_id": "rust-bio-rust-bio/rust-bio-rust-bio-319a0d8/fuzz-bak/fuzz_targets/banded_aligner.rs::validate_alignment_score", "code": "fn validate_alignment_score(al: &Alignment, x: TextSlice, y: TextSlice, scoring: &Scoring<MatchParams>) -> bool {\n    use AlignmentOperation::*;\n    let path = al.path();\n    let mut score = 0;\n    if al.mode==AlignmentMode::Custom {\n        if al.xstart > 0 {\n            score += scoring.xclip_prefix;\n        }\n        if al.ystart > 0 {\n            score += scoring.yclip_prefix;\n        }\n        if al.xend < al.xlen {\n            score += scoring.xclip_suffix;\n        }\n        if al.yend < al.ylen {\n            score += scoring.yclip_suffix;\n        }\n    }\n    let mut last_op = None;\n    for (i, j, op) in path {\n        score += match op {\n            Match | Subst => scoring.match_fn.score(x[i-1], y[j-1]),\n            Del => if last_op==Some(Del) { scoring.gap_extend } else { scoring.gap_open + scoring.gap_extend },\n            Ins => if last_op==Some(Ins) { scoring.gap_extend } else { scoring.gap_open + scoring.gap_extend },\n            _ => 0,\n        };\n        last_op = Some(op);\n    }\n    al.score==score\n}", "docstring": null}
