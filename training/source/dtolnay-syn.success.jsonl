{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_generics.rs::test_split_for_impl", "test": "fn test_split_for_impl() {\n    let input = quote! {\n        struct S<'a, 'b: 'a, #[may_dangle] T: 'a = ()> where T: Debug;\n    };\n\n    snapshot!(input as DeriveInput, @r###\"\n    DeriveInput {\n        vis: Visibility::Inherited,\n        ident: \"S\",\n        generics: Generics {\n            lt_token: Some,\n            params: [\n                GenericParam::Lifetime(LifetimeParam {\n                    lifetime: Lifetime {\n                        ident: \"a\",\n                    },\n                }),\n                GenericParam::Lifetime(LifetimeParam {\n                    lifetime: Lifetime {\n                        ident: \"b\",\n                    },\n                    colon_token: Some,\n                    bounds: [\n                        Lifetime {\n                            ident: \"a\",\n                        },\n                    ],\n                }),\n                GenericParam::Type(TypeParam {\n                    attrs: [\n                        Attribute {\n                            style: AttrStyle::Outer,\n                            meta: Meta::Path {\n                                segments: [\n                                    PathSegment {\n                                        ident: \"may_dangle\",\n                                    },\n                                ],\n                            },\n                        },\n                    ],\n                    ident: \"T\",\n                    colon_token: Some,\n                    bounds: [\n                        TypeParamBound::Lifetime {\n                            ident: \"a\",\n                        },\n                    ],\n                    eq_token: Some,\n                    default: Some(Type::Tuple),\n                }),\n            ],\n            gt_token: Some,\n            where_clause: Some(WhereClause {\n                predicates: [\n                    WherePredicate::Type(PredicateType {\n                        bounded_ty: Type::Path {\n                            path: Path {\n                                segments: [\n                                    PathSegment {\n                                        ident: \"T\",\n                                    },\n                                ],\n                            },\n                        },\n                        bounds: [\n                            TypeParamBound::Trait(TraitBound {\n                                path: Path {\n                                    segments: [\n                                        PathSegment {\n                                            ident: \"Debug\",\n                                        },\n                                    ],\n                                },\n                            }),\n                        ],\n                    }),\n                ],\n            }),\n        },\n        data: Data::Struct {\n            fields: Fields::Unit,\n            semi_token: Some,\n        },\n    }\n    \"###);\n\n    let generics = input.generics;\n    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n    let generated = quote! {\n        impl #impl_generics MyTrait for Test #ty_generics #where_clause {}\n    };\n    let expected = quote! {\n        impl<'a, 'b: 'a, #[may_dangle] T: 'a> MyTrait\n        for Test<'a, 'b, T>\n        where\n            T: Debug\n        {}\n    };\n    assert_eq!(generated.to_string(), expected.to_string());\n\n    let turbofish = ty_generics.as_turbofish();\n    let generated = quote! {\n        Test #turbofish\n    };\n    let expected = quote! {\n        Test::<'a, 'b, T>\n    };\n    assert_eq!(generated.to_string(), expected.to_string());\n}", "code_id": "dtolnay-syn/dtolnay-syn-b1a038c/src/bigint.rs::to_string", "code": "pub(crate) fn to_string(&self) -> String {\n        let mut repr = String::with_capacity(self.digits.len());\n\n        let mut has_nonzero = false;\n        for digit in self.digits.iter().rev() {\n            has_nonzero |= *digit != 0;\n            if has_nonzero {\n                repr.push((*digit + b'0') as char);\n            }\n        }\n\n        if repr.is_empty() {\n            repr.push('0');\n        }\n\n        repr\n    }", "docstring": null}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_generics.rs::test_fn_precedence_in_where_clause", "test": "fn test_fn_precedence_in_where_clause() {\n    // This should parse as two separate bounds, `FnOnce() -> i32` and `Send` - not\n    // `FnOnce() -> (i32 + Send)`.\n    let input = quote! {\n        fn f<G>()\n        where\n            G: FnOnce() -> i32 + Send,\n        {\n        }\n    };\n\n    snapshot!(input as ItemFn, @r###\"\n    ItemFn {\n        vis: Visibility::Inherited,\n        sig: Signature {\n            ident: \"f\",\n            generics: Generics {\n                lt_token: Some,\n                params: [\n                    GenericParam::Type(TypeParam {\n                        ident: \"G\",\n                    }),\n                ],\n                gt_token: Some,\n                where_clause: Some(WhereClause {\n                    predicates: [\n                        WherePredicate::Type(PredicateType {\n                            bounded_ty: Type::Path {\n                                path: Path {\n                                    segments: [\n                                        PathSegment {\n                                            ident: \"G\",\n                                        },\n                                    ],\n                                },\n                            },\n                            bounds: [\n                                TypeParamBound::Trait(TraitBound {\n                                    path: Path {\n                                        segments: [\n                                            PathSegment {\n                                                ident: \"FnOnce\",\n                                                arguments: PathArguments::Parenthesized {\n                                                    output: ReturnType::Type(\n                                                        Type::Path {\n                                                            path: Path {\n                                                                segments: [\n                                                                    PathSegment {\n                                                                        ident: \"i32\",\n                                                                    },\n                                                                ],\n                                                            },\n                                                        },\n                                                    ),\n                                                },\n                                            },\n                                        ],\n                                    },\n                                }),\n                                TypeParamBound::Trait(TraitBound {\n                                    path: Path {\n                                        segments: [\n                                            PathSegment {\n                                                ident: \"Send\",\n                                            },\n                                        ],\n                                    },\n                                }),\n                            ],\n                        }),\n                    ],\n                }),\n            },\n            output: ReturnType::Default,\n        },\n        block: Block,\n    }\n    \"###);\n\n    let where_clause = input.sig.generics.where_clause.as_ref().unwrap();\n    assert_eq!(where_clause.predicates.len(), 1);\n\n    let predicate = match &where_clause.predicates[0] {\n        WherePredicate::Type(pred) => pred,\n        _ => panic!(\"wrong predicate kind\"),\n    };\n\n    assert_eq!(predicate.bounds.len(), 2, \"{:#?}\", predicate.bounds);\n\n    let first_bound = &predicate.bounds[0];\n    assert_eq!(quote!(#first_bound).to_string(), \"FnOnce () -> i32\");\n\n    let second_bound = &predicate.bounds[1];\n    assert_eq!(quote!(#second_bound).to_string(), \"Send\");\n}", "code_id": "dtolnay-syn/dtolnay-syn-b1a038c/src/data.rs::len", "code": "pub fn len(&self) -> usize {\n        match self {\n            Fields::Unit => 0,\n            Fields::Named(f) => f.named.len(),\n            Fields::Unnamed(f) => f.unnamed.len(),\n        }\n    }", "docstring": null}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_generics.rs::test_where_clause_at_end_of_input", "test": "fn test_where_clause_at_end_of_input() {\n    let input = quote! {\n        where\n    };\n\n    snapshot!(input as WhereClause, @\"WhereClause\");\n\n    assert_eq!(input.predicates.len(), 0);\n}", "code_id": "dtolnay-syn/dtolnay-syn-b1a038c/src/punctuated.rs::len", "code": "pub fn len(&self) -> usize {\n        self.inner.len() + if self.last.is_some() { 1 } else { 0 }\n    }", "docstring": null}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_grouping.rs::test_grouping", "test": "fn test_grouping() {\n    let tokens: TokenStream = TokenStream::from_iter(vec![\n        TokenTree::Literal(Literal::i32_suffixed(1)),\n        TokenTree::Punct(Punct::new('+', Spacing::Alone)),\n        TokenTree::Group(Group::new(\n            Delimiter::None,\n            TokenStream::from_iter(vec![\n                TokenTree::Literal(Literal::i32_suffixed(2)),\n                TokenTree::Punct(Punct::new('+', Spacing::Alone)),\n                TokenTree::Literal(Literal::i32_suffixed(3)),\n            ]),\n        )),\n        TokenTree::Punct(Punct::new('*', Spacing::Alone)),\n        TokenTree::Literal(Literal::i32_suffixed(4)),\n    ]);\n\n    assert_eq!(tokens.to_string(), \"1i32 + 2i32 + 3i32 * 4i32\");\n\n    snapshot!(tokens as Expr, @r###\"\n    Expr::Binary {\n        left: Expr::Lit {\n            lit: 1i32,\n        },\n        op: BinOp::Add,\n        right: Expr::Binary {\n            left: Expr::Group {\n                expr: Expr::Binary {\n                    left: Expr::Lit {\n                        lit: 2i32,\n                    },\n                    op: BinOp::Add,\n                    right: Expr::Lit {\n                        lit: 3i32,\n                    },\n                },\n            },\n            op: BinOp::Mul,\n            right: Expr::Lit {\n                lit: 4i32,\n            },\n        },\n    }\n    \"###);\n}", "code_id": "dtolnay-syn/dtolnay-syn-b1a038c/src/bigint.rs::to_string", "code": "pub(crate) fn to_string(&self) -> String {\n        let mut repr = String::with_capacity(self.digits.len());\n\n        let mut has_nonzero = false;\n        for digit in self.digits.iter().rev() {\n            has_nonzero |= *digit != 0;\n            if has_nonzero {\n                repr.push((*digit + b'0') as char);\n            }\n        }\n\n        if repr.is_empty() {\n            repr.push('0');\n        }\n\n        repr\n    }", "docstring": null}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_iterators.rs::iter", "test": "fn iter() {\n    let mut p: Punctuated<_, Token![,]> = punctuated!(2, 3, 4);\n\n    check_exact_size_iterator!(p.iter());\n    check_exact_size_iterator!(p.iter_mut());\n    check_exact_size_iterator!(p.into_iter());\n\n    let mut p: Punctuated<_, Token![,]> = punctuated!(2, 3, 4);\n\n    assert_eq!(p.iter().next_back(), Some(&4));\n    assert_eq!(p.iter_mut().next_back(), Some(&mut 4));\n    assert_eq!(p.into_iter().next_back(), Some(4));\n}", "code_id": "dtolnay-syn/dtolnay-syn-b1a038c/src/punctuated.rs::next_back", "code": "fn next_back(&mut self) -> Option<Self::Item> {\n        self.last\n            .next()\n            .map(Pair::End)\n            .or_else(|| self.inner.next_back().map(|(t, p)| Pair::Punctuated(t, p)))\n    }", "docstring": null}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_lit.rs::strings", "test": "fn strings() {\n    fn test_string(s: &str, value: &str) {\n        match lit(s) {\n            Lit::Str(lit) => {\n                assert_eq!(lit.value(), value);\n                let again = lit.into_token_stream().to_string();\n                if again != s {\n                    test_string(&again, value);\n                }\n            }\n            wrong => panic!(\"{:?}\", wrong),\n        }\n    }\n\n    test_string(\"\\\"a\\\"\", \"a\");\n    test_string(\"\\\"\\\\n\\\"\", \"\\n\");\n    test_string(\"\\\"\\\\r\\\"\", \"\\r\");\n    test_string(\"\\\"\\\\t\\\"\", \"\\t\");\n    test_string(\"\\\"🐕\\\"\", \"🐕\"); // NOTE: This is an emoji\n    test_string(\"\\\"\\\\\\\"\\\"\", \"\\\"\");\n    test_string(\"\\\"'\\\"\", \"'\");\n    test_string(\"\\\"\\\"\", \"\");\n    test_string(\"\\\"\\\\u{1F415}\\\"\", \"\\u{1F415}\");\n    test_string(\"\\\"\\\\u{1_2__3_}\\\"\", \"\\u{123}\");\n    test_string(\n        \"\\\"contains\\nnewlines\\\\\\nescaped newlines\\\"\",\n        \"contains\\nnewlinesescaped newlines\",\n    );\n    test_string(\n        \"\\\"escaped newline\\\\\\n \\x0C unsupported whitespace\\\"\",\n        \"escaped newline\\x0C unsupported whitespace\",\n    );\n    test_string(\"r\\\"raw\\nstring\\\\\\nhere\\\"\", \"raw\\nstring\\\\\\nhere\");\n    test_string(\"\\\"...\\\"q\", \"...\");\n    test_string(\"r\\\"...\\\"q\", \"...\");\n    test_string(\"r##\\\"...\\\"##q\", \"...\");\n}\n\n#[te", "code_id": "dtolnay-syn/dtolnay-syn-b1a038c/src/lit.rs::value", "code": "pub fn value(&self) -> String {\n        let repr = self.repr.token.to_string();\n        let (value, _suffix) = value::parse_lit_str(&repr);\n        String::from(value)\n    }", "docstring": null}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_path.rs::print_incomplete_qpath", "test": "fn print_incomplete_qpath() {\n    // qpath with `as` token\n    let mut ty: TypePath = parse_quote!(<Self as A>::Q);\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self as A > :: Q`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self as A > ::`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self >`)\n    \"###);\n    assert!(ty.path.segments.pop().is_none());\n\n    // qpath without `as` token\n    let mut ty: TypePath = parse_quote!(<Self>::A::B);\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self > :: A :: B`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self > :: A ::`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`< Self > ::`)\n    \"###);\n    assert!(ty.path.segments.pop().is_none());\n\n    // normal path\n    let mut ty: TypePath = parse_quote!(Self::A::B);\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`Self :: A :: B`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`Self :: A ::`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(`Self ::`)\n    \"###);\n    assert!(ty.path.segments.pop().is_some());\n    snapshot!(ty.to_token_stream(), @r###\"\n    TokenStream(``)\n    \"###);\n    assert!(ty.path.segments.pop().is_none());\n}", "code_id": "dtolnay-syn/dtolnay-syn-b1a038c/src/restriction.rs::is_some", "code": "pub(crate) fn is_some(&self) -> bool {\n            match self {\n                Visibility::Inherited => false,\n                _ => true,\n            }\n        }", "docstring": null}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_token_trees.rs::test_literal_mangling", "test": "fn test_literal_mangling() {\n    let code = \"0_4\";\n    let parsed: Lit = syn::parse_str(code).unwrap();\n    assert_eq!(code, quote!(#parsed).to_string());\n}", "code_id": "dtolnay-syn/dtolnay-syn-b1a038c/src/bigint.rs::to_string", "code": "pub(crate) fn to_string(&self) -> String {\n        let mut repr = String::with_capacity(self.digits.len());\n\n        let mut has_nonzero = false;\n        for digit in self.digits.iter().rev() {\n            has_nonzero |= *digit != 0;\n            if has_nonzero {\n                repr.push((*digit + b'0') as char);\n            }\n        }\n\n        if repr.is_empty() {\n            repr.push('0');\n        }\n\n        repr\n    }", "docstring": null}
