{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/117_untagged_tuple_variant.rs::test_ebkalderon_case", "test": "fn test_ebkalderon_case() {\n    let file = r#\"BuildSystem(\n    version: \"1.0.0\",\n    flags: [\n        \"--enable-thing\",\n        \"--enable-other-thing\",\n        If(\"some-conditional\", [\"--enable-third-thing\"]),\n    ]\n)\n\"#;\n\n    assert_eq!(\n        from_str::<BuildSystem>(file).unwrap(),\n        BuildSystem {\n            version: \"1.0.0\".into(),\n            flags: vec![\n                Flag::Value(\"--enable-thing\".into()),\n                Flag::Value(\"--enable-other-thing\".into()),\n                Flag::If(\n                    \"some-conditional\".into(),\n                    vec![\"--enable-third-thing\".into()]\n                )\n            ]\n        },\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/117_untagged_tuple_variant.rs::test_vessd_case", "test": "fn test_vessd_case() {\n    let foo_vec = vec![Foo::Bar(0); 5];\n    let foo_str = to_string(&foo_vec).unwrap();\n    assert_eq!(foo_str.as_str(), \"[0,0,0,0,0]\");\n    assert_eq!(from_str::<Vec<Foo>>(&foo_str).unwrap(), foo_vec);\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/203_error_positions.rs::test_error_positions", "test": "fn test_error_positions() {\n    assert_eq!(\n        ron::from_str::<TypeError>(\"  ()\"),\n        Err(SpannedError {\n            code: Error::InvalidValueForType {\n                expected: String::from(\"impossible\"),\n                found: String::from(\"a unit value\"),\n            },\n            position: Position { line: 1, col: 3 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<Test>(\"StructVariant(a: true, b: 0, c: -42)\"),\n        Err(SpannedError {\n            code: Error::InvalidValueForType {\n                expected: String::from(\"a nonzero u32\"),\n                found: String::from(\"the unsigned integer `0`\"),\n            },\n            position: Position { line: 1, col: 28 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<Test>(\"TupleVariant(42)\"),\n        Err(SpannedError {\n            code: Error::ExpectedDifferentLength {\n                expected: String::from(\"tuple variant Test::TupleVariant with 2 elements\"),\n                found: 1,\n            },\n            position: Position { line: 1, col: 16 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<Test>(\"NotAVariant\"),\n        Err(SpannedError {\n            code: Error::NoSuchEnumVariant {\n                expected: &[\"TupleVariant\", \"StructVariant\"],\n                found: String::from(\"NotAVariant\"),\n                outer: Some(String::from(\"Test\")),\n            },\n            position: Position { line: 1, col: 12 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<Test>(\"StructVariant(a: true, b: 1, c: -42, d: \\\"gotcha\\\")\"),\n        Err(SpannedError {\n            code: Error::NoSuchStructField {\n                expected: &[\"a\", \"b\", \"c\"],\n                found: String::from(\"d\"),\n                outer: Some(String::from(\"StructVariant\")),\n            },\n            position: Position { line: 1, col: 39 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<Test>(\"StructVariant(a: true, c: -42)\"),\n        Err(SpannedError {\n            code: Error::MissingStructField {\n                field: \"b\",\n                outer: Some(String::from(\"StructVariant\")),\n            },\n            position: Position { line: 1, col: 30 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<Test>(\"StructVariant(a: true, b: 1, a: false, c: -42)\"),\n        Err(SpannedError {\n            code: Error::DuplicateStructField {\n                field: \"a\",\n                outer: Some(String::from(\"StructVariant\")),\n            },\n            position: Position { line: 1, col: 31 },\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/250_variant_newtypes.rs::test_deserialise_non_newtypes", "test": "fn test_deserialise_non_newtypes() {\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] Unit\"#).unwrap(),\n        TestEnum::Unit,\n    );\n\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] PrimitiveNewtype(\"hi\")\"#)\n            .unwrap(),\n        TestEnum::PrimitiveNewtype(String::from(\"hi\")),\n    );\n\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] Tuple(4, false)\"#).unwrap(),\n        TestEnum::Tuple(4, false),\n    );\n\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] Struct(a: 4, b: false)\"#)\n            .unwrap(),\n        TestEnum::Struct { a: 4, b: false },\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/250_variant_newtypes.rs::test_deserialise_tuple_newtypes", "test": "fn test_deserialise_tuple_newtypes() {\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeUnit(Unit)\"#)\n            .unwrap_err()\n            .code,\n        Error::ExpectedStructLikeEnd,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeUnit(())\"#)\n            .unwrap_err()\n            .code,\n        Error::ExpectedStructLikeEnd,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeUnit()\"#).unwrap(),\n        TestEnum::TupleNewtypeUnit(Unit),\n    );\n\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeNewtype(Newtype(4))\"#\n        )\n        .unwrap_err()\n        .code,\n        Error::ExpectedInteger,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeNewtype((4))\"#)\n            .unwrap_err()\n            .code,\n        Error::ExpectedInteger,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeNewtype(4)\"#)\n            .unwrap(),\n        TestEnum::TupleNewtypeNewtype(Newtype(4)),\n    );\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_newtypes)] TupleNewtypeNewtype(4)\"#).unwrap(),\n        TestEnum::TupleNewtypeNewtype(Newtype(4)),\n    );\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_newtypes)] #![enable(unwrap_variant_newtypes)] TupleNewtypeNewtype(4)\"#).unwrap(),\n        TestEnum::TupleNewtypeNewtype(Newtype(4)),\n    );\n\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeTuple((4, false))\"#\n        )\n        .unwrap_err()\n        .code,\n        Error::ExpectedInteger,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeTuple(4, false)\"#)\n            .unwrap(),\n        TestEnum::TupleNewtypeTuple((4, false)),\n    );\n\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeTupleStruct(TupleStruct(4, false))\"#\n        )\n        .unwrap_err()\n        .code,\n        Error::ExpectedInteger,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeTupleStruct((4, false))\"#\n        )\n        .unwrap_err()\n        .code,\n        Error::ExpectedInteger,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeTupleStruct(4, false)\"#\n        )\n        .unwrap(),\n        TestEnum::TupleNewtypeTupleStruct(TupleStruct(4, false)),\n    );\n\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeStruct(Struct(a: 4, b: false))\"#\n        )\n        .unwrap_err()\n        .code,\n        Error::ExpectedMapColon,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeStruct((a: 4, b: false))\"#\n        )\n        .unwrap_err()\n        .code,\n        Error::ExpectedIdentifier,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeStruct(a: 4, b: false)\"#\n        )\n        .unwrap(),\n        TestEnum::TupleNewtypeStruct(Struct { a: 4, b: false }),\n    );\n\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeEnum(A)\"#).unwrap(),\n        TestEnum::TupleNewtypeEnum(Enum::A),\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeEnum(B(a: 4, b: false))\"#\n        )\n        .unwrap(),\n        TestEnum::TupleNewtypeEnum(Enum::B(Struct { a: 4, b: false })),\n    );\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeEnum(C 4, false)\"#)\n            .unwrap_err()\n            .code,\n        Error::ExpectedStructLike,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeEnum(C(4, false))\"#\n        )\n        .unwrap(),\n        TestEnum::TupleNewtypeEnum(Enum::C(4, false)),\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeEnum(D a: 4, b: false)\"#\n        )\n        .unwrap_err()\n        .code,\n        Error::ExpectedStructLike,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeEnum(D(a: 4, b: false))\"#\n        )\n        .unwrap(),\n        TestEnum::TupleNewtypeEnum(Enum::D { a: 4, b: false }),\n    );\n\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeOption(None)\"#)\n            .unwrap(),\n        TestEnum::TupleNewtypeOption(None),\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeOption(Some(a: 4, b: false))\"#\n        )\n        .unwrap(),\n        TestEnum::TupleNewtypeOption(Some(Struct { a: 4, b: false })),\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeOption(a: 4, b: false)\"#\n        )\n        .unwrap_err()\n        .code,\n        Error::ExpectedOption,\n    );\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes, implicit_some)] TupleNewtypeOption(a: 4, b: false)\"#).unwrap(),\n        TestEnum::TupleNewtypeOption(Some(Struct { a: 4, b: false })),\n    );\n\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeSeq([])\"#).unwrap(),\n        TestEnum::TupleNewtypeSeq(vec![]),\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeSeq([(a: 4, b: false)])\"#\n        )\n        .unwrap(),\n        TestEnum::TupleNewtypeSeq(vec![Struct { a: 4, b: false }]),\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeSeq([Struct(a: 4, b: false)])\"#\n        )\n        .unwrap(),\n        TestEnum::TupleNewtypeSeq(vec![Struct { a: 4, b: false }]),\n    );\n\n    assert_eq!(\n        from_str::<TestEnum>(r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeMap({})\"#).unwrap(),\n        TestEnum::TupleNewtypeMap(vec![].into_iter().collect()),\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeMap({2: (a: 4, b: false)})\"#\n        )\n        .unwrap(),\n        TestEnum::TupleNewtypeMap(vec![(2, Struct { a: 4, b: false })].into_iter().collect()),\n    );\n    assert_eq!(\n        from_str::<TestEnum>(\n            r#\"#![enable(unwrap_variant_newtypes)] TupleNewtypeMap({8: Struct(a: 4, b: false)})\"#\n        )\n        .unwrap(),\n        TestEnum::TupleNewtypeMap(vec![(8, Struct { a: 4, b: false })].into_iter().collect()),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/256_comma_error.rs::test_missing_comma_error", "test": "fn test_missing_comma_error() {\n    let tuple_string = r#\"(\n        1 // <-- forgotten comma here\n        2\n    )\"#;\n\n    assert_eq!(\n        ron::from_str::<(i32, i32)>(tuple_string).unwrap_err(),\n        SpannedError {\n            code: Error::ExpectedComma,\n            position: Position { line: 3, col: 9 }\n        }\n    );\n\n    let list_string = r#\"[\n        0,\n        1 // <-- forgotten comma here\n        2\n    ]\"#;\n\n    assert_eq!(\n        ron::from_str::<Vec<i32>>(list_string).unwrap_err(),\n        SpannedError {\n            code: Error::ExpectedComma,\n            position: Position { line: 4, col: 9 }\n        }\n    );\n\n    let struct_string = r#\"Test(\n        a: 1 // <-- forgotten comma here\n        b: 2\n    )\"#;\n\n    assert_eq!(\n        ron::from_str::<Test>(struct_string).unwrap_err(),\n        SpannedError {\n            code: Error::ExpectedComma,\n            position: Position { line: 3, col: 9 }\n        }\n    );\n\n    let map_string = r#\"{\n        \"a\": 1 // <-- forgotten comma here\n        \"b\": 2\n    }\"#;\n\n    assert_eq!(\n        ron::from_str::<std::collections::HashMap<String, i32>>(map_string).unwrap_err(),\n        SpannedError {\n            code: Error::ExpectedComma,\n            position: Position { line: 3, col: 9 }\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/256_comma_error.rs::test_comma_end", "test": "fn test_comma_end() {\n    assert_eq!(ron::from_str::<(i32, i32)>(\"(0, 1)\").unwrap(), (0, 1));\n    assert_eq!(ron::from_str::<(i32, i32)>(\"(0, 1,)\").unwrap(), (0, 1));\n    assert_eq!(ron::from_str::<()>(\"()\"), Ok(()));\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/301_struct_name_mismatch.rs::test_unit_struct_name_mismatch", "test": "fn test_unit_struct_name_mismatch() {\n    assert_eq!(ron::from_str::<MyUnitStruct>(\"()\"), Ok(MyUnitStruct),);\n    assert_eq!(\n        ron::from_str::<MyUnitStruct>(\"MyUnitStruct\"),\n        Ok(MyUnitStruct),\n    );\n    assert_eq!(\n        ron::from_str::<MyUnitStruct>(\"MyUnit Struct\"),\n        Err(SpannedError {\n            code: Error::ExpectedDifferentStructName {\n                expected: \"MyUnitStruct\",\n                found: String::from(\"MyUnit\")\n            },\n            position: Position { line: 1, col: 7 }\n        }),\n    );\n    assert_eq!(\n        ron::from_str::<MyUnitStruct>(\"42\"),\n        Err(SpannedError {\n            code: Error::ExpectedNamedStructLike(\"MyUnitStruct\"),\n            position: Position { line: 1, col: 1 }\n        }),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/301_struct_name_mismatch.rs::test_tuple_struct_name_mismatch", "test": "fn test_tuple_struct_name_mismatch() {\n    assert_eq!(\n        ron::from_str::<MyTupleStruct>(\"(true, 42)\"),\n        Ok(MyTupleStruct(true, 42)),\n    );\n    assert_eq!(\n        ron::from_str::<MyTupleStruct>(\"MyTupleStruct(true, 42)\"),\n        Ok(MyTupleStruct(true, 42)),\n    );\n    assert_eq!(\n        ron::from_str::<MyTupleStruct>(\"MyTypleStruct(true, 42)\"),\n        Err(SpannedError {\n            code: Error::ExpectedDifferentStructName {\n                expected: \"MyTupleStruct\",\n                found: String::from(\"MyTypleStruct\")\n            },\n            position: Position { line: 1, col: 14 }\n        }),\n    );\n    assert_eq!(\n        ron::from_str::<MyTupleStruct>(\"42\"),\n        Err(SpannedError {\n            code: Error::ExpectedNamedStructLike(\"MyTupleStruct\"),\n            position: Position { line: 1, col: 1 }\n        }),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/301_struct_name_mismatch.rs::test_newtype_struct_name_mismatch", "test": "fn test_newtype_struct_name_mismatch() {\n    assert_eq!(\n        ron::from_str::<MyNewtypeStruct>(\"((true, 42))\"),\n        Ok(MyNewtypeStruct(MyTupleStruct(true, 42))),\n    );\n    assert_eq!(\n        ron::from_str::<MyNewtypeStruct>(\"MyNewtypeStruct((true, 42))\"),\n        Ok(MyNewtypeStruct(MyTupleStruct(true, 42))),\n    );\n    assert_eq!(\n        ron::from_str::<MyNewtypeStruct>(\"MyNewtypeStrucl((true, 42))\"),\n        Err(SpannedError {\n            code: Error::ExpectedDifferentStructName {\n                expected: \"MyNewtypeStruct\",\n                found: String::from(\"MyNewtypeStrucl\")\n            },\n            position: Position { line: 1, col: 16 }\n        }),\n    );\n    assert_eq!(\n        ron::from_str::<MyNewtypeStruct>(\"42\"),\n        Err(SpannedError {\n            code: Error::ExpectedNamedStructLike(\"MyNewtypeStruct\"),\n            position: Position { line: 1, col: 1 }\n        }),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/301_struct_name_mismatch.rs::test_struct_name_mismatch", "test": "fn test_struct_name_mismatch() {\n    assert_eq!(\n        ron::from_str::<MyStruct>(\"(a: true, b: 42)\"),\n        Ok(MyStruct { a: true, b: 42 }),\n    );\n    assert_eq!(\n        ron::from_str::<MyStruct>(\"MyStruct(a: true, b: 42)\"),\n        Ok(MyStruct { a: true, b: 42 }),\n    );\n    assert_eq!(\n        ron::from_str::<MyStruct>(\"MuStryct(a: true, b: 42)\"),\n        Err(SpannedError {\n            code: Error::ExpectedDifferentStructName {\n                expected: \"MyStruct\",\n                found: String::from(\"MuStryct\")\n            },\n            position: Position { line: 1, col: 9 }\n        }),\n    );\n    assert_eq!(\n        ron::from_str::<MyStruct>(\"42\"),\n        Err(SpannedError {\n            code: Error::ExpectedNamedStructLike(\"MyStruct\"),\n            position: Position { line: 1, col: 1 }\n        }),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/322_escape_idents.rs::roundtrip_ident_with_dash", "test": "fn roundtrip_ident_with_dash() {\n    let value = MyStructWithDashes {\n        my_enum: MyEnumWithDashes::ThisIsMyUnitVariant,\n        my_enum2: MyEnumWithDashes::ThisIsMyTupleVariant(false, -3),\n        will_be_renamed: 32,\n    };\n\n    let serial = ron::ser::to_string(&value).unwrap();\n\n    println!(\"Serialized: {}\", serial);\n\n    let deserial = ron::de::from_str(&serial);\n\n    assert_eq!(Ok(value), deserial);\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/337_value_float_roundtrip.rs::roundtrip_value_float_with_decimals", "test": "fn roundtrip_value_float_with_decimals() {\n    let v: ron::Value = ron::from_str(\"1.0\").unwrap();\n\n    assert_eq!(v, ron::Value::Number(1.0_f64.into()));\n\n    let ser = ron::ser::to_string(&v).unwrap();\n\n    let roundtrip = ron::from_str(&ser).unwrap();\n\n    assert_eq!(v, roundtrip);\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/367_implicit_some.rs::test_recursive_implicit_some", "test": "fn test_recursive_implicit_some() {\n    // Test case provided by d86leader in\n    //  https://github.com/ron-rs/ron/issues/367#issue-1147920589\n\n    let x1: std::result::Result<MaybeFields, _> =\n        ron::from_str(\"#![enable(implicit_some)]\\n(f1: 1)\");\n    let x2: std::result::Result<MaybeFields, _> =\n        ron::from_str(\"#![enable(implicit_some)]\\n(f1: 1, f2: None, f3: None)\");\n    let x3: std::result::Result<MaybeFields, _> =\n        ron::from_str(\"#![enable(implicit_some)]\\n(f1: 1, f2: 2, f3: 3)\");\n    let x4: std::result::Result<MaybeFields, _> =\n        ron::from_str(\"#![enable(implicit_some)]\\n(f1: 1, f2: 2, f3: Some(3))\");\n    let x5: std::result::Result<MaybeFields, _> =\n        ron::from_str(\"#![enable(implicit_some)]\\n(f1: 1, f2: 2, f3: Some(Some(3)))\");\n    let x6: std::result::Result<MaybeFields, _> =\n        ron::from_str(\"#![enable(implicit_some)]\\n(f1: 1, f2: 2, f3: Some(None))\");\n\n    assert_eq!(\n        x1,\n        Ok(MaybeFields {\n            f1: 1,\n            f2: None,\n            f3: None\n        })\n    );\n    assert_eq!(\n        x2,\n        Ok(MaybeFields {\n            f1: 1,\n            f2: None,\n            f3: None\n        })\n    );\n    assert_eq!(\n        x3,\n        Ok(MaybeFields {\n            f1: 1,\n            f2: Some(2),\n            f3: Some(Some(3))\n        })\n    );\n    assert_eq!(\n        x4,\n        Ok(MaybeFields {\n            f1: 1,\n            f2: Some(2),\n            f3: Some(Some(3))\n        })\n    );\n    assert_eq!(\n        x5,\n        Ok(MaybeFields {\n            f1: 1,\n            f2: Some(2),\n            f3: Some(Some(3))\n        })\n    );\n    assert_eq!(\n        x6,\n        Ok(MaybeFields {\n            f1: 1,\n            f2: Some(2),\n            f3: Some(None)\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/367_implicit_some.rs::test_nested_implicit_some", "test": "fn test_nested_implicit_some() {\n    assert_eq!(\n        ron::from_str::<Option<Option<Option<u32>>>>(\"#![enable(implicit_some)]\\n5\"),\n        Ok(Some(Some(Some(5))))\n    );\n    assert_eq!(\n        ron::from_str::<Option<Option<Option<u32>>>>(\"#![enable(implicit_some)]\\nNone\"),\n        Ok(None)\n    );\n    assert_eq!(\n        ron::from_str::<Option<Option<Option<u32>>>>(\"#![enable(implicit_some)]\\nSome(5)\"),\n        Ok(Some(Some(Some(5))))\n    );\n    assert_eq!(\n        ron::from_str::<Option<Option<Option<u32>>>>(\"#![enable(implicit_some)]\\nSome(None)\"),\n        Ok(Some(None))\n    );\n    assert_eq!(\n        ron::from_str::<Option<Option<Option<u32>>>>(\"#![enable(implicit_some)]\\nSome(Some(5))\"),\n        Ok(Some(Some(Some(5))))\n    );\n    assert_eq!(\n        ron::from_str::<Option<Option<Option<u32>>>>(\"#![enable(implicit_some)]\\nSome(Some(None))\"),\n        Ok(Some(Some(None)))\n    );\n    assert_eq!(\n        ron::from_str::<Option<Option<Option<u32>>>>(\n            \"#![enable(implicit_some)]\\nSome(Some(Some(5)))\"\n        ),\n        Ok(Some(Some(Some(5))))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/370_float_parsing.rs::test_float_literal_parsing", "test": "fn test_float_literal_parsing() {\n    assert_eq!(ron::from_str(\"inf\"), Ok(f64::INFINITY));\n    assert_eq!(ron::from_str(\"+inf\"), Ok(f64::INFINITY));\n    assert_eq!(ron::from_str(\"-inf\"), Ok(f64::NEG_INFINITY));\n\n    assert!(ron::from_str::<f64>(\"NaN\").unwrap().is_nan());\n    assert!(ron::from_str::<f64>(\"+NaN\").unwrap().is_nan());\n    assert!(ron::from_str::<f64>(\"-NaN\").unwrap().is_nan());\n\n    assert_eq!(ron::from_str(\"1\"), Ok(1.0_f64));\n    assert_eq!(ron::from_str(\"+1\"), Ok(1.0_f64));\n    assert_eq!(ron::from_str(\"-1\"), Ok(-1.0_f64));\n    assert_eq!(ron::from_str(\"1e3\"), Ok(1000.0_f64));\n    assert_eq!(ron::from_str(\"1e+1\"), Ok(10.0_f64));\n    assert_eq!(ron::from_str(\"7E-1\"), Ok(0.7_f64));\n\n    assert_eq!(ron::from_str(\"1.\"), Ok(1.0_f64));\n    assert_eq!(ron::from_str(\"+1.1\"), Ok(1.1_f64));\n    assert_eq!(ron::from_str(\"-1.42\"), Ok(-1.42_f64));\n    assert_eq!(ron::from_str(\"-1.5e3\"), Ok(-1500.0_f64));\n    assert_eq!(ron::from_str(\"1.e+1\"), Ok(10.0_f64));\n    assert_eq!(ron::from_str(\"7.4E-1\"), Ok(0.74_f64));\n\n    assert_eq!(ron::from_str(\".1\"), Ok(0.1_f64));\n    assert_eq!(ron::from_str(\"+.1\"), Ok(0.1_f64));\n    assert_eq!(ron::from_str(\"-.42\"), Ok(-0.42_f64));\n    assert_eq!(ron::from_str(\"-.5e3\"), Ok(-500.0_f64));\n    assert_eq!(ron::from_str(\".3e+1\"), Ok(3.0_f64));\n    assert_eq!(ron::from_str(\".4E-1\"), Ok(0.04_f64));\n\n    assert_eq!(\n        ron::from_str::<f64>(\"1_0.1_0\"),\n        Err(SpannedError {\n            code: Error::FloatUnderscore,\n            position: Position { line: 1, col: 2 },\n        })\n    );\n    assert_eq!(\n        ron::from_str::<f64>(\"1_0.10\"),\n        Err(SpannedError {\n            code: Error::FloatUnderscore,\n            position: Position { line: 1, col: 2 },\n        })\n    );\n    assert_eq!(\n        ron::from_str::<f64>(\"10.1_0\"),\n        Err(SpannedError {\n            code: Error::FloatUnderscore,\n            position: Position { line: 1, col: 5 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<f64>(\"1.0e1.0\"),\n        Err(SpannedError {\n            code: Error::ExpectedFloat,\n            position: Position { line: 1, col: 8 },\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/393_serde_errors.rs::test_unknown_enum_variant", "test": "fn test_unknown_enum_variant() {\n    assert_eq!(\n        ron::from_str::<TestEnum>(\"NotAVariant\"),\n        Err(SpannedError {\n            code: Error::NoSuchEnumVariant {\n                expected: &[\"StructVariant\", \"NewtypeVariant\"],\n                found: String::from(\"NotAVariant\"),\n                outer: Some(String::from(\"TestEnum\")),\n            },\n            position: Position { line: 1, col: 12 },\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/393_serde_errors.rs::test_struct_enum_fields", "test": "fn test_struct_enum_fields() {\n    assert_eq!(\n        ron::from_str::<TestEnum>(\"StructVariant(a: true, b: 'b', c: -42, d: \\\"gotcha\\\")\"),\n        Err(SpannedError {\n            code: Error::NoSuchStructField {\n                expected: &[\"a\", \"b\", \"c\"],\n                found: String::from(\"d\"),\n                outer: Some(String::from(\"StructVariant\")),\n            },\n            position: Position { line: 1, col: 41 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<TestEnum>(\"StructVariant(a: true, c: -42)\"),\n        Err(SpannedError {\n            code: Error::MissingStructField {\n                field: \"b\",\n                outer: Some(String::from(\"StructVariant\")),\n            },\n            position: Position { line: 1, col: 30 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<TestEnum>(\"StructVariant(a: true, b: 'b', a: false, c: -42)\"),\n        Err(SpannedError {\n            code: Error::DuplicateStructField {\n                field: \"a\",\n                outer: Some(String::from(\"StructVariant\")),\n            },\n            position: Position { line: 1, col: 33 },\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/393_serde_errors.rs::test_newtype_enum_fields", "test": "fn test_newtype_enum_fields() {\n    assert_eq!(\n        ron::from_str::<TestEnum>(\"#![enable(unwrap_variant_newtypes)] NewtypeVariant(a: true, b: 'b', c: -42, d: \\\"gotcha\\\")\"),\n        Err(SpannedError {\n            code: Error::NoSuchStructField {\n                expected: &[\"a\", \"b\", \"c\"],\n                found: String::from(\"d\"),\n                outer: Some(String::from(\"NewtypeVariant\")),\n            },\n            position: Position { line: 1, col: 78 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<TestEnum>(\n            \"#![enable(unwrap_variant_newtypes)] NewtypeVariant(a: true, c: -42)\"\n        ),\n        Err(SpannedError {\n            code: Error::MissingStructField {\n                field: \"b\",\n                outer: Some(String::from(\"NewtypeVariant\")),\n            },\n            position: Position { line: 1, col: 67 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<TestEnum>(\n            \"#![enable(unwrap_variant_newtypes)] NewtypeVariant(a: true, b: 'b', a: false, c: -42)\"\n        ),\n        Err(SpannedError {\n            code: Error::DuplicateStructField {\n                field: \"a\",\n                outer: Some(String::from(\"NewtypeVariant\")),\n            },\n            position: Position { line: 1, col: 70 },\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/393_serde_errors.rs::test_struct_fields", "test": "fn test_struct_fields() {\n    assert_eq!(\n        ron::from_str::<TestStruct>(\"TestStruct(a: true, b: 'b', c: -42, d: \\\"gotcha\\\")\"),\n        Err(SpannedError {\n            code: Error::NoSuchStructField {\n                expected: &[\"a\", \"b\", \"c\"],\n                found: String::from(\"d\"),\n                outer: Some(String::from(\"TestStruct\")),\n            },\n            position: Position { line: 1, col: 38 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<TestStruct>(\"TestStruct(a: true, c: -42)\"),\n        Err(SpannedError {\n            code: Error::MissingStructField {\n                field: \"b\",\n                outer: Some(String::from(\"TestStruct\")),\n            },\n            position: Position { line: 1, col: 27 },\n        })\n    );\n\n    assert_eq!(\n        ron::from_str::<TestStruct>(\"TestStruct(a: true, b: 'b', a: false, c: -42)\"),\n        Err(SpannedError {\n            code: Error::DuplicateStructField {\n                field: \"a\",\n                outer: Some(String::from(\"TestStruct\")),\n            },\n            position: Position { line: 1, col: 30 },\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/393_serde_errors.rs::test_internally_tagged_enum", "test": "fn test_internally_tagged_enum() {\n    // Note: Not extracting the variant type is not great,\n    //        but at least not wrong either\n    //       Since the error occurs in serde-generated user code,\n    //        after successfully deserialising, we cannot annotate\n\n    assert_eq!(\n        ron::from_str::<TestEnumInternal>(\"(type: \\\"StructVariant\\\")\"),\n        Err(SpannedError {\n            code: Error::MissingStructField {\n                field: \"a\",\n                outer: None,\n            },\n            position: Position { line: 1, col: 24 },\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/393_serde_errors.rs::test_adjacently_tagged_enum", "test": "fn test_adjacently_tagged_enum() {\n    // Note: TestEnumAdjacent makes sense here since we are now treating\n    //        the enum as a struct\n\n    assert_eq!(\n        ron::from_str::<TestEnumAdjacent>(\"(type: StructVariant, content: (d: 4))\"),\n        Err(SpannedError {\n            code: Error::MissingStructField {\n                field: \"a\",\n                outer: Some(String::from(\"TestEnumAdjacent\")),\n            },\n            position: Position { line: 1, col: 37 },\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/393_serde_errors.rs::test_untagged_enum", "test": "fn test_untagged_enum() {\n    // Note: Errors inside untagged enums are not bubbled up\n\n    assert_eq!(\n        ron::from_str::<TestEnumUntagged>(\"(a: true, a: false)\"),\n        Err(SpannedError {\n            code: Error::Message(String::from(\n                \"data did not match any variant of untagged enum TestEnumUntagged\"\n            )),\n            position: Position { line: 1, col: 20 },\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/401_raw_identifier.rs::test_invalid_identifiers", "test": "fn test_invalid_identifiers() {\n    let ser = ron::ser::to_string_pretty(\n        &InvalidStruct,\n        ron::ser::PrettyConfig::default().struct_names(true),\n    );\n    assert_eq!(\n        ser,\n        Err(Error::InvalidIdentifier(String::from(\"Hello World\")))\n    );\n\n    let ser = ron::ser::to_string_pretty(\n        &EmptyStruct,\n        ron::ser::PrettyConfig::default().struct_names(true),\n    );\n    assert_eq!(ser, Err(Error::InvalidIdentifier(String::from(\"\"))));\n\n    let de = ron::from_str::<InvalidStruct>(\"Hello World\").unwrap_err();\n    assert_eq!(\n        de,\n        SpannedError {\n            code: Error::ExpectedDifferentStructName {\n                expected: \"Hello World\",\n                found: String::from(\"Hello\"),\n            },\n            position: Position { line: 1, col: 6 },\n        }\n    );\n\n    let de = ron::from_str::<EmptyStruct>(\"\").unwrap_err();\n    assert_eq!(\n        de,\n        SpannedError {\n            code: Error::ExpectedUnit,\n            position: Position { line: 1, col: 1 },\n        }\n    );\n\n    let de = ron::from_str::<EmptyStruct>(\"r#\").unwrap_err();\n    assert_eq!(\n        format!(\"{}\", de),\n        \"1:1: Expected only opening `(`, no name, for un-nameable struct\"\n    );\n\n    let de = ron::from_str::<RawStruct>(\"\").unwrap_err();\n    assert_eq!(\n        de,\n        SpannedError {\n            code: Error::ExpectedNamedStructLike(\"Hello+World\"),\n            position: Position { line: 1, col: 1 },\n        },\n    );\n\n    let de = ron::from_str::<RawStruct>(\"r#\").unwrap_err();\n    assert_eq!(\n        de,\n        SpannedError {\n            code: Error::ExpectedNamedStructLike(\"Hello+World\"),\n            position: Position { line: 1, col: 1 },\n        },\n    );\n\n    let de = ron::from_str::<RawStruct>(\"Hello+World\").unwrap_err();\n    assert_eq!(\n        de,\n        SpannedError {\n            code: Error::SuggestRawIdentifier(String::from(\"Hello+World\")),\n            position: Position { line: 1, col: 1 },\n        }\n    );\n\n    let de = ron::from_str::<RawStruct>(\n        \"r#Hello+World(\n        ab.cd-ef: true,\n    )\",\n    )\n    .unwrap_err();\n    assert_eq!(\n        de,\n        SpannedError {\n            code: Error::SuggestRawIdentifier(String::from(\"ab.cd-ef\")),\n            position: Position { line: 2, col: 9 },\n        }\n    );\n\n    let de = ron::from_str::<RawStruct>(\n        \"r#Hello+World(\n        r#ab.cd+ef: true,\n    )\",\n    )\n    .unwrap_err();\n    assert_eq!(\n        de,\n        SpannedError {\n            code: Error::NoSuchStructField {\n                expected: &[\"ab.cd-ef\"],\n                found: String::from(\"ab.cd+ef\"),\n                outer: Some(String::from(\"Hello+World\")),\n            },\n            position: Position { line: 2, col: 19 },\n        }\n    );\n\n    let de = ron::from_str::<RawEnum>(\"Hello-World\").unwrap_err();\n    assert_eq!(\n        de,\n        SpannedError {\n            code: Error::SuggestRawIdentifier(String::from(\"Hello-World\")),\n            position: Position { line: 1, col: 1 },\n        }\n    );\n\n    let de = ron::from_str::<RawEnum>(\"r#Hello+World\").unwrap_err();\n    assert_eq!(\n        de,\n        SpannedError {\n            code: Error::NoSuchEnumVariant {\n                expected: &[\"Hello-World\"],\n                found: String::from(\"Hello+World\"),\n                outer: Some(String::from(\"RawEnum\")),\n            },\n            position: Position { line: 1, col: 14 },\n        }\n    );\n\n    let de = ron::from_str::<EmptyStruct>(\"r#+\").unwrap_err();\n    assert_eq!(\n        format!(\"{}\", de),\n        r#\"1:4: Expected struct \"\"_[invalid identifier] but found `r#+`\"#,\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/410_trailing_comma.rs::test_trailing_comma_some", "test": "fn test_trailing_comma_some() {\n    assert!(from_str::<Option<i32>>(\"Some(1)\").is_ok());\n    assert!(from_str::<Option<i32>>(\"Some(1,)\").is_ok());\n    assert!(from_str::<Option<i32>>(\"Some(1,,)\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/410_trailing_comma.rs::test_trailing_comma_tuple", "test": "fn test_trailing_comma_tuple() {\n    assert!(from_str::<(i32, i32)>(\"(1,2)\").is_ok());\n    assert!(from_str::<(i32, i32)>(\"(1,2,)\").is_ok());\n    assert!(from_str::<(i32, i32)>(\"(1,2,,)\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/410_trailing_comma.rs::test_trailing_comma_list", "test": "fn test_trailing_comma_list() {\n    assert!(from_str::<Vec<i32>>(\"[1,2]\").is_ok());\n    assert!(from_str::<Vec<i32>>(\"[1,2,]\").is_ok());\n    assert!(from_str::<Vec<i32>>(\"[1,2,,]\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/410_trailing_comma.rs::test_trailing_comma_map", "test": "fn test_trailing_comma_map() {\n    assert!(from_str::<HashMap<i32, bool>>(\"{1:false,2:true}\").is_ok());\n    assert!(from_str::<HashMap<i32, bool>>(\"{1:false,2:true,}\").is_ok());\n    assert!(from_str::<HashMap<i32, bool>>(\"{1:false,2:true,,}\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/410_trailing_comma.rs::test_trailing_comma_newtype_struct", "test": "fn test_trailing_comma_newtype_struct() {\n    assert!(from_str::<Newtype>(\"(1)\").is_ok());\n    assert!(from_str::<Newtype>(\"(1,)\").is_ok());\n    assert!(from_str::<Newtype>(\"(1,,)\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/410_trailing_comma.rs::test_trailing_comma_tuple_struct", "test": "fn test_trailing_comma_tuple_struct() {\n    assert!(from_str::<Tuple>(\"(1,2)\").is_ok());\n    assert!(from_str::<Tuple>(\"(1,2,)\").is_ok());\n    assert!(from_str::<Tuple>(\"(1,2,,)\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/410_trailing_comma.rs::test_trailing_comma_struct", "test": "fn test_trailing_comma_struct() {\n    assert!(from_str::<Struct>(\"(a:1,b:2)\").is_ok());\n    assert!(from_str::<Struct>(\"(a:1,b:2,)\").is_ok());\n    assert!(from_str::<Struct>(\"(a:1,b:2,,)\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/410_trailing_comma.rs::test_trailing_comma_enum_newtype_variant", "test": "fn test_trailing_comma_enum_newtype_variant() {\n    assert!(from_str::<Enum>(\"Newtype(1)\").is_ok());\n    assert!(from_str::<Enum>(\"Newtype(1,)\").is_ok());\n    assert!(from_str::<Enum>(\"Newtype(1,,)\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/410_trailing_comma.rs::test_trailing_comma_enum_tuple_variant", "test": "fn test_trailing_comma_enum_tuple_variant() {\n    assert!(from_str::<Enum>(\"Tuple(1,2)\").is_ok());\n    assert!(from_str::<Enum>(\"Tuple(1,2,)\").is_ok());\n    assert!(from_str::<Enum>(\"Tuple(1,2,,)\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/410_trailing_comma.rs::test_trailing_comma_enum_struct_variant", "test": "fn test_trailing_comma_enum_struct_variant() {\n    assert!(from_str::<Enum>(\"Struct(a:1,b:2)\").is_ok());\n    assert!(from_str::<Enum>(\"Struct(a:1,b:2,)\").is_ok());\n    assert!(from_str::<Enum>(\"Struct(a:1,b:2,,)\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/423_de_borrowed_identifier.rs::manually_deserialize_dyn", "test": "fn manually_deserialize_dyn() {\n    let ron = r#\"SerializeDyn(\n        type: \"engine_utils::types::registry::tests::Player\",\n    )\"#;\n\n    let mut de = ron::Deserializer::from_bytes(ron.as_bytes()).unwrap();\n\n    let result = de\n        .deserialize_struct(\"SerializeDyn\", &[\"type\"], SerializeDynVisitor)\n        .unwrap();\n\n    assert_eq!(\n        *result.downcast::<Option<(String, String)>>().unwrap(),\n        Some((\n            String::from(\"type\"),\n            String::from(\"engine_utils::types::registry::tests::Player\")\n        ))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/borrowed_str.rs::borrowed_str", "test": "fn borrowed_str() {\n    assert_eq!(\n        ron::de::from_str(BORROWED).ok(),\n        Some(Borrowed { value: \"test\" })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/comments.rs::test_nested", "test": "fn test_nested() {\n    assert_eq!(\n        from_str(\n            \"/*\n        /* quite * some * nesting * going * on * /* here /* (yeah, maybe a bit too much) */ */ */\n    */\n    // The actual value comes.. /*\n    // very soon, these are just checks that */\n    // multi-line comments don't trigger in line comments /*\n\\\"THE VALUE\\\" /* This is the value /* :) */ */\n    \"\n        ),\n        Ok(\"THE VALUE\".to_owned())\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/comments.rs::test_unclosed", "test": "fn test_unclosed() {\n    assert_eq!(\n        from_str::<String>(\n            \"/*\n        /* quite * some * nesting * going * on * /* here /* (yeah, maybe a bit too much) */ */ */\n    */\n    // The actual value comes.. /*\n    // very soon, these are just checks that */\n    // multi-line comments don't trigger in line comments /*\n/* Unfortunately, this comment won't get closed :(\n\\\"THE VALUE (which is invalid)\\\"\n\"\n        ),\n        Err(RonErr {\n            code: Error::UnclosedBlockComment,\n            position: Position { col: 1, line: 9 }\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/large_number.rs::test_large_number", "test": "fn test_large_number() {\n    let test_var = Value::Number(Number::new(10000000000000000000000.0f64));\n    let test_ser = ron::ser::to_string(&test_var).unwrap();\n    let test_deser = ron::de::from_str::<Value>(&test_ser);\n\n    assert_eq!(\n        test_deser.unwrap(),\n        Value::Number(Number::new(10000000000000000000000.0))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_i32_min", "test": "fn test_i32_min() {\n    assert_eq!(\n        std::i32::MIN,\n        from_str(&to_string(&std::i32::MIN).unwrap()).unwrap()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_i32_max", "test": "fn test_i32_max() {\n    assert_eq!(\n        std::i32::MAX,\n        from_str(&to_string(&std::i32::MAX).unwrap()).unwrap()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_i64_min", "test": "fn test_i64_min() {\n    assert_eq!(\n        std::i64::MIN,\n        from_str(&to_string(&std::i64::MIN).unwrap()).unwrap()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_i64_max", "test": "fn test_i64_max() {\n    assert_eq!(\n        std::i64::MAX,\n        from_str(&to_string(&std::i64::MAX).unwrap()).unwrap()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_i128_min", "test": "fn test_i128_min() {\n    assert_eq!(\n        std::i128::MIN,\n        from_str(&to_string(&std::i128::MIN).unwrap()).unwrap()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_i128_max", "test": "fn test_i128_max() {\n    assert_eq!(\n        std::i128::MAX,\n        from_str(&to_string(&std::i128::MAX).unwrap()).unwrap()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_u128_min", "test": "fn test_u128_min() {\n    assert_eq!(\n        std::u128::MIN,\n        from_str(&to_string(&std::u128::MIN).unwrap()).unwrap()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/min_max.rs::test_u128_max", "test": "fn test_u128_max() {\n    assert_eq!(\n        std::u128::MAX,\n        from_str(&to_string(&std::u128::MAX).unwrap()).unwrap()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/roundtrip.rs::roundtrip", "test": "fn roundtrip() {\n    let value = Struct {\n        tuple: ((), NewType(0.5), TupleStruct(UnitStruct, -5)),\n        vec: vec![None, Some(UnitStruct)],\n        map: vec![\n            (Key(5), Enum::Unit),\n            (Key(6), Enum::Bool(false)),\n            (Key(7), Enum::Bool(true)),\n            (Key(9), Enum::Chars('x', \"\".to_string())),\n        ]\n        .into_iter()\n        .collect(),\n    };\n\n    let serial = ron::ser::to_string(&value).unwrap();\n\n    println!(\"Serialized: {}\", serial);\n\n    let deserial = ron::de::from_str(&serial);\n\n    assert_eq!(Ok(value), deserial);\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/roundtrip.rs::roundtrip_pretty", "test": "fn roundtrip_pretty() {\n    let value = Struct {\n        tuple: ((), NewType(0.5), TupleStruct(UnitStruct, -5)),\n        vec: vec![None, Some(UnitStruct)],\n        map: vec![\n            (Key(5), Enum::Unit),\n            (Key(6), Enum::Bool(false)),\n            (Key(7), Enum::Bool(true)),\n            (Key(9), Enum::Chars('x', \"\".to_string())),\n        ]\n        .into_iter()\n        .collect(),\n    };\n\n    let pretty = ron::ser::PrettyConfig::new()\n        .enumerate_arrays(true)\n        .extensions(Extensions::IMPLICIT_SOME);\n    let serial = ron::ser::to_string_pretty(&value, pretty).unwrap();\n\n    println!(\"Serialized: {}\", serial);\n\n    let deserial = ron::de::from_str(&serial);\n\n    assert_eq!(Ok(value), deserial);\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/roundtrip.rs::roundtrip_sep_tuple_members", "test": "fn roundtrip_sep_tuple_members() {\n    #[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]\n    pub enum FileOrMem {\n        File(String),\n        Memory,\n    }\n\n    #[derive(Debug, Deserialize, PartialEq, Serialize)]\n    struct Both {\n        a: Struct,\n        b: FileOrMem,\n    }\n\n    let a = Struct {\n        tuple: ((), NewType(0.5), TupleStruct(UnitStruct, -5)),\n        vec: vec![None, Some(UnitStruct)],\n        map: vec![\n            (Key(5), Enum::Unit),\n            (Key(6), Enum::Bool(false)),\n            (Key(7), Enum::Bool(true)),\n            (Key(9), Enum::Chars('x', \"\".to_string())),\n        ]\n        .into_iter()\n        .collect(),\n    };\n    let b = FileOrMem::File(\"foo\".to_owned());\n\n    let value = Both { a, b };\n\n    let pretty = ron::ser::PrettyConfig::new().separate_tuple_members(true);\n    let serial = ron::ser::to_string_pretty(&value, pretty).unwrap();\n\n    println!(\"Serialized: {}\", serial);\n\n    let deserial = ron::de::from_str(&serial);\n\n    assert_eq!(Ok(value), deserial);\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/value.rs::bool", "test": "fn bool() {\n    assert_eq!(\"true\".parse(), Ok(Value::Bool(true)));\n    assert_eq!(\"false\".parse(), Ok(Value::Bool(false)));\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/value.rs::char", "test": "fn char() {\n    assert_eq!(\"'a'\".parse(), Ok(Value::Char('a')));\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/value.rs::map", "test": "fn map() {\n    let mut map = Map::new();\n    map.insert(Value::Char('a'), Value::Number(Number::new(1)));\n    map.insert(Value::Char('b'), Value::Number(Number::new(2f64)));\n    assert_eq!(\"{ 'a': 1, 'b': 2.0 }\".parse(), Ok(Value::Map(map)));\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/value.rs::number", "test": "fn number() {\n    assert_eq!(\"42\".parse(), Ok(Value::Number(Number::new(42))));\n    assert_eq!(\n        \"3.141592653589793\".parse(),\n        Ok(Value::Number(Number::new(f64::consts::PI)))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/value.rs::option", "test": "fn option() {\n    let opt = Some(Box::new(Value::Char('c')));\n    assert_eq!(\"Some('c')\".parse(), Ok(Value::Option(opt)));\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/value.rs::string", "test": "fn string() {\n    let normal = \"\\\"String\\\"\";\n    assert_eq!(normal.parse(), Ok(Value::String(\"String\".into())));\n\n    let raw = \"r\\\"Raw String\\\"\";\n    assert_eq!(raw.parse(), Ok(Value::String(\"Raw String\".into())));\n\n    let raw_hashes = \"r#\\\"Raw String\\\"#\";\n    assert_eq!(raw_hashes.parse(), Ok(Value::String(\"Raw String\".into())));\n\n    let raw_escaped = \"r##\\\"Contains \\\"#\\\"##\";\n    assert_eq!(\n        raw_escaped.parse(),\n        Ok(Value::String(\"Contains \\\"#\".into()))\n    );\n\n    let raw_multi_line = \"r\\\"Multi\\nLine\\\"\";\n    assert_eq!(\n        raw_multi_line.parse(),\n        Ok(Value::String(\"Multi\\nLine\".into()))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/value.rs::seq", "test": "fn seq() {\n    let seq = vec![\n        Value::Number(Number::new(1)),\n        Value::Number(Number::new(2f64)),\n    ];\n    assert_eq!(\"[1, 2.0]\".parse(), Ok(Value::Seq(seq)));\n\n    let err = Value::Seq(vec![Value::Number(Number::new(1))])\n        .into_rust::<[i32; 2]>()\n        .unwrap_err();\n\n    assert_eq!(\n        err,\n        Error::ExpectedDifferentLength {\n            expected: String::from(\"an array of length 2\"),\n            found: 1,\n        }\n    );\n\n    let err = Value::Seq(vec![\n        Value::Number(Number::new(1)),\n        Value::Number(Number::new(2)),\n        Value::Number(Number::new(3)),\n    ])\n    .into_rust::<[i32; 2]>()\n    .unwrap_err();\n\n    assert_eq!(\n        err,\n        Error::ExpectedDifferentLength {\n            expected: String::from(\"a sequence of length 2\"),\n            found: 3,\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "ron-rs-ron/ron-rs-ron-eafa2b6/tests/value.rs::unit", "test": "fn unit() {\n    use ron::error::{Error, Position, SpannedError};\n\n    assert_eq!(\"()\".parse(), Ok(Value::Unit));\n    assert_eq!(\"Foo\".parse(), Ok(Value::Unit));\n\n    assert_eq!(\n        \"\".parse::<Value>(),\n        Err(SpannedError {\n            code: Error::Eof,\n            position: Position { col: 1, line: 1 }\n        })\n    );\n}", "error": "Not Definition Found"}
