{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::dynamic_add2_works", "test": "fn dynamic_add2_works() {\n    let (mut store, add2, add2_dyn) = setup_add2();\n    for a in 0..10 {\n        for b in 0..10 {\n            let params = [Value::I32(a), Value::I32(b)];\n            let expected = a + b;\n            let mut result = Value::I32(0);\n            // Call to Func with statically typed closure.\n            add2.call(&mut store, &params, slice::from_mut(&mut result))\n                .unwrap();\n            // Reset result before execution.\n            result = Value::I32(0);\n            // Call to Func with dynamically typed closure.\n            add2_dyn\n                .call(&mut store, &params, slice::from_mut(&mut result))\n                .unwrap();\n            assert_eq!(result.i32(), Some(expected));\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::dynamic_add3_works", "test": "fn dynamic_add3_works() {\n    let (mut store, add3, add3_dyn) = setup_add3();\n    for a in 0..5 {\n        for b in 0..5 {\n            for c in 0..5 {\n                let params = [Value::I32(a), Value::I32(b), Value::I32(c)];\n                let expected = a + b + c;\n                let mut result = Value::I32(0);\n                // Call to Func with statically typed closure.\n                add3.call(&mut store, &params, slice::from_mut(&mut result))\n                    .unwrap();\n                assert_eq!(result.i32(), Some(expected));\n                // Reset result before execution.\n                result = Value::I32(0);\n                // Call to Func with dynamically typed closure.\n                add3_dyn\n                    .call(&mut store, &params, slice::from_mut(&mut result))\n                    .unwrap();\n                assert_eq!(result.i32(), Some(expected));\n            }\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::dynamic_duplicate_works", "test": "fn dynamic_duplicate_works() {\n    let (mut store, duplicate, duplicate_dyn) = setup_duplicate();\n    for input in 0..10 {\n        let params = [Value::I32(input)];\n        let expected = [Value::I32(input), Value::I32(input)];\n        let mut results = [Value::I32(0), Value::I32(0)];\n        // Call to Func with statically typed closure.\n        duplicate.call(&mut store, &params, &mut results).unwrap();\n        assert_eq!(results[0].i32(), expected[0].i32());\n        assert_eq!(results[1].i32(), expected[1].i32());\n        // Reset result before execution.\n        results = [Value::I32(0), Value::I32(0)];\n        // Call to Func with dynamically typed closure.\n        duplicate_dyn\n            .call(&mut store, &params, &mut results)\n            .unwrap();\n        assert_eq!(results[0].i32(), expected[0].i32());\n        assert_eq!(results[1].i32(), expected[1].i32());\n    }\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::static_many_params_works", "test": "fn static_many_params_works() {\n    let (mut store, func) = setup_many_params();\n    let typed_func = func.typed::<I32x16, ()>(&mut store).unwrap();\n    let inputs = ascending_tuple();\n    let result = typed_func.call(&mut store, inputs);\n    assert_matches!(result, Ok(()));\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::dynamic_many_results_works", "test": "fn dynamic_many_results_works() {\n    let (mut store, func) = setup_many_results();\n    let mut results = [0; 16].map(Value::I32);\n    func.call(&mut store, &[], &mut results).unwrap();\n    let mut i = 0;\n    let expected = [0; 16].map(|_| {\n        let value = Value::I32(i as _);\n        i += 1;\n        value\n    });\n    assert_eq!(\n        results.map(|result| result.i32().unwrap()),\n        expected.map(|expected| expected.i32().unwrap())\n    )\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::dynamic_many_params_many_results_works", "test": "fn dynamic_many_params_many_results_works() {\n    let (mut store, func) = setup_many_params_many_results();\n    let mut results = [0; 16].map(Value::I32);\n    let inputs = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15].map(Value::I32);\n    func.call(&mut store, &inputs, &mut results).unwrap();\n    assert_eq!(\n        results.map(|result| result.i32().unwrap()),\n        inputs.map(|input| input.i32().unwrap()),\n    )\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::dynamic_many_types_works", "test": "fn dynamic_many_types_works() {\n    let mut store = test_setup();\n    // Function taking no arguments and returning 16 results as tuple (maximum).\n    let func = Func::wrap(\n        &mut store,\n        |v0: i32, v1: u32, v2: i64, v3: u64, v4: F32, v5: F64| (v0, v1, v2, v3, v4, v5),\n    );\n    let mut results = [0; 6].map(Value::I32);\n    let inputs = [\n        Value::I32(0),\n        Value::I32(1),\n        Value::I64(2),\n        Value::I64(3),\n        Value::F32(4.0.into()),\n        Value::F64(5.0.into()),\n    ];\n    func.call(&mut store, &inputs, &mut results).unwrap();\n    assert_eq!(results[0].i32(), Some(0));\n    assert_eq!(results[1].i32(), Some(1));\n    assert_eq!(results[2].i64(), Some(2));\n    assert_eq!(results[3].i64(), Some(3));\n    assert_eq!(results[4].f32(), Some(4.0.into()));\n    assert_eq!(results[5].f64(), Some(5.0.into()));\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::static_type_check_works", "test": "fn static_type_check_works() {\n    let mut store = test_setup();\n    let identity = Func::wrap(&mut store, |value: i32| value);\n    // Case: Too few inputs given to function.\n    assert_matches!(\n        identity.typed::<(), i32>(&mut store),\n        Err(Error::Func(FuncError::MismatchingParameterLen))\n    );\n    // Case: Too many inputs given to function.\n    assert_matches!(\n        identity.typed::<(i32, i32), i32>(&mut store),\n        Err(Error::Func(FuncError::MismatchingParameterLen))\n    );\n    // Case: Too few results given to function.\n    assert_matches!(\n        identity.typed::<i32, ()>(&mut store),\n        Err(Error::Func(FuncError::MismatchingResultLen))\n    );\n    // Case: Too many results given to function.\n    assert_matches!(\n        identity.typed::<i32, (i32, i32)>(&mut store),\n        Err(Error::Func(FuncError::MismatchingResultLen))\n    );\n    // Case: Mismatching type given as input to function.\n    assert_matches!(\n        identity.typed::<i64, i32>(&mut store),\n        Err(Error::Func(FuncError::MismatchingParameterType))\n    );\n    // Case: Mismatching type given as output of function.\n    assert_matches!(\n        identity.typed::<i32, i64>(&mut store),\n        Err(Error::Func(FuncError::MismatchingResultType))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resource_limiter.rs::test_big_memory_fails_to_instantiate", "test": "fn test_big_memory_fails_to_instantiate() {\n    let loose_limits = StoreLimitsBuilder::new().memory_size(0x30_0000).build();\n    let tight_limits = StoreLimitsBuilder::new().memory_size(0x20_0000).build();\n    assert!(Test::new(0x30, 0, loose_limits).is_ok());\n    assert!(Test::new(0x30, 0, tight_limits).is_err());\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resource_limiter.rs::test_big_table_fails_to_instantiate", "test": "fn test_big_table_fails_to_instantiate() {\n    let loose_limits = StoreLimitsBuilder::new().table_elements(100).build();\n    let tight_limits = StoreLimitsBuilder::new().table_elements(99).build();\n    assert!(Test::new(0x30, 100, loose_limits).is_ok());\n    assert!(Test::new(0x30, 100, tight_limits).is_err());\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resource_limiter.rs::test_memory_count_limit", "test": "fn test_memory_count_limit() {\n    let limits = StoreLimitsBuilder::new().memories(0).build();\n    assert!(Test::new(0x30, 100, limits).is_err());\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resource_limiter.rs::test_instance_count_limit", "test": "fn test_instance_count_limit() {\n    let limits = StoreLimitsBuilder::new().instances(0).build();\n    assert!(Test::new(0x30, 100, limits).is_err());\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resource_limiter.rs::test_tables_count_limit", "test": "fn test_tables_count_limit() {\n    let limits = StoreLimitsBuilder::new().tables(0).build();\n    assert!(Test::new(0x30, 100, limits).is_err());\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resource_limiter.rs::test_memory_does_not_grow_on_limited_growth", "test": "fn test_memory_does_not_grow_on_limited_growth() -> Result<(), Error> {\n    let limits = StoreLimitsBuilder::new().memory_size(0x30_0000).build();\n    let mut test = Test::new(0x20, 100, limits)?;\n    // By default the policy of a memory.grow failure is just for the instruction\n    // to return -1 and not-grow the underlying memory. We also have the option to\n    // trap on failure, which is exercised by the next test below.\n\n    // Check memory size is what we expect.\n    assert_eq!(test.memory_size.call(&mut test.store, ())?, 0x20);\n    // First memory.grow doesn't hit the limit, so succeeds, returns previous size.\n    assert_eq!(test.memory_grow.call(&mut test.store, (0x10,))?, 0x20);\n    // Check memory size is what we expect.\n    assert_eq!(test.memory_size.call(&mut test.store, ())?, 0x30);\n    // Second call goes past the limit, so fails to grow the memory, but returns Ok(-1)\n    assert_eq!(test.memory_grow.call(&mut test.store, (0x10,))?, -1);\n    // Check memory size is what we expect.\n    assert_eq!(test.memory_size.call(&mut test.store, ())?, 0x30);\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resource_limiter.rs::test_memory_traps_on_limited_growth", "test": "fn test_memory_traps_on_limited_growth() -> Result<(), Error> {\n    let limits = StoreLimitsBuilder::new()\n        .memory_size(0x30_0000)\n        .trap_on_grow_failure(true)\n        .build();\n    let mut test = Test::new(0x20, 100, limits)?;\n    // Check memory size is what we expect.\n    assert_eq!(test.memory_size.call(&mut test.store, ())?, 0x20);\n    // First memory.grow doesn't hit the limit, so succeeds, returns previous size.\n    assert_eq!(test.memory_grow.call(&mut test.store, (0x10,))?, 0x20);\n    // Check memory size is what we expect.\n    assert_eq!(test.memory_size.call(&mut test.store, ())?, 0x30);\n    // Second call goes past the limit, so fails to grow the memory, and we've configured it to trap.\n    assert!(matches!(\n        test.memory_grow\n            .call(&mut test.store, (0x10,))\n            .unwrap_err()\n            .trap_code(),\n        Some(TrapCode::GrowthOperationLimited)\n    ));\n    // Check memory size is what we expect.\n    assert_eq!(test.memory_size.call(&mut test.store, ())?, 0x30);\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resource_limiter.rs::test_table_does_not_grow_on_limited_growth", "test": "fn test_table_does_not_grow_on_limited_growth() -> Result<(), Error> {\n    let limits = StoreLimitsBuilder::new().table_elements(100).build();\n    let mut test = Test::new(0x20, 99, limits)?;\n    // By default the policy of a table.grow failure is just for the instruction\n    // to return -1 and not-grow the underlying table. We also have the option to\n    // trap on failure, which is exercised by the next test below.\n\n    // Check table size is what we expect.\n    assert_eq!(test.table_size.call(&mut test.store, ())?, 99);\n    // First table.grow doesn't hit the limit, so succeeds, returns previous size.\n    assert_eq!(test.table_grow.call(&mut test.store, (1,))?, 99);\n    // Check table size is what we expect.\n    assert_eq!(test.table_size.call(&mut test.store, ())?, 100);\n    // Second call goes past the limit, so fails to grow the table, but returns Ok(-1)\n    assert_eq!(test.table_grow.call(&mut test.store, (1,))?, -1);\n    // Check table size is what we expect.\n    assert_eq!(test.table_size.call(&mut test.store, ())?, 100);\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resource_limiter.rs::test_table_traps_on_limited_growth", "test": "fn test_table_traps_on_limited_growth() -> Result<(), Error> {\n    let limits = StoreLimitsBuilder::new()\n        .table_elements(100)\n        .trap_on_grow_failure(true)\n        .build();\n    let mut test = Test::new(0x20, 99, limits)?;\n    // Check table size is what we expect.\n    assert_eq!(test.table_size.call(&mut test.store, ())?, 99);\n    // First table.grow doesn't hit the limit, so succeeds, returns previous size.\n    assert_eq!(test.table_grow.call(&mut test.store, (1,))?, 99);\n    // Check table size is what we expect.\n    assert_eq!(test.table_size.call(&mut test.store, ())?, 100);\n    // Second call goes past the limit, so fails to grow the table, and we've configured it to trap.\n    assert!(matches!(\n        test.table_grow\n            .call(&mut test.store, (1,))\n            .unwrap_err()\n            .trap_code(),\n        Some(TrapCode::GrowthOperationLimited)\n    ));\n    // Check table size is what we expect.\n    assert_eq!(test.table_size.call(&mut test.store, ())?, 100);\n    Ok(())\n}", "error": "Not Definition Found"}
