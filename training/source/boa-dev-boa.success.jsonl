{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/allocation.rs::gc_basic_cell_allocation", "test": "fn gc_basic_cell_allocation() {\n    run_test(|| {\n        let gc_cell = Gc::new(GcRefCell::new(16_u16));\n\n        force_collect();\n        Harness::assert_collections(1);\n        Harness::assert_bytes_allocated();\n        assert_eq!(*gc_cell.borrow_mut(), 16);\n    });\n}", "code_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/cell.rs::borrow_mut", "code": "pub fn borrow_mut(&self) -> GcRefMut<'_, T> {\n        match self.try_borrow_mut() {\n            Ok(value) => value,\n            Err(e) => panic!(\"{}\", e),\n        }\n    }", "docstring": null}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_weak_gc_test", "test": "fn eph_weak_gc_test() {\n    run_test(|| {\n        let gc_value = Gc::new(3);\n\n        {\n            let cloned_gc = gc_value.clone();\n\n            let weak = WeakGc::new(&cloned_gc);\n\n            assert_eq!(*weak.upgrade().expect(\"Is live currently\"), 3);\n            drop(cloned_gc);\n            force_collect();\n            assert_eq!(*weak.upgrade().expect(\"WeakGc is still live here\"), 3);\n\n            drop(gc_value);\n            force_collect();\n\n            assert!(weak.upgrade().is_none());\n        }\n    });\n}", "code_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/cursor/mod.rs::expect", "code": "pub(super) fn expect<K>(\n        &mut self,\n        kind: K,\n        context: &'static str,\n        interner: &mut Interner,\n    ) -> ParseResult<Token>\n    where\n        K: Into<TokenKind>,\n    {\n        let next_token = self.next(interner).or_abrupt()?;\n        let kind = kind.into();\n\n        if next_token.kind() == &kind {\n            Ok(next_token)\n        } else {\n            Err(Error::expected(\n                [kind.to_string(interner)],\n                next_token.to_string(interner),\n                next_token.span(),\n                context,\n            ))\n        }\n    }", "docstring": null}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_ephemeron_test", "test": "fn eph_ephemeron_test() {\n    run_test(|| {\n        let gc_value = Gc::new(3);\n\n        {\n            let cloned_gc = gc_value.clone();\n\n            let ephemeron = Ephemeron::new(&cloned_gc, String::from(\"Hello World!\"));\n\n            assert_eq!(\n                *ephemeron.value().expect(\"Ephemeron is live\"),\n                String::from(\"Hello World!\")\n            );\n            drop(cloned_gc);\n            force_collect();\n            assert_eq!(\n                *ephemeron.value().expect(\"Ephemeron is still live here\"),\n                String::from(\"Hello World!\")\n            );\n\n            drop(gc_value);\n            force_collect();\n\n            assert!(ephemeron.value().is_none());\n        }\n    });\n}", "code_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/cursor/mod.rs::expect", "code": "pub(super) fn expect<K>(\n        &mut self,\n        kind: K,\n        context: &'static str,\n        interner: &mut Interner,\n    ) -> ParseResult<Token>\n    where\n        K: Into<TokenKind>,\n    {\n        let next_token = self.next(interner).or_abrupt()?;\n        let kind = kind.into();\n\n        if next_token.kind() == &kind {\n            Ok(next_token)\n        } else {\n            Err(Error::expected(\n                [kind.to_string(interner)],\n                next_token.to_string(interner),\n                next_token.span(),\n                context,\n            ))\n        }\n    }", "docstring": null}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_allocation_chains", "test": "fn eph_allocation_chains() {\n    run_test(|| {\n        let gc_value = Gc::new(String::from(\"foo\"));\n\n        {\n            let cloned_gc = gc_value.clone();\n            let weak = WeakGc::new(&cloned_gc);\n            let wrap = Gc::new(weak);\n\n            assert_eq!(wrap.upgrade().as_deref().map(String::as_str), Some(\"foo\"));\n\n            let eph = Ephemeron::new(&wrap, 3);\n\n            drop(cloned_gc);\n            force_collect();\n            assert_eq!(wrap.upgrade().as_deref().map(String::as_str), Some(\"foo\"));\n            assert_eq!(eph.value(), Some(3));\n\n            drop(gc_value);\n            force_collect();\n            assert!(wrap.upgrade().is_none());\n            assert_eq!(eph.value(), Some(3));\n\n            drop(wrap);\n            force_collect();\n            assert!(eph.value().is_none());\n        }\n    });\n}", "code_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/builtins/iterable/mod.rs::map", "code": "pub fn map(&self) -> JsObject {\n        self.map.clone()\n    }", "docstring": null}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_basic_alloc_dump_test", "test": "fn eph_basic_alloc_dump_test() {\n    run_test(|| {\n        let gc_value = Gc::new(String::from(\"gc here\"));\n        let _gc_two = Gc::new(\"hmmm\");\n\n        let eph = Ephemeron::new(&gc_value, 4);\n        let _fourth = Gc::new(\"tail\");\n\n        assert_eq!(eph.value(), Some(4));\n    });\n}", "code_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/internals/ephemeron_box.rs::value", "code": "pub(crate) fn value(&self) -> Option<&V> {\n        // SAFETY: the garbage collector ensures `ptr` is valid as long as `data` is `Some`.\n        unsafe { self.data.get().map(|ptr| &ptr.as_ref().value) }\n    }", "docstring": null}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_basic_clone_test", "test": "fn eph_basic_clone_test() {\n    run_test(|| {\n        let init_gc = Gc::new(String::from(\"bar\"));\n\n        let weak = WeakGc::new(&init_gc);\n\n        let new_gc = weak.upgrade().expect(\"Weak is live\");\n        let new_weak = weak.clone();\n\n        drop(weak);\n        force_collect();\n\n        assert_eq!(*new_gc, *new_weak.upgrade().expect(\"weak should be live\"));\n        assert_eq!(\n            *init_gc,\n            *new_weak.upgrade().expect(\"weak_should be live still\")\n        );\n    });\n}", "code_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/cursor/mod.rs::expect", "code": "pub(super) fn expect<K>(\n        &mut self,\n        kind: K,\n        context: &'static str,\n        interner: &mut Interner,\n    ) -> ParseResult<Token>\n    where\n        K: Into<TokenKind>,\n    {\n        let next_token = self.next(interner).or_abrupt()?;\n        let kind = kind.into();\n\n        if next_token.kind() == &kind {\n            Ok(next_token)\n        } else {\n            Err(Error::expected(\n                [kind.to_string(interner)],\n                next_token.to_string(interner),\n                next_token.span(),\n                context,\n            ))\n        }\n    }", "docstring": null}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak.rs::eph_finalizer", "test": "fn eph_finalizer() {\n    #[derive(Clone, Trace)]\n    struct S {\n        #[unsafe_ignore_trace]\n        inner: Rc<Cell<bool>>,\n    }\n\n    impl Finalize for S {\n        fn finalize(&self) {\n            self.inner.set(true);\n        }\n    }\n\n    run_test(|| {\n        let val = S {\n            inner: Rc::new(Cell::new(false)),\n        };\n\n        let key = Gc::new(50u32);\n        let eph = Ephemeron::new(&key, Gc::new(val.clone()));\n        assert!(eph.has_value());\n        // finalize hasn't been run\n        assert!(!val.inner.get());\n\n        drop(key);\n        force_collect();\n        assert!(!eph.has_value());\n        // finalize ran when collecting\n        assert!(val.inner.get());\n    });\n}", "code_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/pointers/ephemeron.rs::has_value", "code": "pub fn has_value(&self) -> bool {\n        // SAFETY: this is safe because `Ephemeron` is tracked to always point to a valid pointer\n        // `inner_ptr`.\n        unsafe { self.inner_ptr.get().as_ref().value().is_some() }\n    }", "docstring": null}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak_map.rs::weak_map_basic", "test": "fn weak_map_basic() {\n    run_test(|| {\n        let key1 = Gc::new(String::from(\"key1\"));\n        let key2 = Gc::new(String::from(\"key2\"));\n        let key3 = Gc::new(String::from(\"key3\"));\n\n        assert!(!has_weak_maps());\n\n        let mut map = WeakMap::new();\n\n        assert!(has_weak_maps());\n\n        map.insert(&key1, ());\n        map.insert(&key2, ());\n        map.insert(&key3, ());\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        assert!(map.contains_key(&key1));\n        assert!(map.contains_key(&key2));\n        assert!(map.contains_key(&key3));\n\n        drop(key1);\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        assert!(map.contains_key(&key2));\n        assert!(map.contains_key(&key3));\n\n        drop(key2);\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        assert!(map.contains_key(&key3));\n        assert!(has_weak_maps());\n\n        drop(key3);\n\n        assert!(has_weak_maps());\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        drop(map);\n\n        force_collect();\n        assert!(!has_weak_maps());\n    });\n}", "code_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/lib.rs::has_weak_maps", "code": "pub fn has_weak_maps() -> bool {\n    BOA_GC.with(|current| {\n        let gc = current.borrow();\n\n        gc.weak_map_start.get().is_some()\n    })\n}", "docstring": null}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak_map.rs::weak_map_multiple", "test": "fn weak_map_multiple() {\n    run_test(|| {\n        let key1 = Gc::new(String::from(\"key1\"));\n        let key2 = Gc::new(String::from(\"key2\"));\n        let key3 = Gc::new(String::from(\"key3\"));\n\n        assert!(!has_weak_maps());\n\n        let mut map_1 = WeakMap::new();\n        let mut map_2 = WeakMap::new();\n\n        assert!(has_weak_maps());\n\n        map_1.insert(&key1, ());\n        map_1.insert(&key2, ());\n        map_2.insert(&key3, ());\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        assert!(map_1.contains_key(&key1));\n        assert!(map_1.contains_key(&key2));\n        assert!(!map_1.contains_key(&key3));\n        assert!(!map_2.contains_key(&key1));\n        assert!(!map_2.contains_key(&key2));\n        assert!(map_2.contains_key(&key3));\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        drop(key1);\n        drop(key2);\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        assert!(!map_1.contains_key(&key3));\n        assert!(map_2.contains_key(&key3));\n\n        drop(key3);\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        drop(map_1);\n\n        force_collect();\n        assert!(has_weak_maps());\n\n        drop(map_2);\n\n        force_collect();\n        assert!(!has_weak_maps());\n    });\n}", "code_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/lib.rs::has_weak_maps", "code": "pub fn has_weak_maps() -> bool {\n    BOA_GC.with(|current| {\n        let gc = current.borrow();\n\n        gc.weak_map_start.get().is_some()\n    })\n}", "docstring": null}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_gc/src/test/weak_map.rs::weak_map_key_live", "test": "fn weak_map_key_live() {\n    run_test(|| {\n        let key = Gc::new(String::from(\"key\"));\n        let key_copy = key.clone();\n\n        let mut map = WeakMap::new();\n\n        map.insert(&key, ());\n\n        assert!(map.contains_key(&key));\n        assert!(map.contains_key(&key_copy));\n\n        assert_eq!(map.remove(&key), Some(()));\n\n        map.insert(&key, ());\n\n        drop(key);\n\n        force_collect();\n\n        assert!(map.contains_key(&key_copy));\n    });\n}", "code_id": "boa-dev-boa/boa-dev-boa-6008683/boa_engine/src/builtins/map/ordered_map.rs::contains_key", "code": "pub fn contains_key(&self, key: &JsValue) -> bool {\n        self.map.contains_key(key)\n    }", "docstring": null}
{"test_id": "boa-dev-boa/boa-dev-boa-6008683/boa_parser/src/parser/tests/mod.rs::spread_in_arrow_function", "test": "fn spread_in_arrow_function() {\n    let s = r#\"\n    (...b) => {\n        b\n    }\n    \"#;\n\n    let interner = &mut Interner::default();\n    let b = interner.get_or_intern_static(\"b\", utf16!(\"b\"));\n    let params = FormalParameterList::from(FormalParameter::new(\n        Variable::from_identifier(b.into(), None),\n        true,\n    ));\n    assert_eq!(params.flags(), FormalParameterListFlags::HAS_REST_PARAMETER);\n    assert_eq!(params.length(), 0);\n    check_script_parser(\n        s,\n        vec![Statement::Expression(Expression::from(ArrowFunction::new(\n            None,\n            params,\n            FunctionBody::new(\n                vec![Statement::Expression(Expression::from(Identifier::from(b))).into()].into(),\n            ),\n        )))\n        .into()],\n        interner,\n    );\n}", "code_id": "boa-dev-boa/boa-dev-boa-6008683/boa_ast/src/function/parameters.rs::flags", "code": "pub const fn flags(&self) -> FormalParameterListFlags {\n        self.flags\n    }", "docstring": null}
