{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_basename.rs::test_version", "test": "fn test_version() {\n    for version_flg in [\"-V\", \"--version\"] {\n        assert!(new_ucmd!()\n            .arg(version_flg)\n            .succeeds()\n            .no_stderr()\n            .stdout_str()\n            .starts_with(\"basename\"));\n    }\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context", "test": "fn valid_context() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.touch(\"a.tmp\");\n    dir.symlink_file(\"a.tmp\", \"la.tmp\");\n\n    let la_context = get_file_context(dir.plus(\"a.tmp\")).unwrap();\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    cmd.args(&[\"--verbose\", new_la_context])\n        .arg(dir.plus(\"la.tmp\"))\n        .succeeds();\n    assert_eq!(get_file_context(dir.plus(\"la.tmp\")).unwrap(), la_context);\n    assert_eq!(\n        get_file_context(dir.plus(\"a.tmp\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_on_valid_symlink", "test": "fn valid_context_on_valid_symlink() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.touch(\"a.tmp\");\n    dir.symlink_file(\"a.tmp\", \"la.tmp\");\n\n    let a_context = get_file_context(dir.plus(\"a.tmp\")).unwrap();\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    cmd.args(&[\"--verbose\", \"--no-dereference\", new_la_context])\n        .arg(dir.plus(\"la.tmp\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"la.tmp\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(get_file_context(dir.plus(\"a.tmp\")).unwrap(), a_context);\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_on_broken_symlink", "test": "fn valid_context_on_broken_symlink() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.symlink_file(\"a.tmp\", \"la.tmp\");\n\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    cmd.args(&[\"--verbose\", \"--no-dereference\", new_la_context])\n        .arg(dir.plus(\"la.tmp\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"la.tmp\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_with_prior_xattributes", "test": "fn valid_context_with_prior_xattributes() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.touch(\"a.tmp\");\n\n    let a_context = get_file_context(dir.plus(\"a.tmp\")).unwrap();\n    if a_context.is_none() {\n        set_file_context(dir.plus(\"a.tmp\"), \"unconfined_u:object_r:user_tmp_t:s0\").unwrap();\n    }\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    cmd.args(&[\"--verbose\", new_la_context])\n        .arg(dir.plus(\"a.tmp\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"a.tmp\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_directory_recursive", "test": "fn valid_context_directory_recursive() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.mkdir(\"a\");\n    dir.symlink_dir(\"a\", \"la\");\n\n    let b_path = Path::new(\"a\").join(\"b.txt\");\n    dir.touch(b_path.to_str().unwrap());\n\n    let a_context = get_file_context(dir.plus(\"a\")).unwrap();\n    let b_context = get_file_context(dir.plus(b_path.to_str().unwrap())).unwrap();\n\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    // -P (default): do not traverse any symbolic links.\n    cmd.args(&[\"--verbose\", \"--recursive\", new_la_context])\n        .arg(dir.plus(\"la\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"la\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(get_file_context(dir.plus(\"a\")).unwrap(), a_context);\n    assert_eq!(\n        get_file_context(dir.plus(b_path.to_str().unwrap())).unwrap(),\n        b_context\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_context_directory_recursive_follow_args_dir_symlinks", "test": "fn valid_context_directory_recursive_follow_args_dir_symlinks() {\n    let (dir, mut cmd) = at_and_ucmd!();\n    dir.mkdir(\"a\");\n    dir.symlink_dir(\"a\", \"la\");\n\n    let b_path = Path::new(\"a\").join(\"b.txt\");\n    dir.touch(b_path.to_str().unwrap());\n\n    let la_context = get_file_context(dir.plus(\"la\")).unwrap();\n    let new_la_context = \"guest_u:object_r:etc_t:s0:c42\";\n\n    /*\n    let lc_path = Path::new(\"a\").join(\"lc\");\n    dir.symlink_dir(\"c\", lc_path.to_str().unwrap());\n    assert_eq!(\n        get_file_context(dir.plus(lc_path.to_str().unwrap())).unwrap(),\n        None\n    );\n    */\n\n    // -H: if a command line argument is a symbolic link to a directory, traverse it.\n    cmd.args(&[\"--verbose\", \"--recursive\", \"-H\", new_la_context])\n        .arg(dir.plus(\"la\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"a\")).unwrap().as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(\n        get_file_context(dir.plus(b_path.to_str().unwrap()))\n            .unwrap()\n            .as_deref(),\n        Some(new_la_context)\n    );\n    assert_eq!(get_file_context(dir.plus(\"la\")).unwrap(), la_context);\n    /*\n    assert_eq!(\n        get_file_context(dir.plus(lc_path.to_str().unwrap()))\n            .unwrap()\n            .as_deref(),\n        Some(new_la_context)\n    );\n    */\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::user_role_range_type", "test": "fn user_role_range_type() {\n    let (dir, mut cmd) = at_and_ucmd!();\n\n    dir.touch(\"a.tmp\");\n    let a_context = get_file_context(dir.plus(\"a.tmp\")).unwrap();\n    if a_context.is_none() {\n        set_file_context(dir.plus(\"a.tmp\"), \"unconfined_u:object_r:user_tmp_t:s0\").unwrap();\n    }\n\n    cmd.args(&[\n        \"--verbose\",\n        \"--user=guest_u\",\n        \"--role=object_r\",\n        \"--type=etc_t\",\n        \"--range=s0:c42\",\n    ])\n    .arg(dir.plus(\"a.tmp\"))\n    .succeeds();\n\n    assert_eq!(\n        get_file_context(dir.plus(\"a.tmp\")).unwrap().as_deref(),\n        Some(\"guest_u:object_r:etc_t:s0:c42\")\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::user_change", "test": "fn user_change() {\n    let (dir, mut cmd) = at_and_ucmd!();\n\n    dir.touch(\"a.tmp\");\n    let a_context = get_file_context(dir.plus(\"a.tmp\")).unwrap();\n    let new_a_context = if let Some(a_context) = a_context {\n        let mut components: Vec<_> = a_context.split(':').collect();\n        components[0] = \"guest_u\";\n        components.join(\":\")\n    } else {\n        set_file_context(dir.plus(\"a.tmp\"), \"unconfined_u:object_r:user_tmp_t:s0\").unwrap();\n        String::from(\"guest_u:object_r:user_tmp_t:s0\")\n    };\n\n    cmd.args(&[\"--verbose\", \"--user=guest_u\"])\n        .arg(dir.plus(\"a.tmp\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"a.tmp\")).unwrap(),\n        Some(new_a_context)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::role_change", "test": "fn role_change() {\n    let (dir, mut cmd) = at_and_ucmd!();\n\n    dir.touch(\"a.tmp\");\n    let a_context = get_file_context(dir.plus(\"a.tmp\")).unwrap();\n    let new_a_context = if let Some(a_context) = a_context {\n        let mut components: Vec<_> = a_context.split(':').collect();\n        components[1] = \"system_r\";\n        components.join(\":\")\n    } else {\n        set_file_context(dir.plus(\"a.tmp\"), \"unconfined_u:object_r:user_tmp_t:s0\").unwrap();\n        String::from(\"unconfined_u:system_r:user_tmp_t:s0\")\n    };\n\n    cmd.args(&[\"--verbose\", \"--role=system_r\"])\n        .arg(dir.plus(\"a.tmp\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"a.tmp\")).unwrap(),\n        Some(new_a_context)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::type_change", "test": "fn type_change() {\n    let (dir, mut cmd) = at_and_ucmd!();\n\n    dir.touch(\"a.tmp\");\n    let a_context = get_file_context(dir.plus(\"a.tmp\")).unwrap();\n    let new_a_context = if let Some(a_context) = a_context {\n        let mut components: Vec<_> = a_context.split(':').collect();\n        components[2] = \"etc_t\";\n        components.join(\":\")\n    } else {\n        set_file_context(dir.plus(\"a.tmp\"), \"unconfined_u:object_r:user_tmp_t:s0\").unwrap();\n        String::from(\"unconfined_u:object_r:etc_t:s0\")\n    };\n\n    cmd.args(&[\"--verbose\", \"--type=etc_t\"])\n        .arg(dir.plus(\"a.tmp\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"a.tmp\")).unwrap(),\n        Some(new_a_context)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::range_change", "test": "fn range_change() {\n    let (dir, mut cmd) = at_and_ucmd!();\n\n    dir.touch(\"a.tmp\");\n    let a_context = get_file_context(dir.plus(\"a.tmp\")).unwrap();\n    let new_a_context = if let Some(a_context) = a_context {\n        a_context\n            .split(':')\n            .take(3)\n            .chain(iter::once(\"s0:c42\"))\n            .collect::<Vec<_>>()\n            .join(\":\")\n    } else {\n        set_file_context(dir.plus(\"a.tmp\"), \"unconfined_u:object_r:user_tmp_t:s0\").unwrap();\n        String::from(\"unconfined_u:object_r:user_tmp_t:s0:c42\")\n    };\n\n    cmd.args(&[\"--verbose\", \"--range=s0:c42\"])\n        .arg(dir.plus(\"a.tmp\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"a.tmp\")).unwrap(),\n        Some(new_a_context)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chcon.rs::valid_reference", "test": "fn valid_reference() {\n    let (dir, mut cmd) = at_and_ucmd!();\n\n    dir.touch(\"a.tmp\");\n    let new_a_context = \"guest_u:object_r:etc_t:s0:c42\";\n    set_file_context(dir.plus(\"a.tmp\"), new_a_context).unwrap();\n\n    dir.touch(\"b.tmp\");\n    let b_context = get_file_context(dir.plus(\"b.tmp\")).unwrap();\n    assert_ne!(b_context.as_deref(), Some(new_a_context));\n\n    cmd.arg(\"--verbose\")\n        .arg(format!(\"--reference={}\", dir.plus_as_string(\"a.tmp\")))\n        .arg(dir.plus(\"b.tmp\"))\n        .succeeds();\n    assert_eq!(\n        get_file_context(dir.plus(\"b.tmp\")).unwrap().as_deref(),\n        Some(new_a_context)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chmod.rs::test_gnu_special_filenames", "test": "fn test_gnu_special_filenames() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n    let perms_before = Permissions::from_mode(0o100_640);\n    let perms_after = Permissions::from_mode(0o100_440);\n\n    make_file(&at.plus_as_string(\"--\"), perms_before.mode());\n    scene.ucmd().arg(\"-w\").arg(\"--\").arg(\"--\").succeeds();\n    assert_eq!(at.metadata(\"--\").permissions(), perms_after);\n    set_permissions(at.plus(\"--\"), perms_before.clone()).unwrap();\n    scene.ucmd().arg(\"--\").arg(\"-w\").arg(\"--\").succeeds();\n    assert_eq!(at.metadata(\"--\").permissions(), perms_after);\n    at.remove(\"--\");\n\n    make_file(&at.plus_as_string(\"-w\"), perms_before.mode());\n    scene.ucmd().arg(\"-w\").arg(\"--\").arg(\"-w\").succeeds();\n    assert_eq!(at.metadata(\"-w\").permissions(), perms_after);\n    set_permissions(at.plus(\"-w\"), perms_before).unwrap();\n    scene.ucmd().arg(\"--\").arg(\"-w\").arg(\"-w\").succeeds();\n    assert_eq!(at.metadata(\"-w\").permissions(), perms_after);\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chroot.rs::test_missing_operand", "test": "fn test_missing_operand() {\n    let result = new_ucmd!().fails();\n\n    result.code_is(125);\n\n    assert!(result\n        .stderr_str()\n        .starts_with(\"error: the following required arguments were not provided\"));\n\n    assert!(result.stderr_str().contains(\"<newroot>\"));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_chroot.rs::test_invalid_user_spec", "test": "fn test_invalid_user_spec() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    at.mkdir(\"a\");\n\n    let result = ucmd.arg(\"a\").arg(\"--userspec=ARABA:\").fails();\n    result.code_is(125);\n    assert!(result.stderr_str().starts_with(\"chroot: invalid userspec\"));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_arg_no_clobber_twice", "test": "fn test_cp_arg_no_clobber_twice() {\n    let scene = TestScenario::new(util_name!());\n    let at = &scene.fixtures;\n\n    at.touch(\"source.txt\");\n    scene\n        .ucmd()\n        .arg(\"--no-clobber\")\n        .arg(\"source.txt\")\n        .arg(\"dest.txt\")\n        .succeeds()\n        .no_stderr();\n\n    assert_eq!(at.read(\"source.txt\"), \"\");\n\n    at.append(\"source.txt\", \"some-content\");\n    scene\n        .ucmd()\n        .arg(\"--no-clobber\")\n        .arg(\"source.txt\")\n        .arg(\"dest.txt\")\n        .fails();\n\n    assert_eq!(at.read(\"source.txt\"), \"some-content\");\n    // Should be empty as the \"no-clobber\" should keep\n    // the previous version\n    assert_eq!(at.read(\"dest.txt\"), \"\");\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_deref", "test": "fn test_cp_deref() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    #[cfg(not(windows))]\n    let _r = fs::symlink(\n        TEST_HELLO_WORLD_SOURCE,\n        at.subdir.join(TEST_HELLO_WORLD_SOURCE_SYMLINK),\n    );\n    #[cfg(windows)]\n    let _r = symlink_file(\n        TEST_HELLO_WORLD_SOURCE,\n        at.subdir.join(TEST_HELLO_WORLD_SOURCE_SYMLINK),\n    );\n    //using -L option\n    ucmd.arg(\"-L\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HELLO_WORLD_SOURCE_SYMLINK)\n        .arg(TEST_COPY_TO_FOLDER)\n        .succeeds();\n\n    let path_to_new_symlink = at\n        .subdir\n        .join(TEST_COPY_TO_FOLDER)\n        .join(TEST_HELLO_WORLD_SOURCE_SYMLINK);\n    // unlike -P/--no-deref, we expect a file, not a link\n    assert!(at.file_exists(\n        path_to_new_symlink\n            .clone()\n            .into_os_string()\n            .into_string()\n            .unwrap()\n    ));\n    // Check the content of the destination file that was copied.\n    assert_eq!(at.read(TEST_COPY_TO_FOLDER_FILE), \"Hello, World!\\n\");\n    let path_to_check = path_to_new_symlink.to_str().unwrap();\n    assert_eq!(at.read(path_to_check), \"Hello, World!\\n\");\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_cp.rs::test_cp_no_deref", "test": "fn test_cp_no_deref() {\n    let (at, mut ucmd) = at_and_ucmd!();\n\n    #[cfg(not(windows))]\n    let _r = fs::symlink(\n        TEST_HELLO_WORLD_SOURCE,\n        at.subdir.join(TEST_HELLO_WORLD_SOURCE_SYMLINK),\n    );\n    #[cfg(windows)]\n    let _r = symlink_file(\n        TEST_HELLO_WORLD_SOURCE,\n        at.subdir.join(TEST_HELLO_WORLD_SOURCE_SYMLINK),\n    );\n    //using -P option\n    ucmd.arg(\"-P\")\n        .arg(TEST_HELLO_WORLD_SOURCE)\n        .arg(TEST_HELLO_WORLD_SOURCE_SYMLINK)\n        .arg(TEST_COPY_TO_FOLDER)\n        .succeeds();\n\n    let path_to_new_symlink = at\n        .subdir\n        .join(TEST_COPY_TO_FOLDER)\n        .join(TEST_HELLO_WORLD_SOURCE_SYMLINK);\n    assert!(at.is_symlink(\n        &path_to_new_symlink\n            .clone()\n            .into_os_string()\n            .into_string()\n            .unwrap()\n    ));\n    // Check the content of the destination file that was copied.\n    assert_eq!(at.read(TEST_COPY_TO_FOLDER_FILE), \"Hello, World!\\n\");\n    let path_to_check = path_to_new_symlink.to_str().unwrap();\n    assert_eq!(at.read(path_to_check), \"Hello, World!\\n\");\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_for_invalid_file", "test": "fn test_date_for_invalid_file() {\n    let result = new_ucmd!().arg(\"--file\").arg(\"invalid_file\").fails();\n    result.no_stdout();\n    assert_eq!(\n        result.stderr_str().trim(),\n        \"date: invalid_file: No such file or directory\",\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_date_for_dir_as_file", "test": "fn test_date_for_dir_as_file() {\n    let result = new_ucmd!().arg(\"--file\").arg(\"/\").fails();\n    result.no_stdout();\n    assert_eq!(\n        result.stderr_str().trim(),\n        \"date: expected file, got directory '/'\",\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_invalid_format_string", "test": "fn test_invalid_format_string() {\n    let result = new_ucmd!().arg(\"+%!\").fails();\n    result.no_stdout();\n    assert!(result.stderr_str().starts_with(\"date: invalid format \"));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_date.rs::test_unsupported_format", "test": "fn test_unsupported_format() {\n    let result = new_ucmd!().arg(\"+%#z\").fails();\n    result.no_stdout();\n    assert!(result.stderr_str().starts_with(\"date: invalid format %#z\"));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_precedence_of_human_readable_header_over_output_header", "test": "fn test_precedence_of_human_readable_header_over_output_header() {\n    let output = new_ucmd!()\n        .args(&[\"-H\", \"--output=size\"])\n        .succeeds()\n        .stdout_move_str();\n    let header = output.lines().next().unwrap().to_string();\n    assert_eq!(header.trim(), \"Size\");\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_total_label_in_correct_column", "test": "fn test_total_label_in_correct_column() {\n    let output = new_ucmd!()\n        .args(&[\"--output=source\", \"--total\", \".\"])\n        .succeeds()\n        .stdout_move_str();\n    let last_line = output.lines().last().unwrap();\n    assert_eq!(last_line.trim(), \"total\");\n\n    let output = new_ucmd!()\n        .args(&[\"--output=target\", \"--total\", \".\"])\n        .succeeds()\n        .stdout_move_str();\n    let last_line = output.lines().last().unwrap();\n    assert_eq!(last_line.trim(), \"total\");\n\n    let output = new_ucmd!()\n        .args(&[\"--output=source,target\", \"--total\", \".\"])\n        .succeeds()\n        .stdout_move_str();\n    let last_line = output.lines().last().unwrap();\n    assert_eq!(\n        last_line.split_whitespace().collect::<Vec<&str>>(),\n        vec![\"total\", \"-\"]\n    );\n\n    let output = new_ucmd!()\n        .args(&[\"--output=target,source\", \"--total\", \".\"])\n        .succeeds()\n        .stdout_move_str();\n    let last_line = output.lines().last().unwrap();\n    assert_eq!(\n        last_line.split_whitespace().collect::<Vec<&str>>(),\n        vec![\"-\", \"total\"]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_df.rs::test_output_multiple_occurrences", "test": "fn test_output_multiple_occurrences() {\n    let output = new_ucmd!()\n        .args(&[\"--output=source\", \"--output=target\"])\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(\n        output\n            .lines()\n            .next()\n            .unwrap()\n            .split_whitespace()\n            .collect::<Vec<_>>(),\n        vec![\"Filesystem\", \"Mounted\", \"on\"]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_dircolors.rs::test_dircolors_for_dir_as_file", "test": "fn test_dircolors_for_dir_as_file() {\n    let result = new_ucmd!().args(&[\"-c\", \"/\"]).fails();\n    result.no_stdout();\n    assert_eq!(\n        result.stderr_str().trim(),\n        \"dircolors: expected file, got directory '/'\",\n    );\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_dereference_args", "test": "fn test_du_dereference_args() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.mkdir_all(\"subdir\");\n    let mut file1 = at.make_file(\"subdir/file-ignore1\");\n    file1.write_all(b\"azeaze\").unwrap();\n    let mut file2 = at.make_file(\"subdir/file-ignore1\");\n    file2.write_all(b\"amaz?ng\").unwrap();\n    at.symlink_dir(\"subdir\", \"sublink\");\n\n    let result = ts.ucmd().arg(\"-D\").arg(\"-s\").arg(\"sublink\").succeeds();\n    let stdout = result.stdout_str();\n\n    assert!(!stdout.starts_with('0'));\n    assert!(stdout.contains(\"sublink\"));\n\n    // Without the option\n    let result = ts.ucmd().arg(\"-s\").arg(\"sublink\").succeeds();\n    result.stdout_contains(\"0\\tsublink\\n\");\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_du.rs::test_du_exclude_several_components", "test": "fn test_du_exclude_several_components() {\n    let ts = TestScenario::new(util_name!());\n    let at = &ts.fixtures;\n\n    at.mkdir_all(\"a/b/c\");\n    at.mkdir_all(\"a/x/y\");\n    at.mkdir_all(\"a/u/y\");\n\n    // Exact match\n    let result = ts\n        .ucmd()\n        .arg(\"--exclude=a/u\")\n        .arg(\"--exclude=a/b\")\n        .arg(\"a\")\n        .succeeds();\n    assert!(!result.stdout_str().contains(\"a/u\"));\n    assert!(!result.stdout_str().contains(\"a/b\"));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_echo", "test": "fn test_echo() {\n    let result = new_ucmd!().arg(\"echo\").arg(\"FOO-bar\").succeeds();\n\n    assert_eq!(result.stdout_str().trim(), \"FOO-bar\");\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_single_name_value_pair", "test": "fn test_single_name_value_pair() {\n    let out = new_ucmd!().arg(\"FOO=bar\").run();\n\n    assert!(out.stdout_str().lines().any(|line| line == \"FOO=bar\"));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_unset_variable", "test": "fn test_unset_variable() {\n    let out = TestScenario::new(util_name!())\n        .ucmd()\n        .env(\"HOME\", \"FOO\")\n        .arg(\"-u\")\n        .arg(\"HOME\")\n        .succeeds()\n        .stdout_move_str();\n\n    assert!(!out.lines().any(|line| line.starts_with(\"HOME=\")));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_change_directory", "test": "fn test_change_directory() {\n    let scene = TestScenario::new(util_name!());\n    let temporary_directory = tempdir().unwrap();\n    let temporary_path = std::fs::canonicalize(temporary_directory.path()).unwrap();\n    assert_ne!(env::current_dir().unwrap(), temporary_path);\n\n    // command to print out current working directory\n    let pwd = \"pwd\";\n\n    let out = scene\n        .ucmd()\n        .arg(\"--chdir\")\n        .arg(&temporary_path)\n        .arg(pwd)\n        .succeeds()\n        .stdout_move_str();\n    assert_eq!(out.trim(), temporary_path.as_os_str());\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_env.rs::test_fail_change_directory", "test": "fn test_fail_change_directory() {\n    let scene = TestScenario::new(util_name!());\n    let some_non_existing_path = \"some_nonexistent_path\";\n    assert!(!Path::new(some_non_existing_path).is_dir());\n\n    let out = scene\n        .ucmd()\n        .arg(\"--chdir\")\n        .arg(some_non_existing_path)\n        .arg(\"pwd\")\n        .fails()\n        .stderr_move_str();\n    assert!(out.contains(\"env: cannot change directory to \"));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_ln.rs::test_relative_src_already_symlink", "test": "fn test_relative_src_already_symlink() {\n    let (at, mut ucmd) = at_and_ucmd!();\n    at.touch(\"file1\");\n    at.symlink_file(\"file1\", \"file2\");\n    ucmd.arg(\"-sr\").arg(\"file2\").arg(\"file3\").succeeds();\n    assert!(at.resolve_link(\"file3\").ends_with(\"file1\"));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_tmpdir_one_arg", "test": "fn test_mktemp_tmpdir_one_arg() {\n    let scene = TestScenario::new(util_name!());\n\n    let result = scene\n        .ucmd()\n        .arg(\"--tmpdir\")\n        .arg(\"apt-key-gpghome.XXXXXXXXXX\")\n        .succeeds();\n    result.no_stderr().stdout_contains(\"apt-key-gpghome.\");\n    assert!(PathBuf::from(result.stdout_str().trim()).is_file());\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_mktemp_directory_tmpdir", "test": "fn test_mktemp_directory_tmpdir() {\n    let scene = TestScenario::new(util_name!());\n\n    let result = scene\n        .ucmd()\n        .arg(\"--directory\")\n        .arg(\"--tmpdir\")\n        .arg(\"apt-key-gpghome.XXXXXXXXXX\")\n        .succeeds();\n    result.no_stderr().stdout_contains(\"apt-key-gpghome.\");\n    assert!(PathBuf::from(result.stdout_str().trim()).is_dir());\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_nonexistent_tmpdir_env_var", "test": "fn test_nonexistent_tmpdir_env_var() {\n    #[cfg(not(windows))]\n    new_ucmd!().env(TMPDIR, \"no/such/dir\").fails().stderr_only(\"mktemp: failed to create file via template 'no/such/dir/tmp.XXXXXXXXXX': No such file or directory\\n\");\n    #[cfg(windows)]\n    {\n        let result = new_ucmd!().env(TMPDIR, r\"no\\such\\dir\").fails();\n        result.no_stdout();\n        let stderr = result.stderr_str();\n        assert!(\n            stderr.starts_with(\"mktemp: failed to create file via template\"),\n            \"{}\",\n            stderr\n        );\n        assert!(\n            stderr.ends_with(\"no\\\\such\\\\dir\\\\tmp.XXXXXXXXXX': No such file or directory\\n\"),\n            \"{}\",\n            stderr\n        );\n    }\n\n    #[cfg(not(windows))]\n    new_ucmd!().env(TMPDIR, \"no/such/dir\").arg(\"-d\").fails().stderr_only(\"mktemp: failed to create directory via template 'no/such/dir/tmp.XXXXXXXXXX': No such file or directory\\n\");\n    #[cfg(windows)]\n    {\n        let result = new_ucmd!().env(TMPDIR, r\"no\\such\\dir\").arg(\"-d\").fails();\n        result.no_stdout();\n        let stderr = result.stderr_str();\n        assert!(\n            stderr.starts_with(\"mktemp: failed to create directory via template\"),\n            \"{}\",\n            stderr\n        );\n        assert!(\n            stderr.ends_with(\"no\\\\such\\\\dir\\\\tmp.XXXXXXXXXX': No such file or directory\\n\"),\n            \"{}\",\n            stderr\n        );\n    }\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_nonexistent_dir_prefix", "test": "fn test_nonexistent_dir_prefix() {\n    #[cfg(not(windows))]\n    new_ucmd!().arg(\"d/XXX\").fails().stderr_only(\n        \"mktemp: failed to create file via template 'd/XXX': No such file or directory\\n\",\n    );\n    #[cfg(windows)]\n    {\n        let result = new_ucmd!().arg(r\"d\\XXX\").fails();\n        result.no_stdout();\n        let stderr = result.stderr_str();\n        assert!(\n            stderr.starts_with(\"mktemp: failed to create file via template\"),\n            \"{}\",\n            stderr\n        );\n        assert!(\n            stderr.ends_with(\"d\\\\XXX': No such file or directory\\n\"),\n            \"{}\",\n            stderr\n        );\n    }\n\n    #[cfg(not(windows))]\n    new_ucmd!().arg(\"-d\").arg(\"d/XXX\").fails().stderr_only(\n        \"mktemp: failed to create directory via template 'd/XXX': No such file or directory\\n\",\n    );\n    #[cfg(windows)]\n    {\n        let result = new_ucmd!().arg(\"-d\").arg(r\"d\\XXX\").fails();\n        result.no_stdout();\n        let stderr = result.stderr_str();\n        assert!(\n            stderr.starts_with(\"mktemp: failed to create directory via template\"),\n            \"{}\",\n            stderr\n        );\n        assert!(\n            stderr.ends_with(\"d\\\\XXX': No such file or directory\\n\"),\n            \"{}\",\n            stderr\n        );\n    }\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_default_issue_4821_t_tmpdir", "test": "fn test_default_issue_4821_t_tmpdir() {\n    let scene = TestScenario::new(util_name!());\n    let pathname = scene.fixtures.as_string();\n    let result = scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-t\")\n        .arg(\"foo.XXXX\")\n        .succeeds();\n    let stdout = result.stdout_str();\n    println!(\"stdout = {stdout}\");\n    assert!(stdout.contains(&pathname));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_default_issue_4821_t_tmpdir_p", "test": "fn test_default_issue_4821_t_tmpdir_p() {\n    let scene = TestScenario::new(util_name!());\n    let pathname = scene.fixtures.as_string();\n    let result = scene\n        .ucmd()\n        .arg(\"-t\")\n        .arg(\"-p\")\n        .arg(&pathname)\n        .arg(\"foo.XXXX\")\n        .succeeds();\n    let stdout = result.stdout_str();\n    println!(\"stdout = {stdout}\");\n    assert!(stdout.contains(&pathname));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_mktemp.rs::test_t_ensure_tmpdir_has_higher_priority_than_p", "test": "fn test_t_ensure_tmpdir_has_higher_priority_than_p() {\n    let scene = TestScenario::new(util_name!());\n    let pathname = scene.fixtures.as_string();\n    let result = scene\n        .ucmd()\n        .env(TMPDIR, &pathname)\n        .arg(\"-t\")\n        .arg(\"-p\")\n        .arg(\"should_not_attempt_to_write_in_this_nonexisting_dir\")\n        .arg(\"foo.XXXX\")\n        .succeeds();\n    let stdout = result.stdout_str();\n    println!(\"stdout = {stdout}\");\n    assert!(stdout.contains(&pathname));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_file", "test": "fn test_file() {\n    // TODO: Can this be replaced by AtPath?\n    use std::env;\n    let temp = env::temp_dir();\n    let tmpdir = Path::new(&temp);\n    let file = tmpdir.join(\"test\");\n\n    {\n        let mut f = File::create(&file).unwrap();\n        // spell-checker:disable-next-line\n        assert!(\n            f.write_all(b\"abcdefghijklmnopqrstuvwxyz\\n\").is_ok(),\n            \"Test setup failed - could not write file\"\n        );\n    }\n\n    new_ucmd!()\n        .arg(\"--endian=little\")\n        .arg(file.as_os_str())\n        .succeeds()\n        .no_stderr()\n        .stdout_is(unindent(ALPHA_OUT));\n\n    // Ensure that default format matches `-t o2`, and that `-t` does not absorb file argument\n    new_ucmd!()\n        .arg(\"--endian=little\")\n        .arg(\"-t\")\n        .arg(\"o2\")\n        .arg(file.as_os_str())\n        .succeeds()\n        .no_stderr()\n        .stdout_is(unindent(ALPHA_OUT));\n\n    let _ = remove_file(file);\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_2files", "test": "fn test_2files() {\n    let temp = env::temp_dir();\n    let tmpdir = Path::new(&temp);\n    let file1 = tmpdir.join(\"test1\");\n    let file2 = tmpdir.join(\"test2\");\n\n    for (n, a) in [(1, \"a\"), (2, \"b\")] {\n        println!(\"number: {n} letter:{a}\");\n    }\n\n    // spell-checker:disable-next-line\n    for (path, data) in [(&file1, \"abcdefghijklmnop\"), (&file2, \"qrstuvwxyz\\n\")] {\n        let mut f = File::create(path).unwrap();\n        assert!(\n            f.write_all(data.as_bytes()).is_ok(),\n            \"Test setup failed - could not write file\"\n        );\n    }\n\n    new_ucmd!()\n        .arg(\"--endian=little\")\n        .arg(file1.as_os_str())\n        .arg(file2.as_os_str())\n        .succeeds()\n        .no_stderr()\n        .stdout_is(unindent(ALPHA_OUT));\n    // TODO: Handle errors?\n    let _ = remove_file(file1);\n    let _ = remove_file(file2);\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_od.rs::test_from_mixed", "test": "fn test_from_mixed() {\n    let temp = env::temp_dir();\n    let tmpdir = Path::new(&temp);\n    let file1 = tmpdir.join(\"test-1\");\n    let file3 = tmpdir.join(\"test-3\");\n\n    // spell-checker:disable-next-line\n    let (data1, data2, data3) = (\"abcdefg\", \"hijklmnop\", \"qrstuvwxyz\\n\");\n    for (path, data) in [(&file1, data1), (&file3, data3)] {\n        let mut f = File::create(path).unwrap();\n        assert!(\n            f.write_all(data.as_bytes()).is_ok(),\n            \"Test setup failed - could not write file\"\n        );\n    }\n\n    new_ucmd!()\n        .arg(\"--endian=little\")\n        .arg(file1.as_os_str())\n        .arg(\"-\")\n        .arg(file3.as_os_str())\n        .run_piped_stdin(data2.as_bytes())\n        .success()\n        .no_stderr()\n        .stdout_is(unindent(ALPHA_OUT));\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uname.rs::test_uname_processor", "test": "fn test_uname_processor() {\n    let result = new_ucmd!().arg(\"-p\").succeeds();\n    assert_eq!(result.stdout_str().trim_end(), \"unknown\");\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uname.rs::test_uname_kernel", "test": "fn test_uname_kernel() {\n    let (_, mut ucmd) = at_and_ucmd!();\n\n    #[cfg(target_os = \"linux\")]\n    {\n        let result = ucmd.arg(\"-o\").succeeds();\n        assert!(result.stdout_str().to_lowercase().contains(\"linux\"));\n    }\n\n    #[cfg(not(target_os = \"linux\"))]\n    ucmd.arg(\"-o\").succeeds();\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uname.rs::test_uname_operating_system", "test": "fn test_uname_operating_system() {\n    #[cfg(target_os = \"android\")]\n    new_ucmd!()\n        .arg(\"--operating-system\")\n        .succeeds()\n        .stdout_is(\"Android\\n\");\n    #[cfg(target_vendor = \"apple\")]\n    new_ucmd!()\n        .arg(\"--operating-system\")\n        .succeeds()\n        .stdout_is(\"Darwin\\n\");\n    #[cfg(target_os = \"freebsd\")]\n    new_ucmd!()\n        .arg(\"--operating-system\")\n        .succeeds()\n        .stdout_is(\"FreeBSD\\n\");\n    #[cfg(target_os = \"fuchsia\")]\n    new_ucmd!()\n        .arg(\"--operating-system\")\n        .succeeds()\n        .stdout_is(\"Fuchsia\\n\");\n    #[cfg(all(target_os = \"linux\", any(target_env = \"gnu\", target_env = \"\")))]\n    new_ucmd!()\n        .arg(\"--operating-system\")\n        .succeeds()\n        .stdout_is(\"GNU/Linux\\n\");\n    #[cfg(all(target_os = \"linux\", not(any(target_env = \"gnu\", target_env = \"\"))))]\n    new_ucmd!()\n        .arg(\"--operating-system\")\n        .succeeds()\n        .stdout_is(\"Linux\\n\");\n    #[cfg(target_os = \"netbsd\")]\n    new_ucmd!()\n        .arg(\"--operating-system\")\n        .succeeds()\n        .stdout_is(\"NetBSD\\n\");\n    #[cfg(target_os = \"openbsd\")]\n    new_ucmd!()\n        .arg(\"--operating-system\")\n        .succeeds()\n        .stdout_is(\"OpenBSD\\n\");\n    #[cfg(target_os = \"redox\")]\n    new_ucmd!()\n        .arg(\"--operating-system\")\n        .succeeds()\n        .stdout_is(\"Redox\\n\");\n    #[cfg(target_os = \"windows\")]\n    {\n        let result = new_ucmd!().arg(\"--operating-system\").succeeds();\n        println!(\"{:?}\", result.stdout_str());\n        assert!(result.stdout_str().starts_with(\"MS/Windows\"));\n    }\n}", "error": "Not Definition Found"}
{"test_id": "uutils-coreutils/uutils-coreutils-73b7c46/tests/by-util/test_uname.rs::test_uname_output_for_invisible_chars", "test": "fn test_uname_output_for_invisible_chars() {\n    // let re = regex::Regex::new(\"[^[[:print:]]]\").unwrap(); // matches invisible (and emojis)\n    let re = regex::Regex::new(\"[^[[:print:]]\\\\p{Other_Symbol}]\").unwrap(); // matches invisible (not emojis)\n    let result = new_ucmd!().arg(\"--all\").succeeds();\n    assert_eq!(re.find(result.stdout_str().trim_end()), None);\n}", "error": "Not Definition Found"}
