{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_linter/tests/integration_test.rs::test_declare_oxc_lint", "test": "fn test_declare_oxc_lint() {\n    // Simple, multiline documentation\n    assert_eq!(TestRule::documentation().unwrap(), \"Dummy description\\n# which is multiline\\n\");\n\n    // Ensure structs with fields can be passed to the macro\n    assert_eq!(TestRule2::documentation().unwrap(), \"Dummy description2\\n\");\n\n    // Auto-generated kebab-case name\n    assert_eq!(TestRule::NAME, \"test-rule\");\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/alias.rs::infinite_recursion", "test": "fn infinite_recursion() {\n    let f = super::fixture();\n    let resolver = Resolver::new(ResolveOptions {\n        alias: vec![\n            (\"./a\".into(), vec![AliasValue::Path(\"./b\".into())]),\n            (\"./b\".into(), vec![AliasValue::Path(\"./a\".into())]),\n        ],\n        ..ResolveOptions::default()\n    });\n    let resolution = resolver.resolve(f, \"./a\");\n    assert_eq!(resolution, Err(ResolveError::Recursion));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/browser_field.rs::ignore", "test": "fn ignore() {\n    let f = super::fixture().join(\"browser-module\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        alias_fields: vec![\n            vec![\"browser\".into()],\n            vec![\"innerBrowser1\".into()],\n            vec![\"innerBrowser2\".into()],\n        ],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let data = [\n        (f.clone(), \"./lib/ignore\", f.join(\"lib/ignore.js\")),\n        (f.clone(), \"./lib/ignore.js\", f.join(\"lib/ignore.js\")),\n        (f.join(\"lib\"), \"./ignore\", f.join(\"lib/ignore.js\")),\n        (f.join(\"lib\"), \"./ignore.js\", f.join(\"lib/ignore.js\")),\n    ];\n\n    for (path, request, expected) in data {\n        let resolution = resolver.resolve(&path, request);\n        let expected = ResolveError::Ignored(expected);\n        assert_eq!(resolution, Err(expected), \"{path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/browser_field.rs::replace_file", "test": "fn replace_file() {\n    let f = super::fixture().join(\"browser-module\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        alias_fields: vec![\n            vec![\"browser\".into()],\n            vec![\"innerBrowser1\".into(), \"field2\".into(), \"browser\".into()], // not presented\n            vec![\"innerBrowser1\".into(), \"field\".into(), \"browser\".into()],\n            vec![\"innerBrowser2\".into(), \"browser\".into()],\n        ],\n        // Not part of enhanced-resolve. Added to make sure no interaction between these two fields.\n        main_fields: vec![\"browser\".into()],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let data = [\n        (\"should replace a file 1\", f.clone(), \"./lib/replaced\", f.join(\"lib/browser.js\")),\n        (\"should replace a file 2\", f.clone(), \"./lib/replaced.js\", f.join(\"lib/browser.js\")),\n        (\"should replace a file 3\", f.join(\"lib\"), \"./replaced\", f.join(\"lib/browser.js\")),\n        (\"should replace a file 4\", f.join(\"lib\"), \"./replaced.js\", f.join(\"lib/browser.js\")),\n        (\"should replace a module with a file 1\", f.clone(), \"module-a\", f.join(\"browser/module-a.js\")),\n        (\"should replace a module with a file 2\", f.join(\"lib\"), \"module-a\", f.join(\"browser/module-a.js\")),\n        (\"should replace a module with a module 1\", f.clone(), \"module-b\", f.join(\"node_modules/module-c.js\")),\n        (\"should replace a module with a module 2\", f.join(\"lib\"), \"module-b\", f.join(\"node_modules/module-c.js\")),\n        (\"should resolve in nested property 1\", f.clone(), \"./lib/main1.js\", f.join(\"lib/main.js\")),\n        (\"should resolve in nested property 2\", f.clone(), \"./lib/main2.js\", f.join(\"lib/browser.js\")),\n        (\"should check only alias field properties\", f.clone(), \"./toString\", f.join(\"lib/toString.js\")),\n        // not part of enhanced-resolve\n        (\"recursion\", f.clone(), \"module-c\", f.join(\"node_modules/module-c.js\")),\n    ];\n\n    for (comment, path, request, expected) in data {\n        let resolved_path = resolver.resolve(&path, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/browser_field.rs::broken", "test": "fn broken() {\n    let f = super::fixture();\n\n    let resolver = Resolver::new(ResolveOptions {\n        alias_fields: vec![vec![\"browser\".into()]],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let data = [\n        // The browser field string value should be ignored\n        (f.clone(), \"browser-module-broken\", f.join(\"node_modules/browser-module-broken/main.js\")),\n    ];\n\n    for (path, request, expected) in data {\n        let resolved_path = resolver.resolve(&path, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/builtins.rs::builtins_off", "test": "fn builtins_off() {\n    let f = Path::new(\"/\");\n    let resolver = Resolver::default();\n    let resolved_path = resolver.resolve(f, \"zlib\").map(|r| r.full_path());\n    assert_eq!(resolved_path, Err(ResolveError::NotFound(PathBuf::from(\"/\"))));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/builtins.rs::builtins", "test": "fn builtins() {\n    let f = Path::new(\"/\");\n\n    let resolver =\n        Resolver::new(ResolveOptions { builtin_modules: true, ..ResolveOptions::default() });\n\n    let pass = [\n        \"_http_agent\",\n        \"_http_client\",\n        \"_http_common\",\n        \"_http_incoming\",\n        \"_http_outgoing\",\n        \"_http_server\",\n        \"_stream_duplex\",\n        \"_stream_passthrough\",\n        \"_stream_readable\",\n        \"_stream_transform\",\n        \"_stream_wrap\",\n        \"_stream_writable\",\n        \"_tls_common\",\n        \"_tls_wrap\",\n        \"assert\",\n        \"assert/strict\",\n        \"async_hooks\",\n        \"buffer\",\n        \"child_process\",\n        \"cluster\",\n        \"console\",\n        \"constants\",\n        \"crypto\",\n        \"dgram\",\n        \"diagnostics_channel\",\n        \"dns\",\n        \"dns/promises\",\n        \"domain\",\n        \"events\",\n        \"fs\",\n        \"fs/promises\",\n        \"http\",\n        \"http2\",\n        \"https\",\n        \"inspector\",\n        \"module\",\n        \"net\",\n        \"os\",\n        \"path\",\n        \"path/posix\",\n        \"path/win32\",\n        \"perf_hooks\",\n        \"process\",\n        \"punycode\",\n        \"querystring\",\n        \"readline\",\n        \"repl\",\n        \"stream\",\n        \"stream/consumers\",\n        \"stream/promises\",\n        \"stream/web\",\n        \"string_decoder\",\n        \"sys\",\n        \"timers\",\n        \"timers/promises\",\n        \"tls\",\n        \"trace_events\",\n        \"tty\",\n        \"url\",\n        \"util\",\n        \"util/types\",\n        \"v8\",\n        \"vm\",\n        \"worker_threads\",\n        \"zlib\",\n    ];\n\n    for request in pass {\n        let resolved_path = resolver.resolve(f, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Err(ResolveError::Builtin(request.to_string())), \"{request}\");\n    }\n\n    for request in pass {\n        let request = format!(\"node:{request}\");\n        let resolved_path = resolver.resolve(f, &request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Err(ResolveError::Builtin(request.to_string())), \"{request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/exports_field.rs::test", "test": "fn test() {\n    let f = super::fixture().join(\"exports-field\");\n    let f2 = super::fixture().join(\"exports-field2\");\n    let f4 = super::fixture().join(\"exports-field-error\");\n    let f5 = super::fixture().join(\"imports-exports-wildcard\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into()],\n        fully_specified: true,\n        condition_names: vec![\"webpack\".into()],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"resolve root using exports field, not a main field\", f.clone(), \"exports-field\", f.join(\"node_modules/exports-field/x.js\")),\n        (\"resolver should respect condition names\", f.clone(), \"exports-field/dist/main.js\", f.join(\"node_modules/exports-field/lib/lib2/main.js\")),\n        // enhanced_resolve behaves differently to node.js. enhanced_resolve fallbacks when an\n        // array item is unresolved, where as node.js fallbacks when an array has an\n        // InvalidPackageTarget error.\n        // (\"resolver should respect fallback\", f2.clone(), \"exports-field/dist/browser.js\", f2.join(\"node_modules/exports-field/lib/browser.js\")),\n        // The following two tests require fallback from array values, the path is changed here to\n        // only test query and fragment.\n        (\"resolver should respect query parameters #1\", f2.clone(), \"exports-field/dist/main.js?foo\", f2.join(\"node_modules/exports-field/lib/lib2/main.js?foo\")),\n        (\"resolver should respect fragment parameters #1\", f2.clone(), \"exports-field/dist/main.js#foo\", f2.join(\"node_modules/exports-field/lib/lib2/main.js#foo\")),\n        (\"relative path should work, if relative path as request is used\", f.clone(), \"./node_modules/exports-field/lib/main.js\", f.join(\"node_modules/exports-field/lib/main.js\")),\n        (\"self-resolving root\", f.clone(), \"@exports-field/core\", f.join(\"a.js\")),\n        (\"should resolve with wildcard pattern #1\", f5.clone(), \"m/features/f.js\", f5.join(\"node_modules/m/src/features/f.js\")),\n        (\"should resolve with wildcard pattern #2\", f5.clone(), \"m/features/y/y.js\", f5.join(\"node_modules/m/src/features/y/y.js\")),\n        (\"should resolve with wildcard pattern #3\", f5.clone(), \"m/features-no-ext/y/y.js\", f5.join(\"node_modules/m/src/features/y/y.js\")),\n        (\"should resolve with wildcard pattern #4\", f5.clone(), \"m/middle/nested/f.js\", f5.join(\"node_modules/m/src/middle/nested/f.js\")),\n        (\"should resolve with wildcard pattern #5\", f5.clone(), \"m/middle-1/nested/f.js\", f5.join(\"node_modules/m/src/middle-1/nested/f.js\")),\n        (\"should resolve with wildcard pattern #6\", f5.clone(), \"m/middle-2/nested/f.js\", f5.join(\"node_modules/m/src/middle-2/nested/f.js\")),\n        (\"should resolve with wildcard pattern #7\", f5.clone(), \"m/middle-3/nested/f\", f5.join(\"node_modules/m/src/middle-3/nested/f/nested/f.js\")),\n        (\"should resolve with wildcard pattern #8\", f5.clone(), \"m/middle-4/f/nested\", f5.join(\"node_modules/m/src/middle-4/f/f.js\")),\n        (\"should resolve with wildcard pattern #9\", f5.clone(), \"m/middle-5/f$/$\", f5.join(\"node_modules/m/src/middle-5/f$/$.js\")),\n    ];\n\n    // Not needed or snapshot:\n    //   * should log the correct info\n\n    for (comment, path, request, expected) in pass {\n        let resolved_path = resolver.resolve(&path, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {path:?} {request}\");\n    }\n\n    #[rustfmt::skip]\n    let fail = [\n        // (\"throw error if extension not provided\", f2.clone(), \"exports-field/dist/main\", ResolveError::NotFound(f2.join(\"node_modules/exports-field/lib/lib2/main\"))),\n        (\"resolver should respect query parameters #2. Direct matching\", f2.clone(), \"exports-field?foo\", ResolveError::PackagePathNotExported(\"./?foo\".into())),\n        (\"resolver should respect fragment parameters #2. Direct matching\", f2, \"exports-field#foo\", ResolveError::PackagePathNotExported(\"./#foo\".into())),\n        (\"relative path should not work with exports field\", f.clone(), \"./node_modules/exports-field/dist/main.js\", ResolveError::NotFound(f.join(\"node_modules/exports-field/dist/main.js\"))),\n        (\"backtracking should not work for request\", f.clone(), \"exports-field/dist/../../../a.js\", ResolveError::InvalidPackageTarget(\"./lib/../../../a.js\".to_string())),\n        (\"backtracking should not work for exports field target\", f.clone(), \"exports-field/dist/a.js\", ResolveError::InvalidPackageTarget(\"./../../a.js\".to_string())),\n        (\"not exported error\", f.clone(), \"exports-field/anything/else\", ResolveError::PackagePathNotExported(\"./anything/else\".to_string())),\n        (\"request ending with slash #1\", f.clone(), \"exports-field/\", ResolveError::PackagePathNotExported(\"./\".to_string())),\n        (\"request ending with slash #2\", f.clone(), \"exports-field/dist/\", ResolveError::PackagePathNotExported(\"./dist/\".to_string())),\n        (\"request ending with slash #3\", f.clone(), \"exports-field/lib/\", ResolveError::PackagePathNotExported(\"./lib/\".to_string())),\n        (\"should throw error if target is invalid\", f4, \"exports-field\", ResolveError::InvalidPackageTarget(\"./a/../b/../../pack1/index.js\".to_string())),\n        (\"throw error if exports field is invalid\", f.clone(), \"invalid-exports-field\", ResolveError::InvalidPackageConfig(f.join(\"node_modules/invalid-exports-field/package.json\"))),\n        (\"should throw error if target is 'null'\", f5, \"m/features/internal/file.js\", ResolveError::PackagePathNotExported(\"./features/internal/file.js\".to_string())),\n    ];\n\n    for (comment, path, request, error) in fail {\n        let resolution = resolver.resolve(&path, request);\n        assert_eq!(resolution, Err(error), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/exports_field.rs::exports_not_browser_field1", "test": "fn exports_not_browser_field1() {\n    let f = super::fixture().join(\"exports-field\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        alias_fields: vec![vec![\"browser\".into()]],\n        condition_names: vec![\"webpack\".into()],\n        extensions: vec![\".js\".into()],\n        ..ResolveOptions::default()\n    });\n\n    let resolved_path = resolver.resolve(&f, \"exports-field/dist/main.js\").map(|r| r.full_path());\n    assert_eq!(resolved_path, Ok(f.join(\"node_modules/exports-field/lib/lib2/main.js\")));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/exports_field.rs::exports_not_browser_field2", "test": "fn exports_not_browser_field2() {\n    let f2 = super::fixture().join(\"exports-field2\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        alias_fields: vec![vec![\"browser\".into()]],\n        extensions: vec![\".js\".into()],\n        condition_names: vec![\"node\".into()],\n        ..ResolveOptions::default()\n    });\n\n    let resolved_path = resolver.resolve(&f2, \"exports-field/dist/main.js\").map(|r| r.full_path());\n    assert_eq!(resolved_path, Ok(f2.join(\"node_modules/exports-field/lib/browser.js\")));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/exports_field.rs::extension_without_fully_specified", "test": "fn extension_without_fully_specified() {\n    let f2 = super::fixture().join(\"exports-field2\");\n\n    let commonjs_resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into()],\n        condition_names: vec![\"webpack\".into()],\n        ..ResolveOptions::default()\n    });\n\n    let resolved_path =\n        commonjs_resolver.resolve(&f2, \"exports-field/dist/main\").map(|r| r.full_path());\n    assert_eq!(resolved_path, Ok(f2.join(\"node_modules/exports-field/lib/lib2/main.js\")));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/exports_field.rs::field_name_path", "test": "fn field_name_path() {\n    let f2 = super::fixture().join(\"exports-field2\");\n    let f3 = super::fixture().join(\"exports-field3\");\n\n    // field name path #1 #2 #3\n    let exports_fields = [\n        vec![vec![\"exportsField\".into(), \"exports\".into()]],\n        vec![vec![\"exportsField\".into(), \"exports\".into()], vec![\"exports\".into()]],\n        vec![vec![\"exports\".into()], vec![\"exportsField\".into(), \"exports\".into()]],\n    ];\n\n    for exports_fields in exports_fields {\n        let resolver = Resolver::new(ResolveOptions {\n            alias_fields: vec![vec![\"browser\".into()]],\n            exports_fields,\n            extensions: vec![\".js\".into()],\n            ..ResolveOptions::default()\n        });\n        let resolved_path = resolver.resolve(&f3, \"exports-field\").map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(f3.join(\"node_modules/exports-field/main.js\")));\n    }\n\n    // field name path #4\n    let resolver = Resolver::new(ResolveOptions {\n        alias_fields: vec![vec![\"browser\".into()]],\n        exports_fields: vec![vec![\"exports\".into()]],\n        extensions: vec![\".js\".into()],\n        ..ResolveOptions::default()\n    });\n    let resolved_path = resolver.resolve(&f2, \"exports-field\").map(|r| r.full_path());\n    assert_eq!(resolved_path, Ok(f2.join(\"node_modules/exports-field/index.js\")));\n\n    // field name path #5\n    let resolver = Resolver::new(ResolveOptions {\n        alias_fields: vec![vec![\"browser\".into()]],\n        exports_fields: vec![vec![\"ex\".into()], vec![\"exports_field\".into(), \"exports\".into()]],\n        extensions: vec![\".js\".into()],\n        ..ResolveOptions::default()\n    });\n    let resolved_path = resolver.resolve(&f3, \"exports-field\").map(|r| r.full_path());\n    assert_eq!(resolved_path, Ok(f3.join(\"node_modules/exports-field/index\")));\n\n    // non-compliant export targeting a directory\n    let resolver = Resolver::new(ResolveOptions {\n        exports_fields: vec![vec![\"broken\".into()]],\n        extensions: vec![\".js\".into()],\n        ..ResolveOptions::default()\n    });\n    let resolved_path = resolver.resolve(&f3, \"exports-field\").map(|r| r.full_path());\n    assert_eq!(resolved_path, Ok(f3.join(\"node_modules/exports-field/src/index.js\")));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/exports_field.rs::extension_alias_1_2", "test": "fn extension_alias_1_2() {\n    let f = super::fixture().join(\"exports-field-and-extension-alias\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into()],\n        extension_alias: vec![(\".js\".into(), vec![\".ts\".into(), \".js\".into()])],\n        fully_specified: true,\n        condition_names: vec![\"webpack\".into(), \"default\".into()],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"should resolve with the `extensionAlias` option\", f.clone(), \"@org/pkg/string.js\", f.join(\"node_modules/@org/pkg/dist/string.js\")),\n        (\"should resolve with the `extensionAlias` option #2\", f.clone(), \"pkg/string.js\", f.join(\"node_modules/pkg/dist/string.js\")),\n    ];\n\n    for (comment, path, request, expected) in pass {\n        let resolved_path = resolver.resolve(&path, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/exports_field.rs::extension_alias_3", "test": "fn extension_alias_3() {\n    let f = super::fixture().join(\"exports-field-and-extension-alias\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into()],\n        extension_alias: vec![(\n            \".js\".into(),\n            vec![\".foo\".into(), \".baz\".into(), \".baz\".into(), \".ts\".into(), \".js\".into()],\n        )],\n        fully_specified: true,\n        condition_names: vec![\"webpack\".into(), \"default\".into()],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"should resolve with the `extensionAlias` option #3\", f.clone(), \"pkg/string.js\", f.join(\"node_modules/pkg/dist/string.js\")),\n    ];\n\n    for (comment, path, request, expected) in pass {\n        let resolved_path = resolver.resolve(&path, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/exports_field.rs::extension_alias_throw_error", "test": "fn extension_alias_throw_error() {\n    let f = super::fixture().join(\"exports-field-and-extension-alias\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into()],\n        extension_alias: vec![(\".js\".into(), vec![\".ts\".into()])],\n        fully_specified: true,\n        condition_names: vec![\"webpack\".into(), \"default\".into()],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let fail = [\n        // enhanced-resolve has two test cases that are exactly the same here\n        // https://github.com/webpack/enhanced-resolve/blob/a998c7d218b7a9ec2461fc4fddd1ad5dd7687485/test/exportsField.test.js#L2976-L3024\n        (\"should throw error with the `extensionAlias` option\", f, \"pkg/string.js\", ResolveError::ExtensionAlias),\n        // TODO: The error is PackagePathNotExported in enhanced-resolve\n        // (\"should throw error with the `extensionAlias` option\", f.clone(), \"pkg/string.js\", ResolveError::PackagePathNotExported(\"node_modules/pkg/dist/string.ts\".to_string())),\n    ];\n\n    for (comment, path, request, error) in fail {\n        let resolution = resolver.resolve(&path, request);\n        assert_eq!(resolution, Err(error), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/extension_alias.rs::extension_alias", "test": "fn extension_alias() {\n    let f = super::fixture().join(\"extension-alias\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into()],\n        main_files: vec![\"index.js\".into()],\n        extension_alias: vec![\n            (\".js\".into(), vec![\".ts\".into(), \".js\".into()]),\n            (\".mjs\".into(), vec![\".mts\".into()]),\n        ],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"should alias fully specified file\", f.clone(), \"./index.js\", f.join(\"index.ts\")),\n        (\"should alias fully specified file when there are two alternatives\", f.clone(), \"./dir/index.js\", f.join(\"dir/index.ts\")),\n        (\"should also allow the second alternative\", f.clone(), \"./dir2/index.js\", f.join(\"dir2/index.js\")),\n        (\"should support alias option without an array\", f.clone(), \"./dir2/index.mjs\", f.join(\"dir2/index.mts\")),\n    ];\n\n    for (comment, path, request, expected) in pass {\n        let resolved_path = resolver.resolve(&path, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {path:?} {request}\");\n    }\n\n    #[rustfmt::skip]\n    let fail = [\n        (\"should not allow to fallback to the original extension or add extensions\", f, \"./index.mjs\"),\n    ];\n\n    for (comment, path, request) in fail {\n        let resolution = resolver.resolve(&path, request);\n        assert_eq!(resolution, Err(ResolveError::ExtensionAlias), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/extension_alias.rs::not_apply_to_extension_nor_main_files", "test": "fn not_apply_to_extension_nor_main_files() {\n    let f = super::fixture().join(\"extension-alias\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into()],\n        main_files: vec![\"index.js\".into()],\n        extension_alias: vec![(\".js\".into(), vec![])],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"directory\", f.clone(), \"./dir2\", \"dir2/index.js\"),\n        (\"file\", f.clone(), \"./dir2/index\", \"dir2/index.js\"),\n    ];\n\n    for (comment, path, request, expected) in pass {\n        let resolved_path = resolver.resolve(&path, request).map(|r| r.full_path());\n        let expected = f.join(expected);\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/extensions.rs::extensions", "test": "fn extensions() {\n    let f = super::fixture().join(\"extensions\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".ts\".into(), \".js\".into()],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"should resolve according to order of provided extensions\", \"./foo\", \"foo.ts\"),\n        (\"should resolve according to order of provided extensions (dir index)\", \"./dir\", \"dir/index.ts\"),\n        (\"should resolve according to main field in module root\", \".\", \"index.js\"),\n        // This is a core module\n        // (\"should resolve single file module before directory\", \"module\", \"node_modules/module.js\"),\n        (\"should resolve trailing slash directory before single file\", \"module/\", \"node_modules/module/index.ts\"),\n    ];\n\n    for (comment, request, expected_path) in pass {\n        let resolved_path = resolver.resolve(&f, request).map(|r| r.full_path());\n        let expected = f.join(expected_path);\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {request} {expected_path}\");\n    }\n\n    #[rustfmt::skip]\n    let fail = [\n        (\"not resolve to file when request has a trailing slash (relative)\", \"./foo.js/\", f.join(\"foo.js\"))\n    ];\n\n    for (comment, request, expected_error) in fail {\n        let resolution = resolver.resolve(&f, request);\n        let error = ResolveError::NotFound(expected_error);\n        assert_eq!(resolution, Err(error), \"{comment} {request} {resolution:?}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/extensions.rs::default_enforce_extension", "test": "fn default_enforce_extension() {\n    let f = super::fixture().join(\"extensions\");\n\n    let resolved = Resolver::new(ResolveOptions {\n        extensions: vec![\".ts\".into(), String::new(), \".js\".into()],\n        ..ResolveOptions::default()\n    })\n    .resolve(&f, \"./foo\");\n\n    assert_eq!(resolved.map(Resolution::into_path_buf), Ok(f.join(\"foo.ts\")));\n    // TODO: need to match missingDependencies returned from the resolve function\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/extensions.rs::respect_enforce_extension", "test": "fn respect_enforce_extension() {\n    let f = super::fixture().join(\"extensions\");\n\n    let resolved = Resolver::new(ResolveOptions {\n        enforce_extension: EnforceExtension::Disabled,\n        extensions: vec![\".ts\".into(), String::new(), \".js\".into()],\n        ..ResolveOptions::default()\n    })\n    .resolve(&f, \"./foo\");\n    assert_eq!(resolved.map(Resolution::into_path_buf), Ok(f.join(\"foo.ts\")));\n    // TODO: need to match missingDependencies returned from the resolve function\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/extensions.rs::multi_dot_extension", "test": "fn multi_dot_extension() {\n    let f = super::fixture().join(\"extensions\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        // Test for `.d.ts`, not part of enhanced-resolve.\n        extensions: vec![\".a.b.c\".into(), \".d.ts\".into(), \".ts\".into(), \".js\".into()],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"should resolve according to order of provided extensions\", \"./foo\", \"foo.ts\"),\n        (\"should resolve file with extension\", \"./app.module\", \"app.module.js\")\n    ];\n\n    for (comment, request, expected_path) in pass {\n        let resolved_path = resolver.resolve(&f, request).map(|r| r.full_path());\n        let expected = f.join(expected_path);\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {request} {expected_path}\");\n    }\n\n    #[rustfmt::skip]\n    let fail = [\n        (\"not resolve to file\", \"./index.\", f.join(\"index.\"))\n    ];\n\n    for (comment, request, expected_error) in fail {\n        let resolution = resolver.resolve(&f, request);\n        let error = ResolveError::NotFound(expected_error);\n        assert_eq!(resolution, Err(error), \"{comment} {request} {resolution:?}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/imports_field.rs::test", "test": "fn test() {\n    let f = super::fixture().join(\"imports-field\");\n    let f2 = super::fixture().join(\"imports-exports-wildcard/node_modules/m/\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into()],\n        main_files: vec![\"index.js\".into()],\n        condition_names: vec![\"webpack\".into()],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"should resolve using imports field instead of self-referencing\", f.clone(), \"#imports-field\", f.join(\"b.js\")),\n        (\"should resolve using imports field instead of self-referencing for a subpath\", f.join(\"dir\"), \"#imports-field\", f.join(\"b.js\")),\n        (\"should resolve package #1\", f.clone(), \"#a/dist/main.js\", f.join(\"node_modules/a/lib/lib2/main.js\")),\n        (\"should resolve package #3\", f.clone(), \"#ccc/index.js\", f.join(\"node_modules/c/index.js\")),\n        (\"should resolve package #4\", f.clone(), \"#c\", f.join(\"node_modules/c/index.js\")),\n        (\"should resolve with wildcard pattern\", f2.clone(), \"#internal/i.js\", f2.join(\"src/internal/i.js\")),\n    ];\n\n    for (comment, path, request, expected) in pass {\n        let resolved_path = resolver.resolve(&path, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {path:?} {request}\");\n    }\n\n    // Note added:\n    // * should resolve absolute path as an imports field target\n    // * should log the correct info\n\n    #[rustfmt::skip]\n    let fail = [\n        (\"should disallow resolve out of package scope\", f.clone(), \"#b\", ResolveError::InvalidPackageTarget(\"../b.js\".to_string())),\n        (\"should resolve package #2\", f, \"#a\", ResolveError::PackageImportNotDefined(\"#a\".to_string())),\n    ];\n\n    for (comment, path, request, error) in fail {\n        let resolution = resolver.resolve(&path, request);\n        assert_eq!(resolution, Err(error), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/incorrect_description_file.rs::incorrect_description_file_1", "test": "fn incorrect_description_file_1() {\n    let f = super::fixture().join(\"incorrect-package\");\n    let resolution = Resolver::default().resolve(f.join(\"pack1\"), \".\");\n    let error = ResolveError::JSON(JSONError {\n        path: f.join(\"pack1/package.json\"),\n        message: String::from(\"EOF while parsing a value at line 3 column 0\"),\n        line: 3,\n        column: 0,\n    });\n    assert_eq!(resolution, Err(error));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/incorrect_description_file.rs::incorrect_description_file_2", "test": "fn incorrect_description_file_2() {\n    let f = super::fixture().join(\"incorrect-package\");\n    let resolution = Resolver::default().resolve(f.join(\"pack2\"), \".\");\n    let error = ResolveError::JSON(JSONError {\n        path: f.join(\"pack2/package.json\"),\n        message: String::from(\"EOF while parsing a value at line 1 column 0\"),\n        line: 1,\n        column: 0,\n    });\n    assert_eq!(resolution, Err(error));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/incorrect_description_file.rs::incorrect_description_file_3", "test": "fn incorrect_description_file_3() {\n    let f = super::fixture().join(\"incorrect-package\");\n    let resolution = Resolver::default().resolve(f.join(\"pack2\"), \".\");\n    assert!(resolution.is_err());\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/incorrect_description_file.rs::no_description_file", "test": "fn no_description_file() {\n    let f = super::fixture_root().join(\"enhanced_resolve\");\n\n    // has description file\n    let resolver = Resolver::default();\n    assert_eq!(\n        resolver.resolve(&f, \".\").map(Resolution::into_path_buf),\n        Ok(f.join(\"lib/index.js\"))\n    );\n\n    // without description file\n    let resolver =\n        Resolver::new(ResolveOptions { description_files: vec![], ..ResolveOptions::default() });\n    assert_eq!(resolver.resolve(&f, \".\"), Err(ResolveError::NotFound(f)));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/main_field.rs::test", "test": "fn test() {\n    let f = super::fixture().join(\"restrictions\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        main_fields: vec![\"style\".into()],\n        ..ResolveOptions::default()\n    });\n\n    let resolution = resolver.resolve(&f, \"pck2\").map(|r| r.full_path());\n    assert_eq!(resolution, Ok(f.join(\"node_modules/pck2/index.css\")));\n\n    let resolver = Resolver::new(ResolveOptions {\n        main_fields: vec![\"module\".into(), \"main\".into()],\n        ..ResolveOptions::default()\n    });\n\n    let resolution = resolver.resolve(&f, \"pck2\").map(|r| r.full_path());\n    assert_eq!(resolution, Ok(f.join(\"node_modules/pck2/module.js\")));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/resolve.rs::resolve", "test": "fn resolve() {\n    let f = super::fixture();\n\n    let resolver = Resolver::default();\n\n    let main1_js_path = f.join(\"main1.js\").to_string_lossy().to_string();\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"absolute path\", f.clone(), main1_js_path.as_str(), f.join(\"main1.js\")),\n        (\"file with .js\", f.clone(), \"./main1.js\", f.join(\"main1.js\")),\n        (\"file without extension\", f.clone(), \"./main1\", f.join(\"main1.js\")),\n        (\"another file with .js\", f.clone(), \"./a.js\", f.join(\"a.js\")),\n        (\"another file without extension\", f.clone(), \"./a\", f.join(\"a.js\")),\n        (\"file in module with .js\", f.clone(), \"m1/a.js\", f.join(\"node_modules/m1/a.js\")),\n        (\"file in module without extension\", f.clone(), \"m1/a\", f.join(\"node_modules/m1/a.js\")),\n        (\"another file in module without extension\", f.clone(), \"complexm/step1\", f.join(\"node_modules/complexm/step1.js\")),\n        (\"from submodule to file in sibling module\", f.join(\"node_modules/complexm\"), \"m2/b.js\", f.join(\"node_modules/m2/b.js\")),\n        (\"from nested directory to overwritten file in module\", f.join(\"multiple_modules\"), \"m1/a.js\", f.join(\"multiple_modules/node_modules/m1/a.js\")),\n        (\"from nested directory to not overwritten file in module\", f.join(\"multiple_modules\"), \"m1/b.js\", f.join(\"node_modules/m1/b.js\")),\n        (\"file with query\", f.clone(), \"./main1.js?query\", f.join(\"main1.js?query\")),\n        (\"file with fragment\", f.clone(), \"./main1.js#fragment\", f.join(\"main1.js#fragment\")),\n        (\"file with fragment and query\", f.clone(), \"./main1.js#fragment?query\", f.join(\"main1.js#fragment?query\")),\n        (\"file with query and fragment\", f.clone(), \"./main1.js?#fragment\", f.join(\"main1.js?#fragment\")),\n        (\"file in module with query\", f.clone(), \"m1/a?query\", f.join(\"node_modules/m1/a.js?query\")),\n        (\"file in module with fragment\", f.clone(), \"m1/a#fragment\", f.join(\"node_modules/m1/a.js#fragment\")),\n        (\"file in module with fragment and query\", f.clone(), \"m1/a#fragment?query\", f.join(\"node_modules/m1/a.js#fragment?query\")),\n        (\"file in module with query and fragment\", f.clone(), \"m1/a?#fragment\", f.join(\"node_modules/m1/a.js?#fragment\")),\n        (\"file in module with query and fragment\", f.clone(), \"m1/a?#fragment\", f.join(\"node_modules/m1/a.js?#fragment\")),\n        (\"differ between directory and file, resolve file\", f.clone(), \"./dirOrFile\", f.join(\"dirOrFile.js\")),\n        (\"differ between directory and file, resolve directory\", f.clone(), \"./dirOrFile/\", f.join(\"dirOrFile/index.js\")),\n        (\"find node_modules outside of node_modules\", f.join(\"browser-module/node_modules\"), \"m1/a\", f.join(\"node_modules/m1/a.js\")),\n        (\"don't crash on main field pointing to self\", f.clone(), \"./main-field-self\", f.join(\"./main-field-self/index.js\")),\n        (\"don't crash on main field pointing to self (2)\", f.clone(), \"./main-field-self2\", f.join(\"./main-field-self2/index.js\")),\n        // enhanced-resolve has `#` prepended with a `\\0`, they are removed from the\n        // following 3 expected test results.\n        // See https://github.com/webpack/enhanced-resolve#escaping\n        (\"handle fragment edge case (no fragment)\", f.clone(), \"./no#fragment/#/#\", f.join(\"no#fragment/#/#.js\")),\n        (\"handle fragment edge case (fragment)\", f.clone(), \"./no#fragment/#/\", f.join(\"no.js#fragment/#/\")),\n        (\"handle fragment escaping\", f.clone(), \"./no\\0#fragment/\\0#/\\0##fragment\", f.join(\"no#fragment/#/#.js#fragment\")),\n    ];\n\n    for (comment, path, request, expected) in pass {\n        let resolved_path = resolver.resolve(&path, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/resolve.rs::issue238_resolve", "test": "fn issue238_resolve() {\n    let f = super::fixture().join(\"issue-238\");\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into(), \".jsx\".into(), \".ts\".into(), \".tsx\".into()],\n        modules: vec![\"src/a\".into(), \"src/b\".into(), \"src/common\".into(), \"node_modules\".into()],\n        ..ResolveOptions::default()\n    });\n    let resolved_path =\n        resolver.resolve(f.join(\"src/common\"), \"config/myObjectFile\").map(|r| r.full_path());\n    assert_eq!(resolved_path, Ok(f.join(\"src/common/config/myObjectFile.js\")),);\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/resolve.rs::prefer_relative", "test": "fn prefer_relative() {\n    let f = super::fixture();\n\n    let resolver =\n        Resolver::new(ResolveOptions { prefer_relative: true, ..ResolveOptions::default() });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"should correctly resolve with preferRelative 1\", \"main1.js\", f.join(\"main1.js\")),\n        (\"should correctly resolve with preferRelative 2\", \"m1/a.js\", f.join(\"node_modules/m1/a.js\")),\n    ];\n\n    for (comment, request, expected) in pass {\n        let resolved_path = resolver.resolve(&f, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/resolve.rs::resolve_to_context", "test": "fn resolve_to_context() {\n    let f = super::fixture();\n    let resolver =\n        Resolver::new(ResolveOptions { resolve_to_context: true, ..ResolveOptions::default() });\n\n    #[rustfmt::skip]\n    let data = [\n        (\"context for fixtures\", f.clone(), \"./\", f.clone()),\n        (\"context for fixtures/lib\", f.clone(), \"./lib\", f.join(\"lib\")),\n        (\"context for fixtures with ..\", f.clone(), \"./lib/../../fixtures/./lib/..\", f.clone()),\n        (\"context for fixtures with query\", f.clone(), \"./?query\", f.clone().with_file_name(\"fixtures?query\")),\n    ];\n\n    for (comment, path, request, expected) in data {\n        let resolved_path = resolver.resolve(&path, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/restrictions.rs::restriction1", "test": "fn restriction1() {\n    let fixture = super::fixture();\n    let f = fixture.join(\"restrictions\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into()],\n        restrictions: vec![Restriction::Path(f.clone())],\n        ..ResolveOptions::default()\n    });\n\n    let resolution = resolver.resolve(&f, \"pck2\");\n    assert_eq!(resolution, Err(ResolveError::Restriction(fixture.join(\"c.js\"))));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/roots.rs::roots", "test": "fn roots() {\n    let f = super::fixture();\n\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into()],\n        alias: vec![(\"foo\".into(), vec![AliasValue::Path(\"/fixtures\".into())])],\n        roots: vec![dirname(), f.clone()],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"should respect roots option\", \"/fixtures/b.js\", f.join(\"b.js\")),\n        (\"should try another root option, if it exists\", \"/b.js\", f.join(\"b.js\")),\n        (\"should respect extension\", \"/fixtures/b\", f.join(\"b.js\")),\n        (\"should resolve in directory\", \"/fixtures/extensions/dir\", f.join(\"extensions/dir/index.js\")),\n        (\"should respect aliases\", \"foo/b\", f.join(\"b.js\")),\n    ];\n\n    for (comment, request, expected) in pass {\n        let resolved_path = resolver.resolve(&f, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {request}\");\n    }\n\n    #[rustfmt::skip]\n    let fail = [\n        (\"should not work with relative path\", \"fixtures/b.js\", ResolveError::NotFound(f.clone()))\n    ];\n\n    for (comment, request, expected) in fail {\n        let resolution = resolver.resolve(&f, request);\n        assert_eq!(resolution, Err(expected), \"{comment} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/roots.rs::resolve_to_context", "test": "fn resolve_to_context() {\n    let f = super::fixture();\n    let resolver = Resolver::new(ResolveOptions {\n        roots: vec![dirname(), f.clone()],\n        resolve_to_context: true,\n        ..ResolveOptions::default()\n    });\n    let resolved_path = resolver.resolve(&f, \"/fixtures/lib\").map(|r| r.full_path());\n    let expected = f.join(\"lib\");\n    assert_eq!(resolved_path, Ok(expected));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/roots.rs::prefer_absolute", "test": "fn prefer_absolute() {\n    let f = super::fixture();\n    let resolver = Resolver::new(ResolveOptions {\n        extensions: vec![\".js\".into()],\n        alias: vec![(\"foo\".into(), vec![AliasValue::Path(\"/fixtures\".into())])],\n        roots: vec![dirname(), f.clone()],\n        prefer_absolute: true,\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"should resolve an absolute path (prefer absolute)\", f.join(\"b.js\").to_string_lossy().to_string(), f.join(\"b.js\")),\n    ];\n\n    for (comment, request, expected) in pass {\n        let resolved_path = resolver.resolve(&f, &request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/scoped_packages.rs::scoped_packages", "test": "fn scoped_packages() {\n    let f = super::fixture().join(\"scoped\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        alias_fields: vec![vec![\"browser\".into()]],\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"main field should work\", f.clone(), \"@scope/pack1\", f.join(\"./node_modules/@scope/pack1/main.js\")),\n        (\"browser field should work\", f.clone(), \"@scope/pack2\", f.join(\"./node_modules/@scope/pack2/main.js\")),\n        (\"folder request should work\", f.clone(), \"@scope/pack2/lib\", f.join(\"./node_modules/@scope/pack2/lib/index.js\"))\n    ];\n\n    for (comment, path, request, expected) in pass {\n        let resolved_path = resolver.resolve(&f, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/simple.rs::simple", "test": "fn simple() {\n    // mimic `enhanced-resolve/test/simple.test.js`\n    let dirname = env::current_dir().unwrap().join(\"fixtures\");\n    let f = dirname.join(\"enhanced_resolve/test\");\n\n    let resolver = Resolver::default();\n\n    let data = [\n        (\"direct\", f.clone(), \"../lib/index\"),\n        (\"as directory\", f, \"..\"),\n        (\"as module\", dirname.clone(), \"./enhanced_resolve\"),\n    ];\n\n    for (comment, path, request) in data {\n        let resolved_path = resolver.resolve(&path, request).map(|f| f.full_path());\n        let expected = dirname.join(\"enhanced_resolve/lib/index.js\");\n        assert_eq!(resolved_path, Ok(expected), \"{comment} {path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/simple.rs::dashed_name", "test": "fn dashed_name() {\n    let f = super::fixture();\n\n    let resolver = Resolver::default();\n\n    let data = [\n        (f.clone(), \"dash\", f.join(\"node_modules/dash/index.js\")),\n        (f.clone(), \"dash-name\", f.join(\"node_modules/dash-name/index.js\")),\n        (f.join(\"node_modules/dash\"), \"dash\", f.join(\"node_modules/dash/index.js\")),\n        (f.join(\"node_modules/dash\"), \"dash-name\", f.join(\"node_modules/dash-name/index.js\")),\n        (f.join(\"node_modules/dash-name\"), \"dash\", f.join(\"node_modules/dash/index.js\")),\n        (f.join(\"node_modules/dash-name\"), \"dash-name\", f.join(\"node_modules/dash-name/index.js\")),\n    ];\n\n    for (path, request, expected) in data {\n        let resolved_path = resolver.resolve(&path, request).map(|f| f.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/symlink.rs::test", "test": "fn test() -> io::Result<()> {\n    let root = super::fixture_root().join(\"enhanced_resolve\");\n    let dirname = root.join(\"test\");\n    let temp_path = dirname.join(\"temp\");\n    if !temp_path.exists() {\n        let is_admin = init(&dirname, &temp_path).is_ok();\n        if !is_admin {\n            return Ok(());\n        }\n        if let Err(err) = create_symlinks(&dirname, &temp_path) {\n            cleanup_symlinks(&temp_path);\n            return Err(err);\n        }\n    }\n\n    let resolver_without_symlinks =\n        Resolver::new(ResolveOptions { symlinks: false, ..ResolveOptions::default() });\n    let resolver_with_symlinks = Resolver::default();\n\n    #[rustfmt::skip]\n    let pass = [\n        (\"with a symlink to a file\", temp_path.clone(), \"./index.js\"),\n        (\"with a relative symlink to a file\", temp_path.clone(), \"./node.relative.js\"),\n        (\"with a relative symlink to a symlink to a file\", temp_path.clone(), \"./node.relative.sym.js\"),\n        (\"with a symlink to a directory 1\", temp_path.clone(), \"./lib/index.js\"),\n        (\"with a symlink to a directory 2\", temp_path.clone(), \"./this/lib/index.js\"),\n        (\"with multiple symlinks in the path 1\", temp_path.clone(), \"./this/test/temp/index.js\"),\n        (\"with multiple symlinks in the path 2\", temp_path.clone(), \"./this/test/temp/lib/index.js\"),\n        (\"with multiple symlinks in the path 3\", temp_path.clone(), \"./this/test/temp/this/lib/index.js\"),\n        (\"with a symlink to a directory 2 (chained)\", temp_path.clone(), \"./that/lib/index.js\"),\n        (\"with multiple symlinks in the path 1 (chained)\", temp_path.clone(), \"./that/test/temp/index.js\"),\n        (\"with multiple symlinks in the path 2 (chained)\", temp_path.clone(), \"./that/test/temp/lib/index.js\"),\n        (\"with multiple symlinks in the path 3 (chained)\", temp_path.clone(), \"./that/test/temp/that/lib/index.js\"),\n        (\"with symlinked directory as context 1\", temp_path.join( \"lib\"), \"./index.js\"),\n        (\"with symlinked directory as context 2\", temp_path.join( \"this\"), \"./lib/index.js\"),\n        (\"with symlinked directory as context and in path\", temp_path.join( \"this\"), \"./test/temp/lib/index.js\"),\n        (\"with symlinked directory in context path\", temp_path.join( \"this/lib\"), \"./index.js\"),\n        (\"with symlinked directory in context path and symlinked file\", temp_path.join( \"this/test\"), \"./temp/index.js\"),\n        (\"with symlinked directory in context path and symlinked directory\", temp_path.join( \"this/test\"), \"./temp/lib/index.js\"),\n        (\"with symlinked directory as context 2 (chained)\", temp_path.join( \"that\"), \"./lib/index.js\"),\n        (\"with symlinked directory as context and in path (chained)\", temp_path.join( \"that\"), \"./test/temp/lib/index.js\"),\n        (\"with symlinked directory in context path (chained)\", temp_path.join( \"that/lib\"), \"./index.js\"),\n        (\"with symlinked directory in context path and symlinked file (chained)\", temp_path.join( \"that/test\"), \"./temp/index.js\"),\n        (\"with symlinked directory in context path and symlinked directory (chained)\", temp_path.join( \"that/test\"), \"./temp/lib/index.js\")\n    ];\n\n    for (comment, path, request) in pass {\n        let filename = resolver_with_symlinks.resolve(&path, request).map(|r| r.full_path());\n        assert_eq!(filename, Ok(root.join(\"lib/index.js\")), \"{comment:?}\");\n\n        let resolved_path =\n            resolver_without_symlinks.resolve(&path, request).map(|r| r.full_path());\n        assert_eq!(resolved_path, Ok(path.join(request)));\n    }\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/tsconfig_paths.rs::tsconfig", "test": "fn tsconfig() {\n    let f = super::fixture_root().join(\"parcel\");\n\n    #[rustfmt::skip]\n    let pass = [\n        (f.clone(), \"ts-path\", f.join(\"foo.js\")),\n        (f.join(\"nested\"), \"ts-path\", f.join(\"nested/test.js\")),\n        (f.join(\"tsconfig/index\"), \"foo\", f.join(\"node_modules/tsconfig-index/foo.js\")),\n        // This requires reading package.json.tsconfig field\n        // (f.join(\"tsconfig/field\"), \"foo\", f.join(\"node_modules/tsconfig-field/foo.js\"))\n        (f.join(\"tsconfig/exports\"), \"foo\", f.join(\"node_modules/tsconfig-exports/foo.js\")),\n        (f.join(\"tsconfig/extends-extension\"), \"foo\", f.join(\"tsconfig/extends-extension/foo.js\")),\n        (f.join(\"tsconfig/extends-extensionless\"), \"foo\", f.join(\"node_modules/tsconfig-field/foo.js\"))\n    ];\n\n    for (path, request, expected) in pass {\n        let resolver = Resolver::new(ResolveOptions {\n            tsconfig: Some(TsconfigOptions {\n                config_file: path.join(\"tsconfig.json\"),\n                references: TsconfigReferences::Auto,\n            }),\n            ..ResolveOptions::default()\n        });\n        let resolved_path = resolver.resolve(&path, request).map(|f| f.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{request} {path:?}\");\n    }\n\n    #[rustfmt::skip]\n    let data = [\n        (f.join(\"node_modules/tsconfig-not-used\"), \"ts-path\", Ok(f.join(\"foo.js\"))),\n    ];\n\n    let resolver = Resolver::new(ResolveOptions {\n        tsconfig: Some(TsconfigOptions {\n            config_file: f.join(\"tsconfig.json\"),\n            references: TsconfigReferences::Auto,\n        }),\n        ..ResolveOptions::default()\n    });\n    for (path, request, expected) in data {\n        let resolution = resolver.resolve(&path, request).map(|f| f.full_path());\n        assert_eq!(resolution, expected, \"{path:?} {request}\");\n    }\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/tsconfig_paths.rs::json_with_comments", "test": "fn json_with_comments() {\n    let f = super::fixture_root().join(\"parcel/tsconfig/trailing-comma\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        tsconfig: Some(TsconfigOptions {\n            config_file: f.join(\"tsconfig.json\"),\n            references: TsconfigReferences::Auto,\n        }),\n        ..ResolveOptions::default()\n    });\n\n    let resolved_path = resolver.resolve(&f, \"foo\").map(|f| f.full_path());\n    assert_eq!(resolved_path, Ok(f.join(\"bar.js\")));\n}", "error": "Not Definition Found"}
{"test_id": "web-infra-dev-oxc/oxc-project-oxc-884a819/crates/oxc_resolver/src/tests/tsconfig_project_references.rs::auto", "test": "fn auto() {\n    let f = super::fixture_root().join(\"tsconfig_project_references\");\n\n    let resolver = Resolver::new(ResolveOptions {\n        tsconfig: Some(TsconfigOptions {\n            config_file: f.join(\"app\"),\n            references: TsconfigReferences::Auto,\n        }),\n        ..ResolveOptions::default()\n    });\n\n    #[rustfmt::skip]\n    let pass = [\n        // Test normal paths alias\n        (f.join(\"app\"), \"@/index.ts\", f.join(\"app/aliased/index.ts\")),\n        (f.join(\"app\"), \"@/../index.ts\", f.join(\"app/index.ts\")),\n        // Test project reference\n        (f.join(\"project_a\"), \"@/index.ts\", f.join(\"project_a/aliased/index.ts\")),\n        (f.join(\"project_b/src\"), \"@/index.ts\", f.join(\"project_b/src/aliased/index.ts\")),\n        // Does not have paths alias\n        (f.join(\"project_a\"), \"./index.ts\", f.join(\"project_a/index.ts\")),\n        (f.join(\"project_c\"), \"./index.ts\", f.join(\"project_c/index.ts\")),\n    ];\n\n    for (path, request, expected) in pass {\n        let resolved_path = resolver.resolve(&path, request).map(|f| f.full_path());\n        assert_eq!(resolved_path, Ok(expected), \"{request} {path:?}\");\n    }\n}", "error": "Not Definition Found"}
