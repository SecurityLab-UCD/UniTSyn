{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::config_builder_for_client_rejects_empty_kx_groups", "test": "fn config_builder_for_client_rejects_empty_kx_groups() {\n    assert_eq!(\n        ClientConfig::builder()\n            .with_safe_default_cipher_suites()\n            .with_kx_groups(&[])\n            .with_safe_default_protocol_versions()\n            .err(),\n        Some(Error::General(\"no kx groups configured\".into()))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::config_builder_for_client_rejects_empty_cipher_suites", "test": "fn config_builder_for_client_rejects_empty_cipher_suites() {\n    assert_eq!(\n        ClientConfig::builder()\n            .with_cipher_suites(&[])\n            .with_safe_default_kx_groups()\n            .with_safe_default_protocol_versions()\n            .err(),\n        Some(Error::General(\"no usable cipher suites configured\".into()))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::config_builder_for_client_rejects_incompatible_cipher_suites", "test": "fn config_builder_for_client_rejects_incompatible_cipher_suites() {\n    assert_eq!(\n        ClientConfig::builder()\n            .with_cipher_suites(&[rustls::cipher_suite::TLS13_AES_256_GCM_SHA384])\n            .with_safe_default_kx_groups()\n            .with_protocol_versions(&[&rustls::version::TLS12])\n            .err(),\n        Some(Error::General(\"no usable cipher suites configured\".into()))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::config_builder_for_server_rejects_empty_kx_groups", "test": "fn config_builder_for_server_rejects_empty_kx_groups() {\n    assert_eq!(\n        ServerConfig::builder()\n            .with_safe_default_cipher_suites()\n            .with_kx_groups(&[])\n            .with_safe_default_protocol_versions()\n            .err(),\n        Some(Error::General(\"no kx groups configured\".into()))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::config_builder_for_server_rejects_empty_cipher_suites", "test": "fn config_builder_for_server_rejects_empty_cipher_suites() {\n    assert_eq!(\n        ServerConfig::builder()\n            .with_cipher_suites(&[])\n            .with_safe_default_kx_groups()\n            .with_safe_default_protocol_versions()\n            .err(),\n        Some(Error::General(\"no usable cipher suites configured\".into()))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::config_builder_for_server_rejects_incompatible_cipher_suites", "test": "fn config_builder_for_server_rejects_incompatible_cipher_suites() {\n    assert_eq!(\n        ServerConfig::builder()\n            .with_cipher_suites(&[rustls::cipher_suite::TLS13_AES_256_GCM_SHA384])\n            .with_safe_default_kx_groups()\n            .with_protocol_versions(&[&rustls::version::TLS12])\n            .err(),\n        Some(Error::General(\"no usable cipher suites configured\".into()))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_can_get_server_cert", "test": "fn client_can_get_server_cert() {\n    for kt in ALL_KEY_TYPES.iter() {\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions(*kt, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_configs(client_config, make_server_config(*kt));\n            do_handshake(&mut client, &mut server);\n\n            let certs = client.peer_certificates();\n            assert_eq!(certs, Some(kt.get_chain().as_slice()));\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_can_get_client_cert", "test": "fn server_can_get_client_cert() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let server_config = Arc::new(make_server_config_with_mandatory_client_auth(*kt));\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions_with_auth(*kt, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n            do_handshake(&mut client, &mut server);\n\n            let certs = server.peer_certificates();\n            assert_eq!(certs, Some(kt.get_client_chain().as_slice()));\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_allow_any_anonymous_or_authenticated_client", "test": "fn server_allow_any_anonymous_or_authenticated_client() {\n    let kt = KeyType::Rsa;\n    for client_cert_chain in [None, Some(kt.get_client_chain())].iter() {\n        let client_auth_roots = get_client_root_store(kt);\n        let client_auth = AllowAnyAnonymousOrAuthenticatedClient::new(client_auth_roots);\n\n        let server_config = ServerConfig::builder()\n            .with_safe_defaults()\n            .with_client_cert_verifier(Arc::new(client_auth))\n            .with_single_cert(kt.get_chain(), kt.get_key())\n            .unwrap();\n        let server_config = Arc::new(server_config);\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = if client_cert_chain.is_some() {\n                make_client_config_with_versions_with_auth(kt, &[version])\n            } else {\n                make_client_config_with_versions(kt, &[version])\n            };\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n            do_handshake(&mut client, &mut server);\n\n            let certs = server.peer_certificates();\n            assert_eq!(certs, client_cert_chain.as_deref());\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_cert_resolve_with_sni", "test": "fn server_cert_resolve_with_sni() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let client_config = make_client_config(*kt);\n        let mut server_config = make_server_config(*kt);\n\n        server_config.cert_resolver = Arc::new(ServerCheckCertResolve {\n            expected_sni: Some(\"the-value-from-sni\".into()),\n            ..Default::default()\n        });\n\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"the-value-from-sni\")).unwrap();\n        let mut server = ServerConnection::new(Arc::new(server_config)).unwrap();\n\n        let err = do_handshake_until_error(&mut client, &mut server);\n        assert!(err.is_err());\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_cert_resolve_with_alpn", "test": "fn server_cert_resolve_with_alpn() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let mut client_config = make_client_config(*kt);\n        client_config.alpn_protocols = vec![\"foo\".into(), \"bar\".into()];\n\n        let mut server_config = make_server_config(*kt);\n        server_config.cert_resolver = Arc::new(ServerCheckCertResolve {\n            expected_alpn: Some(vec![b\"foo\".to_vec(), b\"bar\".to_vec()]),\n            ..Default::default()\n        });\n\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"sni-value\")).unwrap();\n        let mut server = ServerConnection::new(Arc::new(server_config)).unwrap();\n\n        let err = do_handshake_until_error(&mut client, &mut server);\n        assert!(err.is_err());\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_trims_terminating_dot", "test": "fn client_trims_terminating_dot() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let client_config = make_client_config(*kt);\n        let mut server_config = make_server_config(*kt);\n\n        server_config.cert_resolver = Arc::new(ServerCheckCertResolve {\n            expected_sni: Some(\"some-host.com\".into()),\n            ..Default::default()\n        });\n\n        let mut client =\n            ClientConnection::new(Arc::new(client_config), dns_name(\"some-host.com.\")).unwrap();\n        let mut server = ServerConnection::new(Arc::new(server_config)).unwrap();\n\n        let err = do_handshake_until_error(&mut client, &mut server);\n        assert!(err.is_err());\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_with_sni_disabled_does_not_send_sni", "test": "fn client_with_sni_disabled_does_not_send_sni() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let mut server_config = make_server_config(*kt);\n        server_config.cert_resolver = Arc::new(ServerCheckNoSNI {});\n        let server_config = Arc::new(server_config);\n\n        for version in rustls::ALL_VERSIONS {\n            let mut client_config = make_client_config_with_versions(*kt, &[version]);\n            client_config.enable_sni = false;\n\n            let mut client =\n                ClientConnection::new(Arc::new(client_config), dns_name(\"value-not-sent\")).unwrap();\n            let mut server = ServerConnection::new(Arc::clone(&server_config)).unwrap();\n\n            let err = do_handshake_until_error(&mut client, &mut server);\n            assert!(err.is_err());\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_checks_server_certificate_with_given_name", "test": "fn client_checks_server_certificate_with_given_name() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let server_config = Arc::new(make_server_config(*kt));\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions(*kt, &[version]);\n            let mut client = ClientConnection::new(\n                Arc::new(client_config),\n                dns_name(\"not-the-right-hostname.com\"),\n            )\n            .unwrap();\n            let mut server = ServerConnection::new(Arc::clone(&server_config)).unwrap();\n\n            let err = do_handshake_until_error(&mut client, &mut server);\n            assert_eq!(\n                err,\n                Err(ErrorFromPeer::Client(Error::InvalidCertificate(\n                    CertificateError::NotValidForName\n                )))\n            );\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_mandatory_auth_revocation_works", "test": "fn client_mandatory_auth_revocation_works() {\n    for kt in ALL_KEY_TYPES.iter() {\n        // Create a server configuration that includes a CRL that specifies the client certificate\n        // is revoked.\n        let crls = vec![kt.client_crl()];\n        let server_config = Arc::new(make_server_config_with_mandatory_client_auth_crls(\n            *kt, crls,\n        ));\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions_with_auth(*kt, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n            // Because the client certificate is revoked, the handshake should fail.\n            let err = do_handshake_until_error(&mut client, &mut server);\n            assert_eq!(\n                err,\n                Err(ErrorFromPeer::Server(Error::InvalidCertificate(\n                    CertificateError::Revoked\n                )))\n            );\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_optional_auth_revocation_works", "test": "fn client_optional_auth_revocation_works() {\n    for kt in ALL_KEY_TYPES.iter() {\n        // Create a server configuration that includes a CRL that specifies the client certificate\n        // is revoked.\n        let crls = vec![kt.client_crl()];\n        let server_config = Arc::new(make_server_config_with_optional_client_auth(*kt, crls));\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions_with_auth(*kt, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n            // Because the client certificate is revoked, the handshake should fail.\n            let err = do_handshake_until_error(&mut client, &mut server);\n            assert_eq!(\n                err,\n                Err(ErrorFromPeer::Server(Error::InvalidCertificate(\n                    CertificateError::Revoked\n                )))\n            );\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_error_is_sticky", "test": "fn client_error_is_sticky() {\n    let (mut client, _) = make_pair(KeyType::Rsa);\n    client\n        .read_tls(&mut b\"\\x16\\x03\\x03\\x00\\x08\\x0f\\x00\\x00\\x04junk\".as_ref())\n        .unwrap();\n    let mut err = client.process_new_packets();\n    assert!(err.is_err());\n    err = client.process_new_packets();\n    assert!(err.is_err());\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_error_is_sticky", "test": "fn server_error_is_sticky() {\n    let (_, mut server) = make_pair(KeyType::Rsa);\n    server\n        .read_tls(&mut b\"\\x16\\x03\\x03\\x00\\x08\\x0f\\x00\\x00\\x04junk\".as_ref())\n        .unwrap();\n    let mut err = server.process_new_packets();\n    assert!(err.is_err());\n    err = server.process_new_packets();\n    assert!(err.is_err());\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::stream_write_reports_underlying_io_error_before_plaintext_processed", "test": "fn stream_write_reports_underlying_io_error_before_plaintext_processed() {\n    let (mut client, mut server) = make_pair(KeyType::Rsa);\n    do_handshake(&mut client, &mut server);\n\n    let mut pipe = FailsWrites {\n        errkind: io::ErrorKind::ConnectionAborted,\n        after: 0,\n    };\n    client\n        .writer()\n        .write_all(b\"hello\")\n        .unwrap();\n    let mut client_stream = Stream::new(&mut client, &mut pipe);\n    let rc = client_stream.write(b\"world\");\n    assert!(rc.is_err());\n    let err = rc.err().unwrap();\n    assert_eq!(err.kind(), io::ErrorKind::ConnectionAborted);\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_stream_handshake_error", "test": "fn client_stream_handshake_error() {\n    let (client_config, server_config) = make_disjoint_suite_configs();\n    let (mut client, mut server) = make_pair_for_configs(client_config, server_config);\n\n    {\n        let mut pipe = OtherSession::new_fails(&mut server);\n        let mut client_stream = Stream::new(&mut client, &mut pipe);\n        let rc = client_stream.write(b\"hello\");\n        assert!(rc.is_err());\n        assert_eq!(\n            format!(\"{:?}\", rc),\n            \"Err(Custom { kind: InvalidData, error: AlertReceived(HandshakeFailure) })\"\n        );\n        let rc = client_stream.write(b\"hello\");\n        assert!(rc.is_err());\n        assert_eq!(\n            format!(\"{:?}\", rc),\n            \"Err(Custom { kind: InvalidData, error: AlertReceived(HandshakeFailure) })\"\n        );\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::client_streamowned_handshake_error", "test": "fn client_streamowned_handshake_error() {\n    let (client_config, server_config) = make_disjoint_suite_configs();\n    let (client, mut server) = make_pair_for_configs(client_config, server_config);\n\n    let pipe = OtherSession::new_fails(&mut server);\n    let mut client_stream = StreamOwned::new(client, pipe);\n    let rc = client_stream.write(b\"hello\");\n    assert!(rc.is_err());\n    assert_eq!(\n        format!(\"{:?}\", rc),\n        \"Err(Custom { kind: InvalidData, error: AlertReceived(HandshakeFailure) })\"\n    );\n    let rc = client_stream.write(b\"hello\");\n    assert!(rc.is_err());\n    assert_eq!(\n        format!(\"{:?}\", rc),\n        \"Err(Custom { kind: InvalidData, error: AlertReceived(HandshakeFailure) })\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_stream_handshake_error", "test": "fn server_stream_handshake_error() {\n    let (client_config, server_config) = make_disjoint_suite_configs();\n    let (mut client, mut server) = make_pair_for_configs(client_config, server_config);\n\n    client\n        .writer()\n        .write_all(b\"world\")\n        .unwrap();\n\n    {\n        let mut pipe = OtherSession::new_fails(&mut client);\n        let mut server_stream = Stream::new(&mut server, &mut pipe);\n        let mut bytes = [0u8; 5];\n        let rc = server_stream.read(&mut bytes);\n        assert!(rc.is_err());\n        assert_eq!(\n            format!(\"{:?}\", rc),\n            \"Err(Custom { kind: InvalidData, error: PeerIncompatible(NoCipherSuitesInCommon) })\"\n        );\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::server_streamowned_handshake_error", "test": "fn server_streamowned_handshake_error() {\n    let (client_config, server_config) = make_disjoint_suite_configs();\n    let (mut client, server) = make_pair_for_configs(client_config, server_config);\n\n    client\n        .writer()\n        .write_all(b\"world\")\n        .unwrap();\n\n    let pipe = OtherSession::new_fails(&mut client);\n    let mut server_stream = StreamOwned::new(server, pipe);\n    let mut bytes = [0u8; 5];\n    let rc = server_stream.read(&mut bytes);\n    assert!(rc.is_err());\n    assert_eq!(\n        format!(\"{:?}\", rc),\n        \"Err(Custom { kind: InvalidData, error: PeerIncompatible(NoCipherSuitesInCommon) })\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::sni_resolver_works", "test": "fn sni_resolver_works() {\n    let kt = KeyType::Rsa;\n    let mut resolver = rustls::server::ResolvesServerCertUsingSni::new();\n    let signing_key = sign::RsaSigningKey::new(&kt.get_key()).unwrap();\n    let signing_key: Arc<dyn sign::SigningKey> = Arc::new(signing_key);\n    resolver\n        .add(\n            \"localhost\",\n            sign::CertifiedKey::new(kt.get_chain(), signing_key.clone()),\n        )\n        .unwrap();\n\n    let mut server_config = make_server_config(kt);\n    server_config.cert_resolver = Arc::new(resolver);\n    let server_config = Arc::new(server_config);\n\n    let mut server1 = ServerConnection::new(Arc::clone(&server_config)).unwrap();\n    let mut client1 =\n        ClientConnection::new(Arc::new(make_client_config(kt)), dns_name(\"localhost\")).unwrap();\n    let err = do_handshake_until_error(&mut client1, &mut server1);\n    assert_eq!(err, Ok(()));\n\n    let mut server2 = ServerConnection::new(Arc::clone(&server_config)).unwrap();\n    let mut client2 =\n        ClientConnection::new(Arc::new(make_client_config(kt)), dns_name(\"notlocalhost\")).unwrap();\n    let err = do_handshake_until_error(&mut client2, &mut server2);\n    assert_eq!(\n        err,\n        Err(ErrorFromPeer::Server(Error::General(\n            \"no server certificate chain resolved\".into()\n        )))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/api.rs::sni_resolver_rejects_wrong_names", "test": "fn sni_resolver_rejects_wrong_names() {\n    let kt = KeyType::Rsa;\n    let mut resolver = rustls::server::ResolvesServerCertUsingSni::new();\n    let signing_key = sign::RsaSigningKey::new(&kt.get_key()).unwrap();\n    let signing_key: Arc<dyn sign::SigningKey> = Arc::new(signing_key);\n\n    assert_eq!(\n        Ok(()),\n        resolver.add(\n            \"localhost\",\n            sign::CertifiedKey::new(kt.get_chain(), signing_key.clone())\n        )\n    );\n    assert_eq!(\n        Err(Error::General(\n            \"The server certificate is not valid for the given name\".into()\n        )),\n        resolver.add(\n            \"not-localhost\",\n            sign::CertifiedKey::new(kt.get_chain(), signing_key.clone())\n        )\n    );\n    assert_eq!(\n        Err(Error::General(\"Bad DNS name\".into())),\n        resolver.add(\n            \"not ascii ðŸ¦€\",\n            sign::CertifiedKey::new(kt.get_chain(), signing_key.clone())\n        )\n    );\n}\n\n#", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/client_cert_verifier.rs::client_verifier_no_schemes", "test": "fn client_verifier_no_schemes() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let client_verifier = MockClientVerifier {\n            verified: ver_ok,\n            subjects: get_client_root_store(*kt)\n                .roots\n                .iter()\n                .map(|r| r.subject().clone())\n                .collect(),\n            mandatory: true,\n            offered_schemes: Some(vec![]),\n        };\n\n        let server_config = server_config_with_verifier(*kt, client_verifier);\n        let server_config = Arc::new(server_config);\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions_with_auth(*kt, &[version]);\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config.clone()), &server_config);\n            let err = do_handshake_until_error(&mut client, &mut server);\n            assert_eq!(\n                err,\n                Err(ErrorFromPeer::Client(Error::InvalidMessage(\n                    InvalidMessage::NoSignatureSchemes,\n                ))),\n            );\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/client_cert_verifier.rs::client_verifier_no_auth_yes_root", "test": "fn client_verifier_no_auth_yes_root() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let client_verifier = MockClientVerifier {\n            verified: ver_unreachable,\n            subjects: get_client_root_store(*kt)\n                .roots\n                .iter()\n                .map(|r| r.subject().clone())\n                .collect(),\n            mandatory: true,\n            offered_schemes: None,\n        };\n\n        let server_config = server_config_with_verifier(*kt, client_verifier);\n        let server_config = Arc::new(server_config);\n\n        for version in rustls::ALL_VERSIONS {\n            let client_config = make_client_config_with_versions(*kt, &[version]);\n            let mut server = ServerConnection::new(Arc::clone(&server_config)).unwrap();\n            let mut client =\n                ClientConnection::new(Arc::new(client_config), dns_name(\"localhost\")).unwrap();\n            let errs = do_handshake_until_both_error(&mut client, &mut server);\n            assert_eq!(\n                errs,\n                Err(vec![\n                    ErrorFromPeer::Server(Error::NoCertificatesPresented),\n                    ErrorFromPeer::Client(Error::AlertReceived(\n                        AlertDescription::CertificateRequired\n                    ))\n                ])\n            );\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/server_cert_verifier.rs::client_can_override_certificate_verification_and_reject_certificate", "test": "fn client_can_override_certificate_verification_and_reject_certificate() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let verifier = Arc::new(MockServerVerifier::rejects_certificate(\n            Error::InvalidMessage(InvalidMessage::HandshakePayloadTooLarge),\n        ));\n\n        let server_config = Arc::new(make_server_config(*kt));\n\n        for version in rustls::ALL_VERSIONS {\n            let mut client_config = make_client_config_with_versions(*kt, &[version]);\n            client_config\n                .dangerous()\n                .set_certificate_verifier(verifier.clone());\n\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n            let errs = do_handshake_until_both_error(&mut client, &mut server);\n            assert_eq!(\n                errs,\n                Err(vec![\n                    ErrorFromPeer::Client(Error::InvalidMessage(\n                        InvalidMessage::HandshakePayloadTooLarge,\n                    )),\n                    ErrorFromPeer::Server(Error::AlertReceived(AlertDescription::HandshakeFailure)),\n                ]),\n            );\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/server_cert_verifier.rs::client_can_override_certificate_verification_and_reject_tls12_signatures", "test": "fn client_can_override_certificate_verification_and_reject_tls12_signatures() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let mut client_config = make_client_config_with_versions(*kt, &[&rustls::version::TLS12]);\n        let verifier = Arc::new(MockServerVerifier::rejects_tls12_signatures(\n            Error::InvalidMessage(InvalidMessage::HandshakePayloadTooLarge),\n        ));\n\n        client_config\n            .dangerous()\n            .set_certificate_verifier(verifier);\n\n        let server_config = Arc::new(make_server_config(*kt));\n\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n        let errs = do_handshake_until_both_error(&mut client, &mut server);\n        assert_eq!(\n            errs,\n            Err(vec![\n                ErrorFromPeer::Client(Error::InvalidMessage(\n                    InvalidMessage::HandshakePayloadTooLarge,\n                )),\n                ErrorFromPeer::Server(Error::AlertReceived(AlertDescription::HandshakeFailure)),\n            ]),\n        );\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/server_cert_verifier.rs::client_can_override_certificate_verification_and_reject_tls13_signatures", "test": "fn client_can_override_certificate_verification_and_reject_tls13_signatures() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let mut client_config = make_client_config_with_versions(*kt, &[&rustls::version::TLS13]);\n        let verifier = Arc::new(MockServerVerifier::rejects_tls13_signatures(\n            Error::InvalidMessage(InvalidMessage::HandshakePayloadTooLarge),\n        ));\n\n        client_config\n            .dangerous()\n            .set_certificate_verifier(verifier);\n\n        let server_config = Arc::new(make_server_config(*kt));\n\n        let (mut client, mut server) =\n            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n        let errs = do_handshake_until_both_error(&mut client, &mut server);\n        assert_eq!(\n            errs,\n            Err(vec![\n                ErrorFromPeer::Client(Error::InvalidMessage(\n                    InvalidMessage::HandshakePayloadTooLarge,\n                )),\n                ErrorFromPeer::Server(Error::AlertReceived(AlertDescription::HandshakeFailure)),\n            ]),\n        );\n    }\n}", "error": "Not Definition Found"}
{"test_id": "rustls-rustls/rustls-rustls-ae583bd/rustls/tests/server_cert_verifier.rs::client_can_override_certificate_verification_and_offer_no_signature_schemes", "test": "fn client_can_override_certificate_verification_and_offer_no_signature_schemes() {\n    for kt in ALL_KEY_TYPES.iter() {\n        let verifier = Arc::new(MockServerVerifier::offers_no_signature_schemes());\n\n        let server_config = Arc::new(make_server_config(*kt));\n\n        for version in rustls::ALL_VERSIONS {\n            let mut client_config = make_client_config_with_versions(*kt, &[version]);\n            client_config\n                .dangerous()\n                .set_certificate_verifier(verifier.clone());\n\n            let (mut client, mut server) =\n                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);\n            let errs = do_handshake_until_both_error(&mut client, &mut server);\n            assert_eq!(\n                errs,\n                Err(vec![\n                    ErrorFromPeer::Server(Error::PeerIncompatible(\n                        rustls::PeerIncompatible::NoSignatureSchemesInCommon\n                    )),\n                    ErrorFromPeer::Client(Error::AlertReceived(AlertDescription::HandshakeFailure)),\n                ])\n            );\n        }\n    }\n}", "error": "Not Definition Found"}
