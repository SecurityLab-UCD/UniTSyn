{"test_id": "tokio-rs-prost/tokio-rs-prost-0c89fa6/conformance/tests/conformance.rs::test_conformance", "test": "fn test_conformance() {\n    // Get the path to the proto-conformance binary. Adapted from\n    // https://github.com/rust-lang/cargo/blob/19fdb308cdbb25faf4f1e25a71351d8d603fa447/tests/cargotest/support/mod.rs#L306.\n    let proto_conformance = env::current_exe()\n        .map(|mut path| {\n            path.pop();\n            if path.ends_with(\"deps\") {\n                path.pop();\n            }\n            path.join(\"conformance\")\n        })\n        .unwrap();\n\n    let status = Command::new(conformance::test_runner())\n        .arg(\"--enforce_recommended\")\n        .arg(\"--failure_list\")\n        .arg(\"failing_tests.txt\")\n        .arg(proto_conformance)\n        .status()\n        .expect(\"failed to execute conformance-test-runner\");\n\n    assert!(status.success(), \"proto conformance test failed\");\n}", "error": "Not Definition Found"}
{"test_id": "tokio-rs-prost/tokio-rs-prost-0c89fa6/tests/src/generic_derive.rs::generic_enum", "test": "fn generic_enum() {\n    let msg = GenericMessage { data: Some(100u64) };\n    let enumeration = GenericEnum::Data(msg);\n    match enumeration {\n        GenericEnum::Data(d) => assert_eq!(100, d.data.unwrap()),\n        GenericEnum::Number(_) => panic!(\"Not supposed to reach\"),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "tokio-rs-prost/tokio-rs-prost-0c89fa6/tests/src/unittest.rs::extreme_default_values", "test": "fn extreme_default_values() {\n    let pb = protobuf_unittest::TestExtremeDefaultValues::default();\n\n    assert_eq!(\n        b\"\\0\\x01\\x07\\x08\\x0C\\n\\r\\t\\x0B\\\\\\'\\\"\\xFE\",\n        pb.escaped_bytes()\n    );\n\n    assert_eq!(0xFFFFFFFF, pb.large_uint32());\n    assert_eq!(0xFFFFFFFFFFFFFFFF, pb.large_uint64());\n    assert_eq!(-0x7FFFFFFF, pb.small_int32());\n    assert_eq!(-0x7FFFFFFFFFFFFFFF, pb.small_int64());\n    assert_eq!(-0x80000000, pb.really_small_int32());\n    assert_eq!(-0x8000000000000000, pb.really_small_int64());\n\n    assert_eq!(pb.utf8_string(), \"\\u{1234}\");\n\n    assert_eq!(0.0, pb.zero_float());\n    assert_eq!(1.0, pb.one_float());\n    assert_eq!(1.5, pb.small_float());\n    assert_eq!(-1.0, pb.negative_one_float());\n    assert_eq!(-1.5, pb.negative_float());\n    assert_eq!(2E8, pb.large_float());\n    assert_eq!(-8e-28, pb.small_negative_float());\n\n    assert_eq!(f64::INFINITY, pb.inf_double());\n    assert_eq!(f64::NEG_INFINITY, pb.neg_inf_double());\n    assert_ne!(pb.nan_double(), pb.nan_double());\n    assert_eq!(f32::INFINITY, pb.inf_float());\n    assert_eq!(f32::NEG_INFINITY, pb.neg_inf_float());\n    assert_ne!(pb.nan_float(), pb.nan_float());\n\n    assert_eq!(\"? ? ?? ?? ??? ??/ ??-\", pb.cpp_trigraph());\n\n    assert_eq!(\"hel\\x00lo\", pb.string_with_zero());\n    assert_eq!(b\"wor\\x00ld\", pb.bytes_with_zero());\n    assert_eq!(\"ab\\x00c\", pb.string_piece_with_zero());\n    assert_eq!(\"12\\x003\", pb.cord_with_zero());\n    assert_eq!(\"${unknown}\", pb.replacement_string());\n}", "error": "Not Definition Found"}
{"test_id": "tokio-rs-prost/tokio-rs-prost-0c89fa6/tests/src/well_known_types.rs::test_timestamp", "test": "fn test_timestamp() {\n    use std::collections::HashSet;\n\n    let timestamp = ::prost_types::Timestamp {\n        seconds: 100,\n        nanos: 42,\n    };\n\n    let mut non_normalized_timestamp = ::prost_types::Timestamp {\n        seconds: 99,\n        nanos: 1_000_000_042,\n    };\n\n    let mut hashset = HashSet::new();\n    assert!(hashset.insert(timestamp.clone()));\n    assert!(\n        hashset.insert(non_normalized_timestamp.clone()),\n        \"hash for non-normalized different and should be inserted\"\n    );\n\n    assert_ne!(\n        timestamp, non_normalized_timestamp,\n        \"non-nomarlized timestamp considered different\"\n    );\n    non_normalized_timestamp.normalize();\n    assert_eq!(\n        timestamp, non_normalized_timestamp,\n        \"normalized timestamp matches\"\n    );\n\n    let mut hashset = HashSet::new();\n    assert!(hashset.insert(timestamp));\n    assert!(\n        !hashset.insert(non_normalized_timestamp),\n        \"hash for normalized should match and not inserted\"\n    );\n}", "error": "Not Definition Found"}
