{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/wasm/tests/wasm_testsuite.rs::use_name_section", "test": "fn use_name_section() {\n    let data = wat::parse_str(\n        r#\"\n        (module $module_name\n            (func $func_name (local $loc_name i32)\n            )\n        )\"#,\n    )\n    .unwrap();\n\n    let mut dummy_environ = DummyEnvironment::new(TargetFrontendConfig {\n        default_call_conv: CallConv::SystemV,\n        pointer_width: PointerWidth::U32,\n    });\n\n    translate_module(data.as_ref(), &mut dummy_environ).unwrap();\n\n    assert_eq!(\n        dummy_environ.get_func_name(FuncIndex::from_u32(0)).unwrap(),\n        \"func_name\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/cache/tests/cache_write_default_config.rs::test_cache_write_default_config", "test": "fn test_cache_write_default_config() {\n    let dir = tempfile::tempdir().expect(\"Can't create temporary directory\");\n    let config_path = dir.path().join(\"cache-config.toml\");\n\n    let result = create_new_config(Some(&config_path));\n    assert!(result.is_ok());\n    assert!(config_path.exists());\n    assert_eq!(config_path, result.unwrap());\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/records.rs::pair_ints_offsets", "test": "fn pair_ints_offsets() {\n    assert_eq!(types::PairInts::offset_of_first(), 0);\n    assert_eq!(types::PairInts::offset_of_second(), 4);\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/records.rs::pair_different_ints_offsets", "test": "fn pair_different_ints_offsets() {\n    assert_eq!(types::PairDifferentInts::offset_of_first(), 0);\n    assert_eq!(types::PairDifferentInts::offset_of_second(), 8);\n    assert_eq!(types::PairDifferentInts::offset_of_third(), 10);\n    assert_eq!(types::PairDifferentInts::offset_of_fourth(), 12);\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/records.rs::pair_int_ptrs_offsets", "test": "fn pair_int_ptrs_offsets() {\n    assert_eq!(types::PairIntPtrs::offset_of_first(), 0);\n    assert_eq!(types::PairIntPtrs::offset_of_second(), 4);\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/records.rs::pair_int_and_ptr_offsets", "test": "fn pair_int_and_ptr_offsets() {\n    assert_eq!(types::PairIntAndPtr::offset_of_first(), 0);\n    assert_eq!(types::PairIntAndPtr::offset_of_second(), 4);\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/records.rs::pair_record_of_list_offset", "test": "fn pair_record_of_list_offset() {\n    assert_eq!(types::RecordOfList::offset_of_arr(), 0);\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/wasmtime_integration.rs::test_sync_host_func", "test": "fn test_sync_host_func() {\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    integration::add_atoms_to_linker(&mut linker, |cx| cx).unwrap();\n    let mut store = store(&engine);\n    let shim_mod = shim_module(&engine);\n    let shim_inst = linker.instantiate(&mut store, &shim_mod).unwrap();\n\n    let mut results = [Val::I32(0)];\n    shim_inst\n        .get_func(&mut store, \"int_float_args_shim\")\n        .unwrap()\n        .call(&mut store, &[0i32.into(), 123.45f32.into()], &mut results)\n        .unwrap();\n\n    assert_eq!(\n        results[0].unwrap_i32(),\n        types::Errno::Ok as i32,\n        \"int_float_args errno\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/wasmtime_integration.rs::test_async_host_func", "test": "fn test_async_host_func() {\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    integration::add_atoms_to_linker(&mut linker, |cx| cx).unwrap();\n    let mut store = store(&engine);\n\n    let shim_mod = shim_module(&engine);\n    let shim_inst = linker.instantiate(&mut store, &shim_mod).unwrap();\n\n    let input: i32 = 123;\n    let result_location: i32 = 0;\n\n    let mut results = [Val::I32(0)];\n    shim_inst\n        .get_func(&mut store, \"double_int_return_float_shim\")\n        .unwrap()\n        .call(\n            &mut store,\n            &[input.into(), result_location.into()],\n            &mut results,\n        )\n        .unwrap();\n\n    assert_eq!(\n        results[0].unwrap_i32(),\n        types::Errno::Ok as i32,\n        \"double_int_return_float errno\"\n    );\n\n    // The actual result is in memory:\n    let mem = shim_inst.get_memory(&mut store, \"memory\").unwrap();\n    let mut result_bytes: [u8; 4] = [0, 0, 0, 0];\n    mem.read(&store, result_location as usize, &mut result_bytes)\n        .unwrap();\n    let result = f32::from_le_bytes(result_bytes);\n    assert_eq!((input * 2) as f32, result);\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/wasmtime_sync.rs::test_sync_host_func", "test": "fn test_sync_host_func() {\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    atoms::add_to_linker(&mut linker, |cx| cx).unwrap();\n    let mut store = store(&engine);\n    let shim_mod = shim_module(&engine);\n    let shim_inst = linker.instantiate(&mut store, &shim_mod).unwrap();\n\n    let mut results = [Val::I32(0)];\n    shim_inst\n        .get_func(&mut store, \"int_float_args_shim\")\n        .unwrap()\n        .call(&mut store, &[0i32.into(), 123.45f32.into()], &mut results)\n        .unwrap();\n\n    assert_eq!(\n        results[0].unwrap_i32(),\n        types::Errno::Ok as i32,\n        \"int_float_args errno\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/wasmtime_sync.rs::test_async_host_func", "test": "fn test_async_host_func() {\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    atoms::add_to_linker(&mut linker, |cx| cx).unwrap();\n    let mut store = store(&engine);\n\n    let shim_mod = shim_module(&engine);\n    let shim_inst = linker.instantiate(&mut store, &shim_mod).unwrap();\n\n    let input: i32 = 123;\n    let result_location: i32 = 0;\n\n    let mut results = [Val::I32(0)];\n    shim_inst\n        .get_func(&mut store, \"double_int_return_float_shim\")\n        .unwrap()\n        .call(\n            &mut store,\n            &[input.into(), result_location.into()],\n            &mut results,\n        )\n        .unwrap();\n\n    assert_eq!(\n        results[0].unwrap_i32(),\n        types::Errno::Ok as i32,\n        \"double_int_return_float errno\"\n    );\n\n    // The actual result is in memory:\n    let mem = shim_inst.get_memory(&mut store, \"memory\").unwrap();\n    let mut result_bytes: [u8; 4] = [0, 0, 0, 0];\n    mem.read(&store, result_location as usize, &mut result_bytes)\n        .unwrap();\n    let result = f32::from_le_bytes(result_bytes);\n    assert_eq!((input * 2) as f32, result);\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::run_wasmtime_simple_fail_no_args", "test": "fn run_wasmtime_simple_fail_no_args() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/simple.wat\")?;\n    assert!(\n        run_wasmtime(&[\n            \"run\",\n            \"-Ccache=n\",\n            \"--invoke\",\n            \"simple\",\n            wasm.path().to_str().unwrap(),\n        ])\n        .is_err(),\n        \"shall fail\"\n    );\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::old_cli_warn_if_ambiguous_flags", "test": "fn old_cli_warn_if_ambiguous_flags() -> Result<()> {\n    // This is accepted in the old CLI parser and the new but it's interpreted\n    // differently so a warning should be printed.\n    let output = get_wasmtime_command()?\n        .args(&[\"tests/all/cli_tests/simple.wat\", \"--invoke\", \"get_f32\"])\n        .output()?;\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"100\\n\");\n    assert_eq!(\n        String::from_utf8_lossy(&output.stderr),\n        \"\\\nwarning: this CLI invocation of Wasmtime will be parsed differently in future\n         Wasmtime versions -- see this online issue for more information:\n         https://github.com/bytecodealliance/wasmtime/issues/7384\n\n         Wasmtime will now execute with the old (<= Wasmtime 13) CLI parsing,\n         however this behavior can also be temporarily configured with an\n         environment variable:\n\n         - WASMTIME_NEW_CLI=0 to indicate old semantics are desired and silence this warning, or\n         - WASMTIME_NEW_CLI=1 to indicate new semantics are desired and use the latest behavior\nwarning: using `--invoke` with a function that returns values is experimental and may break in the future\n\"\n    );\n\n    // Test disabling the warning\n    let output = get_wasmtime_command()?\n        .args(&[\"tests/all/cli_tests/simple.wat\", \"--invoke\", \"get_f32\"])\n        .env(\"WASMTIME_NEW_CLI\", \"0\")\n        .output()?;\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"100\\n\");\n    assert_eq!(\n        String::from_utf8_lossy(&output.stderr),\n        \"\\\nwarning: using `--invoke` with a function that returns values is experimental and may break in the future\n\"\n    );\n\n    // Test forcing the new behavior where nothing happens because the file is\n    // invoked with `--invoke` as its own argument.\n    let output = get_wasmtime_command()?\n        .args(&[\"tests/all/cli_tests/simple.wat\", \"--invoke\", \"get_f32\"])\n        .env(\"WASMTIME_NEW_CLI\", \"1\")\n        .output()?;\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n    assert_eq!(String::from_utf8_lossy(&output.stderr), \"\");\n\n    // This is unambiguous\n    let output = get_wasmtime_command()?\n        .args(&[\"--invoke\", \"get_f32\", \"tests/all/cli_tests/simple.wat\"])\n        .output()?;\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"100\\n\");\n    assert_eq!(\n        String::from_utf8_lossy(&output.stderr),\n        \"\\\nwarning: using `--invoke` with a function that returns values is experimental and may break in the future\n\"\n    );\n\n    // This fails to parse in the old but succeeds in the new, so it should run\n    // under the new semantics with no warning.\n    let output = get_wasmtime_command()?\n        .args(&[\"run\", \"tests/all/cli_tests/print-arguments.wat\", \"--arg\"])\n        .output()?;\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        \"print-arguments.wat\\n--arg\\n\"\n    );\n    assert_eq!(String::from_utf8_lossy(&output.stderr), \"\");\n\n    // Old behavior can be forced however\n    let output = get_wasmtime_command()?\n        .args(&[\"run\", \"tests/all/cli_tests/print-arguments.wat\", \"--arg\"])\n        .env(\"WASMTIME_NEW_CLI\", \"0\")\n        .output()?;\n    assert!(!output.status.success());\n\n    // This works in both the old and the new, so no warnings\n    let output = get_wasmtime_command()?\n        .args(&[\"run\", \"tests/all/cli_tests/print-arguments.wat\", \"arg\"])\n        .output()?;\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        \"print-arguments.wat\\narg\\n\"\n    );\n    assert_eq!(String::from_utf8_lossy(&output.stderr), \"\");\n\n    // This works in both the old and the new, so no warnings\n    let output = get_wasmtime_command()?\n        .args(&[\n            \"run\",\n            \"--\",\n            \"tests/all/cli_tests/print-arguments.wat\",\n            \"--arg\",\n        ])\n        .output()?;\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        \"print-arguments.wat\\n--arg\\n\"\n    );\n    assert_eq!(String::from_utf8_lossy(&output.stderr), \"\");\n\n    // Old flags still work, but with a warning\n    let output = get_wasmtime_command()?\n        .args(&[\n            \"run\",\n            \"--max-wasm-stack\",\n            \"1000000\",\n            \"tests/all/cli_tests/print-arguments.wat\",\n        ])\n        .output()?;\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        \"print-arguments.wat\\n\"\n    );\n    assert_eq!(\n        String::from_utf8_lossy(&output.stderr),\n        \"\\\nwarning: this CLI invocation of Wasmtime is going to break in the future -- for\n         more information see this issue online:\n         https://github.com/bytecodealliance/wasmtime/issues/7384\n\n         Wasmtime will now execute with the old (<= Wasmtime 13) CLI parsing,\n         however this behavior can also be temporarily configured with an\n         environment variable:\n\n         - WASMTIME_NEW_CLI=0 to indicate old semantics are desired and silence this warning, or\n         - WASMTIME_NEW_CLI=1 to indicate new semantics are desired and see the error\n\"\n    );\n\n    // Old flags warning is suppressible.\n    let output = get_wasmtime_command()?\n        .args(&[\n            \"run\",\n            \"--max-wasm-stack\",\n            \"1000000\",\n            \"tests/all/cli_tests/print-arguments.wat\",\n        ])\n        .env(\"WASMTIME_NEW_CLI\", \"0\")\n        .output()?;\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        \"print-arguments.wat\\n\"\n    );\n    assert_eq!(String::from_utf8_lossy(&output.stderr), \"\");\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/code_too_large.rs::code_too_large_without_panic", "test": "fn code_too_large_without_panic() -> Result<()> {\n    const N: usize = 120000;\n\n    // Build a module with a function whose body will allocate too many\n    // temporaries for our current (Cranelift-based) compiler backend to\n    // handle. This test ensures that we propagate the failure upward\n    // and return it programmatically, rather than panic'ing. If we ever\n    // improve our compiler backend to actually handle such a large\n    // function body, we'll need to increase the limits here too!\n    let mut s = String::new();\n    s.push_str(\"(module\\n\");\n    s.push_str(\"(table 1 1 funcref)\\n\");\n    s.push_str(\"(func (export \\\"\\\") (result i32)\\n\");\n    s.push_str(\"i32.const 0\\n\");\n    for _ in 0..N {\n        s.push_str(\"table.get 0\\n\");\n        s.push_str(\"ref.is_null\\n\");\n    }\n    s.push_str(\"))\\n\");\n\n    let store = Store::<()>::default();\n    let result = Module::new(store.engine(), &s);\n    match result {\n        Err(e) => assert!(e\n            .to_string()\n            .starts_with(\"Compilation error: Code for function is too large\")),\n        Ok(_) => panic!(\"Please adjust limits to make the module too large to compile!\"),\n    }\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::bad_globals", "test": "fn bad_globals() {\n    let mut store = Store::<()>::default();\n    let ty = GlobalType::new(ValType::I32, Mutability::Var);\n    assert!(Global::new(&mut store, ty.clone(), Val::I64(0)).is_err());\n    assert!(Global::new(&mut store, ty.clone(), Val::F32(0)).is_err());\n    assert!(Global::new(&mut store, ty.clone(), Val::F64(0)).is_err());\n\n    let ty = GlobalType::new(ValType::I32, Mutability::Const);\n    let g = Global::new(&mut store, ty.clone(), Val::I32(0)).unwrap();\n    assert!(g.set(&mut store, Val::I32(1)).is_err());\n\n    let ty = GlobalType::new(ValType::I32, Mutability::Var);\n    let g = Global::new(&mut store, ty.clone(), Val::I32(0)).unwrap();\n    assert!(g.set(&mut store, Val::I64(0)).is_err());\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::bad_tables", "test": "fn bad_tables() {\n    let mut store = Store::<()>::default();\n\n    // mismatched initializer\n    let ty = TableType::new(ValType::FuncRef, 0, Some(1));\n    assert!(Table::new(&mut store, ty.clone(), Val::I32(0)).is_err());\n\n    // get out of bounds\n    let ty = TableType::new(ValType::FuncRef, 0, Some(1));\n    let t = Table::new(&mut store, ty.clone(), Val::FuncRef(None)).unwrap();\n    assert!(t.get(&mut store, 0).is_none());\n    assert!(t.get(&mut store, u32::max_value()).is_none());\n\n    // set out of bounds or wrong type\n    let ty = TableType::new(ValType::FuncRef, 1, Some(1));\n    let t = Table::new(&mut store, ty.clone(), Val::FuncRef(None)).unwrap();\n    assert!(t.set(&mut store, 0, Val::I32(0)).is_err());\n    assert!(t.set(&mut store, 0, Val::FuncRef(None)).is_ok());\n    assert!(t.set(&mut store, 1, Val::FuncRef(None)).is_err());\n\n    // grow beyond max\n    let ty = TableType::new(ValType::FuncRef, 1, Some(1));\n    let t = Table::new(&mut store, ty.clone(), Val::FuncRef(None)).unwrap();\n    assert!(t.grow(&mut store, 0, Val::FuncRef(None)).is_ok());\n    assert!(t.grow(&mut store, 1, Val::FuncRef(None)).is_err());\n    assert_eq!(t.size(&store), 1);\n\n    // grow wrong type\n    let ty = TableType::new(ValType::FuncRef, 1, Some(2));\n    let t = Table::new(&mut store, ty.clone(), Val::FuncRef(None)).unwrap();\n    assert!(t.grow(&mut store, 1, Val::I32(0)).is_err());\n    assert_eq!(t.size(&store), 1);\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::create_get_set_externref_tables_via_api", "test": "fn create_get_set_externref_tables_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let table_ty = TableType::new(ValType::ExternRef, 10, None);\n    let table = Table::new(\n        &mut store,\n        table_ty,\n        Val::ExternRef(Some(ExternRef::new(42_usize))),\n    )?;\n\n    assert_eq!(\n        *table\n            .get(&mut store, 5)\n            .unwrap()\n            .unwrap_externref()\n            .unwrap()\n            .data()\n            .downcast_ref::<usize>()\n            .unwrap(),\n        42\n    );\n    table.set(&mut store, 5, Val::ExternRef(None))?;\n    assert!(table\n        .get(&mut store, 5)\n        .unwrap()\n        .unwrap_externref()\n        .is_none());\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/func.rs::signatures_match", "test": "fn signatures_match() {\n    let mut store = Store::<()>::default();\n\n    let f = Func::wrap(&mut store, || {});\n    assert_eq!(f.ty(&store).params().collect::<Vec<_>>(), &[]);\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[]);\n\n    let f = Func::wrap(&mut store, || -> i32 { loop {} });\n    assert_eq!(f.ty(&store).params().collect::<Vec<_>>(), &[]);\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[ValType::I32]);\n\n    let f = Func::wrap(&mut store, || -> i64 { loop {} });\n    assert_eq!(f.ty(&store).params().collect::<Vec<_>>(), &[]);\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[ValType::I64]);\n\n    let f = Func::wrap(&mut store, || -> f32 { loop {} });\n    assert_eq!(f.ty(&store).params().collect::<Vec<_>>(), &[]);\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[ValType::F32]);\n\n    let f = Func::wrap(&mut store, || -> f64 { loop {} });\n    assert_eq!(f.ty(&store).params().collect::<Vec<_>>(), &[]);\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[ValType::F64]);\n\n    let f = Func::wrap(\n        &mut store,\n        |_: f32, _: f64, _: i32, _: i64, _: i32, _: Option<ExternRef>, _: Option<Func>| -> f64 {\n            loop {}\n        },\n    );\n    assert_eq!(\n        f.ty(&store).params().collect::<Vec<_>>(),\n        &[\n            ValType::F32,\n            ValType::F64,\n            ValType::I32,\n            ValType::I64,\n            ValType::I32,\n            ValType::ExternRef,\n            ValType::FuncRef,\n        ]\n    );\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[ValType::F64]);\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/func.rs::get_from_wrapper", "test": "fn get_from_wrapper() {\n    let mut store = Store::<()>::default();\n    let f = Func::wrap(&mut store, || {});\n    assert!(f.typed::<(), ()>(&store).is_ok());\n    assert!(f.typed::<(), i32>(&store).is_err());\n    assert!(f.typed::<(), ()>(&store).is_ok());\n    assert!(f.typed::<i32, ()>(&store).is_err());\n    assert!(f.typed::<i32, i32>(&store).is_err());\n    assert!(f.typed::<(i32, i32), ()>(&store).is_err());\n    assert!(f.typed::<(i32, i32), i32>(&store).is_err());\n\n    let f = Func::wrap(&mut store, || -> i32 { loop {} });\n    assert!(f.typed::<(), i32>(&store).is_ok());\n    let f = Func::wrap(&mut store, || -> f32 { loop {} });\n    assert!(f.typed::<(), f32>(&store).is_ok());\n    let f = Func::wrap(&mut store, || -> f64 { loop {} });\n    assert!(f.typed::<(), f64>(&store).is_ok());\n    let f = Func::wrap(&mut store, || -> Option<ExternRef> { loop {} });\n    assert!(f.typed::<(), Option<ExternRef>>(&store).is_ok());\n    let f = Func::wrap(&mut store, || -> Option<Func> { loop {} });\n    assert!(f.typed::<(), Option<Func>>(&store).is_ok());\n\n    let f = Func::wrap(&mut store, |_: i32| {});\n    assert!(f.typed::<i32, ()>(&store).is_ok());\n    assert!(f.typed::<i64, ()>(&store).is_err());\n    assert!(f.typed::<f32, ()>(&store).is_err());\n    assert!(f.typed::<f64, ()>(&store).is_err());\n    let f = Func::wrap(&mut store, |_: i64| {});\n    assert!(f.typed::<i64, ()>(&store).is_ok());\n    let f = Func::wrap(&mut store, |_: f32| {});\n    assert!(f.typed::<f32, ()>(&store).is_ok());\n    let f = Func::wrap(&mut store, |_: f64| {});\n    assert!(f.typed::<f64, ()>(&store).is_ok());\n    let f = Func::wrap(&mut store, |_: Option<ExternRef>| {});\n    assert!(f.typed::<Option<ExternRef>, ()>(&store).is_ok());\n    let f = Func::wrap(&mut store, |_: Option<Func>| {});\n    assert!(f.typed::<Option<Func>, ()>(&store).is_ok());\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/func.rs::pass_cross_store_arg", "test": "fn pass_cross_store_arg() -> anyhow::Result<()> {\n    let mut config = Config::new();\n    config.wasm_reference_types(true);\n    let engine = Engine::new(&config)?;\n\n    let mut store1 = Store::new(&engine, ());\n    let mut store2 = Store::new(&engine, ());\n\n    let store1_func = Func::wrap(&mut store1, |_: Option<Func>| {});\n    let store2_func = Func::wrap(&mut store2, || {});\n\n    // Using regular `.call` fails with cross-Store arguments.\n    assert!(store1_func\n        .call(\n            &mut store1,\n            &[Val::FuncRef(Some(store2_func.clone()))],\n            &mut []\n        )\n        .is_err());\n\n    // And using `.get` followed by a function call also fails with cross-Store\n    // arguments.\n    let f = store1_func.typed::<Option<Func>, ()>(&store1)?;\n    let result = f.call(&mut store1, Some(store2_func));\n    assert!(result.is_err());\n    assert!(result.unwrap_err().to_string().contains(\"cross-`Store`\"));\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/funcref.rs::wrong_store", "test": "fn wrong_store() -> anyhow::Result<()> {\n    let dropped = Arc::new(AtomicBool::new(false));\n    {\n        let mut store1 = Store::<()>::default();\n        let mut store2 = Store::<()>::default();\n\n        let set = SetOnDrop(dropped.clone());\n        let f1 = Func::wrap(&mut store1, move || {\n            let _ = &set;\n        });\n        let f2 = Func::wrap(&mut store2, move || Some(f1.clone()));\n        assert!(f2.call(&mut store2, &[], &mut []).is_err());\n    }\n    assert!(dropped.load(SeqCst));\n\n    return Ok(());\n\n    struct SetOnDrop(Arc<AtomicBool>);\n\n    impl Drop for SetOnDrop {\n        fn drop(&mut self) {\n            self.0.store(true, SeqCst);\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/host_funcs.rs::signatures_match", "test": "fn signatures_match() -> Result<()> {\n    let engine = Engine::default();\n    let mut linker = Linker::<()>::new(&engine);\n\n    linker.func_wrap(\"\", \"f1\", || {})?;\n    linker.func_wrap(\"\", \"f2\", || -> i32 { loop {} })?;\n    linker.func_wrap(\"\", \"f3\", || -> i64 { loop {} })?;\n    linker.func_wrap(\"\", \"f4\", || -> f32 { loop {} })?;\n    linker.func_wrap(\"\", \"f5\", || -> f64 { loop {} })?;\n    linker.func_wrap(\n        \"\",\n        \"f6\",\n        |_: f32, _: f64, _: i32, _: i64, _: i32, _: Option<ExternRef>, _: Option<Func>| -> f64 {\n            loop {}\n        },\n    )?;\n\n    let mut store = Store::new(&engine, ());\n\n    let f = linker\n        .get(&mut store, \"\", \"f1\")\n        .unwrap()\n        .into_func()\n        .unwrap();\n    assert_eq!(f.ty(&store).params().collect::<Vec<_>>(), &[]);\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[]);\n\n    let f = linker\n        .get(&mut store, \"\", \"f2\")\n        .unwrap()\n        .into_func()\n        .unwrap();\n    assert_eq!(f.ty(&store).params().collect::<Vec<_>>(), &[]);\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[ValType::I32]);\n\n    let f = linker\n        .get(&mut store, \"\", \"f3\")\n        .unwrap()\n        .into_func()\n        .unwrap();\n    assert_eq!(f.ty(&store).params().collect::<Vec<_>>(), &[]);\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[ValType::I64]);\n\n    let f = linker\n        .get(&mut store, \"\", \"f4\")\n        .unwrap()\n        .into_func()\n        .unwrap();\n    assert_eq!(f.ty(&store).params().collect::<Vec<_>>(), &[]);\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[ValType::F32]);\n\n    let f = linker\n        .get(&mut store, \"\", \"f5\")\n        .unwrap()\n        .into_func()\n        .unwrap();\n    assert_eq!(f.ty(&store).params().collect::<Vec<_>>(), &[]);\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[ValType::F64]);\n\n    let f = linker\n        .get(&mut store, \"\", \"f6\")\n        .unwrap()\n        .into_func()\n        .unwrap();\n    assert_eq!(\n        f.ty(&store).params().collect::<Vec<_>>(),\n        &[\n            ValType::F32,\n            ValType::F64,\n            ValType::I32,\n            ValType::I64,\n            ValType::I32,\n            ValType::ExternRef,\n            ValType::FuncRef,\n        ]\n    );\n    assert_eq!(f.ty(&store).results().collect::<Vec<_>>(), &[ValType::F64]);\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/instance.rs::wrong_import_numbers", "test": "fn wrong_import_numbers() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let module = Module::new(store.engine(), r#\"(module (import \"\" \"\" (func)))\"#)?;\n\n    assert!(Instance::new(&mut store, &module, &[]).is_err());\n    let func = Func::wrap(&mut store, || {});\n    assert!(Instance::new(&mut store, &module, &[func.clone().into(), func.into()]).is_err());\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/invoke_func_via_table.rs::test_invoke_func_via_table", "test": "fn test_invoke_func_via_table() -> Result<()> {\n    let mut store = Store::<()>::default();\n\n    let wat = r#\"\n      (module\n        (func $f (result i64) (i64.const 42))\n\n        (table (export \"table\") 1 1 anyfunc)\n        (elem (i32.const 0) $f)\n      )\n    \"#;\n    let module = Module::new(store.engine(), wat).context(\"> Error compiling module!\")?;\n    let instance =\n        Instance::new(&mut store, &module, &[]).context(\"> Error instantiating module!\")?;\n\n    let f = instance\n        .get_table(&mut store, \"table\")\n        .unwrap()\n        .get(&mut store, 0)\n        .unwrap()\n        .funcref()\n        .unwrap()\n        .unwrap()\n        .clone();\n    let mut results = [Val::I32(0)];\n    f.call(&mut store, &[], &mut results).unwrap();\n    assert_eq!(results[0].unwrap_i64(), 42);\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/linker.rs::link_undefined", "test": "fn link_undefined() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let linker = Linker::new(store.engine());\n    let module = Module::new(store.engine(), r#\"(module (import \"\" \"\" (func)))\"#)?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    let module = Module::new(store.engine(), r#\"(module (import \"\" \"\" (global i32)))\"#)?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    let module = Module::new(store.engine(), r#\"(module (import \"\" \"\" (memory 1)))\"#)?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    let module = Module::new(\n        store.engine(),\n        r#\"(module (import \"\" \"\" (table 1 funcref)))\"#,\n    )?;\n    assert!(linker.instantiate(&mut store, &module).is_err());\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/linker.rs::link_twice_bad", "test": "fn link_twice_bad() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::<()>::new(store.engine());\n\n    // functions\n    linker.func_wrap(\"f\", \"\", || {})?;\n    assert!(linker.func_wrap(\"f\", \"\", || {}).is_err());\n    assert!(linker\n        .func_wrap(\"f\", \"\", || -> Result<()> { loop {} })\n        .is_err());\n\n    // globals\n    let ty = GlobalType::new(ValType::I32, Mutability::Const);\n    let global = Global::new(&mut store, ty, Val::I32(0))?;\n    linker.define(&mut store, \"g\", \"1\", global.clone())?;\n    assert!(linker.define(&mut store, \"g\", \"1\", global.clone()).is_err());\n\n    let ty = GlobalType::new(ValType::I32, Mutability::Var);\n    let global = Global::new(&mut store, ty, Val::I32(0))?;\n    linker.define(&mut store, \"g\", \"2\", global.clone())?;\n    assert!(linker.define(&mut store, \"g\", \"2\", global.clone()).is_err());\n\n    let ty = GlobalType::new(ValType::I64, Mutability::Const);\n    let global = Global::new(&mut store, ty, Val::I64(0))?;\n    linker.define(&mut store, \"g\", \"3\", global.clone())?;\n    assert!(linker.define(&mut store, \"g\", \"3\", global.clone()).is_err());\n\n    // memories\n    let ty = MemoryType::new(1, None);\n    let memory = Memory::new(&mut store, ty)?;\n    linker.define(&mut store, \"m\", \"\", memory.clone())?;\n    assert!(linker.define(&mut store, \"m\", \"\", memory.clone()).is_err());\n    let ty = MemoryType::new(2, None);\n    let memory = Memory::new(&mut store, ty)?;\n    assert!(linker.define(&mut store, \"m\", \"\", memory.clone()).is_err());\n\n    // tables\n    let ty = TableType::new(ValType::FuncRef, 1, None);\n    let table = Table::new(&mut store, ty, Val::FuncRef(None))?;\n    linker.define(&mut store, \"t\", \"\", table.clone())?;\n    assert!(linker.define(&mut store, \"t\", \"\", table.clone()).is_err());\n    let ty = TableType::new(ValType::FuncRef, 2, None);\n    let table = Table::new(&mut store, ty, Val::FuncRef(None))?;\n    assert!(linker.define(&mut store, \"t\", \"\", table.clone()).is_err());\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/linker.rs::alias_one", "test": "fn alias_one() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let mut linker = Linker::new(store.engine());\n    assert!(linker.alias(\"a\", \"b\", \"c\", \"d\").is_err());\n    linker.func_wrap(\"a\", \"b\", || {})?;\n    assert!(linker.alias(\"a\", \"b\", \"c\", \"d\").is_ok());\n    assert!(linker.get(&mut store, \"a\", \"b\").is_some());\n    assert!(linker.get(&mut store, \"c\", \"d\").is_some());\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/memory.rs::massive_64_bit_still_limited", "test": "fn massive_64_bit_still_limited() -> Result<()> {\n    // Creating a 64-bit memory which exceeds the limits of the address space\n    // should still send a request to the `ResourceLimiter` to ensure that it\n    // gets at least some chance to see that oom was requested.\n    let mut config = Config::new();\n    config.wasm_memory64(true);\n    let engine = Engine::new(&config)?;\n\n    let mut store = Store::new(&engine, MyLimiter { hit: false });\n    store.limiter(|x| x);\n    let ty = MemoryType::new64(1 << 48, None);\n    assert!(Memory::new(&mut store, ty).is_err());\n    assert!(store.data().hit);\n\n    return Ok(());\n\n    struct MyLimiter {\n        hit: bool,\n    }\n\n    impl ResourceLimiter for MyLimiter {\n        fn memory_growing(\n            &mut self,\n            _current: usize,\n            _request: usize,\n            _max: Option<usize>,\n        ) -> Result<bool> {\n            self.hit = true;\n            Ok(true)\n        }\n        fn table_growing(\n            &mut self,\n            _current: u32,\n            _request: u32,\n            _max: Option<u32>,\n        ) -> Result<bool> {\n            unreachable!()\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/memory.rs::static_forced_max", "test": "fn static_forced_max() -> Result<()> {\n    let mut config = Config::new();\n    config.static_memory_maximum_size(5 * 65536);\n    config.static_memory_forced(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, ());\n\n    let mem = Memory::new(&mut store, MemoryType::new(0, None))?;\n    mem.grow(&mut store, 5).unwrap();\n    assert!(mem.grow(&mut store, 1).is_err());\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/memory.rs::memory64_maximum_minimum", "test": "fn memory64_maximum_minimum() -> Result<()> {\n    let mut config = Config::new();\n    config.wasm_memory64(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, ());\n\n    assert!(Memory::new(&mut store, MemoryType::new64(1 << 48, None)).is_err());\n\n    let module = Module::new(\n        &engine,\n        &format!(\n            r#\"\n                (module\n                    (memory i64 {})\n                )\n            \"#,\n            1u64 << 48,\n        ),\n    )?;\n    assert!(Instance::new(&mut store, &module, &[]).is_err());\n\n    let module = Module::new(\n        &engine,\n        &format!(\n            r#\"\n                (module\n                    (memory i64 {})\n                    (data (i64.const 0) \"\")\n                )\n            \"#,\n            1u64 << 48,\n        ),\n    )?;\n    assert!(Instance::new(&mut store, &module, &[]).is_err());\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/memory.rs::shared_memory_basics", "test": "fn shared_memory_basics() -> Result<()> {\n    let engine = Engine::default();\n    assert!(SharedMemory::new(&engine, MemoryType::new(1, None)).is_err());\n    assert!(SharedMemory::new(&engine, MemoryType::new(1, Some(1))).is_err());\n    assert!(SharedMemory::new(&engine, MemoryType::new64(1, None)).is_err());\n    assert!(SharedMemory::new(&engine, MemoryType::new64(1, Some(1))).is_err());\n    assert!(SharedMemory::new(&engine, MemoryType::shared(1, 0)).is_err());\n\n    let memory = SharedMemory::new(&engine, MemoryType::shared(1, 1))?;\n    assert!(memory.ty().is_shared());\n    assert_eq!(memory.ty().minimum(), 1);\n    assert_eq!(memory.ty().maximum(), Some(1));\n    assert_eq!(memory.size(), 1);\n    assert_eq!(memory.data_size(), 65536);\n    assert_eq!(memory.data().len(), 65536);\n    assert!(memory.grow(1).is_err());\n\n    // misaligned\n    assert_eq!(memory.atomic_notify(1, 100), Err(Trap::HeapMisaligned));\n    assert_eq!(\n        memory.atomic_wait32(1, 100, None),\n        Err(Trap::HeapMisaligned)\n    );\n    assert_eq!(\n        memory.atomic_wait64(1, 100, None),\n        Err(Trap::HeapMisaligned)\n    );\n\n    // oob\n    assert_eq!(\n        memory.atomic_notify(1 << 20, 100),\n        Err(Trap::MemoryOutOfBounds)\n    );\n    assert_eq!(\n        memory.atomic_wait32(1 << 20, 100, None),\n        Err(Trap::MemoryOutOfBounds)\n    );\n    assert_eq!(\n        memory.atomic_wait64(1 << 20, 100, None),\n        Err(Trap::MemoryOutOfBounds)\n    );\n\n    // ok\n    assert_eq!(memory.atomic_notify(8, 100), Ok(0));\n    assert_eq!(memory.atomic_wait32(8, 1, None), Ok(WaitResult::Mismatch));\n    assert_eq!(memory.atomic_wait64(8, 1, None), Ok(WaitResult::Mismatch));\n\n    // timeout\n    let near_future = Instant::now() + Duration::new(0, 100);\n    assert_eq!(\n        memory.atomic_wait32(8, 0, Some(near_future)),\n        Ok(WaitResult::TimedOut)\n    );\n    assert_eq!(\n        memory.atomic_wait64(8, 0, Some(near_future)),\n        Ok(WaitResult::TimedOut)\n    );\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/module.rs::caches_across_engines", "test": "fn caches_across_engines() {\n    let c = Config::new();\n\n    let bytes = Module::new(&Engine::new(&c).unwrap(), \"(module)\")\n        .unwrap()\n        .serialize()\n        .unwrap();\n\n    unsafe {\n        let res = Module::deserialize(&Engine::default(), &bytes);\n        assert!(res.is_ok());\n\n        // differ in runtime settings\n        let res = Module::deserialize(\n            &Engine::new(Config::new().static_memory_maximum_size(0)).unwrap(),\n            &bytes,\n        );\n        assert!(res.is_err());\n\n        // differ in wasm features enabled (which can affect\n        // runtime/compilation settings)\n        let res = Module::deserialize(\n            &Engine::new(Config::new().wasm_simd(false)).unwrap(),\n            &bytes,\n        );\n        assert!(res.is_err());\n    }\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/module_serialize.rs::test_version_mismatch", "test": "fn test_version_mismatch() -> Result<()> {\n    let engine = Engine::default();\n    let buffer = serialize(&engine, \"(module)\")?;\n\n    let mut config = Config::new();\n    config\n        .module_version(ModuleVersionStrategy::Custom(\"custom!\".to_owned()))\n        .unwrap();\n    let custom_version_engine = Engine::new(&config).unwrap();\n    match unsafe { Module::deserialize(&custom_version_engine, &buffer) } {\n        Ok(_) => bail!(\"expected deserialization to fail\"),\n        Err(e) => assert!(e\n            .to_string()\n            .starts_with(\"Module was compiled with incompatible version\")),\n    }\n\n    let mut config = Config::new();\n    config.module_version(ModuleVersionStrategy::None).unwrap();\n    let none_version_engine = Engine::new(&config).unwrap();\n    unsafe { Module::deserialize(&none_version_engine, &buffer) }\n        .expect(\"accepts the wasmtime versioned module\");\n\n    let buffer = serialize(&custom_version_engine, \"(module)\")?;\n    unsafe { Module::deserialize(&none_version_engine, &buffer) }\n        .expect(\"accepts the custom versioned module\");\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::preserve_data_segments", "test": "fn preserve_data_segments() -> Result<()> {\n    let mut pool = crate::small_pool_config();\n    pool.total_memories(2);\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n    let engine = Engine::new(&config)?;\n    let m = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"mem\") 1 1)\n                (data (i32.const 0) \"foo\"))\n        \"#,\n    )?;\n    let mut store = Store::new(&engine, ());\n    let i = Instance::new(&mut store, &m, &[])?;\n\n    // Drop the module. This should *not* drop the actual data referenced by the\n    // module.\n    drop(m);\n\n    // Spray some stuff on the heap. If wasm data lived on the heap this should\n    // paper over things and help us catch use-after-free here if it would\n    // otherwise happen.\n    if !cfg!(miri) {\n        let mut strings = Vec::new();\n        for _ in 0..1000 {\n            let mut string = String::new();\n            for _ in 0..1000 {\n                string.push('g');\n            }\n            strings.push(string);\n        }\n        drop(strings);\n    }\n\n    let mem = i.get_memory(&mut store, \"mem\").unwrap();\n\n    // Hopefully it's still `foo`!\n    assert!(mem.data(&store).starts_with(b\"foo\"));\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::drop_externref_global_during_module_init", "test": "fn drop_externref_global_during_module_init() -> Result<()> {\n    struct Limiter;\n\n    impl ResourceLimiter for Limiter {\n        fn memory_growing(&mut self, _: usize, _: usize, _: Option<usize>) -> Result<bool> {\n            Ok(false)\n        }\n\n        fn table_growing(&mut self, _: u32, _: u32, _: Option<u32>) -> Result<bool> {\n            Ok(false)\n        }\n    }\n\n    let pool = crate::small_pool_config();\n    let mut config = Config::new();\n    config.wasm_reference_types(true);\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (global i32 (i32.const 1))\n                (global i32 (i32.const 2))\n                (global i32 (i32.const 3))\n                (global i32 (i32.const 4))\n                (global i32 (i32.const 5))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, Limiter);\n    Instance::new(&mut store, &module, &[])?;\n    drop(store);\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory 1)\n                (global (mut externref) (ref.null extern))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, Limiter);\n    store.limiter(|s| s);\n    assert!(Instance::new(&mut store, &module, &[]).is_err());\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::rust_panic_import", "test": "fn rust_panic_import() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (import \"\" \"\" (func $foo))\n                (import \"\" \"\" (func $bar))\n                (func (export \"foo\") call $foo)\n                (func (export \"bar\") call $bar)\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let sig = FuncType::new(None, None);\n    let func = Func::new(&mut store, sig, |_, _, _| panic!(\"this is a panic\"));\n    let func2 = Func::wrap(&mut store, || panic!(\"this is another panic\"));\n    let instance = Instance::new(&mut store, &module, &[func.into(), func2.into()])?;\n    let func = instance.get_typed_func::<(), ()>(&mut store, \"foo\")?;\n    let err =\n        panic::catch_unwind(AssertUnwindSafe(|| drop(func.call(&mut store, ())))).unwrap_err();\n    assert_eq!(err.downcast_ref::<&'static str>(), Some(&\"this is a panic\"));\n\n    let func = instance.get_typed_func::<(), ()>(&mut store, \"bar\")?;\n    let err = panic::catch_unwind(AssertUnwindSafe(|| {\n        drop(func.call(&mut store, ()));\n    }))\n    .unwrap_err();\n    assert_eq!(\n        err.downcast_ref::<&'static str>(),\n        Some(&\"this is another panic\")\n    );\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::rust_panic_start_function", "test": "fn rust_panic_start_function() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (import \"\" \"\" (func $foo))\n                (start $foo)\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let sig = FuncType::new(None, None);\n    let func = Func::new(&mut store, sig, |_, _, _| panic!(\"this is a panic\"));\n    let err = panic::catch_unwind(AssertUnwindSafe(|| {\n        drop(Instance::new(&mut store, &module, &[func.into()]));\n    }))\n    .unwrap_err();\n    assert_eq!(err.downcast_ref::<&'static str>(), Some(&\"this is a panic\"));\n\n    let func = Func::wrap(&mut store, || panic!(\"this is another panic\"));\n    let err = panic::catch_unwind(AssertUnwindSafe(|| {\n        drop(Instance::new(&mut store, &module, &[func.into()]));\n    }))\n    .unwrap_err();\n    assert_eq!(\n        err.downcast_ref::<&'static str>(),\n        Some(&\"this is another panic\")\n    );\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::multithreaded_traps", "test": "fn multithreaded_traps() -> Result<()> {\n    // Compile and run unreachable on a thread, then moves over the whole store to another thread,\n    // and make sure traps are still correctly caught after notifying the store of the move.\n    let mut store = Store::<()>::default();\n    let module = Module::new(\n        store.engine(),\n        r#\"(module (func (export \"run\") unreachable))\"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n\n    assert!(instance\n        .get_typed_func::<(), ()>(&mut store, \"run\")?\n        .call(&mut store, ())\n        .is_err());\n\n    let handle = std::thread::spawn(move || {\n        assert!(instance\n            .get_typed_func::<(), ()>(&mut store, \"run\")\n            .unwrap()\n            .call(&mut store, ())\n            .is_err());\n    });\n\n    handle.join().expect(\"couldn't join thread\");\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::host_return_error_no_backtrace", "test": "fn host_return_error_no_backtrace() -> Result<()> {\n    let mut config = Config::new();\n    config.wasm_backtrace(false);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, ());\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (import \"\" \"\" (func $host))\n                (func $foo (export \"f\") call $bar)\n                (func $bar call $host)\n            )\n        \"#,\n    )?;\n    let func = Func::wrap(&mut store, |_cx: Caller<'_, ()>| -> Result<()> {\n        bail!(\"test\")\n    });\n    let instance = Instance::new(&mut store, &module, &[func.into()])?;\n    let f = instance.get_typed_func::<(), ()>(&mut store, \"f\")?;\n    assert!(f.call(&mut store, ()).is_err());\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::trap_with_array_to_wasm_stack_args", "test": "fn trap_with_array_to_wasm_stack_args() -> Result<()> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, ());\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (func $trap\n                    unreachable)\n                (func $run (param i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)\n                    call $trap)\n                (export \"run\" (func $run))\n            )\n        \"#,\n    )?;\n\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let run = instance.get_func(&mut store, \"run\").unwrap();\n\n    let err = run\n        .call(\n            &mut store,\n            &[\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n                Val::I64(0),\n            ],\n            &mut [],\n        )\n        .unwrap_err();\n    assert!(err.is::<Trap>());\n\n    let trace = err.downcast_ref::<WasmBacktrace>().unwrap();\n    assert_eq!(trace.frames().len(), 2);\n    assert_eq!(trace.frames()[0].func_name(), Some(\"trap\"));\n    assert_eq!(trace.frames()[1].func_name(), Some(\"run\"));\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::trap_with_native_to_wasm_stack_args", "test": "fn trap_with_native_to_wasm_stack_args() -> Result<()> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, ());\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (func $trap\n                    unreachable)\n                (func $run (param i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)\n                    call $trap)\n                (export \"run\" (func $run))\n            )\n        \"#,\n    )?;\n\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let run = instance.get_func(&mut store, \"run\").unwrap();\n\n    let err = run\n        .typed::<(\n            i64,\n            i64,\n            i64,\n            i64,\n            i64,\n            i64,\n            i64,\n            i64,\n            i64,\n            i64,\n            i64,\n            i64,\n            i64,\n            i64,\n            i64,\n        ), ()>(&mut store)?\n        .call(&mut store, (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))\n        .unwrap_err();\n    assert!(err.is::<Trap>());\n\n    let trace = err.downcast_ref::<WasmBacktrace>().unwrap();\n    assert_eq!(trace.frames().len(), 2);\n    assert_eq!(trace.frames()[0].func_name(), Some(\"trap\"));\n    assert_eq!(trace.frames()[1].func_name(), Some(\"run\"));\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/wait_notify.rs::atomic_wait_timeout_length", "test": "fn atomic_wait_timeout_length() -> Result<()> {\n    let sleep_nanoseconds = 500000000;\n    let wat = format!(\n        r#\"(module\n        (import \"env\" \"memory\" (memory 1 1 shared))\n\n        (func (export \"func1\") (result i32)\n            (memory.atomic.wait32 (i32.const 0) (i32.const 0) (i64.const {sleep_nanoseconds}))\n        )\n\n        (data (i32.const 0) \"\\00\\00\\00\\00\")\n    )\"#\n    );\n    let mut config = Config::new();\n    config.wasm_threads(true);\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, wat)?;\n    let mut store = Store::new(&engine, ());\n    let shared_memory = SharedMemory::new(&engine, MemoryType::shared(1, 1))?;\n    let instance = Instance::new(&mut store, &module, &[shared_memory.clone().into()])?;\n    let now = Instant::now();\n    let func_ret = instance\n        .get_typed_func::<(), i32>(&mut store, \"func1\")\n        .unwrap()\n        .call(&mut store, ())\n        .unwrap();\n    let duration = now.elapsed();\n    assert!(\n        duration.as_nanos() >= sleep_nanoseconds,\n        \"duration: {duration:?} < {sleep_nanoseconds:?}\"\n    );\n    assert_eq!(func_ret, 2);\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/aot.rs::module_component_mismatch", "test": "fn module_component_mismatch() -> Result<()> {\n    let engine = super::engine();\n    let module = Module::new(&engine, \"(module)\")?.serialize()?;\n    let component = Component::new(&engine, \"(component)\")?.serialize()?;\n\n    unsafe {\n        assert!(Module::deserialize(&engine, &component).is_err());\n        assert!(Component::deserialize(&engine, &module).is_err());\n    }\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/aot.rs::cannot_serialize_exported_module", "test": "fn cannot_serialize_exported_module() -> Result<()> {\n    let engine = super::engine();\n    let component = Component::new(\n        &engine,\n        r#\"(component\n            (core module $m)\n            (export \"a\" (core module $m))\n        )\"#,\n    )?;\n    let mut store = Store::new(&engine, ());\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let module = instance.get_module(&mut store, \"a\").unwrap();\n    assert!(module.serialize().is_err());\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/func.rs::thunks", "test": "fn thunks() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"thunk\"))\n                (func (export \"thunk-trap\") unreachable)\n            )\n            (core instance $i (instantiate $m))\n            (func (export \"thunk\")\n                (canon lift (core func $i \"thunk\"))\n            )\n            (func (export \"thunk-trap\")\n                (canon lift (core func $i \"thunk-trap\"))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    instance\n        .get_typed_func::<(), ()>(&mut store, \"thunk\")?\n        .call_and_post_return(&mut store, ())?;\n    let err = instance\n        .get_typed_func::<(), ()>(&mut store, \"thunk-trap\")?\n        .call(&mut store, ())\n        .unwrap_err();\n    assert_eq!(err.downcast::<Trap>()?, Trap::UnreachableCodeReached);\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/func.rs::typecheck", "test": "fn typecheck() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"thunk\"))\n                (func (export \"take-string\") (param i32 i32))\n                (func (export \"two-args\") (param i32 i32 i32))\n                (func (export \"ret-one\") (result i32) unreachable)\n\n                (memory (export \"memory\") 1)\n                (func (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n                    unreachable)\n            )\n            (core instance $i (instantiate (module $m)))\n            (func (export \"thunk\")\n                (canon lift (core func $i \"thunk\"))\n            )\n            (func (export \"take-string\") (param \"a\" string)\n                (canon lift (core func $i \"take-string\") (memory $i \"memory\") (realloc (func $i \"realloc\")))\n            )\n            (func (export \"take-two-args\") (param \"a\" s32) (param \"b\" (list u8))\n                (canon lift (core func $i \"two-args\") (memory $i \"memory\") (realloc (func $i \"realloc\")))\n            )\n            (func (export \"ret-tuple\") (result \"a\" u8) (result \"b\" s8)\n                (canon lift (core func $i \"ret-one\") (memory $i \"memory\") (realloc (func $i \"realloc\")))\n            )\n            (func (export \"ret-tuple1\") (result (tuple u32))\n                (canon lift (core func $i \"ret-one\") (memory $i \"memory\") (realloc (func $i \"realloc\")))\n            )\n            (func (export \"ret-string\") (result string)\n                (canon lift (core func $i \"ret-one\") (memory $i \"memory\") (realloc (func $i \"realloc\")))\n            )\n            (func (export \"ret-list-u8\") (result (list u8))\n                (canon lift (core func $i \"ret-one\") (memory $i \"memory\") (realloc (func $i \"realloc\")))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let thunk = instance.get_func(&mut store, \"thunk\").unwrap();\n    let take_string = instance.get_func(&mut store, \"take-string\").unwrap();\n    let take_two_args = instance.get_func(&mut store, \"take-two-args\").unwrap();\n    let ret_tuple = instance.get_func(&mut store, \"ret-tuple\").unwrap();\n    let ret_tuple1 = instance.get_func(&mut store, \"ret-tuple1\").unwrap();\n    let ret_string = instance.get_func(&mut store, \"ret-string\").unwrap();\n    let ret_list_u8 = instance.get_func(&mut store, \"ret-list-u8\").unwrap();\n    assert!(thunk.typed::<(), (u32,)>(&store).is_err());\n    assert!(thunk.typed::<(u32,), ()>(&store).is_err());\n    assert!(thunk.typed::<(), ()>(&store).is_ok());\n    assert!(take_string.typed::<(), ()>(&store).is_err());\n    assert!(take_string.typed::<(String,), ()>(&store).is_ok());\n    assert!(take_string.typed::<(&str,), ()>(&store).is_ok());\n    assert!(take_string.typed::<(&[u8],), ()>(&store).is_err());\n    assert!(take_two_args.typed::<(), ()>(&store).is_err());\n    assert!(take_two_args.typed::<(i32, &[u8]), (u32,)>(&store).is_err());\n    assert!(take_two_args.typed::<(u32, &[u8]), ()>(&store).is_err());\n    assert!(take_two_args.typed::<(i32, &[u8]), ()>(&store).is_ok());\n    assert!(ret_tuple.typed::<(), ()>(&store).is_err());\n    assert!(ret_tuple.typed::<(), (u8,)>(&store).is_err());\n    assert!(ret_tuple.typed::<(), (u8, i8)>(&store).is_ok());\n    assert!(ret_tuple1.typed::<(), ((u32,),)>(&store).is_ok());\n    assert!(ret_tuple1.typed::<(), (u32,)>(&store).is_err());\n    assert!(ret_string.typed::<(), ()>(&store).is_err());\n    assert!(ret_string.typed::<(), (WasmStr,)>(&store).is_ok());\n    assert!(ret_list_u8.typed::<(), (WasmList<u16>,)>(&store).is_err());\n    assert!(ret_list_u8.typed::<(), (WasmList<i8>,)>(&store).is_err());\n    assert!(ret_list_u8.typed::<(), (WasmList<u8>,)>(&store).is_ok());\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/func.rs::floats", "test": "fn floats() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"i32.reinterpret_f32\") (param f32) (result i32)\n                    local.get 0\n                    i32.reinterpret_f32\n                )\n                (func (export \"i64.reinterpret_f64\") (param f64) (result i64)\n                    local.get 0\n                    i64.reinterpret_f64\n                )\n                (func (export \"f32.reinterpret_i32\") (param i32) (result f32)\n                    local.get 0\n                    f32.reinterpret_i32\n                )\n                (func (export \"f64.reinterpret_i64\") (param i64) (result f64)\n                    local.get 0\n                    f64.reinterpret_i64\n                )\n            )\n            (core instance $i (instantiate $m))\n\n            (func (export \"f32-to-u32\") (param \"a\" float32) (result u32)\n                (canon lift (core func $i \"i32.reinterpret_f32\"))\n            )\n            (func (export \"f64-to-u64\") (param \"a\" float64) (result u64)\n                (canon lift (core func $i \"i64.reinterpret_f64\"))\n            )\n            (func (export \"u32-to-f32\") (param \"a\" u32) (result float32)\n                (canon lift (core func $i \"f32.reinterpret_i32\"))\n            )\n            (func (export \"u64-to-f64\") (param \"a\" u64) (result float64)\n                (canon lift (core func $i \"f64.reinterpret_i64\"))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let f32_to_u32 = instance.get_typed_func::<(f32,), (u32,)>(&mut store, \"f32-to-u32\")?;\n    let f64_to_u64 = instance.get_typed_func::<(f64,), (u64,)>(&mut store, \"f64-to-u64\")?;\n    let u32_to_f32 = instance.get_typed_func::<(u32,), (f32,)>(&mut store, \"u32-to-f32\")?;\n    let u64_to_f64 = instance.get_typed_func::<(u64,), (f64,)>(&mut store, \"u64-to-f64\")?;\n\n    assert_eq!(f32_to_u32.call(&mut store, (1.0,))?, (1.0f32.to_bits(),));\n    f32_to_u32.post_return(&mut store)?;\n    assert_eq!(f64_to_u64.call(&mut store, (2.0,))?, (2.0f64.to_bits(),));\n    f64_to_u64.post_return(&mut store)?;\n    assert_eq!(u32_to_f32.call(&mut store, (3.0f32.to_bits(),))?, (3.0,));\n    u32_to_f32.post_return(&mut store)?;\n    assert_eq!(u64_to_f64.call(&mut store, (4.0f64.to_bits(),))?, (4.0,));\n    u64_to_f64.post_return(&mut store)?;\n\n    assert_eq!(\n        u32_to_f32\n            .call(&mut store, (CANON_32BIT_NAN | 1,))?\n            .0\n            .to_bits(),\n        CANON_32BIT_NAN\n    );\n    u32_to_f32.post_return(&mut store)?;\n    assert_eq!(\n        u64_to_f64\n            .call(&mut store, (CANON_64BIT_NAN | 1,))?\n            .0\n            .to_bits(),\n        CANON_64BIT_NAN,\n    );\n    u64_to_f64.post_return(&mut store)?;\n\n    assert_eq!(\n        f32_to_u32.call(&mut store, (f32::from_bits(CANON_32BIT_NAN | 1),))?,\n        (CANON_32BIT_NAN,)\n    );\n    f32_to_u32.post_return(&mut store)?;\n    assert_eq!(\n        f64_to_u64.call(&mut store, (f64::from_bits(CANON_64BIT_NAN | 1),))?,\n        (CANON_64BIT_NAN,)\n    );\n    f64_to_u64.post_return(&mut store)?;\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::attempt_to_reenter_during_host", "test": "fn attempt_to_reenter_during_host() -> Result<()> {\n    let component = r#\"\n(component\n  (import \"thunk\" (func $thunk))\n  (core func $thunk_lower (canon lower (func $thunk)))\n\n  (core module $m\n    (import \"host\" \"thunk\" (func $thunk))\n\n    (func $run (export \"run\")\n      call $thunk)\n  )\n  (core instance $m (instantiate $m\n    (with \"host\" (instance (export \"thunk\" (func $thunk_lower))))\n  ))\n\n  (func (export \"run\")\n    (canon lift (core func $m \"run\"))\n  )\n)\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n\n    // First, test the static API\n\n    struct StaticState {\n        func: Option<TypedFunc<(), ()>>,\n    }\n\n    let mut store = Store::new(&engine, StaticState { func: None });\n    let mut linker = Linker::new(&engine);\n    linker.root().func_wrap(\n        \"thunk\",\n        |mut store: StoreContextMut<'_, StaticState>, _: ()| -> Result<()> {\n            let func = store.data_mut().func.take().unwrap();\n            let trap = func.call(&mut store, ()).unwrap_err();\n            assert_eq!(\n                trap.downcast_ref(),\n                Some(&Trap::CannotEnterComponent),\n                \"bad trap: {trap:?}\",\n            );\n            Ok(())\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    let func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n    store.data_mut().func = Some(func);\n    func.call(&mut store, ())?;\n\n    // Next, test the dynamic API\n\n    struct DynamicState {\n        func: Option<Func>,\n    }\n\n    let mut store = Store::new(&engine, DynamicState { func: None });\n    let mut linker = Linker::new(&engine);\n    linker.root().func_new(\n        &component,\n        \"thunk\",\n        |mut store: StoreContextMut<'_, DynamicState>, _, _| {\n            let func = store.data_mut().func.take().unwrap();\n            let trap = func.call(&mut store, &[], &mut []).unwrap_err();\n            assert_eq!(\n                trap.downcast_ref(),\n                Some(&Trap::CannotEnterComponent),\n                \"bad trap: {trap:?}\",\n            );\n            Ok(())\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    let func = instance.get_func(&mut store, \"run\").unwrap();\n    store.data_mut().func = Some(func);\n    func.call(&mut store, &[], &mut [])?;\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/macros.rs::flags", "test": "fn flags() -> Result<()> {\n    let engine = super::engine();\n    let mut store = Store::new(&engine, ());\n\n    // Simple 8-bit flags\n    wasmtime::component::flags! {\n        Foo {\n            #[component(name = \"foo-bar-baz\")]\n            const A;\n            const B;\n            const C;\n        }\n    }\n\n    assert_eq!(Foo::default(), (Foo::A | Foo::B) & Foo::C);\n    assert_eq!(Foo::B, (Foo::A | Foo::B) & Foo::B);\n    assert_eq!(Foo::A, (Foo::A | Foo::B) & Foo::A);\n    assert_eq!(Foo::A | Foo::B, Foo::A ^ Foo::B);\n    assert_eq!(Foo::default(), Foo::A ^ Foo::A);\n    assert_eq!(Foo::B | Foo::C, !Foo::A);\n\n    // Happy path: component type matches flag count and names\n\n    let component = Component::new(\n        &engine,\n        make_echo_component(r#\"(flags \"foo-bar-baz\" \"B\" \"C\")\"#, 4),\n    )?;\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let func = instance.get_typed_func::<(Foo,), (Foo,)>(&mut store, \"echo\")?;\n\n    for n in 0..8 {\n        let mut input = Foo::default();\n        if (n & 1) != 0 {\n            input |= Foo::A;\n        }\n        if (n & 2) != 0 {\n            input |= Foo::B;\n        }\n        if (n & 4) != 0 {\n            input |= Foo::C;\n        }\n\n        let output = func.call_and_post_return(&mut store, (input,))?;\n\n        assert_eq!((input,), output);\n    }\n\n    // Sad path: flag count mismatch (too few)\n\n    let component = Component::new(\n        &engine,\n        make_echo_component(r#\"(flags \"foo-bar-baz\" \"B\")\"#, 4),\n    )?;\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n\n    assert!(instance\n        .get_typed_func::<(Foo,), (Foo,)>(&mut store, \"echo\")\n        .is_err());\n\n    // Sad path: flag count mismatch (too many)\n\n    let component = Component::new(\n        &engine,\n        make_echo_component(r#\"(flags \"foo-bar-baz\" \"B\" \"C\" \"D\")\"#, 4),\n    )?;\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n\n    assert!(instance\n        .get_typed_func::<(Foo,), (Foo,)>(&mut store, \"echo\")\n        .is_err());\n\n    // Sad path: flag name mismatch\n\n    let component = Component::new(&engine, make_echo_component(r#\"(flags \"A\" \"B\" \"C\")\"#, 4))?;\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n\n    assert!(instance\n        .get_typed_func::<(Foo,), (Foo,)>(&mut store, \"echo\")\n        .is_err());\n\n    // Happy path redux, with large flag count (exactly 8)\n\n    flags_test!(Foo8Exact, 8);\n\n    assert_eq!(\n        Foo8Exact::default(),\n        (Foo8Exact::F0 | Foo8Exact::F6) & Foo8Exact::F7\n    );\n    assert_eq!(\n        Foo8Exact::F6,\n        (Foo8Exact::F0 | Foo8Exact::F6) & Foo8Exact::F6\n    );\n    assert_eq!(\n        Foo8Exact::F0,\n        (Foo8Exact::F0 | Foo8Exact::F6) & Foo8Exact::F0\n    );\n    assert_eq!(Foo8Exact::F0 | Foo8Exact::F6, Foo8Exact::F0 ^ Foo8Exact::F6);\n    assert_eq!(Foo8Exact::default(), Foo8Exact::F0 ^ Foo8Exact::F0);\n    assert_eq!(\n        Foo8Exact::F1\n            | Foo8Exact::F2\n            | Foo8Exact::F3\n            | Foo8Exact::F4\n            | Foo8Exact::F5\n            | Foo8Exact::F6\n            | Foo8Exact::F7,\n        !Foo8Exact::F0\n    );\n\n    let component = Component::new(\n        &engine,\n        make_echo_component(\n            &format!(\n                r#\"(flags {})\"#,\n                (0..8)\n                    .map(|index| format!(r#\"\"F{}\"\"#, index))\n                    .collect::<Vec<_>>()\n                    .join(\" \")\n            ),\n            4,\n        ),\n    )?;\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let func = instance.get_typed_func::<(Foo8Exact,), (Foo8Exact,)>(&mut store, \"echo\")?;\n\n    for &input in &[\n        Foo8Exact::F0,\n        Foo8Exact::F1,\n        Foo8Exact::F5,\n        Foo8Exact::F6,\n        Foo8Exact::F7,\n    ] {\n        let output = func.call_and_post_return(&mut store, (input,))?;\n\n        assert_eq!((input,), output);\n    }\n\n    // Happy path redux, with large flag count (more than 8)\n\n    flags_test!(Foo16, 9);\n\n    assert_eq!(Foo16::default(), (Foo16::F0 | Foo16::F7) & Foo16::F8);\n    assert_eq!(Foo16::F7, (Foo16::F0 | Foo16::F7) & Foo16::F7);\n    assert_eq!(Foo16::F0, (Foo16::F0 | Foo16::F7) & Foo16::F0);\n    assert_eq!(Foo16::F0 | Foo16::F7, Foo16::F0 ^ Foo16::F7);\n    assert_eq!(Foo16::default(), Foo16::F0 ^ Foo16::F0);\n    assert_eq!(\n        Foo16::F1\n            | Foo16::F2\n            | Foo16::F3\n            | Foo16::F4\n            | Foo16::F5\n            | Foo16::F6\n            | Foo16::F7\n            | Foo16::F8,\n        !Foo16::F0\n    );\n\n    let component = Component::new(\n        &engine,\n        make_echo_component(\n            &format!(\n                \"(flags {})\",\n                (0..9)\n                    .map(|index| format!(r#\"\"F{}\"\"#, index))\n                    .collect::<Vec<_>>()\n                    .join(\" \")\n            ),\n            4,\n        ),\n    )?;\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let func = instance.get_typed_func::<(Foo16,), (Foo16,)>(&mut store, \"echo\")?;\n\n    for &input in &[Foo16::F0, Foo16::F1, Foo16::F6, Foo16::F7, Foo16::F8] {\n        let output = func.call_and_post_return(&mut store, (input,))?;\n\n        assert_eq!((input,), output);\n    }\n\n    // Happy path redux, with large flag count (exactly 16)\n\n    flags_test!(Foo16Exact, 16);\n\n    assert_eq!(\n        Foo16Exact::default(),\n        (Foo16Exact::F0 | Foo16Exact::F14) & Foo16Exact::F5\n    );\n    assert_eq!(\n        Foo16Exact::F14,\n        (Foo16Exact::F0 | Foo16Exact::F14) & Foo16Exact::F14\n    );\n    assert_eq!(\n        Foo16Exact::F0,\n        (Foo16Exact::F0 | Foo16Exact::F14) & Foo16Exact::F0\n    );\n    assert_eq!(\n        Foo16Exact::F0 | Foo16Exact::F14,\n        Foo16Exact::F0 ^ Foo16Exact::F14\n    );\n    assert_eq!(Foo16Exact::default(), Foo16Exact::F0 ^ Foo16Exact::F0);\n    assert_eq!(\n        Foo16Exact::F0 | Foo16Exact::F15,\n        !((!Foo16Exact::F0) & (!Foo16Exact::F15))\n    );\n\n    let component = Component::new(\n        &engine,\n        make_echo_component(\n            &format!(\n                r#\"(flags {})\"#,\n                (0..16)\n                    .map(|index| format!(r#\"\"F{}\"\"#, index))\n                    .collect::<Vec<_>>()\n                    .join(\" \")\n            ),\n            4,\n        ),\n    )?;\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let func = instance.get_typed_func::<(Foo16Exact,), (Foo16Exact,)>(&mut store, \"echo\")?;\n\n    for &input in &[\n        Foo16Exact::F0,\n        Foo16Exact::F1,\n        Foo16Exact::F13,\n        Foo16Exact::F14,\n        Foo16Exact::F15,\n    ] {\n        let output = func.call_and_post_return(&mut store, (input,))?;\n\n        assert_eq!((input,), output);\n    }\n\n    // Happy path redux, with large flag count (more than 16)\n\n    flags_test!(Foo32, 17);\n\n    assert_eq!(Foo32::default(), (Foo32::F0 | Foo32::F15) & Foo32::F16);\n    assert_eq!(Foo32::F15, (Foo32::F0 | Foo32::F15) & Foo32::F15);\n    assert_eq!(Foo32::F0, (Foo32::F0 | Foo32::F15) & Foo32::F0);\n    assert_eq!(Foo32::F0 | Foo32::F15, Foo32::F0 ^ Foo32::F15);\n    assert_eq!(Foo32::default(), Foo32::F0 ^ Foo32::F0);\n    assert_eq!(Foo32::F0 | Foo32::F16, !((!Foo32::F0) & (!Foo32::F16)));\n\n    let component = Component::new(\n        &engine,\n        make_echo_component(\n            &format!(\n                \"(flags {})\",\n                (0..17)\n                    .map(|index| format!(r#\"\"F{}\"\"#, index))\n                    .collect::<Vec<_>>()\n                    .join(\" \")\n            ),\n            4,\n        ),\n    )?;\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let func = instance.get_typed_func::<(Foo32,), (Foo32,)>(&mut store, \"echo\")?;\n\n    for &input in &[Foo32::F0, Foo32::F1, Foo32::F14, Foo32::F15, Foo32::F16] {\n        let output = func.call_and_post_return(&mut store, (input,))?;\n\n        assert_eq!((input,), output);\n    }\n\n    // Happy path redux, with large flag count (exactly 32)\n\n    flags_test!(Foo32Exact, 32);\n\n    assert_eq!(\n        Foo32Exact::default(),\n        (Foo32Exact::F0 | Foo32Exact::F30) & Foo32Exact::F31\n    );\n    assert_eq!(\n        Foo32Exact::F30,\n        (Foo32Exact::F0 | Foo32Exact::F30) & Foo32Exact::F30\n    );\n    assert_eq!(\n        Foo32Exact::F0,\n        (Foo32Exact::F0 | Foo32Exact::F30) & Foo32Exact::F0\n    );\n    assert_eq!(\n        Foo32Exact::F0 | Foo32Exact::F30,\n        Foo32Exact::F0 ^ Foo32Exact::F30\n    );\n    assert_eq!(Foo32Exact::default(), Foo32Exact::F0 ^ Foo32Exact::F0);\n    assert_eq!(\n        Foo32Exact::F0 | Foo32Exact::F15,\n        !((!Foo32Exact::F0) & (!Foo32Exact::F15))\n    );\n\n    let component = Component::new(\n        &engine,\n        make_echo_component(\n            &format!(\n                r#\"(flags {})\"#,\n                (0..32)\n                    .map(|index| format!(r#\"\"F{}\"\"#, index))\n                    .collect::<Vec<_>>()\n                    .join(\" \")\n            ),\n            4,\n        ),\n    )?;\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let func = instance.get_typed_func::<(Foo32Exact,), (Foo32Exact,)>(&mut store, \"echo\")?;\n\n    for &input in &[\n        Foo32Exact::F0,\n        Foo32Exact::F1,\n        Foo32Exact::F29,\n        Foo32Exact::F30,\n        Foo32Exact::F31,\n    ] {\n        let output = func.call_and_post_return(&mut store, (input,))?;\n\n        assert_eq!((input,), output);\n    }\n\n    // Happy path redux, with large flag count (more than 32)\n\n    flags_test!(Foo64, 33);\n\n    assert_eq!(Foo64::default(), (Foo64::F0 | Foo64::F31) & Foo64::F32);\n    assert_eq!(Foo64::F31, (Foo64::F0 | Foo64::F31) & Foo64::F31);\n    assert_eq!(Foo64::F0, (Foo64::F0 | Foo64::F31) & Foo64::F0);\n    assert_eq!(Foo64::F0 | Foo64::F31, Foo64::F0 ^ Foo64::F31);\n    assert_eq!(Foo64::default(), Foo64::F0 ^ Foo64::F0);\n    assert_eq!(Foo64::F0 | Foo64::F32, !((!Foo64::F0) & (!Foo64::F32)));\n\n    let component = Component::new(\n        &engine,\n        make_echo_component(\n            &format!(\n                \"(flags {})\",\n                (0..33)\n                    .map(|index| format!(r#\"\"F{}\"\"#, index))\n                    .collect::<Vec<_>>()\n                    .join(\" \")\n            ),\n            8,\n        ),\n    )?;\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let func = instance.get_typed_func::<(Foo64,), (Foo64,)>(&mut store, \"echo\")?;\n\n    for &input in &[Foo64::F0, Foo64::F1, Foo64::F30, Foo64::F31, Foo64::F32] {\n        let output = func.call_and_post_return(&mut store, (input,))?;\n\n        assert_eq!((input,), output);\n    }\n\n    // Happy path redux, with large flag count (more than 64)\n\n    flags_test!(Foo96, 65);\n\n    assert_eq!(Foo96::default(), (Foo96::F0 | Foo96::F63) & Foo96::F64);\n    assert_eq!(Foo96::F63, (Foo96::F0 | Foo96::F63) & Foo96::F63);\n    assert_eq!(Foo96::F0, (Foo96::F0 | Foo96::F63) & Foo96::F0);\n    assert_eq!(Foo96::F0 | Foo96::F63, Foo96::F0 ^ Foo96::F63);\n    assert_eq!(Foo96::default(), Foo96::F0 ^ Foo96::F0);\n    assert_eq!(Foo96::F0 | Foo96::F64, !((!Foo96::F0) & (!Foo96::F64)));\n\n    let component = Component::new(\n        &engine,\n        make_echo_component(\n            &format!(\n                \"(flags {})\",\n                (0..65)\n                    .map(|index| format!(r#\"\"F{}\"\"#, index))\n                    .collect::<Vec<_>>()\n                    .join(\" \")\n            ),\n            12,\n        ),\n    )?;\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let func = instance.get_typed_func::<(Foo96,), (Foo96,)>(&mut store, \"echo\")?;\n\n    for &input in &[Foo96::F0, Foo96::F1, Foo96::F62, Foo96::F63, Foo96::F64] {\n        let output = func.call_and_post_return(&mut store, (input,))?;\n\n        assert_eq!((input,), output);\n    }\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/post_return.rs::invalid_api", "test": "fn invalid_api() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"thunk1\"))\n                (func (export \"thunk2\"))\n            )\n            (core instance $i (instantiate $m))\n            (func (export \"thunk1\")\n                (canon lift (core func $i \"thunk1\"))\n            )\n            (func (export \"thunk2\")\n                (canon lift (core func $i \"thunk2\"))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let thunk1 = instance.get_typed_func::<(), ()>(&mut store, \"thunk1\")?;\n    let thunk2 = instance.get_typed_func::<(), ()>(&mut store, \"thunk2\")?;\n\n    // Ensure that we can't call `post_return` before doing anything\n    let msg = \"post_return can only be called after a function has previously been called\";\n    assert_panics(|| drop(thunk1.post_return(&mut store)), msg);\n    assert_panics(|| drop(thunk2.post_return(&mut store)), msg);\n\n    // Schedule a \"needs post return\"\n    thunk1.call(&mut store, ())?;\n\n    // Ensure that we can't reenter the instance through either this function or\n    // another one.\n    let err = thunk1.call(&mut store, ()).unwrap_err();\n    assert_eq!(\n        err.downcast_ref(),\n        Some(&Trap::CannotEnterComponent),\n        \"{err}\",\n    );\n    let err = thunk2.call(&mut store, ()).unwrap_err();\n    assert_eq!(\n        err.downcast_ref(),\n        Some(&Trap::CannotEnterComponent),\n        \"{err}\",\n    );\n\n    // Calling post-return on the wrong function should panic\n    assert_panics(\n        || drop(thunk2.post_return(&mut store)),\n        \"calling post_return on wrong function\",\n    );\n\n    // Actually execute the post-return\n    thunk1.post_return(&mut store)?;\n\n    // And now post-return should be invalid again.\n    assert_panics(|| drop(thunk1.post_return(&mut store)), msg);\n    assert_panics(|| drop(thunk2.post_return(&mut store)), msg);\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::host_resource_types", "test": "fn host_resource_types() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (import \"u\" (type $u (sub resource)))\n\n                (export \"t1\" (type $t))\n                (export \"t2\" (type $t))\n                (export \"u1\" (type $u))\n                (export \"u2\" (type $u))\n\n                (component $c\n                    (import \"r\" (type $r (sub resource)))\n                    (export \"r1\" (type $r))\n                )\n                (instance $i1 (instantiate $c (with \"r\" (type $t))))\n                (instance $i2 (instantiate $c (with \"r\" (type $t))))\n                (export \"t3\" (type $i1 \"r1\"))\n                (export \"t4\" (type $i2 \"r1\"))\n            )\n        \"#,\n    )?;\n\n    struct T;\n    struct U;\n    assert!(ResourceType::host::<T>() != ResourceType::host::<U>());\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<T>(\"t\", |_, _| Ok(()))?;\n    linker.root().resource::<U>(\"u\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n    let t1 = i.get_resource(&mut store, \"t1\").unwrap();\n    let t2 = i.get_resource(&mut store, \"t2\").unwrap();\n    let t3 = i.get_resource(&mut store, \"t3\").unwrap();\n    let t4 = i.get_resource(&mut store, \"t4\").unwrap();\n    let u1 = i.get_resource(&mut store, \"u1\").unwrap();\n    let u2 = i.get_resource(&mut store, \"u2\").unwrap();\n\n    assert_eq!(t1, ResourceType::host::<T>());\n    assert_eq!(t2, ResourceType::host::<T>());\n    assert_eq!(t3, ResourceType::host::<T>());\n    assert_eq!(t4, ResourceType::host::<T>());\n    assert_eq!(u1, ResourceType::host::<U>());\n    assert_eq!(u2, ResourceType::host::<U>());\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::dynamic_type", "test": "fn dynamic_type() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t1\" (type $t1 (sub resource)))\n                (type $t2' (resource (rep i32)))\n                (export $t2 \"t2\" (type $t2'))\n                (core func $f (canon resource.drop $t2))\n\n                (func (export \"a\") (param \"x\" (own $t1))\n                    (canon lift (core func $f)))\n                (func (export \"b\") (param \"x\" (tuple (own $t2)))\n                    (canon lift (core func $f)))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t1\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let a = i.get_func(&mut store, \"a\").unwrap();\n    let b = i.get_func(&mut store, \"b\").unwrap();\n    let t2 = i.get_resource(&mut store, \"t2\").unwrap();\n\n    let a_params = a.params(&store);\n    assert_eq!(a_params[0], Type::Own(ResourceType::host::<MyType>()));\n    let b_params = b.params(&store);\n    match &b_params[0] {\n        Type::Tuple(t) => {\n            assert_eq!(t.types().len(), 1);\n            let t0 = t.types().next().unwrap();\n            assert_eq!(t0, Type::Own(t2));\n        }\n        _ => unreachable!(),\n    }\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::cannot_reenter_during_import", "test": "fn cannot_reenter_during_import() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"f\" (func $f))\n\n                (core func $f (canon lower (func $f)))\n\n                (core module $m\n                    (import \"\" \"f\" (func $f))\n                    (func (export \"call\") call $f)\n                    (func (export \"dtor\") (param i32) unreachable)\n                )\n\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"f\" (func $f))\n                    ))\n                ))\n\n                (type $t2' (resource (rep i32) (dtor (func $i \"dtor\"))))\n                (export $t2 \"t\" (type $t2'))\n                (core func $ctor (canon resource.new $t2))\n                (func (export \"ctor\") (param \"x\" u32) (result (own $t2))\n                    (canon lift (core func $ctor)))\n\n                (func (export \"call\") (canon lift (core func $i \"call\")))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, None);\n    let mut linker = Linker::new(&engine);\n    linker.root().func_wrap(\"f\", |mut cx, ()| {\n        let data: &mut Option<ResourceAny> = cx.data_mut();\n        let err = data.take().unwrap().resource_drop(cx).unwrap_err();\n        assert_eq!(\n            err.downcast_ref(),\n            Some(&Trap::CannotEnterComponent),\n            \"bad error: {err:?}\"\n        );\n        Ok(())\n    })?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let ctor = i.get_typed_func::<(u32,), (ResourceAny,)>(&mut store, \"ctor\")?;\n    let call = i.get_typed_func::<(), ()>(&mut store, \"call\")?;\n\n    let (resource,) = ctor.call(&mut store, (100,))?;\n    ctor.post_return(&mut store)?;\n    *store.data_mut() = Some(resource);\n    call.call(&mut store, ())?;\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::type_mismatch", "test": "fn type_mismatch() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n                (export $t \"t\" (type $t'))\n\n                (core func $drop (canon resource.drop $t))\n\n                (func (export \"f1\") (param \"x\" (own $t))\n                    (canon lift (core func $drop)))\n                (func (export \"f2\") (param \"x\" (borrow $t))\n                    (canon lift (core func $drop)))\n                (func (export \"f3\") (param \"x\" u32)\n                    (canon lift (core func $drop)))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let i = Linker::new(&engine).instantiate(&mut store, &c)?;\n\n    assert!(i\n        .get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f1\")\n        .is_err());\n    assert!(i\n        .get_typed_func::<(&ResourceAny,), ()>(&mut store, \"f1\")\n        .is_ok());\n\n    assert!(i\n        .get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f2\")\n        .is_err());\n    assert!(i\n        .get_typed_func::<(&ResourceAny,), ()>(&mut store, \"f2\")\n        .is_ok());\n\n    assert!(i\n        .get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f3\")\n        .is_err());\n    assert!(i\n        .get_typed_func::<(&ResourceAny,), ()>(&mut store, \"f3\")\n        .is_err());\n    assert!(i.get_typed_func::<(u32,), ()>(&mut store, \"f3\").is_ok());\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/bindgen/ownership.rs::owning", "test": "fn owning() -> Result<()> {\n    wasmtime::component::bindgen!({\n        inline: \"\n        package inline:inline;\n        world test {\n            export lists: interface {\n                foo: func(a: list<list<string>>) -> list<list<string>>;\n            }\n\n            export thing-in: interface {\n                record thing {\n                    name: string,\n                    value: list<string>\n                }\n\n                bar: func(a: thing);\n            }\n\n            export thing-in-and-out: interface {\n                record thing {\n                    name: string,\n                    value: list<string>\n                }\n\n                baz: func(a: thing) -> thing;\n            }\n        }\",\n        ownership: Owning\n    });\n\n    impl PartialEq for exports::thing_in::Thing {\n        fn eq(&self, other: &Self) -> bool {\n            self.name == other.name && self.value == other.value\n        }\n    }\n\n    impl PartialEq for exports::thing_in_and_out::Thing {\n        fn eq(&self, other: &Self) -> bool {\n            self.name == other.name && self.value == other.value\n        }\n    }\n\n    let engine = engine();\n    let component = Component::new(&engine, component())?;\n\n    let linker = Linker::new(&engine);\n    let mut store = Store::new(&engine, ());\n    let (test, _) = Test::instantiate(&mut store, &component, &linker)?;\n\n    let value = vec![vec![\"a\".to_owned(), \"b\".to_owned()]];\n    assert_eq!(value, test.lists().call_foo(&mut store, &value)?);\n\n    let value = exports::thing_in::Thing {\n        name: \"thing 1\".to_owned(),\n        value: vec![\"some value\".to_owned(), \"another value\".to_owned()],\n    };\n    test.thing_in().call_bar(&mut store, &value)?;\n\n    let value = exports::thing_in_and_out::Thing {\n        name: \"thing 1\".to_owned(),\n        value: vec![\"some value\".to_owned(), \"another value\".to_owned()],\n    };\n    assert_eq!(value, test.thing_in_and_out().call_baz(&mut store, &value)?);\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/bindgen/ownership.rs::borrowing_no_duplication", "test": "fn borrowing_no_duplication() -> Result<()> {\n    wasmtime::component::bindgen!({\n        inline: \"\n        package inline:inline;\n        world test {\n            export lists: interface {\n                foo: func(a: list<list<string>>) -> list<list<string>>;\n            }\n\n            export thing-in: interface {\n                record thing {\n                    name: string,\n                    value: list<string>\n                }\n\n                bar: func(a: thing);\n            }\n\n            export thing-in-and-out: interface {\n                record thing {\n                    name: string,\n                    value: list<string>\n                }\n\n                baz: func(a: thing) -> thing;\n            }\n        }\",\n        ownership: Borrowing {\n            duplicate_if_necessary: false\n        }\n    });\n\n    impl PartialEq for exports::thing_in::Thing<'_> {\n        fn eq(&self, other: &Self) -> bool {\n            self.name == other.name && self.value == other.value\n        }\n    }\n\n    impl PartialEq for exports::thing_in_and_out::Thing {\n        fn eq(&self, other: &Self) -> bool {\n            self.name == other.name && self.value == other.value\n        }\n    }\n\n    let engine = engine();\n    let component = Component::new(&engine, component())?;\n\n    let linker = Linker::new(&engine);\n    let mut store = Store::new(&engine, ());\n    let (test, _) = Test::instantiate(&mut store, &component, &linker)?;\n\n    let value = &[&[\"a\", \"b\"] as &[_]] as &[_];\n    assert_eq!(value, test.lists().call_foo(&mut store, value)?);\n\n    let value = exports::thing_in::Thing {\n        name: \"thing 1\",\n        value: &[\"some value\", \"another value\"],\n    };\n    test.thing_in().call_bar(&mut store, value)?;\n\n    let value = exports::thing_in_and_out::Thing {\n        name: \"thing 1\".to_owned(),\n        value: vec![\"some value\".to_owned(), \"another value\".to_owned()],\n    };\n    assert_eq!(value, test.thing_in_and_out().call_baz(&mut store, &value)?);\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/bindgen/ownership.rs::borrowing_with_duplication", "test": "fn borrowing_with_duplication() -> Result<()> {\n    wasmtime::component::bindgen!({\n        inline: \"\n        package inline:inline;\n        world test {\n            export lists: interface {\n                foo: func(a: list<list<string>>) -> list<list<string>>;\n            }\n\n            export thing-in: interface {\n                record thing {\n                    name: string,\n                    value: list<string>\n                }\n\n                bar: func(a: thing);\n            }\n\n            export thing-in-and-out: interface {\n                record thing {\n                    name: string,\n                    value: list<string>\n                }\n\n                baz: func(a: thing) -> thing;\n            }\n        }\",\n        ownership: Borrowing {\n            duplicate_if_necessary: true\n        }\n    });\n\n    impl PartialEq for exports::thing_in::Thing<'_> {\n        fn eq(&self, other: &Self) -> bool {\n            self.name == other.name && self.value == other.value\n        }\n    }\n\n    impl PartialEq for exports::thing_in_and_out::ThingResult {\n        fn eq(&self, other: &Self) -> bool {\n            self.name == other.name && self.value == other.value\n        }\n    }\n\n    let engine = engine();\n    let component = Component::new(&engine, component())?;\n\n    let linker = Linker::new(&engine);\n    let mut store = Store::new(&engine, ());\n    let (test, _) = Test::instantiate(&mut store, &component, &linker)?;\n\n    let value = &[&[\"a\", \"b\"] as &[_]] as &[_];\n    assert_eq!(value, test.lists().call_foo(&mut store, value)?);\n\n    let value = exports::thing_in::Thing {\n        name: \"thing 1\",\n        value: &[\"some value\", \"another value\"],\n    };\n    test.thing_in().call_bar(&mut store, value)?;\n\n    let value = exports::thing_in_and_out::ThingParam {\n        name: \"thing 1\",\n        value: &[\"some value\", \"another value\"],\n    };\n    assert_eq!(\n        exports::thing_in_and_out::ThingResult {\n            name: \"thing 1\".to_owned(),\n            value: vec![\"some value\".to_owned(), \"another value\".to_owned()],\n        },\n        test.thing_in_and_out().call_baz(&mut store, value)?\n    );\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests-gen/cranelift-fuzzgen.rs::test_something", "test": "fn test_something() {\n    let data = [];\n    let mut testcase = testcase;\n    let fuel: u8 = std::env::args()\n        .find_map(|arg| arg.strip_prefix(\"--fuel=\").map(|s| s.to_owned()))\n        .map(|fuel| fuel.parse().expect(\"fuel should be a valid integer\"))\n        .unwrap_or_default();\n    for i in 0..testcase.ctrl_planes.len() {\n        testcase.ctrl_planes[i].set_fuel(fuel)\n    }\n    let testcase = testcase;\n    assert!(testcase.isa.flags().enable_verifier());\n    let valid_inputs = STATISTICS.valid_inputs.fetch_add(1, Ordering::SeqCst);\n    if valid_inputs != 0 && valid_inputs % 10000 == 0 {\n        STATISTICS.print(valid_inputs);\n    }\n    if !testcase.compare_against_host {\n        let opt_testcase = testcase.to_optimized();\n        run_test_inputs(&testcase, |args| {\n            let mut interpreter = build_interpreter(&opt_testcase);\n            run_in_interpreter(&mut interpreter, args)\n        });\n    } else {\n        let mut compiler = TestFileCompiler::new(testcase.isa.clone());\n        compiler\n            .add_functions(&testcase.functions[..], testcase.ctrl_planes.clone())\n            .unwrap();\n        let compiled = compiler.compile().unwrap();\n        let trampoline = compiled.get_trampoline(testcase.main()).unwrap();\n        run_test_inputs(&testcase, |args| run_in_host(&trampoline, args));\n    }\n}", "error": "Not Definition Found"}
