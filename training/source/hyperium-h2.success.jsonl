{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/client_request.rs::recv_too_big_headers", "test": "async fn recv_too_big_headers() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_frame_eq(settings, frames::settings().max_header_list_size(10));\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://http2.akamai.com/\")\n                .eos(),\n        )\n        .await;\n        srv.recv_frame(\n            frames::headers(3)\n                .request(\"GET\", \"https://http2.akamai.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frames::headers(1).response(200).eos()).await;\n        srv.send_frame(frames::headers(3).response(200)).await;\n        // no reset for 1, since it's closed anyway\n        // but reset for 3, since server hasn't closed stream\n        srv.recv_frame(frames::reset(3).refused()).await;\n        idle_ms(10).await;\n    };\n\n    let client = async move {\n        let (mut client, mut conn) = client::Builder::new()\n            .max_header_list_size(10)\n            .handshake::<_, Bytes>(io)\n            .await\n            .expect(\"handshake\");\n\n        let request = Request::builder()\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let req1 = client.send_request(request, true);\n        let req1 = async move {\n            let err = req1.expect(\"send_request\").0.await.expect_err(\"response1\");\n            assert_eq!(err.reason(), Some(Reason::REFUSED_STREAM));\n        };\n\n        let request = Request::builder()\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let req2 = client.send_request(request, true);\n        let req2 = async move {\n            let err = req2.expect(\"send_request\").0.await.expect_err(\"response2\");\n            assert_eq!(err.reason(), Some(Reason::REFUSED_STREAM));\n        };\n\n        conn.drive(join(req1, req2)).await;\n        conn.await.expect(\"client\");\n    };\n    join(srv, client).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/error.rs::reason", "code": "pub fn reason(&self) -> Option<Reason> {\n        match self.kind {\n            Kind::Reset(_, reason, _) | Kind::GoAway(_, reason, _) | Kind::Reason(reason) => {\n                Some(reason)\n            }\n            _ => None,\n        }\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_data_no_padding", "test": "async fn read_data_no_padding() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 5, 0, 0, 0, 0, 0, 1,\n            \"hello\",\n        ];\n    };\n\n    let data = poll_frame!(Data, codec);\n    assert_eq!(data.stream_id(), 1);\n    assert_eq!(data.payload(), &b\"hello\"[..]);\n    assert!(!data.is_end_stream());\n\n    assert_closed!(codec);\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/data.rs::stream_id", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_data_empty_payload", "test": "async fn read_data_empty_payload() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 0, 0, 0, 0, 0, 0, 1,\n        ];\n    };\n\n    let data = poll_frame!(Data, codec);\n    assert_eq!(data.stream_id(), 1);\n    assert_eq!(data.payload(), &b\"\"[..]);\n    assert!(!data.is_end_stream());\n\n    assert_closed!(codec);\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/data.rs::stream_id", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_data_end_stream", "test": "async fn read_data_end_stream() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 5, 0, 1, 0, 0, 0, 1,\n            \"hello\",\n        ];\n    };\n\n    let data = poll_frame!(Data, codec);\n    assert_eq!(data.stream_id(), 1);\n    assert_eq!(data.payload(), &b\"hello\"[..]);\n    assert!(data.is_end_stream());\n    assert_closed!(codec);\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/data.rs::stream_id", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_data_padding", "test": "async fn read_data_padding() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 16, 0, 0x8, 0, 0, 0, 1,\n            5,       // Pad length\n            \"helloworld\", // Data\n            \"\\0\\0\\0\\0\\0\", // Padding\n        ];\n    };\n\n    let data = poll_frame!(Data, codec);\n    assert_eq!(data.stream_id(), 1);\n    assert_eq!(data.payload(), &b\"helloworld\"[..]);\n    assert!(!data.is_end_stream());\n\n    assert_closed!(codec);\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/data.rs::stream_id", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_push_promise", "test": "async fn read_push_promise() {\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 0x5,\n            0x5, 0x4,\n            0, 0, 0, 0x1, // stream id\n            0, 0, 0, 0x2, // promised id\n            0x82, // HPACK :method=\"GET\"\n        ];\n    };\n\n    let pp = poll_frame!(PushPromise, codec);\n    assert_eq!(pp.stream_id(), 1);\n    assert_eq!(pp.promised_id(), 2);\n    assert_eq!(pp.into_parts().0.method, Some(Method::GET));\n\n    assert_closed!(codec);\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/window_update.rs::stream_id", "code": "pub fn stream_id(&self) -> StreamId {\n        self.stream_id\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::update_max_frame_len_at_rest", "test": "async fn update_max_frame_len_at_rest() {\n    use futures::StreamExt;\n    use tokio::io::AsyncReadExt;\n\n    h2_support::trace_init!();\n    // TODO: add test for updating max frame length in flight as well?\n    let mut codec = raw_codec! {\n        read => [\n            0, 0, 5, 0, 0, 0, 0, 0, 1,\n            \"hello\",\n            0, 64, 1, 0, 0, 0, 0, 0, 1,\n            vec![0; 16_385],\n        ];\n    };\n\n    assert_eq!(poll_frame!(Data, codec).payload(), &b\"hello\"[..]);\n\n    codec.set_max_recv_frame_size(16_384);\n\n    assert_eq!(codec.max_recv_frame_size(), 16_384);\n    assert_eq!(\n        codec.next().await.unwrap().unwrap_err().to_string(),\n        \"frame with invalid size\"\n    );\n\n    // drain codec buffer\n    let mut buf = Vec::new();\n    codec.get_mut().read_to_end(&mut buf).await.unwrap();\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/data.rs::payload", "code": "pub fn payload(&self) -> &T {\n        &self.data\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/codec_read.rs::read_goaway_with_debug_data", "test": "async fn read_goaway_with_debug_data() {\n    let mut codec = raw_codec! {\n        read => [\n            // head\n            0, 0, 22, 7, 0, 0, 0, 0, 0,\n            // last_stream_id\n            0, 0, 0, 1,\n            // error_code\n            0, 0, 0, 11,\n            // debug_data\n            \"too_many_pings\",\n        ];\n    };\n\n    let data = poll_frame!(GoAway, codec);\n    assert_eq!(data.reason(), Reason::ENHANCE_YOUR_CALM);\n    assert_eq!(data.last_stream_id(), 1);\n    assert_eq!(&**data.debug_data(), b\"too_many_pings\");\n\n    assert_closed!(codec);\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/proto/go_away.rs::reason", "code": "pub(crate) fn reason(&self) -> Reason {\n        self.reason\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::send_data_without_requesting_capacity", "test": "async fn send_data_without_requesting_capacity() {\n    h2_support::trace_init!();\n\n    let payload = vec![0; 1024];\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        .write(&[\n            // POST /\n            0, 0, 16, 1, 4, 0, 0, 0, 1, 131, 135, 65, 139, 157, 41, 172, 75, 143, 168, 233, 25, 151,\n            33, 233, 132,\n        ])\n        .write(&[\n            // DATA\n            0, 4, 0, 0, 1, 0, 0, 0, 1,\n        ])\n        .write(&payload[..])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[0, 0, 1, 1, 5, 0, 0, 0, 1, 0x89])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    let request = Request::builder()\n        .method(Method::POST)\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    let (response, mut stream) = client.send_request(request, false).unwrap();\n\n    // The capacity should be immediately allocated\n    assert_eq!(stream.capacity(), 0);\n\n    // Send the data\n    stream.send_data(payload.into(), true).unwrap();\n\n    // Get the response\n    let resp = h2.run(response).await.unwrap();\n    assert_eq!(resp.status(), StatusCode::NO_CONTENT);\n\n    h2.await.unwrap();\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/proto/streams/send.rs::capacity", "code": "pub fn capacity(&self, stream: &mut store::Ptr) -> WindowSize {\n        stream.capacity(self.prioritize.max_buffer_size())\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::recv_data_overflows_stream_window", "test": "async fn recv_data_overflows_stream_window() {\n    // this tests for when streams have smaller windows than their connection\n    h2_support::trace_init!();\n\n    let (io, mut srv) = mock::new();\n\n    let mock = async move {\n        let _ = srv.assert_client_handshake().await;\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://http2.akamai.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        // fill the whole window\n        srv.send_frame(frames::data(1, vec![0u8; 16_384])).await;\n        // this frame overflows the window!\n        srv.send_frame(frames::data(1, &[0; 16][..]).eos()).await;\n        srv.recv_frame(frames::reset(1).flow_control()).await;\n    };\n\n    let h2 = async move {\n        let (mut client, conn) = client::Builder::new()\n            .initial_window_size(16_384)\n            .handshake::<_, Bytes>(io)\n            .await\n            .unwrap();\n        let request = Request::builder()\n            .method(Method::GET)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let req = async move {\n            let resp = client.send_request(request, true).unwrap().0.await.unwrap();\n            assert_eq!(resp.status(), StatusCode::OK);\n            let body = resp.into_parts().1;\n            let res = util::concat(body).await;\n            let err = res.unwrap_err();\n            assert_eq!(\n                err.to_string(),\n                \"stream error detected: flow-control protocol violated\"\n            );\n        };\n\n        join(async move { conn.await.unwrap() }, req).await;\n    };\n    join(mock, h2).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-support/src/frames.rs::status", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::stream_close_by_data_frame_releases_capacity", "test": "async fn stream_close_by_data_frame_releases_capacity() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let window_size = frame::DEFAULT_INITIAL_WINDOW_SIZE as usize;\n\n    let h2 = async move {\n        let (mut client, mut h2) = client::handshake(io).await.unwrap();\n        let request = Request::builder()\n            .method(Method::POST)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        // Send request\n        let (resp1, mut s1) = client.send_request(request, false).unwrap();\n\n        // This effectively reserves the entire connection window\n        s1.reserve_capacity(window_size);\n\n        // The capacity should be immediately available as nothing else is\n        // happening on the stream.\n        assert_eq!(s1.capacity(), window_size);\n\n        let request = Request::builder()\n            .method(Method::POST)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        // Create a second stream\n        let (resp2, mut s2) = client.send_request(request, false).unwrap();\n\n        // Request capacity\n        s2.reserve_capacity(5);\n\n        // There should be no available capacity (as it is being held up by\n        // the previous stream\n        assert_eq!(s2.capacity(), 0);\n\n        // Closing the previous stream by sending an empty data frame will\n        // release the capacity to s2\n        s1.send_data(\"\".into(), true).unwrap();\n\n        // The capacity should be available\n        assert_eq!(s2.capacity(), 5);\n\n        // Send the frame\n        s2.send_data(\"hello\".into(), true).unwrap();\n\n        // Drive both streams to prevent the handles from being dropped\n        // (which will send a RST_STREAM) before the connection is closed.\n        h2.drive(resp1).await.unwrap();\n        h2.drive(resp2).await.unwrap();\n    };\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_default_settings!(settings);\n        srv.recv_frame(frames::headers(1).request(\"POST\", \"https://http2.akamai.com/\"))\n            .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        srv.recv_frame(frames::headers(3).request(\"POST\", \"https://http2.akamai.com/\"))\n            .await;\n        srv.send_frame(frames::headers(3).response(200)).await;\n        srv.recv_frame(frames::data(1, &b\"\"[..]).eos()).await;\n        srv.recv_frame(frames::data(3, &b\"hello\"[..]).eos()).await;\n    };\n    join(srv, h2).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/share.rs::capacity", "code": "pub fn capacity(&self) -> usize {\n        self.inner.capacity() as usize\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::stream_close_by_trailers_frame_releases_capacity", "test": "async fn stream_close_by_trailers_frame_releases_capacity() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let window_size = frame::DEFAULT_INITIAL_WINDOW_SIZE as usize;\n\n    let h2 = async move {\n        let (mut client, mut h2) = client::handshake(io).await.unwrap();\n        let request = Request::builder()\n            .method(Method::POST)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        // Send request\n        let (resp1, mut s1) = client.send_request(request, false).unwrap();\n\n        // This effectively reserves the entire connection window\n        s1.reserve_capacity(window_size);\n\n        // The capacity should be immediately available as nothing else is\n        // happening on the stream.\n        assert_eq!(s1.capacity(), window_size);\n\n        let request = Request::builder()\n            .method(Method::POST)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        // Create a second stream\n        let (resp2, mut s2) = client.send_request(request, false).unwrap();\n\n        // Request capacity\n        s2.reserve_capacity(5);\n\n        // There should be no available capacity (as it is being held up by\n        // the previous stream\n        assert_eq!(s2.capacity(), 0);\n\n        // Closing the previous stream by sending a trailers frame will\n        // release the capacity to s2\n        s1.send_trailers(Default::default()).unwrap();\n\n        // The capacity should be available\n        assert_eq!(s2.capacity(), 5);\n\n        // Send the frame\n        s2.send_data(\"hello\".into(), true).unwrap();\n\n        // Drive both streams to prevent the handles from being dropped\n        // (which will send a RST_STREAM) before the connection is closed.\n        h2.drive(resp1).await.unwrap();\n        h2.drive(resp2).await.unwrap();\n    };\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        // Get the first frame\n        assert_default_settings!(settings);\n        srv.recv_frame(frames::headers(1).request(\"POST\", \"https://http2.akamai.com/\"))\n            .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        srv.recv_frame(frames::headers(3).request(\"POST\", \"https://http2.akamai.com/\"))\n            .await;\n        srv.send_frame(frames::headers(3).response(200)).await;\n        srv.recv_frame(frames::headers(1).eos()).await;\n        srv.recv_frame(frames::data(3, &b\"hello\"[..]).eos()).await;\n    };\n    join(srv, h2).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/share.rs::capacity", "code": "pub fn capacity(&self) -> usize {\n        self.inner.capacity() as usize\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::recv_window_update_on_stream_closed_by_data_frame", "test": "async fn recv_window_update_on_stream_closed_by_data_frame() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let h2 = async move {\n        let (mut client, mut h2) = client::handshake(io).await.unwrap();\n        let request = Request::builder()\n            .method(Method::POST)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let (response, mut stream) = client.send_request(request, false).unwrap();\n\n        // Wait for the response\n        let response = h2.drive(response).await.unwrap();\n        assert_eq!(response.status(), StatusCode::OK);\n\n        // Send a data frame, this will also close the connection\n        stream.send_data(\"hello\".into(), true).unwrap();\n\n        // keep `stream` from being dropped in order to prevent\n        // it from sending an RST_STREAM frame.\n        //\n        // i know this is kind of evil, but it's necessary to\n        // ensure that the stream is closed by the EOS frame,\n        // and not by the RST_STREAM.\n        std::mem::forget(stream);\n\n        // Wait for the connection to close\n        h2.await.unwrap();\n    };\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_default_settings!(settings);\n        srv.recv_frame(frames::headers(1).request(\"POST\", \"https://http2.akamai.com/\"))\n            .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        srv.recv_frame(frames::data(1, \"hello\").eos()).await;\n        srv.send_frame(frames::window_update(1, 5)).await;\n    };\n    join(srv, h2).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-support/src/frames.rs::status", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/flow_control.rs::reserved_capacity_assigned_in_multi_window_updates", "test": "async fn reserved_capacity_assigned_in_multi_window_updates() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let h2 = async move {\n        let (mut client, mut h2) = client::handshake(io).await.unwrap();\n        let request = Request::builder()\n            .method(Method::POST)\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let (response, mut stream) = client.send_request(request, false).unwrap();\n\n        // Consume the capacity\n        let payload = vec![0; frame::DEFAULT_INITIAL_WINDOW_SIZE as usize];\n        stream.send_data(payload.into(), false).unwrap();\n\n        // Reserve more data than we want\n        stream.reserve_capacity(10);\n\n        let mut stream = h2.drive(util::wait_for_capacity(stream, 5)).await;\n        stream.send_data(\"hello\".into(), false).unwrap();\n        stream.send_data(\"world\".into(), true).unwrap();\n\n        let response = h2.drive(response).await.unwrap();\n        assert_eq!(response.status(), StatusCode::NO_CONTENT);\n\n        // Wait for the connection to close\n        h2.await.unwrap();\n    };\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_default_settings!(settings);\n        srv.recv_frame(frames::headers(1).request(\"POST\", \"https://http2.akamai.com/\"))\n            .await;\n        srv.recv_frame(frames::data(1, vec![0u8; 16_384])).await;\n        srv.recv_frame(frames::data(1, vec![0u8; 16_384])).await;\n        srv.recv_frame(frames::data(1, vec![0u8; 16_384])).await;\n        srv.recv_frame(frames::data(1, vec![0u8; 16_383])).await;\n        idle_ms(100).await;\n        // Increase the connection window\n        srv.send_frame(frames::window_update(0, 10)).await;\n        // Incrementally increase the stream window\n        srv.send_frame(frames::window_update(1, 4)).await;\n        idle_ms(50).await;\n        srv.send_frame(frames::window_update(1, 1)).await;\n        // Receive first chunk\n        srv.recv_frame(frames::data(1, \"hello\")).await;\n        srv.send_frame(frames::window_update(1, 5)).await;\n        // Receive second chunk\n        srv.recv_frame(frames::data(1, \"world\").eos()).await;\n        srv.send_frame(frames::headers(1).response(204).eos()).await;\n        /*\n        .recv_frame(frames::data(1, \"hello\").eos())\n        .send_frame(frames::window_update(1, 5))\n        */\n    };\n    join(srv, h2).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-support/src/frames.rs::status", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/hammer.rs::hammer_client_concurrency", "test": "fn hammer_client_concurrency() {\n    // This reproduces issue #326.\n    const N: usize = 5000;\n\n    let server = Server::serve(|| Bytes::from_static(b\"hello world!\"));\n\n    let addr = server.addr();\n    let rsps = Arc::new(AtomicUsize::new(0));\n\n    for i in 0..N {\n        print!(\"sending {}\", i);\n        let rsps = rsps.clone();\n        let tcp = TcpStream::connect(&addr);\n        let tcp = tcp\n            .then(|res| {\n                let tcp = res.unwrap();\n                client::handshake(tcp)\n            })\n            .then(move |res| {\n                let rsps = rsps;\n                let (mut client, h2) = res.unwrap();\n                let request = Request::builder()\n                    .uri(\"https://http2.akamai.com/\")\n                    .body(())\n                    .unwrap();\n\n                let (response, mut stream) = client.send_request(request, false).unwrap();\n                stream.send_trailers(HeaderMap::new()).unwrap();\n\n                tokio::spawn(async move {\n                    h2.await.unwrap();\n                });\n\n                response\n                    .and_then(|response| {\n                        let mut body = response.into_body();\n\n                        async move {\n                            while let Some(res) = body.data().await {\n                                res?;\n                            }\n                            body.trailers().await?;\n                            Ok(())\n                        }\n                    })\n                    .map_err(|e| {\n                        panic!(\"client error: {:?}\", e);\n                    })\n                    .map(move |_| {\n                        rsps.fetch_add(1, Ordering::Release);\n                    })\n            });\n\n        let rt = tokio::runtime::Runtime::new().unwrap();\n        rt.block_on(tcp);\n        println!(\"...done\");\n    }\n\n    println!(\"all done\");\n\n    assert_eq!(N, rsps.load(Ordering::Acquire));\n    assert_eq!(N, server.request_count());\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/data.rs::load", "code": "pub(crate) fn load(head: Head, mut payload: Bytes) -> Result<Self, Error> {\n        let flags = DataFlags::load(head.flag());\n\n        // The stream identifier must not be zero\n        if head.stream_id().is_zero() {\n            return Err(Error::InvalidStreamId);\n        }\n\n        let pad_len = if flags.is_padded() {\n            let len = util::strip_padding(&mut payload)?;\n            Some(len)\n        } else {\n            None\n        };\n\n        Ok(Data {\n            stream_id: head.stream_id(),\n            data: payload,\n            flags,\n            pad_len,\n        })\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/push_promise.rs::recv_push_promise_over_max_header_list_size", "test": "async fn recv_push_promise_over_max_header_list_size() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_frame_eq(settings, frames::settings().max_header_list_size(10));\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://http2.akamai.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(\n            frames::push_promise(1, 2).request(\"GET\", \"https://http2.akamai.com/style.css\"),\n        )\n        .await;\n        srv.recv_frame(frames::reset(2).refused()).await;\n        srv.send_frame(frames::headers(1).response(200).eos()).await;\n        idle_ms(10).await;\n    };\n\n    let client = async move {\n        let (mut client, mut conn) = client::Builder::new()\n            .max_header_list_size(10)\n            .handshake::<_, Bytes>(io)\n            .await\n            .expect(\"handshake\");\n        let request = Request::builder()\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let req = async move {\n            let err = client\n                .send_request(request, true)\n                .expect(\"send_request\")\n                .0\n                .await\n                .expect_err(\"response\");\n            assert_eq!(err.reason(), Some(Reason::REFUSED_STREAM));\n        };\n\n        conn.drive(req).await;\n        conn.await.expect(\"client\");\n    };\n    join(srv, client).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/error.rs::reason", "code": "pub fn reason(&self) -> Option<Reason> {\n        match self.kind {\n            Kind::Reset(_, reason, _) | Kind::GoAway(_, reason, _) | Kind::Reason(reason) => {\n                Some(reason)\n            }\n            _ => None,\n        }\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::server_builder_set_max_concurrent_streams", "test": "async fn server_builder_set_max_concurrent_streams() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let mut settings = frame::Settings::default();\n    settings.set_max_concurrent_streams(Some(1));\n\n    let client = async move {\n        let recv_settings = client.assert_server_handshake().await;\n        assert_frame_eq(recv_settings, settings);\n        client\n            .send_frame(frames::headers(1).request(\"GET\", \"https://example.com/\"))\n            .await;\n        client\n            .send_frame(frames::headers(3).request(\"GET\", \"https://example.com/\"))\n            .await;\n        client\n            .send_frame(frames::data(1, &b\"hello\"[..]).eos())\n            .await;\n        client.recv_frame(frames::reset(3).refused()).await;\n        client\n            .recv_frame(frames::headers(1).response(200).eos())\n            .await;\n    };\n\n    let mut builder = server::Builder::new();\n    builder.max_concurrent_streams(1);\n\n    let h2 = async move {\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        let rsp = http::Response::builder().status(200).body(()).unwrap();\n        stream.send_response(rsp, true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, h2).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/hpack/encoder.rs::method", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::push_request", "test": "async fn push_request() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        client\n            .assert_server_handshake_with_settings(frames::settings().max_concurrent_streams(100))\n            .await;\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"https://example.com/\")\n                    .eos(),\n            )\n            .await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 2).request(\"GET\", \"https://http2.akamai.com/style.css\"),\n            )\n            .await;\n        client\n            .recv_frame(frames::headers(2).response(200).eos())\n            .await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 4).request(\"GET\", \"https://http2.akamai.com/style2.css\"),\n            )\n            .await;\n        client\n            .recv_frame(frames::headers(4).response(200).eos())\n            .await;\n        client\n            .recv_frame(frames::headers(1).response(200).eos())\n            .await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        // Promise stream 2\n        let mut pushed_s2 = {\n            let req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style.css\")\n                .body(())\n                .unwrap();\n            stream.push_request(req).unwrap()\n        };\n\n        // Promise stream 4 and push response headers\n        {\n            let req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style2.css\")\n                .body(())\n                .unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream\n                .push_request(req)\n                .unwrap()\n                .send_response(rsp, true)\n                .unwrap();\n        }\n\n        // Push response to stream 2\n        {\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            pushed_s2.send_response(rsp, true).unwrap();\n        }\n\n        // Send response for stream 1\n        let rsp = http::Response::builder().status(200).body(()).unwrap();\n        stream.send_response(rsp, true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, srv).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/hpack/encoder.rs::method", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::push_request_disabled", "test": "async fn push_request_disabled() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        client\n            .assert_server_handshake_with_settings(frames::settings().disable_push())\n            .await;\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"https://example.com/\")\n                    .eos(),\n            )\n            .await;\n        client\n            .recv_frame(frames::headers(1).response(200).eos())\n            .await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        // attempt to push - expect failure\n        let req = http::Request::builder()\n            .method(\"GET\")\n            .uri(\"https://http2.akamai.com/style.css\")\n            .body(())\n            .unwrap();\n        stream\n            .push_request(req)\n            .expect_err(\"push_request should error\");\n\n        // send normal response\n        let rsp = http::Response::builder().status(200).body(()).unwrap();\n        stream.send_response(rsp, true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, srv).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/hpack/encoder.rs::method", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::push_request_against_concurrency", "test": "async fn push_request_against_concurrency() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        client\n            .assert_server_handshake_with_settings(frames::settings().max_concurrent_streams(1))\n            .await;\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"https://example.com/\")\n                    .eos(),\n            )\n            .await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 2).request(\"GET\", \"https://http2.akamai.com/style.css\"),\n            )\n            .await;\n        client.recv_frame(frames::headers(2).response(200)).await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 4).request(\"GET\", \"https://http2.akamai.com/style2.css\"),\n            )\n            .await;\n        client.recv_frame(frames::data(2, &b\"\"[..]).eos()).await;\n        client\n            .recv_frame(frames::headers(4).response(200).eos())\n            .await;\n        client\n            .recv_frame(frames::headers(1).response(200).eos())\n            .await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        // Promise stream 2 and start response (concurrency limit reached)\n        let mut s2_tx = {\n            let req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style.css\")\n                .body(())\n                .unwrap();\n            let mut pushed_stream = stream.push_request(req).unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            pushed_stream.send_response(rsp, false).unwrap()\n        };\n\n        // Promise stream 4 and push response\n        {\n            let pushed_req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style2.css\")\n                .body(())\n                .unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream\n                .push_request(pushed_req)\n                .unwrap()\n                .send_response(rsp, true)\n                .unwrap();\n        }\n\n        // Send and finish response for stream 1\n        {\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream.send_response(rsp, true).unwrap();\n        }\n\n        // Finish response for stream 2 (at which point stream 4 will be sent)\n        s2_tx.send_data(vec![0; 0].into(), true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, srv).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/hpack/encoder.rs::method", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::push_request_with_data", "test": "async fn push_request_with_data() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        client\n            .assert_server_handshake_with_settings(frames::settings().max_concurrent_streams(100))\n            .await;\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"https://example.com/\")\n                    .eos(),\n            )\n            .await;\n        client.recv_frame(frames::headers(1).response(200)).await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 2).request(\"GET\", \"https://http2.akamai.com/style.css\"),\n            )\n            .await;\n        client.recv_frame(frames::headers(2).response(200)).await;\n        client.recv_frame(frames::data(1, &b\"\"[..]).eos()).await;\n        client.recv_frame(frames::data(2, &b\"\\x00\"[..]).eos()).await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        // Start response to stream 1\n        let mut s1_tx = {\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream.send_response(rsp, false).unwrap()\n        };\n\n        // Promise stream 2, push response headers and send data\n        {\n            let pushed_req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style.css\")\n                .body(())\n                .unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            let mut push_tx = stream\n                .push_request(pushed_req)\n                .unwrap()\n                .send_response(rsp, false)\n                .unwrap();\n            // Make sure nothing can queue our pushed stream before we have the PushPromise sent\n            push_tx.send_data(vec![0; 1].into(), true).unwrap();\n            push_tx.reserve_capacity(1);\n        }\n\n        // End response for stream 1\n        s1_tx.send_data(vec![0; 0].into(), true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, srv).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/hpack/encoder.rs::method", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::push_request_between_data", "test": "async fn push_request_between_data() {\n    h2_support::trace_init!();\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        client\n            .assert_server_handshake_with_settings(frames::settings().max_concurrent_streams(100))\n            .await;\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"https://example.com/\")\n                    .eos(),\n            )\n            .await;\n        client.recv_frame(frames::headers(1).response(200)).await;\n        client.recv_frame(frames::data(1, &b\"\"[..])).await;\n        client\n            .recv_frame(\n                frames::push_promise(1, 2).request(\"GET\", \"https://http2.akamai.com/style.css\"),\n            )\n            .await;\n        client\n            .recv_frame(frames::headers(2).response(200).eos())\n            .await;\n        client.recv_frame(frames::data(1, &b\"\"[..]).eos()).await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(req.method(), &http::Method::GET);\n\n        // Push response to stream 1 and send some data\n        let mut s1_tx = {\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            let mut tx = stream.send_response(rsp, false).unwrap();\n            tx.send_data(vec![0; 0].into(), false).unwrap();\n            tx\n        };\n\n        // Promise stream 2 and push response headers\n        {\n            let pushed_req = http::Request::builder()\n                .method(\"GET\")\n                .uri(\"https://http2.akamai.com/style.css\")\n                .body(())\n                .unwrap();\n            let rsp = http::Response::builder().status(200).body(()).unwrap();\n            stream\n                .push_request(pushed_req)\n                .unwrap()\n                .send_response(rsp, true)\n                .unwrap();\n        }\n\n        // End response for stream 1\n        s1_tx.send_data(vec![0; 0].into(), true).unwrap();\n\n        assert!(srv.next().await.is_none());\n    };\n\n    join(client, srv).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/hpack/encoder.rs::method", "code": "fn method(s: &str) -> Header<Option<HeaderName>> {\n        Header::Method(Method::from_bytes(s.as_bytes()).unwrap())\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::extended_connect_protocol_disabled_by_default", "test": "async fn extended_connect_protocol_disabled_by_default() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let settings = client.assert_server_handshake().await;\n\n        assert_eq!(settings.is_extended_connect_protocol_enabled(), None);\n\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"CONNECT\", \"http://bread/baguette\")\n                    .protocol(\"the-bread-protocol\"),\n            )\n            .await;\n\n        client.recv_frame(frames::reset(1).protocol_error()).await;\n    };\n\n    let srv = async move {\n        let mut srv = server::handshake(io).await.expect(\"handshake\");\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n            .await\n            .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/settings.rs::is_extended_connect_protocol_enabled", "code": "pub fn is_extended_connect_protocol_enabled(&self) -> Option<bool> {\n        self.enable_connect_protocol.map(|val| val != 0)\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::extended_connect_protocol_enabled_during_handshake", "test": "async fn extended_connect_protocol_enabled_during_handshake() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let settings = client.assert_server_handshake().await;\n\n        assert_eq!(settings.is_extended_connect_protocol_enabled(), Some(true));\n\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"CONNECT\", \"http://bread/baguette\")\n                    .protocol(\"the-bread-protocol\"),\n            )\n            .await;\n\n        client.recv_frame(frames::headers(1).response(200)).await;\n    };\n\n    let srv = async move {\n        let mut builder = server::Builder::new();\n\n        builder.enable_connect_protocol();\n\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n\n        let (req, mut stream) = srv.next().await.unwrap().unwrap();\n\n        assert_eq!(\n            req.extensions().get::<crate::ext::Protocol>(),\n            Some(&crate::ext::Protocol::from_static(\"the-bread-protocol\"))\n        );\n\n        let rsp = Response::new(());\n        stream.send_response(rsp, false).unwrap();\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n            .await\n            .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/settings.rs::is_extended_connect_protocol_enabled", "code": "pub fn is_extended_connect_protocol_enabled(&self) -> Option<bool> {\n        self.enable_connect_protocol.map(|val| val != 0)\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::reject_pseudo_protocol_on_non_connect_request", "test": "async fn reject_pseudo_protocol_on_non_connect_request() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let settings = client.assert_server_handshake().await;\n\n        assert_eq!(settings.is_extended_connect_protocol_enabled(), Some(true));\n\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"GET\", \"http://bread/baguette\")\n                    .protocol(\"the-bread-protocol\"),\n            )\n            .await;\n\n        client.recv_frame(frames::reset(1).protocol_error()).await;\n    };\n\n    let srv = async move {\n        let mut builder = server::Builder::new();\n\n        builder.enable_connect_protocol();\n\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n\n        assert!(srv.next().await.is_none());\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n            .await\n            .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/settings.rs::is_extended_connect_protocol_enabled", "code": "pub fn is_extended_connect_protocol_enabled(&self) -> Option<bool> {\n        self.enable_connect_protocol.map(|val| val != 0)\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::reject_authority_target_on_extended_connect_request", "test": "async fn reject_authority_target_on_extended_connect_request() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let settings = client.assert_server_handshake().await;\n\n        assert_eq!(settings.is_extended_connect_protocol_enabled(), Some(true));\n\n        client\n            .send_frame(\n                frames::headers(1)\n                    .request(\"CONNECT\", \"bread:80\")\n                    .protocol(\"the-bread-protocol\"),\n            )\n            .await;\n\n        client.recv_frame(frames::reset(1).protocol_error()).await;\n    };\n\n    let srv = async move {\n        let mut builder = server::Builder::new();\n\n        builder.enable_connect_protocol();\n\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n\n        assert!(srv.next().await.is_none());\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n            .await\n            .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/settings.rs::is_extended_connect_protocol_enabled", "code": "pub fn is_extended_connect_protocol_enabled(&self) -> Option<bool> {\n        self.enable_connect_protocol.map(|val| val != 0)\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::reject_non_authority_target_on_connect_request", "test": "async fn reject_non_authority_target_on_connect_request() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let settings = client.assert_server_handshake().await;\n\n        assert_eq!(settings.is_extended_connect_protocol_enabled(), Some(true));\n\n        client\n            .send_frame(frames::headers(1).request(\"CONNECT\", \"https://bread/baguette\"))\n            .await;\n\n        client.recv_frame(frames::reset(1).protocol_error()).await;\n    };\n\n    let srv = async move {\n        let mut builder = server::Builder::new();\n\n        builder.enable_connect_protocol();\n\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n\n        assert!(srv.next().await.is_none());\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n            .await\n            .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/settings.rs::is_extended_connect_protocol_enabled", "code": "pub fn is_extended_connect_protocol_enabled(&self) -> Option<bool> {\n        self.enable_connect_protocol.map(|val| val != 0)\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/server.rs::reject_informational_status_header_in_request", "test": "async fn reject_informational_status_header_in_request() {\n    h2_support::trace_init!();\n\n    let (io, mut client) = mock::new();\n\n    let client = async move {\n        let _ = client.assert_server_handshake().await;\n\n        let status_code = 128;\n        assert!(StatusCode::from_u16(status_code)\n            .unwrap()\n            .is_informational());\n\n        client\n            .send_frame(frames::headers(1).response(status_code))\n            .await;\n\n        client.recv_frame(frames::reset(1).protocol_error()).await;\n    };\n\n    let srv = async move {\n        let builder = server::Builder::new();\n        let mut srv = builder.handshake::<_, Bytes>(io).await.expect(\"handshake\");\n\n        poll_fn(move |cx| srv.poll_closed(cx))\n            .await\n            .expect(\"server\");\n    };\n\n    join(client, srv).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/frame/headers.rs::is_informational", "code": "pub(crate) fn is_informational(&self) -> bool {\n        self.header_block.pseudo.is_informational()\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::send_recv_headers_only", "test": "async fn send_recv_headers_only() {\n    h2_support::trace_init!();\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        // Write GET /\n        .write(&[\n            0, 0, 0x10, 1, 5, 0, 0, 0, 1, 0x82, 0x87, 0x41, 0x8B, 0x9D, 0x29, 0xAC, 0x4B, 0x8F,\n            0xA8, 0xE9, 0x19, 0x97, 0x21, 0xE9, 0x84,\n        ])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[0, 0, 1, 1, 5, 0, 0, 0, 1, 0x89])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    // Send the request\n    let request = Request::builder()\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    tracing::info!(\"sending request\");\n    let (response, _) = client.send_request(request, true).unwrap();\n\n    let resp = h2.run(response).await.unwrap();\n    assert_eq!(resp.status(), StatusCode::NO_CONTENT);\n\n    h2.await.unwrap();\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-support/src/frames.rs::status", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::send_recv_data", "test": "async fn send_recv_data() {\n    h2_support::trace_init!();\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        .write(&[\n            // POST /\n            0, 0, 16, 1, 4, 0, 0, 0, 1, 131, 135, 65, 139, 157, 41, 172, 75, 143, 168, 233, 25, 151,\n            33, 233, 132,\n        ])\n        .write(&[\n            // DATA\n            0, 0, 5, 0, 1, 0, 0, 0, 1, 104, 101, 108, 108, 111,\n        ])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[\n            // HEADERS\n            0, 0, 1, 1, 4, 0, 0, 0, 1, 136, // DATA\n            0, 0, 5, 0, 1, 0, 0, 0, 1, 119, 111, 114, 108, 100,\n        ])\n        .build();\n\n    let (mut client, mut h2) = client::Builder::new().handshake(mock).await.unwrap();\n\n    let request = Request::builder()\n        .method(Method::POST)\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    tracing::info!(\"sending request\");\n    let (response, mut stream) = client.send_request(request, false).unwrap();\n\n    // Reserve send capacity\n    stream.reserve_capacity(5);\n\n    assert_eq!(stream.capacity(), 5);\n\n    // Send the data\n    stream.send_data(\"hello\".as_bytes(), true).unwrap();\n\n    // Get the response\n    let resp = h2.run(response).await.unwrap();\n    assert_eq!(resp.status(), StatusCode::OK);\n\n    // Take the body\n    let (_, body) = resp.into_parts();\n\n    // Wait for all the data frames to be received\n    let bytes: Vec<_> = h2.run(body.try_collect()).await.unwrap();\n\n    // One byte chunk\n    assert_eq!(1, bytes.len());\n\n    assert_eq!(bytes[0], &b\"world\"[..]);\n\n    // The H2 connection is closed\n    h2.await.unwrap();\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/src/proto/streams/send.rs::capacity", "code": "pub fn capacity(&self, stream: &mut store::Ptr) -> WindowSize {\n        stream.capacity(self.prioritize.max_buffer_size())\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::send_headers_recv_data_single_frame", "test": "async fn send_headers_recv_data_single_frame() {\n    h2_support::trace_init!();\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        // Write GET /\n        .write(&[\n            0, 0, 16, 1, 5, 0, 0, 0, 1, 130, 135, 65, 139, 157, 41, 172, 75, 143, 168, 233, 25,\n            151, 33, 233, 132,\n        ])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[\n            0, 0, 1, 1, 4, 0, 0, 0, 1, 136, 0, 0, 5, 0, 0, 0, 0, 0, 1, 104, 101, 108, 108, 111, 0,\n            0, 5, 0, 1, 0, 0, 0, 1, 119, 111, 114, 108, 100,\n        ])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    // Send the request\n    let request = Request::builder()\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    tracing::info!(\"sending request\");\n    let (response, _) = client.send_request(request, true).unwrap();\n\n    let resp = h2.run(response).await.unwrap();\n    assert_eq!(resp.status(), StatusCode::OK);\n\n    // Take the body\n    let (_, body) = resp.into_parts();\n\n    // Wait for all the data frames to be received\n    let bytes: Vec<_> = h2.run(body.try_collect()).await.unwrap();\n\n    // Two data frames\n    assert_eq!(2, bytes.len());\n\n    assert_eq!(bytes[0], &b\"hello\"[..]);\n    assert_eq!(bytes[1], &b\"world\"[..]);\n\n    // The H2 connection is closed\n    h2.await.unwrap();\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-support/src/frames.rs::status", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::closed_streams_are_released", "test": "async fn closed_streams_are_released() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let h2 = async move {\n        let (mut client, mut h2) = client::handshake(io).await.unwrap();\n        let request = Request::get(\"https://example.com/\").body(()).unwrap();\n\n        // Send request\n        let (response, _) = client.send_request(request, true).unwrap();\n        let response = h2.drive(response).await.unwrap();\n        assert_eq!(response.status(), StatusCode::NO_CONTENT);\n\n        // There are no active streams\n        assert_eq!(0, client.num_active_streams());\n\n        // The response contains a handle for the body. This keeps the\n        // stream wired.\n        assert_eq!(1, client.num_wired_streams());\n\n        let (_, body) = response.into_parts();\n        assert!(body.is_end_stream());\n        drop(body);\n\n        // The stream state is now free\n        assert_eq!(0, client.num_wired_streams());\n    };\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_default_settings!(settings);\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://example.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frames::headers(1).response(204).eos()).await;\n    };\n    join(srv, h2).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-support/src/frames.rs::status", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::errors_if_recv_frame_exceeds_max_frame_size", "test": "async fn errors_if_recv_frame_exceeds_max_frame_size() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let h2 = async move {\n        let (mut client, h2) = client::handshake(io).await.unwrap();\n        let req = async move {\n            let resp = client.get(\"https://example.com/\").await.expect(\"response\");\n            assert_eq!(resp.status(), StatusCode::OK);\n            let body = resp.into_parts().1;\n            let res = util::concat(body).await;\n            let err = res.unwrap_err();\n            assert_eq!(\n                err.to_string(),\n                \"connection error detected: frame with invalid size\"\n            );\n        };\n\n        // client should see a conn error\n        let conn = async move {\n            let err = h2.await.unwrap_err();\n            assert_eq!(\n                err.to_string(),\n                \"connection error detected: frame with invalid size\"\n            );\n        };\n        join(conn, req).await;\n    };\n\n    // a bad peer\n    srv.codec_mut().set_max_send_frame_size(16_384 * 4);\n\n    let srv = async move {\n        let _ = srv.assert_client_handshake().await;\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://example.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        srv.send_frame(frames::data(1, vec![0; 16_385]).eos()).await;\n        srv.recv_frame(frames::go_away(0).frame_size()).await;\n    };\n\n    join(srv, h2).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-support/src/frames.rs::status", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/stream_states.rs::configure_max_frame_size", "test": "async fn configure_max_frame_size() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let h2 = async move {\n        let (mut client, h2) = client::Builder::new()\n            .max_frame_size(16_384 * 2)\n            .handshake::<_, Bytes>(io)\n            .await\n            .expect(\"handshake\");\n\n        let req = async move {\n            let resp = client.get(\"https://example.com/\").await.expect(\"response\");\n            assert_eq!(resp.status(), StatusCode::OK);\n            let body = resp.into_parts().1;\n            let buf = util::concat(body).await.expect(\"body\");\n            assert_eq!(buf.len(), 16_385);\n        };\n\n        join(async move { h2.await.expect(\"client\") }, req).await;\n    };\n    // a good peer\n    srv.codec_mut().set_max_send_frame_size(16_384 * 2);\n\n    let srv = async move {\n        let _ = srv.assert_client_handshake().await;\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://example.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frames::headers(1).response(200)).await;\n        srv.send_frame(frames::data(1, vec![0; 16_385]).eos()).await;\n    };\n    join(srv, h2).await;\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-support/src/frames.rs::status", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/trailers.rs::recv_trailers_only", "test": "async fn recv_trailers_only() {\n    h2_support::trace_init!();\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        // Write GET /\n        .write(&[\n            0, 0, 0x10, 1, 5, 0, 0, 0, 1, 0x82, 0x87, 0x41, 0x8B, 0x9D, 0x29, 0xAC, 0x4B, 0x8F,\n            0xA8, 0xE9, 0x19, 0x97, 0x21, 0xE9, 0x84,\n        ])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[\n            0, 0, 1, 1, 4, 0, 0, 0, 1, 0x88, 0, 0, 9, 1, 5, 0, 0, 0, 1, 0x40, 0x84, 0x42, 0x46,\n            0x9B, 0x51, 0x82, 0x3F, 0x5F,\n        ])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    // Send the request\n    let request = Request::builder()\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    tracing::info!(\"sending request\");\n    let (response, _) = client.send_request(request, true).unwrap();\n\n    let response = h2.run(response).await.unwrap();\n    assert_eq!(response.status(), StatusCode::OK);\n\n    let (_, mut body) = response.into_parts();\n\n    // Make sure there is no body\n    let chunk = h2.run(Box::pin(body.next())).await;\n    assert!(chunk.is_none());\n\n    let trailers = h2\n        .run(poll_fn(|cx| body.poll_trailers(cx)))\n        .await\n        .unwrap()\n        .unwrap();\n    assert_eq!(1, trailers.len());\n    assert_eq!(trailers[\"status\"], \"ok\");\n\n    h2.await.unwrap();\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-support/src/frames.rs::status", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "docstring": null}
{"test_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-tests/tests/trailers.rs::send_trailers_immediately", "test": "async fn send_trailers_immediately() {\n    h2_support::trace_init!();\n\n    let mock = mock_io::Builder::new()\n        .handshake()\n        // Write GET /\n        .write(&[\n            0, 0, 0x10, 1, 4, 0, 0, 0, 1, 0x82, 0x87, 0x41, 0x8B, 0x9D, 0x29, 0xAC, 0x4B, 0x8F,\n            0xA8, 0xE9, 0x19, 0x97, 0x21, 0xE9, 0x84, 0, 0, 0x0A, 1, 5, 0, 0, 0, 1, 0x40, 0x83,\n            0xF6, 0x7A, 0x66, 0x84, 0x9C, 0xB4, 0x50, 0x7F,\n        ])\n        .write(frames::SETTINGS_ACK)\n        // Read response\n        .read(&[\n            0, 0, 1, 1, 4, 0, 0, 0, 1, 0x88, 0, 0, 0x0B, 0, 1, 0, 0, 0, 1, 0x68, 0x65, 0x6C, 0x6C,\n            0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64,\n        ])\n        .build();\n\n    let (mut client, mut h2) = client::handshake(mock).await.unwrap();\n\n    // Send the request\n    let request = Request::builder()\n        .uri(\"https://http2.akamai.com/\")\n        .body(())\n        .unwrap();\n\n    tracing::info!(\"sending request\");\n    let (response, mut stream) = client.send_request(request, false).unwrap();\n\n    let mut trailers = HeaderMap::new();\n    trailers.insert(\"zomg\", \"hello\".parse().unwrap());\n\n    stream.send_trailers(trailers).unwrap();\n\n    let response = h2.run(response).await.unwrap();\n    assert_eq!(response.status(), StatusCode::OK);\n\n    let (_, mut body) = response.into_parts();\n\n    // There is a data chunk\n    let _ = h2.run(body.next()).await.unwrap().unwrap();\n\n    let chunk = h2.run(body.next()).await;\n    assert!(chunk.is_none());\n\n    let trailers = h2.run(poll_fn(|cx| body.poll_trailers(cx))).await.unwrap();\n    assert!(trailers.is_none());\n\n    h2.await.unwrap();\n}", "code_id": "hyperium-h2/hyperium-h2-da38b1c/tests/h2-support/src/frames.rs::status", "code": "pub fn status(self, value: StatusCode) -> Self {\n        let (id, mut pseudo, fields) = self.into_parts();\n\n        pseudo.set_status(value);\n\n        Mock(frame::Headers::new(id, pseudo, fields))\n    }", "docstring": null}
