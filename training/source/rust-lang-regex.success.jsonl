{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::capture_names", "test": "fn capture_names() {\n    let re = regex!(r\"(.)(?P<a>.)\");\n    assert_eq!(3, re.captures_len());\n    assert_eq!((3, Some(3)), re.capture_names().size_hint());\n    assert_eq!(vec![None, None, Some(\"a\")],\n               re.capture_names().collect::<Vec<_>>());\n}", "code_id": "rust-lang-regex/rust-lang-regex-cf1a26a/src/re_bytes.rs::captures_len", "code": "pub fn captures_len(&self) -> usize {\n        self.0.capture_names().len()\n    }", "docstring": null}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::regex_string", "test": "fn regex_string() {\n    assert_eq!(r\"[a-zA-Z0-9]+\", regex!(r\"[a-zA-Z0-9]+\").as_str());\n    assert_eq!(r\"[a-zA-Z0-9]+\", &format!(\"{}\", regex!(r\"[a-zA-Z0-9]+\")));\n    assert_eq!(r\"[a-zA-Z0-9]+\", &format!(\"{:?}\", regex!(r\"[a-zA-Z0-9]+\")));\n}", "code_id": "rust-lang-regex/rust-lang-regex-cf1a26a/src/re_bytes.rs::as_str", "code": "pub fn as_str(&self) -> &str {\n        &self.0.regex_strings()[0]\n    }", "docstring": null}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::capture_index_lifetime", "test": "fn capture_index_lifetime() {\n    // This is a test of whether the types on `caps[\"...\"]` are general\n    // enough. If not, this will fail to typecheck.\n    fn inner(s: &str) -> usize {\n        let re = regex!(r\"(?P<number>\\d+)\");\n        let caps = re.captures(t!(s)).unwrap();\n        caps[\"number\"].len()\n    }\n    assert_eq!(3, inner(\"123\"));\n}", "code_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::inner", "code": "fn inner(s: &str) -> usize {\n        let re = regex!(r\"(?P<number>\\d+)\");\n        let caps = re.captures(t!(s)).unwrap();\n        caps[\"number\"].len()\n    }", "docstring": null}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::capture_misc", "test": "fn capture_misc() {\n    let re = regex!(r\"(.)(?P<a>a)?(.)(?P<b>.)\");\n    let cap = re.captures(t!(\"abc\")).unwrap();\n\n    assert_eq!(5, cap.len());\n\n    assert_eq!((0, 3), { let m = cap.get(0).unwrap(); (m.start(), m.end()) });\n    assert_eq!(None, cap.get(2));\n    assert_eq!((2, 3), { let m = cap.get(4).unwrap(); (m.start(), m.end()) });\n\n    assert_eq!(t!(\"abc\"), match_text!(cap.get(0).unwrap()));\n    assert_eq!(None, cap.get(2));\n    assert_eq!(t!(\"c\"), match_text!(cap.get(4).unwrap()));\n\n    assert_eq!(None, cap.name(\"a\"));\n    assert_eq!(t!(\"c\"), match_text!(cap.name(\"b\").unwrap()));\n}", "code_id": "rust-lang-regex/rust-lang-regex-cf1a26a/bench/src/ffi/tcl.rs::len", "code": "pub fn len(&self) -> usize {\n        self.s.len()\n    }", "docstring": null}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/api.rs::sub_capture_matches", "test": "fn sub_capture_matches() {\n    let re = regex!(r\"([a-z])(([a-z])|([0-9]))\");\n    let cap = re.captures(t!(\"a5\")).unwrap();\n    let subs: Vec<_> = cap.iter().collect();\n\n    assert_eq!(5, subs.len());\n    assert!(subs[0].is_some());\n    assert!(subs[1].is_some());\n    assert!(subs[2].is_some());\n    assert!(subs[3].is_none());\n    assert!(subs[4].is_some());\n\n    assert_eq!(t!(\"a5\"), match_text!(subs[0].unwrap()));\n    assert_eq!(t!(\"a\"), match_text!(subs[1].unwrap()));\n    assert_eq!(t!(\"5\"), match_text!(subs[2].unwrap()));\n    assert_eq!(t!(\"5\"), match_text!(subs[4].unwrap()));\n}", "code_id": "rust-lang-regex/rust-lang-regex-cf1a26a/src/re_bytes.rs::len", "code": "pub fn len(&self) -> usize {\n        self.locs.len()\n    }", "docstring": null}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/crazy.rs::dfa_handles_pathological_case", "test": "fn dfa_handles_pathological_case() {\n    fn ones_and_zeroes(count: usize) -> String {\n        use rand::{Rng, thread_rng};\n\n        let mut rng = thread_rng();\n        let mut s = String::new();\n        for _ in 0..count {\n            if rng.gen() {\n                s.push('1');\n            } else {\n                s.push('0');\n            }\n        }\n        s\n    }\n\n    let re = regex!(r\"[01]*1[01]{20}$\");\n    let text = {\n        let mut pieces = ones_and_zeroes(100_000);\n        pieces.push('1');\n        pieces.push_str(&ones_and_zeroes(20));\n        pieces\n    };\n    assert!(re.is_match(text!(&*text)));\n}", "code_id": "rust-lang-regex/rust-lang-regex-cf1a26a/src/re_bytes.rs::is_match", "code": "pub fn is_match(&self, text: &[u8]) -> bool {\n        self.is_match_at(text, 0)\n    }", "docstring": null}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/regression.rs::invalid_regexes_no_crash", "test": "fn invalid_regexes_no_crash() {\n    assert!(regex_new!(\"(*)\").is_err());\n    assert!(regex_new!(\"(?:?)\").is_err());\n    assert!(regex_new!(\"(?)\").is_err());\n    assert!(regex_new!(\"*\").is_err());\n}", "code_id": "rust-lang-regex/rust-lang-regex-cf1a26a/regex-capi/src/error.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        match self.kind {\n            ErrorKind::None => false,\n            ErrorKind::Str(_) | ErrorKind::Regex(_) => true,\n        }\n    }", "docstring": null}
{"test_id": "rust-lang-regex/rust-lang-regex-cf1a26a/tests/test_default.rs::disallow_non_utf8", "test": "fn disallow_non_utf8() {\n    assert!(regex::Regex::new(r\"(?-u)\\xFF\").is_err());\n    assert!(regex::Regex::new(r\"(?-u).\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)[\\xFF]\").is_err());\n    assert!(regex::Regex::new(r\"(?-u)â˜ƒ\").is_err());\n}\n\n", "code_id": "rust-lang-regex/rust-lang-regex-cf1a26a/regex-capi/src/error.rs::is_err", "code": "pub fn is_err(&self) -> bool {\n        match self.kind {\n            ErrorKind::None => false,\n            ErrorKind::Str(_) | ErrorKind::Regex(_) => true,\n        }\n    }", "docstring": null}
