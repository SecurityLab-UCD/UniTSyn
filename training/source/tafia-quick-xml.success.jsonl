{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/issues.rs::issue115", "test": "fn issue115() {\n    let mut r = Reader::from_str(\"<tag1 attr1='line 1\\nline 2'></tag1>\");\n    match r.read_event() {\n        Ok(Event::Start(e)) if e.name() == QName(b\"tag1\") => {\n            let v = e.attributes().map(|a| a.unwrap().value).collect::<Vec<_>>();\n            assert_eq!(v[0].clone().into_owned(), b\"line 1\\nline 2\");\n        }\n        _ => (),\n    }\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/de/mod.rs::into_owned", "code": "fn into_owned(self) -> PayloadEvent<'static> {\n        match self {\n            PayloadEvent::Start(e) => PayloadEvent::Start(e.into_owned()),\n            PayloadEvent::End(e) => PayloadEvent::End(e.into_owned()),\n            PayloadEvent::Text(e) => PayloadEvent::Text(e.into_owned()),\n            PayloadEvent::CData(e) => PayloadEvent::CData(e.into_owned()),\n            PayloadEvent::DocType(e) => PayloadEvent::DocType(e.into_owned()),\n            PayloadEvent::Eof => PayloadEvent::Eof,\n        }\n    }", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/namespaces.rs::attributes_empty_ns", "test": "fn attributes_empty_ns() {\n    let src = \"<a att1='a' r:att2='b' xmlns:r='urn:example:r' />\";\n\n    let mut r = NsReader::from_str(src);\n    r.trim_text(true);\n\n    let e = match r.read_resolved_event() {\n        Ok((Unbound, Empty(e))) => e,\n        e => panic!(\"Expecting Empty event, got {:?}\", e),\n    };\n\n    let mut attrs = e\n        .attributes()\n        .map(|ar| ar.expect(\"Expecting attribute parsing to succeed.\"))\n        // we don't care about xmlns attributes for this test\n        .filter(|kv| kv.key.as_namespace_binding().is_none())\n        .map(|Attribute { key: name, value }| {\n            let (opt_ns, local_name) = r.resolve_attribute(name);\n            (opt_ns, local_name.into_inner(), value)\n        });\n    assert_eq!(\n        attrs.next(),\n        Some((Unbound, &b\"att1\"[..], Cow::Borrowed(&b\"a\"[..])))\n    );\n    assert_eq!(\n        attrs.next(),\n        Some((\n            Bound(Namespace(b\"urn:example:r\")),\n            &b\"att2\"[..],\n            Cow::Borrowed(&b\"b\"[..])\n        ))\n    );\n    assert_eq!(attrs.next(), None);\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/events/attributes.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/namespaces.rs::attributes_empty_ns_expanded", "test": "fn attributes_empty_ns_expanded() {\n    let src = \"<a att1='a' r:att2='b' xmlns:r='urn:example:r' />\";\n\n    let mut r = NsReader::from_str(src);\n    r.trim_text(true).expand_empty_elements(true);\n    {\n        let e = match r.read_resolved_event() {\n            Ok((Unbound, Start(e))) => e,\n            e => panic!(\"Expecting Empty event, got {:?}\", e),\n        };\n\n        let mut attrs = e\n            .attributes()\n            .map(|ar| ar.expect(\"Expecting attribute parsing to succeed.\"))\n            // we don't care about xmlns attributes for this test\n            .filter(|kv| kv.key.as_namespace_binding().is_none())\n            .map(|Attribute { key: name, value }| {\n                let (opt_ns, local_name) = r.resolve_attribute(name);\n                (opt_ns, local_name.into_inner(), value)\n            });\n        assert_eq!(\n            attrs.next(),\n            Some((Unbound, &b\"att1\"[..], Cow::Borrowed(&b\"a\"[..])))\n        );\n        assert_eq!(\n            attrs.next(),\n            Some((\n                Bound(Namespace(b\"urn:example:r\")),\n                &b\"att2\"[..],\n                Cow::Borrowed(&b\"b\"[..])\n            ))\n        );\n        assert_eq!(attrs.next(), None);\n    }\n\n    match r.read_resolved_event() {\n        Ok((Unbound, End(e))) => assert_eq!(e.name(), QName(b\"a\")),\n        e => panic!(\"Expecting End event, got {:?}\", e),\n    }\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/events/attributes.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue343", "test": "fn issue343() {\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct Users {\n        users: HashMap<String, User>,\n    }\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct Max(u16);\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct User {\n        max: Max,\n    }\n\n    let xml = \"<Users>\\\n                        <users>\\\n                            <roger>\\\n                                <max>10</max>\\\n                            </roger>\\\n                        </users>\\\n                    </Users>\";\n    let users: Users = from_str(xml).unwrap();\n\n    assert_eq!(\n        users,\n        Users {\n            users: HashMap::from([(\"roger\".to_string(), User { max: Max(10) })]),\n        }\n    );\n    assert_eq!(to_string(&users).unwrap(), xml);\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/se/mod.rs::to_string", "code": "pub fn to_string<T>(value: &T) -> Result<String, DeError>\nwhere\n    T: ?Sized + Serialize,\n{\n    let mut buffer = String::new();\n    to_writer(&mut buffer, value)?;\n    Ok(buffer)\n}", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue510", "test": "fn issue510() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(rename = \"ENTRY\")]\n    struct Entry {\n        #[serde(rename = \"CUE_V2\")]\n        cues: Option<Vec<Cue>>,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    // #[serde_with::serde_as]\n    struct Cue {\n        #[serde(rename = \"@NAME\")]\n        name: String,\n    }\n\n    let data: Entry = from_str(\n        \"\\\n        <ENTRY>\\\n            <CUE_V2 NAME='foo'></CUE_V2>\\\n            <CUE_V2 NAME='bar'></CUE_V2>\\\n        </ENTRY>\\\n    \",\n    )\n    .unwrap();\n\n    assert_eq!(\n        data,\n        Entry {\n            cues: Some(vec![\n                Cue {\n                    name: \"foo\".to_string(),\n                },\n                Cue {\n                    name: \"bar\".to_string(),\n                },\n            ]),\n        }\n    );\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/se/mod.rs::to_string", "code": "pub fn to_string<T>(value: &T) -> Result<String, DeError>\nwhere\n    T: ?Sized + Serialize,\n{\n    let mut buffer = String::new();\n    to_writer(&mut buffer, value)?;\n    Ok(buffer)\n}", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/serde-issues.rs::issue540", "test": "fn issue540() {\n    #[derive(Serialize)]\n    pub enum Enum {\n        Variant {},\n    }\n\n    #[derive(Serialize)]\n    pub struct Struct {\n        #[serde(flatten)]\n        flatten: Enum,\n    }\n\n    assert_eq!(\n        to_string_with_root(\n            \"root\",\n            &Struct {\n                flatten: Enum::Variant {},\n            }\n        )\n        .unwrap(),\n        \"<root><Variant/></root>\"\n    );\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/se/mod.rs::to_string_with_root", "code": "pub fn to_string_with_root<T>(root_tag: &str, value: &T) -> Result<String, DeError>\nwhere\n    T: ?Sized + Serialize,\n{\n    let mut buffer = String::new();\n    to_writer_with_root(&mut buffer, root_tag, value)?;\n    Ok(buffer)\n}", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/test.rs::test_attributes_empty", "test": "fn test_attributes_empty() {\n    let src = \"<a att1='a' att2='b'/>\";\n    let mut r = Reader::from_str(src);\n    r.trim_text(true);\n    match r.read_event() {\n        Ok(Empty(e)) => {\n            let mut attrs = e.attributes();\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"att1\"),\n                    value: Cow::Borrowed(b\"a\"),\n                }))\n            );\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"att2\"),\n                    value: Cow::Borrowed(b\"b\"),\n                }))\n            );\n            assert_eq!(attrs.next(), None);\n        }\n        e => panic!(\"Expecting Empty event, got {:?}\", e),\n    }\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/events/attributes.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/test.rs::test_attribute_equal", "test": "fn test_attribute_equal() {\n    let src = \"<a att1=\\\"a=b\\\"/>\";\n    let mut r = Reader::from_str(src);\n    r.trim_text(true);\n    match r.read_event() {\n        Ok(Empty(e)) => {\n            let mut attrs = e.attributes();\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"att1\"),\n                    value: Cow::Borrowed(b\"a=b\"),\n                }))\n            );\n            assert_eq!(attrs.next(), None);\n        }\n        e => panic!(\"Expecting Empty event, got {:?}\", e),\n    }\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/events/attributes.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/test.rs::test_comment_starting_with_gt", "test": "fn test_comment_starting_with_gt() {\n    let src = \"<a /><!-->-->\";\n    let mut r = Reader::from_str(src);\n    r.trim_text(true);\n    loop {\n        match r.read_event() {\n            Ok(Comment(e)) => {\n                assert_eq!(e.as_ref(), b\">\");\n                break;\n            }\n            Ok(Eof) => panic!(\"Expecting Comment\"),\n            _ => (),\n        }\n    }\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/name.rs::as_ref", "code": "fn as_ref(&self) -> &[u8] {\n        self.0\n    }", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_offset_err_comment", "test": "fn test_offset_err_comment() {\n    let mut r = Reader::from_str(\"<a><!--b>\");\n    r.trim_text(true);\n\n    next_eq!(r, Start, b\"a\");\n    assert_eq!(r.buffer_position(), 3);\n\n    match r.read_event() {\n        // error at char 4: no closing --> tag found\n        Err(e) => assert_eq!(\n            r.buffer_position(),\n            4,\n            \"expecting buf_pos = 4, found {}, err {:?}\",\n            r.buffer_position(),\n            e\n        ),\n        e => panic!(\"expecting error, found {:?}\", e),\n    }\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/reader/mod.rs::buffer_position", "code": "pub fn buffer_position(&self) -> usize {\n        // when internal state is OpenedTag, we have actually read until '<',\n        // which we don't want to show\n        if let ParseState::OpenedTag = self.state.state {\n            self.state.offset - 1\n        } else {\n            self.state.offset\n        }\n    }", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_offset_err_comment_trim_text", "test": "fn test_offset_err_comment_trim_text() {\n    let mut r = Reader::from_str(\"<a>\\r\\n <!--b>\");\n    r.trim_text(true);\n\n    next_eq!(r, Start, b\"a\");\n    assert_eq!(r.buffer_position(), 3);\n\n    match r.read_event() {\n        // error at char 7: no closing --> tag found\n        Err(e) => assert_eq!(\n            r.buffer_position(),\n            7,\n            \"expecting buf_pos = 7, found {}, err {:?}\",\n            r.buffer_position(),\n            e\n        ),\n        e => panic!(\"expecting error, found {:?}\", e),\n    }\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/reader/mod.rs::buffer_position", "code": "pub fn buffer_position(&self) -> usize {\n        // when internal state is OpenedTag, we have actually read until '<',\n        // which we don't want to show\n        if let ParseState::OpenedTag = self.state.state {\n            self.state.offset - 1\n        } else {\n            self.state.offset\n        }\n    }", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_closing_bracket_in_single_quote_attr", "test": "fn test_closing_bracket_in_single_quote_attr() {\n    let mut r = Reader::from_str(\"<a attr='>' check='2'></a>\");\n    r.trim_text(true);\n    match r.read_event() {\n        Ok(Start(e)) => {\n            let mut attrs = e.attributes();\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"attr\"),\n                    value: Cow::Borrowed(b\">\"),\n                }))\n            );\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"check\"),\n                    value: Cow::Borrowed(b\"2\"),\n                }))\n            );\n            assert_eq!(attrs.next(), None);\n        }\n        x => panic!(\"expected <a attr='>'>, got {:?}\", x),\n    }\n    next_eq!(r, End, b\"a\");\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/events/attributes.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_closing_bracket_in_double_quote_attr", "test": "fn test_closing_bracket_in_double_quote_attr() {\n    let mut r = Reader::from_str(r#\"<a attr=\">\" check=\"2\"></a>\"#);\n    r.trim_text(true);\n    match r.read_event() {\n        Ok(Start(e)) => {\n            let mut attrs = e.attributes();\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"attr\"),\n                    value: Cow::Borrowed(b\">\"),\n                }))\n            );\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"check\"),\n                    value: Cow::Borrowed(b\"2\"),\n                }))\n            );\n            assert_eq!(attrs.next(), None);\n        }\n        x => panic!(\"expected <a attr='>'>, got {:?}\", x),\n    }\n    next_eq!(r, End, b\"a\");\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/events/attributes.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_closing_bracket_in_double_quote_mixed", "test": "fn test_closing_bracket_in_double_quote_mixed() {\n    let mut r = Reader::from_str(r#\"<a attr=\"'>'\" check=\"'2'\"></a>\"#);\n    r.trim_text(true);\n    match r.read_event() {\n        Ok(Start(e)) => {\n            let mut attrs = e.attributes();\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"attr\"),\n                    value: Cow::Borrowed(b\"'>'\"),\n                }))\n            );\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"check\"),\n                    value: Cow::Borrowed(b\"'2'\"),\n                }))\n            );\n            assert_eq!(attrs.next(), None);\n        }\n        x => panic!(\"expected <a attr='>'>, got {:?}\", x),\n    }\n    next_eq!(r, End, b\"a\");\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/events/attributes.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "docstring": null}
{"test_id": "tafia-quick-xml/tafia-quick-xml-120e074/tests/unit_tests.rs::test_closing_bracket_in_single_quote_mixed", "test": "fn test_closing_bracket_in_single_quote_mixed() {\n    let mut r = Reader::from_str(r#\"<a attr='\">\"' check='\"2\"'></a>\"#);\n    r.trim_text(true);\n    match r.read_event() {\n        Ok(Start(e)) => {\n            let mut attrs = e.attributes();\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"attr\"),\n                    value: Cow::Borrowed(br#\"\">\"\"#),\n                }))\n            );\n            assert_eq!(\n                attrs.next(),\n                Some(Ok(Attribute {\n                    key: QName(b\"check\"),\n                    value: Cow::Borrowed(br#\"\"2\"\"#),\n                }))\n            );\n            assert_eq!(attrs.next(), None);\n        }\n        x => panic!(\"expected <a attr='>'>, got {:?}\", x),\n    }\n    next_eq!(r, End, b\"a\");\n}", "code_id": "tafia-quick-xml/tafia-quick-xml-120e074/src/events/attributes.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }", "docstring": null}
