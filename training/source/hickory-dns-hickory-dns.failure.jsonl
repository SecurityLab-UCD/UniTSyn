{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_test_rsa_dnssec.rs::test_dnssec_restart_with_update_journal", "test": "fn test_dnssec_restart_with_update_journal() {\n    // TODO: make journal path configurable, it should be in target/tests/...\n    let server_path = env::var(\"TDNS_WORKSPACE_ROOT\").unwrap_or_else(|_| \"..\".to_owned());\n    let server_path = Path::new(&server_path);\n    let journal = server_path.join(\"tests/test-data/test_configs/example.com_dnssec_update.jrnl\");\n    std::fs::remove_file(&journal).ok();\n\n    generic_test(\n        \"dnssec_with_update.toml\",\n        \"tests/test-data/test_configs/dnssec/rsa_2048.pem\",\n        KeyFormat::Pem,\n        Algorithm::RSASHA256,\n    );\n\n    // after running the above test, the journal file should exist\n    assert!(journal.exists());\n\n    // and all dnssec tests should still pass\n    generic_test(\n        \"dnssec_with_update.toml\",\n        \"tests/test-data/test_configs/dnssec/rsa_2048.pem\",\n        KeyFormat::Pem,\n        Algorithm::RSASHA256,\n    );\n\n    // and journal should still exist\n    assert!(journal.exists());\n\n    // cleanup...\n    // TODO: fix journal path so that it doesn't leave the dir dirty... this might make windows an option after that\n    std::fs::remove_file(&journal).expect(\"failed to cleanup after test\");\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_test_rsa_dnssec.rs::test_dnssec_restart_with_update_journal_dep", "test": "fn test_dnssec_restart_with_update_journal_dep() {\n    // TODO: make journal path configurable, it should be in target/tests/...\n    let server_path = env::var(\"TDNS_WORKSPACE_ROOT\").unwrap_or_else(|_| \"..\".to_owned());\n    let server_path = Path::new(&server_path);\n    let journal = server_path.join(\"tests/test-data/test_configs/example.com.jrnl\");\n    std::fs::remove_file(&journal).ok();\n\n    generic_test(\n        \"dnssec_with_update_deprecated.toml\",\n        \"tests/test-data/test_configs/dnssec/rsa_2048.pem\",\n        KeyFormat::Pem,\n        Algorithm::RSASHA256,\n    );\n\n    // after running the above test, the journal file should exist\n    assert!(journal.exists());\n\n    // and all dnssec tests should still pass\n    generic_test(\n        \"dnssec_with_update_deprecated.toml\",\n        \"tests/test-data/test_configs/dnssec/rsa_2048.pem\",\n        KeyFormat::Pem,\n        Algorithm::RSASHA256,\n    );\n\n    // and journal should still exist\n    assert!(journal.exists());\n\n    // cleanup...\n    // TODO: fix journal path so that it doesn't leave the dir dirty... this might make windows an option after that\n    std::fs::remove_file(&journal).expect(\"failed to cleanup after test\");\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_tests.rs::test_ipv4_only_toml_startup", "test": "fn test_ipv4_only_toml_startup() {\n    named_test_harness(\"ipv4_only.toml\", |_, tcp_port, _, _, _| {\n        let mut io_loop = Runtime::new().unwrap();\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv4Addr::new(127, 0, 0, 1).into(),\n            tcp_port.expect(\"no tcp_port\"),\n        );\n        let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::new(addr);\n        let client = AsyncClient::new(Box::new(stream), sender, None);\n\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        // ipv4 should succeed\n        query_a(&mut io_loop, &mut client);\n\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).into(),\n            tcp_port.expect(\"no tcp_port\"),\n        );\n        let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::new(addr);\n        let client = AsyncClient::new(Box::new(stream), sender, None);\n\n        assert!(io_loop.block_on(client).is_err());\n        //let (client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        //hickory_proto::spawn_bg(&io_loop, bg);\n\n        // ipv6 should fail\n        // FIXME: probably need to send something for proper test... maybe use JoinHandle in tokio 0.2\n        // assert!(io_loop.block_on(client).is_err());\n    })\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/forwarder.rs::test_lookup", "test": "fn test_lookup() {\n    let runtime = Runtime::new().expect(\"failed to create Tokio Runtime\");\n    let forwarder = ForwardAuthority::new(TokioConnectionProvider::default())\n        .expect(\"failed to create forwarder\");\n\n    let lookup = runtime\n        .block_on(forwarder.lookup(\n            &Name::from_str(\"www.example.com.\").unwrap().into(),\n            RecordType::A,\n            Default::default(),\n        ))\n        .unwrap();\n\n    let address = lookup.iter().next().expect(\"no addresses returned!\");\n    let address = address\n        .data()\n        .and_then(RData::as_a)\n        .expect(\"not an A record\");\n    assert_eq!(*address, Ipv4Addr::new(93, 184, 216, 34).into());\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/sqlite_tests.rs::test_iterator", "test": "fn test_iterator() {\n    let (mut record, journal) = create_test_journal();\n\n    let mut iter = journal.iter();\n\n    assert_eq!(\n        record.set_data(Some(RData::A(A::from_str(\"127.0.0.1\").unwrap()))),\n        &iter.next().unwrap()\n    );\n    assert_eq!(\n        record.set_data(Some(RData::A(A::from_str(\"127.0.1.1\").unwrap()))),\n        &iter.next().unwrap()\n    );\n    assert_eq!(None, iter.next());\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/store_file_tests.rs::test_all_lines_are_loaded", "test": "fn test_all_lines_are_loaded() {\n    let config = FileConfig {\n        zone_file_path: \"../../tests/test-data/test_configs/default/nonewline.zone\".to_string(),\n    };\n\n    let mut authority = FileAuthority::try_from_config(\n        Name::from_str(\"example.com.\").unwrap(),\n        ZoneType::Primary,\n        false,\n        None,\n        &config,\n    )\n    .expect(\"failed to load\");\n    let rrkey = RrKey {\n        record_type: RecordType::A,\n        name: LowerName::from(Name::from_ascii(\"ensure.nonewline.\").unwrap()),\n    };\n    assert!(authority.records_get_mut().get(&rrkey).is_some())\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/store_file_tests.rs::test_implicit_in_class", "test": "fn test_implicit_in_class() {\n    let config = FileConfig {\n        zone_file_path: \"../../tests/test-data/test_configs/default/implicitclass.zone\".to_string(),\n    };\n\n    let authority = FileAuthority::try_from_config(\n        Name::from_str(\"example.com.\").unwrap(),\n        ZoneType::Primary,\n        false,\n        None,\n        &config,\n    );\n    assert!(authority.is_ok());\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/timeout_stream_tests.rs::test_no_timeout", "test": "fn test_no_timeout() {\n    #[allow(deprecated)]\n    let sequence =\n        iter(vec![Ok(1), Err(\"error\"), Ok(2)]).map_err(|e| io::Error::new(io::ErrorKind::Other, e));\n    let core = Runtime::new().expect(\"could not get core\");\n\n    let timeout_stream = TimeoutStream::new(sequence, Duration::from_secs(360));\n\n    let (val, timeout_stream) = core.block_on(timeout_stream.into_future());\n    assert_eq!(val.expect(\"nothing in stream\").ok(), Some(1));\n\n    let (error, timeout_stream) = core.block_on(timeout_stream.into_future());\n    assert!(error.expect(\"nothing in stream\").is_err());\n\n    let (val, timeout_stream) = core.block_on(timeout_stream.into_future());\n    assert_eq!(val.expect(\"nothing in stream\").ok(), Some(2));\n\n    let (val, _) = core.block_on(timeout_stream.into_future());\n    assert!(val.is_none())\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/timeout_stream_tests.rs::test_timeout", "test": "fn test_timeout() {\n    let core = Runtime::new().expect(\"could not get core\");\n    let timeout_stream = TimeoutStream::new(NeverStream {}, Duration::from_millis(1));\n\n    assert!(core\n        .block_on(timeout_stream.into_future())\n        .0\n        .expect(\"nothing in stream\")\n        .is_err());\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_notify", "test": "fn test_notify() {\n    let io_loop = Runtime::new().unwrap();\n    let authority = create_example();\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let client = AsyncClient::new(stream, sender, None);\n    let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    let name = Name::from_str(\"ping.example.com\").unwrap();\n\n    let message =\n        io_loop.block_on(client.notify(name, DNSClass::IN, RecordType::A, None::<RecordSet>));\n    assert!(message.is_ok());\n    let message = message.unwrap();\n    assert_eq!(\n        message.response_code(),\n        ResponseCode::NotImp,\n        \"the catalog must support Notify now, update this\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_timeout_query_tcp", "test": "fn test_timeout_query_tcp() {\n    //env_logger::try_init().ok();\n    let io_loop = Runtime::new().unwrap();\n\n    // this is a test network, it should NOT be in use\n    let addr: SocketAddr = (\"203.0.113.0\", 53)\n        .to_socket_addrs()\n        .unwrap()\n        .next()\n        .unwrap();\n\n    let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::with_timeout(\n        addr,\n        std::time::Duration::from_millis(1),\n    );\n    let client = AsyncClient::with_timeout(\n        Box::new(stream),\n        sender,\n        std::time::Duration::from_millis(1),\n        None,\n    );\n\n    assert!(io_loop.block_on(client).is_err());\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_max_chained_lookup_depth", "test": "fn test_max_chained_lookup_depth() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let cname_record1 = cname_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Name::from_str(\"cname2.example.com.\").unwrap(),\n    );\n    let cname_record2 = cname_record(\n        Name::from_str(\"cname2.example.com.\").unwrap(),\n        Name::from_str(\"cname3.example.com.\").unwrap(),\n    );\n    let cname_record3 = cname_record(\n        Name::from_str(\"cname3.example.com.\").unwrap(),\n        Name::from_str(\"cname4.example.com.\").unwrap(),\n    );\n    let cname_record4 = cname_record(\n        Name::from_str(\"cname4.example.com.\").unwrap(),\n        Name::from_str(\"cname5.example.com.\").unwrap(),\n    );\n    let cname_record5 = cname_record(\n        Name::from_str(\"cname5.example.com.\").unwrap(),\n        Name::from_str(\"cname6.example.com.\").unwrap(),\n    );\n    let cname_record6 = cname_record(\n        Name::from_str(\"cname6.example.com.\").unwrap(),\n        Name::from_str(\"cname7.example.com.\").unwrap(),\n    );\n    let cname_record7 = cname_record(\n        Name::from_str(\"cname7.example.com.\").unwrap(),\n        Name::from_str(\"cname8.example.com.\").unwrap(),\n    );\n    let cname_record8 = cname_record(\n        Name::from_str(\"cname8.example.com.\").unwrap(),\n        Name::from_str(\"cname9.example.com.\").unwrap(),\n    );\n    let cname_record9 = cname_record(\n        Name::from_str(\"cname9.example.com.\").unwrap(),\n        Name::from_str(\"v4.example.com.\").unwrap(),\n    );\n    let v4_record = v4_record(\n        Name::from_str(\"v4.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n\n    // The first response should be a cname, the second will be the actual record\n    let message1 = message(resp_query.clone(), vec![cname_record1], vec![], vec![]);\n    let message2 = message(resp_query.clone(), vec![cname_record2], vec![], vec![]);\n    let message3 = message(resp_query.clone(), vec![cname_record3], vec![], vec![]);\n    let message4 = message(resp_query.clone(), vec![cname_record4], vec![], vec![]);\n    let message5 = message(resp_query.clone(), vec![cname_record5], vec![], vec![]);\n    let message6 = message(resp_query.clone(), vec![cname_record6], vec![], vec![]);\n    let message7 = message(resp_query.clone(), vec![cname_record7], vec![], vec![]);\n    let message8 = message(resp_query.clone(), vec![cname_record8], vec![], vec![]);\n    let message9 = message(resp_query.clone(), vec![cname_record9], vec![], vec![]);\n    let message10 = message(resp_query, vec![v4_record], vec![], vec![]);\n\n    // the mock pops messages...\n    let client: MockClientHandle<_, ResolveError> = MockClientHandle::mock(vec![\n        Ok(DnsResponse::from_message(message10).unwrap()),\n        Ok(DnsResponse::from_message(message9).unwrap()),\n        Ok(DnsResponse::from_message(message8).unwrap()),\n        Ok(DnsResponse::from_message(message7).unwrap()),\n        Ok(DnsResponse::from_message(message6).unwrap()),\n        Ok(DnsResponse::from_message(message5).unwrap()),\n        Ok(DnsResponse::from_message(message4).unwrap()),\n        Ok(DnsResponse::from_message(message3).unwrap()),\n        Ok(DnsResponse::from_message(message2).unwrap()),\n        Ok(DnsResponse::from_message(message1).unwrap()),\n    ]);\n\n    let client = CachingClient::new(0, client, false);\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        client.clone(),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n\n    println!(\"performing max cname validation\");\n    assert!(io_loop.block_on(lookup).is_err());\n\n    // This query should succeed, as the queue depth should reset to 0 on a failed request\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"cname9.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        client,\n    );\n\n    println!(\"performing followup resolve, should work\");\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        *lookup.iter().next().unwrap(),\n        RData::A(A::new(93, 184, 216, 34))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/retry_dns_handle_tests.rs::dont_retry_on_negative_response", "test": "fn dont_retry_on_negative_response() {\n    let mut response = Message::new();\n    response\n        .set_message_type(MessageType::Response)\n        .set_op_code(OpCode::Update)\n        .set_response_code(ResponseCode::NoError);\n    let error = ResolveError::from_response(DnsResponse::from_message(response).unwrap(), false)\n        .expect_err(\"NODATA should be an error\");\n    let client = RetryDnsHandle::new(\n        TestClient {\n            retries: 1,\n            error_response: error,\n            attempts: Arc::new(AtomicU16::new(0)),\n        },\n        2,\n    );\n    let test1 = Message::new();\n    assert!(block_on(client.send(test1).first_answer()).is_err());\n}", "error": "Not Definition Found"}
