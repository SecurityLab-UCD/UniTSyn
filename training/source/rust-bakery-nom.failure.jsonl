{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/float.rs::unsigned_float_test", "test": "fn unsigned_float_test() {\n  assert_eq!(unsigned_float(&b\"123.456;\"[..]), Ok((&b\";\"[..], 123.456)));\n  assert_eq!(unsigned_float(&b\"0.123;\"[..]), Ok((&b\";\"[..], 0.123)));\n  assert_eq!(unsigned_float(&b\"123.0;\"[..]), Ok((&b\";\"[..], 123.0)));\n  assert_eq!(unsigned_float(&b\"123.;\"[..]), Ok((&b\";\"[..], 123.0)));\n  assert_eq!(unsigned_float(&b\".123;\"[..]), Ok((&b\";\"[..], 0.123)));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/float.rs::float_test", "test": "fn float_test() {\n  assert_eq!(float(&b\"123.456;\"[..]), Ok((&b\";\"[..], 123.456)));\n  assert_eq!(float(&b\"+123.456;\"[..]), Ok((&b\";\"[..], 123.456)));\n  assert_eq!(float(&b\"-123.456;\"[..]), Ok((&b\";\"[..], -123.456)));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini.rs::parse_category_test", "test": "fn parse_category_test() {\n  let ini_file = &b\"[category]\n\nparameter=value\nkey = value2\"[..];\n\n  let ini_without_category = &b\"\\n\\nparameter=value\nkey = value2\"[..];\n\n  let res = category(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, o)) => println!(\"i: {:?} | o: {:?}\", str::from_utf8(i), o),\n    _ => println!(\"error\"),\n  }\n\n  assert_eq!(res, Ok((ini_without_category, \"category\")));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini.rs::parse_key_value_test", "test": "fn parse_key_value_test() {\n  let ini_file = &b\"parameter=value\nkey = value2\"[..];\n\n  let ini_without_key_value = &b\"\\nkey = value2\"[..];\n\n  let res = key_value(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, (o1, o2))) => println!(\"i: {:?} | o: ({:?},{:?})\", str::from_utf8(i), o1, o2),\n    _ => println!(\"error\"),\n  }\n\n  assert_eq!(res, Ok((ini_without_key_value, (\"parameter\", \"value\"))));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini.rs::parse_key_value_with_space_test", "test": "fn parse_key_value_with_space_test() {\n  let ini_file = &b\"parameter = value\nkey = value2\"[..];\n\n  let ini_without_key_value = &b\"\\nkey = value2\"[..];\n\n  let res = key_value(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, (o1, o2))) => println!(\"i: {:?} | o: ({:?},{:?})\", str::from_utf8(i), o1, o2),\n    _ => println!(\"error\"),\n  }\n\n  assert_eq!(res, Ok((ini_without_key_value, (\"parameter\", \"value\"))));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini.rs::parse_key_value_with_comment_test", "test": "fn parse_key_value_with_comment_test() {\n  let ini_file = &b\"parameter=value;abc\nkey = value2\"[..];\n\n  let ini_without_key_value = &b\"\\nkey = value2\"[..];\n\n  let res = key_value(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, (o1, o2))) => println!(\"i: {:?} | o: ({:?},{:?})\", str::from_utf8(i), o1, o2),\n    _ => println!(\"error\"),\n  }\n\n  assert_eq!(res, Ok((ini_without_key_value, (\"parameter\", \"value\"))));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini.rs::parse_multiple_keys_and_values_test", "test": "fn parse_multiple_keys_and_values_test() {\n  let ini_file = &b\"parameter=value;abc\n\nkey = value2\n\n[category]\"[..];\n\n  let ini_without_key_value = &b\"[category]\"[..];\n\n  let res = keys_and_values(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, ref o)) => println!(\"i: {:?} | o: {:?}\", str::from_utf8(i), o),\n    _ => println!(\"error\"),\n  }\n\n  let mut expected: HashMap<&str, &str> = HashMap::new();\n  expected.insert(\"parameter\", \"value\");\n  expected.insert(\"key\", \"value2\");\n  assert_eq!(res, Ok((ini_without_key_value, expected)));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini.rs::parse_category_then_multiple_keys_and_values_test", "test": "fn parse_category_then_multiple_keys_and_values_test() {\n  //FIXME: there can be an empty line or a comment line after a category\n  let ini_file = &b\"[abcd]\nparameter=value;abc\n\nkey = value2\n\n[category]\"[..];\n\n  let ini_after_parser = &b\"[category]\"[..];\n\n  let res = category_and_keys(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, ref o)) => println!(\"i: {:?} | o: {:?}\", str::from_utf8(i), o),\n    _ => println!(\"error\"),\n  }\n\n  let mut expected_h: HashMap<&str, &str> = HashMap::new();\n  expected_h.insert(\"parameter\", \"value\");\n  expected_h.insert(\"key\", \"value2\");\n  assert_eq!(res, Ok((ini_after_parser, (\"abcd\", expected_h))));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini.rs::parse_multiple_categories_test", "test": "fn parse_multiple_categories_test() {\n  let ini_file = &b\"[abcd]\n\nparameter=value;abc\n\nkey = value2\n\n[category]\nparameter3=value3\nkey4 = value4\n\"[..];\n\n  let ini_after_parser = &b\"\"[..];\n\n  let res = categories(ini_file);\n  //println!(\"{:?}\", res);\n  match res {\n    Ok((i, ref o)) => println!(\"i: {:?} | o: {:?}\", str::from_utf8(i), o),\n    _ => println!(\"error\"),\n  }\n\n  let mut expected_1: HashMap<&str, &str> = HashMap::new();\n  expected_1.insert(\"parameter\", \"value\");\n  expected_1.insert(\"key\", \"value2\");\n  let mut expected_2: HashMap<&str, &str> = HashMap::new();\n  expected_2.insert(\"parameter3\", \"value3\");\n  expected_2.insert(\"key4\", \"value4\");\n  let mut expected_h: HashMap<&str, HashMap<&str, &str>> = HashMap::new();\n  expected_h.insert(\"abcd\", expected_1);\n  expected_h.insert(\"category\", expected_2);\n  assert_eq!(res, Ok((ini_after_parser, expected_h)));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini_str.rs::parse_category_test", "test": "fn parse_category_test() {\n  let ini_file = \"[category]\n\nparameter=value\nkey = value2\";\n\n  let ini_without_category = \"parameter=value\nkey = value2\";\n\n  let res = category(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, o)) => println!(\"i: {} | o: {:?}\", i, o),\n    _ => println!(\"error\"),\n  }\n\n  assert_eq!(res, Ok((ini_without_category, \"category\")));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini_str.rs::parse_key_value_test", "test": "fn parse_key_value_test() {\n  let ini_file = \"parameter=value\nkey = value2\";\n\n  let ini_without_key_value = \"key = value2\";\n\n  let res = key_value(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, (o1, o2))) => println!(\"i: {} | o: ({:?},{:?})\", i, o1, o2),\n    _ => println!(\"error\"),\n  }\n\n  assert_eq!(res, Ok((ini_without_key_value, (\"parameter\", \"value\"))));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini_str.rs::parse_key_value_with_space_test", "test": "fn parse_key_value_with_space_test() {\n  let ini_file = \"parameter = value\nkey = value2\";\n\n  let ini_without_key_value = \"key = value2\";\n\n  let res = key_value(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, (o1, o2))) => println!(\"i: {} | o: ({:?},{:?})\", i, o1, o2),\n    _ => println!(\"error\"),\n  }\n\n  assert_eq!(res, Ok((ini_without_key_value, (\"parameter\", \"value\"))));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini_str.rs::parse_key_value_with_comment_test", "test": "fn parse_key_value_with_comment_test() {\n  let ini_file = \"parameter=value;abc\nkey = value2\";\n\n  let ini_without_key_value = \"key = value2\";\n\n  let res = key_value(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, (o1, o2))) => println!(\"i: {} | o: ({:?},{:?})\", i, o1, o2),\n    _ => println!(\"error\"),\n  }\n\n  assert_eq!(res, Ok((ini_without_key_value, (\"parameter\", \"value\"))));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini_str.rs::parse_multiple_keys_and_values_test", "test": "fn parse_multiple_keys_and_values_test() {\n  let ini_file = \"parameter=value;abc\n\nkey = value2\n\n[category]\";\n\n  let ini_without_key_value = \"[category]\";\n\n  let res = keys_and_values(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, ref o)) => println!(\"i: {} | o: {:?}\", i, o),\n    _ => println!(\"error\"),\n  }\n\n  let mut expected: HashMap<&str, &str> = HashMap::new();\n  expected.insert(\"parameter\", \"value\");\n  expected.insert(\"key\", \"value2\");\n  assert_eq!(res, Ok((ini_without_key_value, expected)));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini_str.rs::parse_category_then_multiple_keys_and_values_test", "test": "fn parse_category_then_multiple_keys_and_values_test() {\n  //FIXME: there can be an empty line or a comment line after a category\n  let ini_file = \"[abcd]\nparameter=value;abc\n\nkey = value2\n\n[category]\";\n\n  let ini_after_parser = \"[category]\";\n\n  let res = category_and_keys(ini_file);\n  println!(\"{:?}\", res);\n  match res {\n    Ok((i, ref o)) => println!(\"i: {} | o: {:?}\", i, o),\n    _ => println!(\"error\"),\n  }\n\n  let mut expected_h: HashMap<&str, &str> = HashMap::new();\n  expected_h.insert(\"parameter\", \"value\");\n  expected_h.insert(\"key\", \"value2\");\n  assert_eq!(res, Ok((ini_after_parser, (\"abcd\", expected_h))));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/ini_str.rs::parse_multiple_categories_test", "test": "fn parse_multiple_categories_test() {\n  let ini_file = \"[abcd]\n\nparameter=value;abc\n\nkey = value2\n\n[category]\nparameter3=value3\nkey4 = value4\n\";\n\n  let res = categories(ini_file);\n  //println!(\"{:?}\", res);\n  match res {\n    Ok((i, ref o)) => println!(\"i: {} | o: {:?}\", i, o),\n    _ => println!(\"error\"),\n  }\n\n  let mut expected_1: HashMap<&str, &str> = HashMap::new();\n  expected_1.insert(\"parameter\", \"value\");\n  expected_1.insert(\"key\", \"value2\");\n  let mut expected_2: HashMap<&str, &str> = HashMap::new();\n  expected_2.insert(\"parameter3\", \"value3\");\n  expected_2.insert(\"key4\", \"value4\");\n  let mut expected_h: HashMap<&str, HashMap<&str, &str>> = HashMap::new();\n  expected_h.insert(\"abcd\", expected_1);\n  expected_h.insert(\"category\", expected_2);\n  assert_eq!(res, Ok((\"\", expected_h)));\n}", "error": "Not Definition Found"}
{"test_id": "rust-bakery-nom/rust-bakery-nom-869f897/tests/overflow.rs::overflow_incomplete_tuple", "test": "fn overflow_incomplete_tuple() {\n  assert_eq!(\n    parser02(&b\"3\"[..]),\n    Err(Err::Incomplete(Needed::new(18446744073709551615)))\n  );\n}", "error": "Not Definition Found"}
