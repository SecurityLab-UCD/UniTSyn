{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_literal_string", "test": "fn parse_literal_string() {\n    let sql = r#\"SELECT 'single', \"double\"\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Value(Value::SingleQuotedString(\"single\".to_string())),\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Value(Value::DoubleQuotedString(\"double\".to_string())),\n        expr_from_projection(&select.projection[1])\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_byte_literal", "test": "fn parse_byte_literal() {\n    let sql = r#\"SELECT B'abc', B\"abc\"\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Value(Value::SingleQuotedByteStringLiteral(\"abc\".to_string())),\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Value(Value::DoubleQuotedByteStringLiteral(\"abc\".to_string())),\n        expr_from_projection(&select.projection[1])\n    );\n\n    let sql = r#\"SELECT b'abc', b\"abc\"\"#;\n    bigquery().one_statement_parses_to(sql, r#\"SELECT B'abc', B\"abc\"\"#);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_raw_literal", "test": "fn parse_raw_literal() {\n    let sql = r#\"SELECT R'abc', R\"abc\", R'f\\(abc,(.*),def\\)', R\"f\\(abc,(.*),def\\)\"\"#;\n    let stmt = bigquery().one_statement_parses_to(\n        sql,\n        r\"SELECT R'abc', R'abc', R'f\\(abc,(.*),def\\)', R'f\\(abc,(.*),def\\)'\",\n    );\n    if let Statement::Query(query) = stmt {\n        if let SetExpr::Select(select) = *query.body {\n            assert_eq!(4, select.projection.len());\n            assert_eq!(\n                &Expr::Value(Value::RawStringLiteral(\"abc\".to_string())),\n                expr_from_projection(&select.projection[0])\n            );\n            assert_eq!(\n                &Expr::Value(Value::RawStringLiteral(\"abc\".to_string())),\n                expr_from_projection(&select.projection[1])\n            );\n            assert_eq!(\n                &Expr::Value(Value::RawStringLiteral(r\"f\\(abc,(.*),def\\)\".to_string())),\n                expr_from_projection(&select.projection[2])\n            );\n            assert_eq!(\n                &Expr::Value(Value::RawStringLiteral(r\"f\\(abc,(.*),def\\)\".to_string())),\n                expr_from_projection(&select.projection[3])\n            );\n            return;\n        }\n    }\n    panic!(\"invalid query\")\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_nested_data_types", "test": "fn parse_nested_data_types() {\n    let sql = \"CREATE TABLE table (x STRUCT<a ARRAY<INT64>, b BYTES(42)>, y ARRAY<STRUCT<INT64>>)\";\n    match bigquery().one_statement_parses_to(sql, sql) {\n        Statement::CreateTable { name, columns, .. } => {\n            assert_eq!(name, ObjectName(vec![\"table\".into()]));\n            assert_eq!(\n                columns,\n                vec![\n                    ColumnDef {\n                        name: Ident::new(\"x\"),\n                        data_type: DataType::Struct(vec![\n                            StructField {\n                                field_name: Some(\"a\".into()),\n                                field_type: DataType::Array(ArrayElemTypeDef::AngleBracket(\n                                    Box::new(DataType::Int64,)\n                                ))\n                            },\n                            StructField {\n                                field_name: Some(\"b\".into()),\n                                field_type: DataType::Bytes(Some(42))\n                            },\n                        ]),\n                        collation: None,\n                        options: vec![],\n                    },\n                    ColumnDef {\n                        name: Ident::new(\"y\"),\n                        data_type: DataType::Array(ArrayElemTypeDef::AngleBracket(Box::new(\n                            DataType::Struct(vec![StructField {\n                                field_name: None,\n                                field_type: DataType::Int64,\n                            }]),\n                        ))),\n                        collation: None,\n                        options: vec![],\n                    },\n                ]\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_tuple_struct_literal", "test": "fn parse_tuple_struct_literal() {\n    // tuple syntax: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#tuple_syntax\n    // syntax: (expr1, expr2 [, ... ])\n    let sql = \"SELECT (1, 2, 3), (1, 1.0, '123', true)\";\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Tuple(vec![\n            Expr::Value(number(\"1\")),\n            Expr::Value(number(\"2\")),\n            Expr::Value(number(\"3\")),\n        ]),\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Tuple(vec![\n            Expr::Value(number(\"1\")),\n            Expr::Value(number(\"1.0\")),\n            Expr::Value(Value::SingleQuotedString(\"123\".to_string())),\n            Expr::Value(Value::Boolean(true))\n        ]),\n        expr_from_projection(&select.projection[1])\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_typeless_struct_syntax", "test": "fn parse_typeless_struct_syntax() {\n    // typeless struct syntax https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#typeless_struct_syntax\n    // syntax: STRUCT( expr1 [AS field_name] [, ... ])\n    let sql = \"SELECT STRUCT(1, 2, 3), STRUCT('abc'), STRUCT(1, t.str_col), STRUCT(1 AS a, 'abc' AS b), STRUCT(str_col AS abc)\";\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(5, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![\n                Expr::Value(number(\"1\")),\n                Expr::Value(number(\"2\")),\n                Expr::Value(number(\"3\")),\n            ],\n            fields: Default::default()\n        },\n        expr_from_projection(&select.projection[0])\n    );\n\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::SingleQuotedString(\"abc\".to_string())),],\n            fields: Default::default()\n        },\n        expr_from_projection(&select.projection[1])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![\n                Expr::Value(number(\"1\")),\n                Expr::CompoundIdentifier(vec![Ident::from(\"t\"), Ident::from(\"str_col\")]),\n            ],\n            fields: Default::default()\n        },\n        expr_from_projection(&select.projection[2])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![\n                Expr::Named {\n                    expr: Expr::Value(number(\"1\")).into(),\n                    name: Ident::from(\"a\")\n                },\n                Expr::Named {\n                    expr: Expr::Value(Value::SingleQuotedString(\"abc\".to_string())).into(),\n                    name: Ident::from(\"b\")\n                },\n            ],\n            fields: Default::default()\n        },\n        expr_from_projection(&select.projection[3])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Named {\n                expr: Expr::Identifier(Ident::from(\"str_col\")).into(),\n                name: Ident::from(\"abc\")\n            }],\n            fields: Default::default()\n        },\n        expr_from_projection(&select.projection[4])\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_typed_struct_syntax", "test": "fn parse_typed_struct_syntax() {\n    // typed struct syntax https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#typed_struct_syntax\n    // syntax: STRUCT<[field_name] field_type, ...>( expr1 [, ... ])\n\n    let sql = r#\"SELECT STRUCT<INT64>(5), STRUCT<x INT64, y STRING>(1, t.str_col), STRUCT<arr ARRAY<FLOAT64>, str STRUCT<BOOL>>(nested_col)\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(3, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"5\")),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Int64,\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![\n                Expr::Value(number(\"1\")),\n                Expr::CompoundIdentifier(vec![\n                    Ident {\n                        value: \"t\".into(),\n                        quote_style: None,\n                    },\n                    Ident {\n                        value: \"str_col\".into(),\n                        quote_style: None,\n                    },\n                ]),\n            ],\n            fields: vec![\n                StructField {\n                    field_name: Some(Ident {\n                        value: \"x\".into(),\n                        quote_style: None,\n                    }),\n                    field_type: DataType::Int64\n                },\n                StructField {\n                    field_name: Some(Ident {\n                        value: \"y\".into(),\n                        quote_style: None,\n                    }),\n                    field_type: DataType::String(None)\n                },\n            ]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Identifier(Ident {\n                value: \"nested_col\".into(),\n                quote_style: None,\n            }),],\n            fields: vec![\n                StructField {\n                    field_name: Some(\"arr\".into()),\n                    field_type: DataType::Array(ArrayElemTypeDef::AngleBracket(Box::new(\n                        DataType::Float64\n                    )))\n                },\n                StructField {\n                    field_name: Some(\"str\".into()),\n                    field_type: DataType::Struct(vec![StructField {\n                        field_name: None,\n                        field_type: DataType::Bool\n                    }])\n                },\n            ]\n        },\n        expr_from_projection(&select.projection[2])\n    );\n\n    let sql = r#\"SELECT STRUCT<x STRUCT, y ARRAY<STRUCT>>(nested_col)\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(1, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Identifier(Ident {\n                value: \"nested_col\".into(),\n                quote_style: None,\n            }),],\n            fields: vec![\n                StructField {\n                    field_name: Some(\"x\".into()),\n                    field_type: DataType::Struct(Default::default())\n                },\n                StructField {\n                    field_name: Some(\"y\".into()),\n                    field_type: DataType::Array(ArrayElemTypeDef::AngleBracket(Box::new(\n                        DataType::Struct(Default::default())\n                    )))\n                },\n            ]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n\n    let sql = r#\"SELECT STRUCT<BOOL>(true), STRUCT<BYTES(42)>(B'abc')\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::Boolean(true)),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Bool\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::SingleQuotedByteStringLiteral(\n                \"abc\".into()\n            )),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Bytes(Some(42))\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n\n    let sql = r#\"SELECT STRUCT<DATE>(\"2011-05-05\"), STRUCT<DATETIME>(DATETIME '1999-01-01 01:23:34.45'), STRUCT<FLOAT64>(5.0), STRUCT<INT64>(1)\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(4, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::DoubleQuotedString(\n                \"2011-05-05\".to_string()\n            )),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Date\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::Datetime(None),\n                value: \"1999-01-01 01:23:34.45\".to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Datetime(None)\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"5.0\")),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Float64\n            }]\n        },\n        expr_from_projection(&select.projection[2])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"1\")),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Int64\n            }]\n        },\n        expr_from_projection(&select.projection[3])\n    );\n\n    let sql = r#\"SELECT STRUCT<INTERVAL>(INTERVAL '1-2 3 4:5:6.789999'), STRUCT<JSON>(JSON '{\"class\" : {\"students\" : [{\"name\" : \"Jane\"}]}}')\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Interval(ast::Interval {\n                value: Box::new(Expr::Value(Value::SingleQuotedString(\n                    \"1-2 3 4:5:6.789999\".to_string()\n                ))),\n                leading_field: None,\n                leading_precision: None,\n                last_field: None,\n                fractional_seconds_precision: None\n            }),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Interval\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::JSON,\n                value: r#\"{\"class\" : {\"students\" : [{\"name\" : \"Jane\"}]}}\"#.to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::JSON\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n\n    let sql = r#\"SELECT STRUCT<STRING(42)>(\"foo\"), STRUCT<TIMESTAMP>(TIMESTAMP '2008-12-25 15:30:00 America/Los_Angeles'), STRUCT<TIME>(TIME '15:30:00')\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(3, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::DoubleQuotedString(\"foo\".to_string())),],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::String(Some(42))\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::Timestamp(None, TimezoneInfo::None),\n                value: \"2008-12-25 15:30:00 America/Los_Angeles\".to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Timestamp(None, TimezoneInfo::None)\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::Time(None, TimezoneInfo::None),\n                value: \"15:30:00\".to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Time(None, TimezoneInfo::None)\n            }]\n        },\n        expr_from_projection(&select.projection[2])\n    );\n\n    let sql = r#\"SELECT STRUCT<NUMERIC>(NUMERIC '1'), STRUCT<BIGNUMERIC>(BIGNUMERIC '1')\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::Numeric(ExactNumberInfo::None),\n                value: \"1\".to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::Numeric(ExactNumberInfo::None)\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::TypedString {\n                data_type: DataType::BigNumeric(ExactNumberInfo::None),\n                value: \"1\".to_string()\n            },],\n            fields: vec![StructField {\n                field_name: None,\n                field_type: DataType::BigNumeric(ExactNumberInfo::None)\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_typed_struct_with_field_name", "test": "fn parse_typed_struct_with_field_name() {\n    let sql = r#\"SELECT STRUCT<x INT64>(5), STRUCT<y STRING>(\"foo\")\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"5\")),],\n            fields: vec![StructField {\n                field_name: Some(Ident::from(\"x\")),\n                field_type: DataType::Int64\n            }]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(Value::DoubleQuotedString(\"foo\".to_string())),],\n            fields: vec![StructField {\n                field_name: Some(Ident::from(\"y\")),\n                field_type: DataType::String(None)\n            }]\n        },\n        expr_from_projection(&select.projection[1])\n    );\n\n    let sql = r#\"SELECT STRUCT<x INT64, y INT64>(5, 5)\"#;\n    let select = bigquery().verified_only_select(sql);\n    assert_eq!(1, select.projection.len());\n    assert_eq!(\n        &Expr::Struct {\n            values: vec![Expr::Value(number(\"5\")), Expr::Value(number(\"5\")),],\n            fields: vec![\n                StructField {\n                    field_name: Some(Ident::from(\"x\")),\n                    field_type: DataType::Int64\n                },\n                StructField {\n                    field_name: Some(Ident::from(\"y\")),\n                    field_type: DataType::Int64\n                }\n            ]\n        },\n        expr_from_projection(&select.projection[0])\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_join_constraint_unnest_alias", "test": "fn parse_join_constraint_unnest_alias() {\n    assert_eq!(\n        only(\n            bigquery()\n                .verified_only_select(\"SELECT * FROM t1 JOIN UNNEST(t1.a) AS f ON c1 = c2\")\n                .from\n        )\n        .joins,\n        vec![Join {\n            relation: TableFactor::UNNEST {\n                alias: table_alias(\"f\"),\n                array_exprs: vec![Expr::CompoundIdentifier(vec![\n                    Ident::new(\"t1\"),\n                    Ident::new(\"a\")\n                ])],\n                with_offset: false,\n                with_offset_alias: None\n            },\n            join_operator: JoinOperator::Inner(JoinConstraint::On(Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"c1\".into())),\n                op: BinaryOperator::Eq,\n                right: Box::new(Expr::Identifier(\"c2\".into())),\n            })),\n        }]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_like", "test": "fn parse_like() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = bigquery().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = bigquery().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that LIKE and NOT LIKE have the same precedence.\n        // This was previously mishandled (#81).\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = bigquery().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_similar_to", "test": "fn parse_similar_to() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = bigquery().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = bigquery().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that SIMILAR TO and NOT SIMILAR TO have the same precedence.\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = bigquery().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_map_access_offset", "test": "fn parse_map_access_offset() {\n    let sql = \"SELECT d[offset(0)]\";\n    let _select = bigquery().verified_only_select(sql);\n    assert_eq!(\n        _select.projection[0],\n        SelectItem::UnnamedExpr(Expr::MapAccess {\n            column: Box::new(Expr::Identifier(Ident {\n                value: \"d\".to_string(),\n                quote_style: None,\n            })),\n            keys: vec![Expr::Function(Function {\n                name: ObjectName(vec![\"offset\".into()]),\n                args: vec![FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(\n                    number(\"0\")\n                ))),],\n                null_treatment: None,\n                filter: None,\n                over: None,\n                distinct: false,\n                special: false,\n                order_by: vec![],\n            })],\n        })\n    );\n\n    // test other operators\n    for sql in [\n        \"SELECT d[SAFE_OFFSET(0)]\",\n        \"SELECT d[ORDINAL(0)]\",\n        \"SELECT d[SAFE_ORDINAL(0)]\",\n    ] {\n        bigquery().verified_only_select(sql);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::test_bigquery_trim", "test": "fn test_bigquery_trim() {\n    let real_sql = r#\"SELECT customer_id, TRIM(item_price_id, '\"', \"a\") AS item_price_id FROM models_staging.subscriptions\"#;\n    assert_eq!(bigquery().verified_stmt(real_sql).to_string(), real_sql);\n\n    let sql_only_select = \"SELECT TRIM('xyz', 'a')\";\n    let select = bigquery().verified_only_select(sql_only_select);\n    assert_eq!(\n        &Expr::Trim {\n            expr: Box::new(Expr::Value(Value::SingleQuotedString(\"xyz\".to_owned()))),\n            trim_where: None,\n            trim_what: None,\n            trim_characters: Some(vec![Expr::Value(Value::SingleQuotedString(\"a\".to_owned()))]),\n        },\n        expr_from_projection(only(&select.projection))\n    );\n\n    // missing comma separation\n    let error_sql = \"SELECT TRIM('xyz' 'a')\";\n    assert_eq!(\n        ParserError::ParserError(\"Expected ), found: 'a'\".to_owned()),\n        bigquery().parse_sql_statements(error_sql).unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_map_access_expr", "test": "fn parse_map_access_expr() {\n    let sql = r#\"SELECT string_values[indexOf(string_names, 'endpoint')] FROM foos WHERE id = 'test' AND string_value[indexOf(string_name, 'app')] <> 'foo'\"#;\n    let select = clickhouse().verified_only_select(sql);\n    assert_eq!(\n        Select {\n            distinct: None,\n            top: None,\n            projection: vec![UnnamedExpr(MapAccess {\n                column: Box::new(Identifier(Ident {\n                    value: \"string_values\".to_string(),\n                    quote_style: None,\n                })),\n                keys: vec![Expr::Function(Function {\n                    name: ObjectName(vec![\"indexOf\".into()]),\n                    args: vec![\n                        FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Identifier(Ident::new(\n                            \"string_names\"\n                        )))),\n                        FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(\n                            Value::SingleQuotedString(\"endpoint\".to_string())\n                        ))),\n                    ],\n                    null_treatment: None,\n                    filter: None,\n                    over: None,\n                    distinct: false,\n                    special: false,\n                    order_by: vec![],\n                })],\n            })],\n            into: None,\n            from: vec![TableWithJoins {\n                relation: Table {\n                    name: ObjectName(vec![Ident::new(\"foos\")]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                joins: vec![],\n            }],\n            lateral_views: vec![],\n            selection: Some(BinaryOp {\n                left: Box::new(BinaryOp {\n                    left: Box::new(Identifier(Ident::new(\"id\"))),\n                    op: BinaryOperator::Eq,\n                    right: Box::new(Expr::Value(Value::SingleQuotedString(\"test\".to_string()))),\n                }),\n                op: BinaryOperator::And,\n                right: Box::new(BinaryOp {\n                    left: Box::new(MapAccess {\n                        column: Box::new(Identifier(Ident::new(\"string_value\"))),\n                        keys: vec![Expr::Function(Function {\n                            name: ObjectName(vec![Ident::new(\"indexOf\")]),\n                            args: vec![\n                                FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Identifier(\n                                    Ident::new(\"string_name\")\n                                ))),\n                                FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(\n                                    Value::SingleQuotedString(\"app\".to_string())\n                                ))),\n                            ],\n                            null_treatment: None,\n                            filter: None,\n                            over: None,\n                            distinct: false,\n                            special: false,\n                            order_by: vec![],\n                        })],\n                    }),\n                    op: BinaryOperator::NotEq,\n                    right: Box::new(Expr::Value(Value::SingleQuotedString(\"foo\".to_string()))),\n                }),\n            }),\n            group_by: GroupByExpr::Expressions(vec![]),\n            cluster_by: vec![],\n            distribute_by: vec![],\n            sort_by: vec![],\n            having: None,\n            named_window: vec![],\n            qualify: None,\n        },\n        select\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_array_expr", "test": "fn parse_array_expr() {\n    let sql = \"SELECT ['1', '2'] FROM test\";\n    let select = clickhouse().verified_only_select(sql);\n    assert_eq!(\n        &Expr::Array(Array {\n            elem: vec![\n                Expr::Value(Value::SingleQuotedString(\"1\".to_string())),\n                Expr::Value(Value::SingleQuotedString(\"2\".to_string())),\n            ],\n            named: false,\n        }),\n        expr_from_projection(only(&select.projection))\n    )\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_array_fn", "test": "fn parse_array_fn() {\n    let sql = \"SELECT array(x1, x2) FROM foo\";\n    let select = clickhouse().verified_only_select(sql);\n    assert_eq!(\n        &Expr::Function(Function {\n            name: ObjectName(vec![Ident::new(\"array\")]),\n            args: vec![\n                FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Identifier(Ident::new(\"x1\")))),\n                FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Identifier(Ident::new(\"x2\")))),\n            ],\n            null_treatment: None,\n            filter: None,\n            over: None,\n            distinct: false,\n            special: false,\n            order_by: vec![],\n        }),\n        expr_from_projection(only(&select.projection))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_kill", "test": "fn parse_kill() {\n    let stmt = clickhouse().verified_stmt(\"KILL MUTATION 5\");\n    assert_eq!(\n        stmt,\n        Statement::Kill {\n            modifier: Some(KillType::Mutation),\n            id: 5,\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_like", "test": "fn parse_like() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = clickhouse().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = clickhouse().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that LIKE and NOT LIKE have the same precedence.\n        // This was previously mishandled (#81).\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = clickhouse().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_clickhouse.rs::parse_similar_to", "test": "fn parse_similar_to() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = clickhouse().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = clickhouse().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that SIMILAR TO and NOT SIMILAR TO have the same precedence.\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = clickhouse().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_insert_values", "test": "fn parse_insert_values() {\n    let row = vec![\n        Expr::Value(number(\"1\")),\n        Expr::Value(number(\"2\")),\n        Expr::Value(number(\"3\")),\n    ];\n    let rows1 = vec![row.clone()];\n    let rows2 = vec![row.clone(), row];\n\n    let sql = \"INSERT customer VALUES (1, 2, 3)\";\n    check_one(sql, \"customer\", &[], &rows1);\n\n    let sql = \"INSERT INTO customer VALUES (1, 2, 3)\";\n    check_one(sql, \"customer\", &[], &rows1);\n\n    let sql = \"INSERT INTO customer VALUES (1, 2, 3), (1, 2, 3)\";\n    check_one(sql, \"customer\", &[], &rows2);\n\n    let sql = \"INSERT INTO public.customer VALUES (1, 2, 3)\";\n    check_one(sql, \"public.customer\", &[], &rows1);\n\n    let sql = \"INSERT INTO db.public.customer VALUES (1, 2, 3)\";\n    check_one(sql, \"db.public.customer\", &[], &rows1);\n\n    let sql = \"INSERT INTO public.customer (id, name, active) VALUES (1, 2, 3)\";\n    check_one(\n        sql,\n        \"public.customer\",\n        &[\"id\".to_string(), \"name\".to_string(), \"active\".to_string()],\n        &rows1,\n    );\n\n    fn check_one(\n        sql: &str,\n        expected_table_name: &str,\n        expected_columns: &[String],\n        expected_rows: &[Vec<Expr>],\n    ) {\n        match verified_stmt(sql) {\n            Statement::Insert {\n                table_name,\n                columns,\n                source,\n                ..\n            } => {\n                assert_eq!(table_name.to_string(), expected_table_name);\n                assert_eq!(columns.len(), expected_columns.len());\n                for (index, column) in columns.iter().enumerate() {\n                    assert_eq!(column, &Ident::new(expected_columns[index].clone()));\n                }\n                match &*source.body {\n                    SetExpr::Values(Values { rows, .. }) => {\n                        assert_eq!(rows.as_slice(), expected_rows)\n                    }\n                    _ => unreachable!(),\n                }\n            }\n            _ => unreachable!(),\n        }\n    }\n\n    verified_stmt(\"INSERT INTO customer WITH foo AS (SELECT 1) SELECT * FROM foo UNION VALUES (1)\");\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_update", "test": "fn parse_update() {\n    let sql = \"UPDATE t SET a = 1, b = 2, c = 3 WHERE d\";\n    match verified_stmt(sql) {\n        Statement::Update {\n            table,\n            assignments,\n            selection,\n            ..\n        } => {\n            assert_eq!(table.to_string(), \"t\".to_string());\n            assert_eq!(\n                assignments,\n                vec![\n                    Assignment {\n                        id: vec![\"a\".into()],\n                        value: Expr::Value(number(\"1\")),\n                    },\n                    Assignment {\n                        id: vec![\"b\".into()],\n                        value: Expr::Value(number(\"2\")),\n                    },\n                    Assignment {\n                        id: vec![\"c\".into()],\n                        value: Expr::Value(number(\"3\")),\n                    },\n                ]\n            );\n            assert_eq!(selection.unwrap(), Expr::Identifier(\"d\".into()));\n        }\n        _ => unreachable!(),\n    }\n\n    verified_stmt(\"UPDATE t SET a = 1, a = 2, a = 3\");\n\n    let sql = \"UPDATE t WHERE 1\";\n    let res = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\"Expected SET, found: WHERE\".to_string()),\n        res.unwrap_err()\n    );\n\n    let sql = \"UPDATE t SET a = 1 extrabadstuff\";\n    let res = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: extrabadstuff\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_update_set_from", "test": "fn parse_update_set_from() {\n    let sql = \"UPDATE t1 SET name = t2.name FROM (SELECT name, id FROM t1 GROUP BY id) AS t2 WHERE t1.id = t2.id\";\n    let dialects = TestedDialects {\n        dialects: vec![\n            Box::new(GenericDialect {}),\n            Box::new(DuckDbDialect {}),\n            Box::new(PostgreSqlDialect {}),\n            Box::new(BigQueryDialect {}),\n            Box::new(SnowflakeDialect {}),\n            Box::new(RedshiftSqlDialect {}),\n            Box::new(MsSqlDialect {}),\n        ],\n        options: None,\n    };\n    let stmt = dialects.verified_stmt(sql);\n    assert_eq!(\n        stmt,\n        Statement::Update {\n            table: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: ObjectName(vec![Ident::new(\"t1\")]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                joins: vec![],\n            },\n            assignments: vec![Assignment {\n                id: vec![Ident::new(\"name\")],\n                value: Expr::CompoundIdentifier(vec![Ident::new(\"t2\"), Ident::new(\"name\")])\n            }],\n            from: Some(TableWithJoins {\n                relation: TableFactor::Derived {\n                    lateral: false,\n                    subquery: Box::new(Query {\n                        with: None,\n                        body: Box::new(SetExpr::Select(Box::new(Select {\n                            distinct: None,\n                            top: None,\n                            projection: vec![\n                                SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"name\"))),\n                                SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"id\"))),\n                            ],\n                            into: None,\n                            from: vec![TableWithJoins {\n                                relation: TableFactor::Table {\n                                    name: ObjectName(vec![Ident::new(\"t1\")]),\n                                    alias: None,\n                                    args: None,\n                                    with_hints: vec![],\n                                    version: None,\n                                    partitions: vec![],\n                                },\n                                joins: vec![],\n                            }],\n                            lateral_views: vec![],\n                            selection: None,\n                            group_by: GroupByExpr::Expressions(vec![Expr::Identifier(Ident::new(\n                                \"id\"\n                            ))]),\n                            cluster_by: vec![],\n                            distribute_by: vec![],\n                            sort_by: vec![],\n                            having: None,\n                            named_window: vec![],\n                            qualify: None\n                        }))),\n                        order_by: vec![],\n                        limit: None,\n                        limit_by: vec![],\n                        offset: None,\n                        fetch: None,\n                        locks: vec![],\n                    }),\n                    alias: Some(TableAlias {\n                        name: Ident::new(\"t2\"),\n                        columns: vec![],\n                    })\n                },\n                joins: vec![],\n            }),\n            selection: Some(Expr::BinaryOp {\n                left: Box::new(Expr::CompoundIdentifier(vec![\n                    Ident::new(\"t1\"),\n                    Ident::new(\"id\")\n                ])),\n                op: BinaryOperator::Eq,\n                right: Box::new(Expr::CompoundIdentifier(vec![\n                    Ident::new(\"t2\"),\n                    Ident::new(\"id\")\n                ])),\n            }),\n            returning: None,\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_update_with_table_alias", "test": "fn parse_update_with_table_alias() {\n    let sql = \"UPDATE users AS u SET u.username = 'new_user' WHERE u.username = 'old_user'\";\n    match verified_stmt(sql) {\n        Statement::Update {\n            table,\n            assignments,\n            from: _from,\n            selection,\n            returning,\n        } => {\n            assert_eq!(\n                TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: ObjectName(vec![Ident::new(\"users\")]),\n                        alias: Some(TableAlias {\n                            name: Ident::new(\"u\"),\n                            columns: vec![],\n                        }),\n                        args: None,\n                        with_hints: vec![],\n                        version: None,\n                        partitions: vec![],\n                    },\n                    joins: vec![],\n                },\n                table\n            );\n            assert_eq!(\n                vec![Assignment {\n                    id: vec![Ident::new(\"u\"), Ident::new(\"username\")],\n                    value: Expr::Value(Value::SingleQuotedString(\"new_user\".to_string())),\n                }],\n                assignments\n            );\n            assert_eq!(\n                Some(Expr::BinaryOp {\n                    left: Box::new(Expr::CompoundIdentifier(vec![\n                        Ident::new(\"u\"),\n                        Ident::new(\"username\"),\n                    ])),\n                    op: BinaryOperator::Eq,\n                    right: Box::new(Expr::Value(Value::SingleQuotedString(\n                        \"old_user\".to_string()\n                    ))),\n                }),\n                selection\n            );\n            assert_eq!(None, returning);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_invalid_table_name", "test": "fn parse_invalid_table_name() {\n    let ast = all_dialects()\n        .run_parser_method(\"db.public..customer\", |parser| parser.parse_object_name());\n    assert!(ast.is_err());\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_no_table_name", "test": "fn parse_no_table_name() {\n    let ast = all_dialects().run_parser_method(\"\", |parser| parser.parse_object_name());\n    assert!(ast.is_err());\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_delete_statement", "test": "fn parse_delete_statement() {\n    let sql = \"DELETE FROM \\\"table\\\"\";\n    match verified_stmt(sql) {\n        Statement::Delete { from, .. } => {\n            assert_eq!(\n                TableFactor::Table {\n                    name: ObjectName(vec![Ident::with_quote('\"', \"table\")]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                from[0].relation\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_delete_statement_for_multi_tables", "test": "fn parse_delete_statement_for_multi_tables() {\n    let sql = \"DELETE schema1.table1, schema2.table2 FROM schema1.table1 JOIN schema2.table2 ON schema2.table2.col1 = schema1.table1.col1 WHERE schema2.table2.col2 = 1\";\n    match verified_stmt(sql) {\n        Statement::Delete { tables, from, .. } => {\n            assert_eq!(\n                ObjectName(vec![Ident::new(\"schema1\"), Ident::new(\"table1\")]),\n                tables[0]\n            );\n            assert_eq!(\n                ObjectName(vec![Ident::new(\"schema2\"), Ident::new(\"table2\")]),\n                tables[1]\n            );\n            assert_eq!(\n                TableFactor::Table {\n                    name: ObjectName(vec![Ident::new(\"schema1\"), Ident::new(\"table1\")]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                from[0].relation\n            );\n            assert_eq!(\n                TableFactor::Table {\n                    name: ObjectName(vec![Ident::new(\"schema2\"), Ident::new(\"table2\")]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                from[0].joins[0].relation\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_delete_statement_for_multi_tables_with_using", "test": "fn parse_delete_statement_for_multi_tables_with_using() {\n    let sql = \"DELETE FROM schema1.table1, schema2.table2 USING schema1.table1 JOIN schema2.table2 ON schema2.table2.pk = schema1.table1.col1 WHERE schema2.table2.col2 = 1\";\n    match verified_stmt(sql) {\n        Statement::Delete {\n            from,\n            using: Some(using),\n            ..\n        } => {\n            assert_eq!(\n                TableFactor::Table {\n                    name: ObjectName(vec![Ident::new(\"schema1\"), Ident::new(\"table1\")]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                from[0].relation\n            );\n            assert_eq!(\n                TableFactor::Table {\n                    name: ObjectName(vec![Ident::new(\"schema2\"), Ident::new(\"table2\")]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                from[1].relation\n            );\n            assert_eq!(\n                TableFactor::Table {\n                    name: ObjectName(vec![Ident::new(\"schema1\"), Ident::new(\"table1\")]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                using[0].relation\n            );\n            assert_eq!(\n                TableFactor::Table {\n                    name: ObjectName(vec![Ident::new(\"schema2\"), Ident::new(\"table2\")]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                using[0].joins[0].relation\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_where_delete_statement", "test": "fn parse_where_delete_statement() {\n    use self::BinaryOperator::*;\n\n    let sql = \"DELETE FROM foo WHERE name = 5\";\n    match verified_stmt(sql) {\n        Statement::Delete {\n            tables: _,\n            from,\n            using,\n            selection,\n            returning,\n            ..\n        } => {\n            assert_eq!(\n                TableFactor::Table {\n                    name: ObjectName(vec![Ident::new(\"foo\")]),\n                    alias: None,\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                from[0].relation,\n            );\n\n            assert_eq!(None, using);\n            assert_eq!(\n                Expr::BinaryOp {\n                    left: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                    op: Eq,\n                    right: Box::new(Expr::Value(number(\"5\"))),\n                },\n                selection.unwrap(),\n            );\n            assert_eq!(None, returning);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_where_delete_with_alias_statement", "test": "fn parse_where_delete_with_alias_statement() {\n    use self::BinaryOperator::*;\n\n    let sql = \"DELETE FROM basket AS a USING basket AS b WHERE a.id < b.id\";\n    match verified_stmt(sql) {\n        Statement::Delete {\n            tables: _,\n            from,\n            using,\n            selection,\n            returning,\n            ..\n        } => {\n            assert_eq!(\n                TableFactor::Table {\n                    name: ObjectName(vec![Ident::new(\"basket\")]),\n                    alias: Some(TableAlias {\n                        name: Ident::new(\"a\"),\n                        columns: vec![],\n                    }),\n                    args: None,\n                    with_hints: vec![],\n                    version: None,\n                    partitions: vec![],\n                },\n                from[0].relation,\n            );\n            assert_eq!(\n                Some(vec![TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: ObjectName(vec![Ident::new(\"basket\")]),\n                        alias: Some(TableAlias {\n                            name: Ident::new(\"b\"),\n                            columns: vec![],\n                        }),\n                        args: None,\n                        with_hints: vec![],\n                        version: None,\n                        partitions: vec![],\n                    },\n                    joins: vec![],\n                }]),\n                using\n            );\n            assert_eq!(\n                Expr::BinaryOp {\n                    left: Box::new(Expr::CompoundIdentifier(vec![\n                        Ident::new(\"a\"),\n                        Ident::new(\"id\"),\n                    ])),\n                    op: Lt,\n                    right: Box::new(Expr::CompoundIdentifier(vec![\n                        Ident::new(\"b\"),\n                        Ident::new(\"id\"),\n                    ])),\n                },\n                selection.unwrap(),\n            );\n            assert_eq!(None, returning);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_simple_select", "test": "fn parse_simple_select() {\n    let sql = \"SELECT id, fname, lname FROM customer WHERE id = 1 LIMIT 5\";\n    let select = verified_only_select(sql);\n    assert!(select.distinct.is_none());\n    assert_eq!(3, select.projection.len());\n    let select = verified_query(sql);\n    assert_eq!(Some(Expr::Value(number(\"5\"))), select.limit);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_limit_is_not_an_alias", "test": "fn parse_limit_is_not_an_alias() {\n    // In dialects supporting LIMIT it shouldn't be parsed as a table alias\n    let ast = verified_query(\"SELECT id FROM customer LIMIT 1\");\n    assert_eq!(Some(Expr::Value(number(\"1\"))), ast.limit);\n\n    let ast = verified_query(\"SELECT 1 LIMIT 5\");\n    assert_eq!(Some(Expr::Value(number(\"5\"))), ast.limit);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_distinct", "test": "fn parse_select_distinct() {\n    let sql = \"SELECT DISTINCT name FROM customer\";\n    let select = verified_only_select(sql);\n    assert!(select.distinct.is_some());\n    assert_eq!(\n        &SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"name\"))),\n        only(&select.projection)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_distinct_two_fields", "test": "fn parse_select_distinct_two_fields() {\n    let sql = \"SELECT DISTINCT name, id FROM customer\";\n    let select = verified_only_select(sql);\n    assert!(select.distinct.is_some());\n    assert_eq!(\n        &SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"name\"))),\n        &select.projection[0]\n    );\n    assert_eq!(\n        &SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"id\"))),\n        &select.projection[1]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_distinct_on", "test": "fn parse_select_distinct_on() {\n    let sql = \"SELECT DISTINCT ON (album_id) name FROM track ORDER BY album_id, milliseconds\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Some(Distinct::On(vec![Expr::Identifier(Ident::new(\"album_id\"))])),\n        &select.distinct\n    );\n\n    let sql = \"SELECT DISTINCT ON () name FROM track ORDER BY milliseconds\";\n    let select = verified_only_select(sql);\n    assert_eq!(&Some(Distinct::On(vec![])), &select.distinct);\n\n    let sql = \"SELECT DISTINCT ON (album_id, milliseconds) name FROM track\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Some(Distinct::On(vec![\n            Expr::Identifier(Ident::new(\"album_id\")),\n            Expr::Identifier(Ident::new(\"milliseconds\")),\n        ])),\n        &select.distinct\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_distinct_missing_paren", "test": "fn parse_select_distinct_missing_paren() {\n    let result = parse_sql_statements(\"SELECT DISTINCT (name, id FROM customer\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected ), found: FROM\".to_string()),\n        result.unwrap_err(),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_all_distinct", "test": "fn parse_select_all_distinct() {\n    let result = parse_sql_statements(\"SELECT ALL DISTINCT name FROM customer\");\n    assert_eq!(\n        ParserError::ParserError(\"Cannot specify both ALL and DISTINCT\".to_string()),\n        result.unwrap_err(),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_into", "test": "fn parse_select_into() {\n    let sql = \"SELECT * INTO table0 FROM table1\";\n    one_statement_parses_to(sql, \"SELECT * INTO table0 FROM table1\");\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &SelectInto {\n            temporary: false,\n            unlogged: false,\n            table: false,\n            name: ObjectName(vec![Ident::new(\"table0\")]),\n        },\n        only(&select.into)\n    );\n\n    let sql = \"SELECT * INTO TEMPORARY UNLOGGED TABLE table0 FROM table1\";\n    one_statement_parses_to(\n        sql,\n        \"SELECT * INTO TEMPORARY UNLOGGED TABLE table0 FROM table1\",\n    );\n\n    // Do not allow aliases here\n    let sql = \"SELECT * INTO table0 asdf FROM table1\";\n    let result = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: asdf\".to_string()),\n        result.unwrap_err()\n    )\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_wildcard", "test": "fn parse_select_wildcard() {\n    let sql = \"SELECT * FROM foo\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &SelectItem::Wildcard(WildcardAdditionalOptions::default()),\n        only(&select.projection)\n    );\n\n    let sql = \"SELECT foo.* FROM foo\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &SelectItem::QualifiedWildcard(\n            ObjectName(vec![Ident::new(\"foo\")]),\n            WildcardAdditionalOptions::default()\n        ),\n        only(&select.projection)\n    );\n\n    let sql = \"SELECT myschema.mytable.* FROM myschema.mytable\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &SelectItem::QualifiedWildcard(\n            ObjectName(vec![Ident::new(\"myschema\"), Ident::new(\"mytable\"),]),\n            WildcardAdditionalOptions::default(),\n        ),\n        only(&select.projection)\n    );\n\n    let sql = \"SELECT * + * FROM foo;\";\n    let result = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: +\".to_string()),\n        result.unwrap_err(),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::test_eof_after_as", "test": "fn test_eof_after_as() {\n    let res = parse_sql_statements(\"SELECT foo AS\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected an identifier after AS, found: EOF\".to_string()),\n        res.unwrap_err()\n    );\n\n    let res = parse_sql_statements(\"SELECT 1 FROM foo AS\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected an identifier after AS, found: EOF\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::test_no_infix_error", "test": "fn test_no_infix_error() {\n    let dialects = TestedDialects {\n        dialects: vec![Box::new(ClickHouseDialect {})],\n        options: None,\n    };\n\n    let res = dialects.parse_sql_statements(\"ASSERT-URA<<\");\n    assert_eq!(\n        ParserError::ParserError(\"No infix parser for token ShiftLeft\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_count_wildcard", "test": "fn parse_select_count_wildcard() {\n    let sql = \"SELECT COUNT(*) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Function(Function {\n            name: ObjectName(vec![Ident::new(\"COUNT\")]),\n            args: vec![FunctionArg::Unnamed(FunctionArgExpr::Wildcard)],\n            null_treatment: None,\n            filter: None,\n            over: None,\n            distinct: false,\n            special: false,\n            order_by: vec![],\n        }),\n        expr_from_projection(only(&select.projection))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_count_distinct", "test": "fn parse_select_count_distinct() {\n    let sql = \"SELECT COUNT(DISTINCT +x) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Function(Function {\n            name: ObjectName(vec![Ident::new(\"COUNT\")]),\n            args: vec![FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::UnaryOp {\n                op: UnaryOperator::Plus,\n                expr: Box::new(Expr::Identifier(Ident::new(\"x\"))),\n            }))],\n            null_treatment: None,\n            filter: None,\n            over: None,\n            distinct: true,\n            special: false,\n            order_by: vec![],\n        }),\n        expr_from_projection(only(&select.projection))\n    );\n\n    one_statement_parses_to(\n        \"SELECT COUNT(ALL +x) FROM customer\",\n        \"SELECT COUNT(+x) FROM customer\",\n    );\n\n    let sql = \"SELECT COUNT(ALL DISTINCT + x) FROM customer\";\n    let res = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\"Cannot specify both ALL and DISTINCT\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_invalid_infix_not", "test": "fn parse_invalid_infix_not() {\n    let res = parse_sql_statements(\"SELECT c FROM t WHERE c NOT (\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: NOT\".to_string()),\n        res.unwrap_err(),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_collate", "test": "fn parse_collate() {\n    let sql = \"SELECT name COLLATE \\\"de_DE\\\" FROM customer\";\n    assert_matches!(\n        only(&all_dialects().verified_only_select(sql).projection),\n        SelectItem::UnnamedExpr(Expr::Collate { .. })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_collate_after_parens", "test": "fn parse_collate_after_parens() {\n    let sql = \"SELECT (name) COLLATE \\\"de_DE\\\" FROM customer\";\n    assert_matches!(\n        only(&all_dialects().verified_only_select(sql).projection),\n        SelectItem::UnnamedExpr(Expr::Collate { .. })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_null_in_select", "test": "fn parse_null_in_select() {\n    let sql = \"SELECT NULL\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Value(Value::Null),\n        expr_from_projection(only(&select.projection)),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_with_date_column_name", "test": "fn parse_select_with_date_column_name() {\n    let sql = \"SELECT date\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Identifier(Ident {\n            value: \"date\".into(),\n            quote_style: None,\n        }),\n        expr_from_projection(only(&select.projection)),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_escaped_single_quote_string_predicate_with_escape", "test": "fn parse_escaped_single_quote_string_predicate_with_escape() {\n    use self::BinaryOperator::*;\n    let sql = \"SELECT id, fname, lname FROM customer \\\n               WHERE salary <> 'Jim''s salary'\";\n\n    let ast = verified_only_select(sql);\n\n    assert_eq!(\n        Some(Expr::BinaryOp {\n            left: Box::new(Expr::Identifier(Ident::new(\"salary\"))),\n            op: NotEq,\n            right: Box::new(Expr::Value(Value::SingleQuotedString(\n                \"Jim's salary\".to_string()\n            ))),\n        }),\n        ast.selection,\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_escaped_single_quote_string_predicate_with_no_escape", "test": "fn parse_escaped_single_quote_string_predicate_with_no_escape() {\n    use self::BinaryOperator::*;\n    let sql = \"SELECT id, fname, lname FROM customer \\\n               WHERE salary <> 'Jim''s salary'\";\n\n    let ast = TestedDialects {\n        dialects: vec![Box::new(MySqlDialect {})],\n        options: Some(\n            ParserOptions::new()\n                .with_trailing_commas(true)\n                .with_unescape(false),\n        ),\n    }\n    .verified_only_select(sql);\n\n    assert_eq!(\n        Some(Expr::BinaryOp {\n            left: Box::new(Expr::Identifier(Ident::new(\"salary\"))),\n            op: NotEq,\n            right: Box::new(Expr::Value(Value::SingleQuotedString(\n                \"Jim''s salary\".to_string()\n            ))),\n        }),\n        ast.selection,\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_number", "test": "fn parse_number() {\n    let expr = verified_expr(\"1.0\");\n\n    #[cfg(feature = \"bigdecimal\")]\n    assert_eq!(\n        expr,\n        Expr::Value(Value::Number(bigdecimal::BigDecimal::from(1), false))\n    );\n\n    #[cfg(not(feature = \"bigdecimal\"))]\n    assert_eq!(expr, Expr::Value(Value::Number(\"1.0\".into(), false)));\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_compound_expr_1", "test": "fn parse_compound_expr_1() {\n    use self::BinaryOperator::*;\n    use self::Expr::*;\n    let sql = \"a + b * c\";\n    assert_eq!(\n        BinaryOp {\n            left: Box::new(Identifier(Ident::new(\"a\"))),\n            op: Plus,\n            right: Box::new(BinaryOp {\n                left: Box::new(Identifier(Ident::new(\"b\"))),\n                op: Multiply,\n                right: Box::new(Identifier(Ident::new(\"c\"))),\n            }),\n        },\n        verified_expr(sql)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_compound_expr_2", "test": "fn parse_compound_expr_2() {\n    use self::BinaryOperator::*;\n    use self::Expr::*;\n    let sql = \"a * b + c\";\n    assert_eq!(\n        BinaryOp {\n            left: Box::new(BinaryOp {\n                left: Box::new(Identifier(Ident::new(\"a\"))),\n                op: Multiply,\n                right: Box::new(Identifier(Ident::new(\"b\"))),\n            }),\n            op: Plus,\n            right: Box::new(Identifier(Ident::new(\"c\"))),\n        },\n        verified_expr(sql)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_unary_math_with_plus", "test": "fn parse_unary_math_with_plus() {\n    use self::Expr::*;\n    let sql = \"-a + -b\";\n    assert_eq!(\n        BinaryOp {\n            left: Box::new(UnaryOp {\n                op: UnaryOperator::Minus,\n                expr: Box::new(Identifier(Ident::new(\"a\"))),\n            }),\n            op: BinaryOperator::Plus,\n            right: Box::new(UnaryOp {\n                op: UnaryOperator::Minus,\n                expr: Box::new(Identifier(Ident::new(\"b\"))),\n            }),\n        },\n        verified_expr(sql)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_unary_math_with_multiply", "test": "fn parse_unary_math_with_multiply() {\n    use self::Expr::*;\n    let sql = \"-a * -b\";\n    assert_eq!(\n        BinaryOp {\n            left: Box::new(UnaryOp {\n                op: UnaryOperator::Minus,\n                expr: Box::new(Identifier(Ident::new(\"a\"))),\n            }),\n            op: BinaryOperator::Multiply,\n            right: Box::new(UnaryOp {\n                op: UnaryOperator::Minus,\n                expr: Box::new(Identifier(Ident::new(\"b\"))),\n            }),\n        },\n        verified_expr(sql)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_mod", "test": "fn parse_mod() {\n    use self::Expr::*;\n    let sql = \"a % b\";\n    assert_eq!(\n        BinaryOp {\n            left: Box::new(Identifier(Ident::new(\"a\"))),\n            op: BinaryOperator::Modulo,\n            right: Box::new(Identifier(Ident::new(\"b\"))),\n        },\n        verified_expr(sql)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_json_ops_without_colon", "test": "fn parse_json_ops_without_colon() {\n    use self::JsonOperator;\n    let binary_ops = &[\n        (\"->\", JsonOperator::Arrow, all_dialects()),\n        (\"->>\", JsonOperator::LongArrow, all_dialects()),\n        (\"#>\", JsonOperator::HashArrow, pg_and_generic()),\n        (\"#>>\", JsonOperator::HashLongArrow, pg_and_generic()),\n        (\"@>\", JsonOperator::AtArrow, all_dialects()),\n        (\"<@\", JsonOperator::ArrowAt, all_dialects()),\n        (\"#-\", JsonOperator::HashMinus, pg_and_generic()),\n        (\"@?\", JsonOperator::AtQuestion, all_dialects()),\n        (\"@@\", JsonOperator::AtAt, all_dialects()),\n    ];\n\n    for (str_op, op, dialects) in binary_ops {\n        let select = dialects.verified_only_select(&format!(\"SELECT a {} b\", &str_op));\n        assert_eq!(\n            SelectItem::UnnamedExpr(Expr::JsonAccess {\n                left: Box::new(Expr::Identifier(Ident::new(\"a\"))),\n                operator: *op,\n                right: Box::new(Expr::Identifier(Ident::new(\"b\"))),\n            }),\n            select.projection[0]\n        );\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_mod_no_spaces", "test": "fn parse_mod_no_spaces() {\n    use self::Expr::*;\n    let canonical = \"a1 % b1\";\n    let sqls = [\"a1 % b1\", \"a1% b1\", \"a1 %b1\", \"a1%b1\"];\n    for sql in sqls {\n        println!(\"Parsing {sql}\");\n        assert_eq!(\n            BinaryOp {\n                left: Box::new(Identifier(Ident::new(\"a1\"))),\n                op: BinaryOperator::Modulo,\n                right: Box::new(Identifier(Ident::new(\"b1\"))),\n            },\n            pg_and_generic().expr_parses_to(sql, canonical)\n        );\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_is_null", "test": "fn parse_is_null() {\n    use self::Expr::*;\n    let sql = \"a IS NULL\";\n    assert_eq!(\n        IsNull(Box::new(Identifier(Ident::new(\"a\")))),\n        verified_expr(sql)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_is_not_null", "test": "fn parse_is_not_null() {\n    use self::Expr::*;\n    let sql = \"a IS NOT NULL\";\n    assert_eq!(\n        IsNotNull(Box::new(Identifier(Ident::new(\"a\")))),\n        verified_expr(sql)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_is_distinct_from", "test": "fn parse_is_distinct_from() {\n    use self::Expr::*;\n    let sql = \"a IS DISTINCT FROM b\";\n    assert_eq!(\n        IsDistinctFrom(\n            Box::new(Identifier(Ident::new(\"a\"))),\n            Box::new(Identifier(Ident::new(\"b\"))),\n        ),\n        verified_expr(sql)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_is_not_distinct_from", "test": "fn parse_is_not_distinct_from() {\n    use self::Expr::*;\n    let sql = \"a IS NOT DISTINCT FROM b\";\n    assert_eq!(\n        IsNotDistinctFrom(\n            Box::new(Identifier(Ident::new(\"a\"))),\n            Box::new(Identifier(Ident::new(\"b\"))),\n        ),\n        verified_expr(sql)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_null_like", "test": "fn parse_null_like() {\n    let sql = \"SELECT \\\n            column1 LIKE NULL AS col_null, \\\n            NULL LIKE column1 AS null_col \\\n        FROM customers\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        SelectItem::ExprWithAlias {\n            expr: Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"column1\"))),\n                negated: false,\n                pattern: Box::new(Expr::Value(Value::Null)),\n                escape_char: None,\n            },\n            alias: Ident {\n                value: \"col_null\".to_owned(),\n                quote_style: None,\n            },\n        },\n        select.projection[0]\n    );\n    assert_eq!(\n        SelectItem::ExprWithAlias {\n            expr: Expr::Like {\n                expr: Box::new(Expr::Value(Value::Null)),\n                negated: false,\n                pattern: Box::new(Expr::Identifier(Ident::new(\"column1\"))),\n                escape_char: None,\n            },\n            alias: Ident {\n                value: \"null_col\".to_owned(),\n                quote_style: None,\n            },\n        },\n        select.projection[1]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_ilike", "test": "fn parse_ilike() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}ILIKE '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = verified_only_select(sql);\n        assert_eq!(\n            Expr::ILike {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}ILIKE '%a' ESCAPE '^'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = verified_only_select(sql);\n        assert_eq!(\n            Expr::ILike {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('^'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that ILIKE and NOT ILIKE have the same precedence.\n        // This was previously mishandled (#81).\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}ILIKE '%a' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::ILike {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_in_list", "test": "fn parse_in_list() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE segment {}IN ('HIGH', 'MED')\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = verified_only_select(sql);\n        assert_eq!(\n            Expr::InList {\n                expr: Box::new(Expr::Identifier(Ident::new(\"segment\"))),\n                list: vec![\n                    Expr::Value(Value::SingleQuotedString(\"HIGH\".to_string())),\n                    Expr::Value(Value::SingleQuotedString(\"MED\".to_string())),\n                ],\n                negated,\n            },\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_in_subquery", "test": "fn parse_in_subquery() {\n    let sql = \"SELECT * FROM customers WHERE segment IN (SELECT segm FROM bar)\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        Expr::InSubquery {\n            expr: Box::new(Expr::Identifier(Ident::new(\"segment\"))),\n            subquery: Box::new(verified_query(\"SELECT segm FROM bar\")),\n            negated: false,\n        },\n        select.selection.unwrap()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_in_unnest", "test": "fn parse_in_unnest() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE segment {}IN UNNEST(expr)\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = verified_only_select(sql);\n        assert_eq!(\n            Expr::InUnnest {\n                expr: Box::new(Expr::Identifier(Ident::new(\"segment\"))),\n                array_expr: Box::new(verified_expr(\"expr\")),\n                negated,\n            },\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_in_error", "test": "fn parse_in_error() {\n    // <expr> IN <expr> is no valid\n    let sql = \"SELECT * FROM customers WHERE segment in segment\";\n    let res = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\"Expected (, found: segment\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_string_agg", "test": "fn parse_string_agg() {\n    let sql = \"SELECT a || b\";\n\n    let select = verified_only_select(sql);\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::BinaryOp {\n            left: Box::new(Expr::Identifier(Ident::new(\"a\"))),\n            op: BinaryOperator::StringConcat,\n            right: Box::new(Expr::Identifier(Ident::new(\"b\"))),\n        }),\n        select.projection[0]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_bitwise_ops", "test": "fn parse_bitwise_ops() {\n    let bitwise_ops = &[\n        (\"^\", BinaryOperator::BitwiseXor, all_dialects_but_pg()),\n        (\"|\", BinaryOperator::BitwiseOr, all_dialects()),\n        (\"&\", BinaryOperator::BitwiseAnd, all_dialects()),\n    ];\n\n    for (str_op, op, dialects) in bitwise_ops {\n        let select = dialects.verified_only_select(&format!(\"SELECT a {} b\", &str_op));\n        assert_eq!(\n            SelectItem::UnnamedExpr(Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(Ident::new(\"a\"))),\n                op: op.clone(),\n                right: Box::new(Expr::Identifier(Ident::new(\"b\"))),\n            }),\n            select.projection[0]\n        );\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_binary_any", "test": "fn parse_binary_any() {\n    let select = verified_only_select(\"SELECT a = ANY(b)\");\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::AnyOp {\n            left: Box::new(Expr::Identifier(Ident::new(\"a\"))),\n            compare_op: BinaryOperator::Eq,\n            right: Box::new(Expr::Identifier(Ident::new(\"b\"))),\n        }),\n        select.projection[0]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_binary_all", "test": "fn parse_binary_all() {\n    let select = verified_only_select(\"SELECT a = ALL(b)\");\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::AllOp {\n            left: Box::new(Expr::Identifier(Ident::new(\"a\"))),\n            compare_op: BinaryOperator::Eq,\n            right: Box::new(Expr::Identifier(Ident::new(\"b\"))),\n        }),\n        select.projection[0]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_logical_xor", "test": "fn parse_logical_xor() {\n    let sql = \"SELECT true XOR true, false XOR false, true XOR false, false XOR true\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::BinaryOp {\n            left: Box::new(Expr::Value(Value::Boolean(true))),\n            op: BinaryOperator::Xor,\n            right: Box::new(Expr::Value(Value::Boolean(true))),\n        }),\n        select.projection[0]\n    );\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::BinaryOp {\n            left: Box::new(Expr::Value(Value::Boolean(false))),\n            op: BinaryOperator::Xor,\n            right: Box::new(Expr::Value(Value::Boolean(false))),\n        }),\n        select.projection[1]\n    );\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::BinaryOp {\n            left: Box::new(Expr::Value(Value::Boolean(true))),\n            op: BinaryOperator::Xor,\n            right: Box::new(Expr::Value(Value::Boolean(false))),\n        }),\n        select.projection[2]\n    );\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::BinaryOp {\n            left: Box::new(Expr::Value(Value::Boolean(false))),\n            op: BinaryOperator::Xor,\n            right: Box::new(Expr::Value(Value::Boolean(true))),\n        }),\n        select.projection[3]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_between", "test": "fn parse_between() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE age {}BETWEEN 25 AND 32\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = verified_only_select(sql);\n        assert_eq!(\n            Expr::Between {\n                expr: Box::new(Expr::Identifier(Ident::new(\"age\"))),\n                low: Box::new(Expr::Value(number(\"25\"))),\n                high: Box::new(Expr::Value(number(\"32\"))),\n                negated,\n            },\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_between_with_expr", "test": "fn parse_between_with_expr() {\n    use self::BinaryOperator::*;\n    let sql = \"SELECT * FROM t WHERE 1 BETWEEN 1 + 2 AND 3 + 4 IS NULL\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        Expr::IsNull(Box::new(Expr::Between {\n            expr: Box::new(Expr::Value(number(\"1\"))),\n            low: Box::new(Expr::BinaryOp {\n                left: Box::new(Expr::Value(number(\"1\"))),\n                op: Plus,\n                right: Box::new(Expr::Value(number(\"2\"))),\n            }),\n            high: Box::new(Expr::BinaryOp {\n                left: Box::new(Expr::Value(number(\"3\"))),\n                op: Plus,\n                right: Box::new(Expr::Value(number(\"4\"))),\n            }),\n            negated: false,\n        })),\n        select.selection.unwrap()\n    );\n\n    let sql = \"SELECT * FROM t WHERE 1 = 1 AND 1 + x BETWEEN 1 AND 2\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        Expr::BinaryOp {\n            left: Box::new(Expr::BinaryOp {\n                left: Box::new(Expr::Value(number(\"1\"))),\n                op: BinaryOperator::Eq,\n                right: Box::new(Expr::Value(number(\"1\"))),\n            }),\n            op: BinaryOperator::And,\n            right: Box::new(Expr::Between {\n                expr: Box::new(Expr::BinaryOp {\n                    left: Box::new(Expr::Value(number(\"1\"))),\n                    op: BinaryOperator::Plus,\n                    right: Box::new(Expr::Identifier(Ident::new(\"x\"))),\n                }),\n                low: Box::new(Expr::Value(number(\"1\"))),\n                high: Box::new(Expr::Value(number(\"2\"))),\n                negated: false,\n            }),\n        },\n        select.selection.unwrap(),\n    )\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_tuple_invalid", "test": "fn parse_tuple_invalid() {\n    let sql = \"select (1\";\n    let res = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\"Expected ), found: EOF\".to_string()),\n        res.unwrap_err()\n    );\n\n    let sql = \"select (), 2\";\n    let res = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\"Expected an expression:, found: )\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_group_by", "test": "fn parse_select_group_by() {\n    let sql = \"SELECT id, fname, lname FROM customer GROUP BY lname, fname\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        GroupByExpr::Expressions(vec![\n            Expr::Identifier(Ident::new(\"lname\")),\n            Expr::Identifier(Ident::new(\"fname\")),\n        ]),\n        select.group_by\n    );\n\n    // Tuples can also be in the set\n    one_statement_parses_to(\n        \"SELECT id, fname, lname FROM customer GROUP BY (lname, fname)\",\n        \"SELECT id, fname, lname FROM customer GROUP BY (lname, fname)\",\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_having", "test": "fn parse_select_having() {\n    let sql = \"SELECT foo FROM bar GROUP BY foo HAVING COUNT(*) > 1\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        Some(Expr::BinaryOp {\n            left: Box::new(Expr::Function(Function {\n                name: ObjectName(vec![Ident::new(\"COUNT\")]),\n                args: vec![FunctionArg::Unnamed(FunctionArgExpr::Wildcard)],\n                null_treatment: None,\n                filter: None,\n                over: None,\n                distinct: false,\n                special: false,\n                order_by: vec![],\n            })),\n            op: BinaryOperator::Gt,\n            right: Box::new(Expr::Value(number(\"1\"))),\n        }),\n        select.having\n    );\n\n    let sql = \"SELECT 'foo' HAVING 1 = 1\";\n    let select = verified_only_select(sql);\n    assert!(select.having.is_some());\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_select_qualify", "test": "fn parse_select_qualify() {\n    let sql = \"SELECT i, p, o FROM qt QUALIFY ROW_NUMBER() OVER (PARTITION BY p ORDER BY o) = 1\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        Some(Expr::BinaryOp {\n            left: Box::new(Expr::Function(Function {\n                name: ObjectName(vec![Ident::new(\"ROW_NUMBER\")]),\n                args: vec![],\n                null_treatment: None,\n                filter: None,\n                over: Some(WindowType::WindowSpec(WindowSpec {\n                    partition_by: vec![Expr::Identifier(Ident::new(\"p\"))],\n                    order_by: vec![OrderByExpr {\n                        expr: Expr::Identifier(Ident::new(\"o\")),\n                        asc: None,\n                        nulls_first: None,\n                    }],\n                    window_frame: None,\n                })),\n                distinct: false,\n                special: false,\n                order_by: vec![],\n            })),\n            op: BinaryOperator::Eq,\n            right: Box::new(Expr::Value(number(\"1\"))),\n        }),\n        select.qualify\n    );\n\n    let sql = \"SELECT i, p, o, ROW_NUMBER() OVER (PARTITION BY p ORDER BY o) AS row_num FROM qt QUALIFY row_num = 1\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        Some(Expr::BinaryOp {\n            left: Box::new(Expr::Identifier(Ident::new(\"row_num\"))),\n            op: BinaryOperator::Eq,\n            right: Box::new(Expr::Value(number(\"1\"))),\n        }),\n        select.qualify\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_cast", "test": "fn parse_cast() {\n    let sql = \"SELECT CAST(id AS BIGINT) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Cast {\n            expr: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            data_type: DataType::BigInt(None),\n            format: None,\n        },\n        expr_from_projection(only(&select.projection))\n    );\n\n    let sql = \"SELECT CAST(id AS TINYINT) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Cast {\n            expr: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            data_type: DataType::TinyInt(None),\n            format: None,\n        },\n        expr_from_projection(only(&select.projection))\n    );\n\n    one_statement_parses_to(\n        \"SELECT CAST(id AS MEDIUMINT) FROM customer\",\n        \"SELECT CAST(id AS MEDIUMINT) FROM customer\",\n    );\n\n    one_statement_parses_to(\n        \"SELECT CAST(id AS BIGINT) FROM customer\",\n        \"SELECT CAST(id AS BIGINT) FROM customer\",\n    );\n\n    verified_stmt(\"SELECT CAST(id AS NUMERIC) FROM customer\");\n\n    verified_stmt(\"SELECT CAST(id AS DEC) FROM customer\");\n\n    verified_stmt(\"SELECT CAST(id AS DECIMAL) FROM customer\");\n\n    let sql = \"SELECT CAST(id AS NVARCHAR(50)) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Cast {\n            expr: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            data_type: DataType::Nvarchar(Some(50)),\n            format: None,\n        },\n        expr_from_projection(only(&select.projection))\n    );\n\n    let sql = \"SELECT CAST(id AS CLOB) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Cast {\n            expr: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            data_type: DataType::Clob(None),\n            format: None,\n        },\n        expr_from_projection(only(&select.projection))\n    );\n\n    let sql = \"SELECT CAST(id AS CLOB(50)) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Cast {\n            expr: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            data_type: DataType::Clob(Some(50)),\n            format: None,\n        },\n        expr_from_projection(only(&select.projection))\n    );\n\n    let sql = \"SELECT CAST(id AS BINARY(50)) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Cast {\n            expr: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            data_type: DataType::Binary(Some(50)),\n            format: None,\n        },\n        expr_from_projection(only(&select.projection))\n    );\n\n    let sql = \"SELECT CAST(id AS VARBINARY(50)) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Cast {\n            expr: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            data_type: DataType::Varbinary(Some(50)),\n            format: None,\n        },\n        expr_from_projection(only(&select.projection))\n    );\n\n    let sql = \"SELECT CAST(id AS BLOB) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Cast {\n            expr: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            data_type: DataType::Blob(None),\n            format: None,\n        },\n        expr_from_projection(only(&select.projection))\n    );\n\n    let sql = \"SELECT CAST(id AS BLOB(50)) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Cast {\n            expr: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            data_type: DataType::Blob(Some(50)),\n            format: None,\n        },\n        expr_from_projection(only(&select.projection))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_try_cast", "test": "fn parse_try_cast() {\n    let sql = \"SELECT TRY_CAST(id AS BIGINT) FROM customer\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TryCast {\n            expr: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            data_type: DataType::BigInt(None),\n            format: None,\n        },\n        expr_from_projection(only(&select.projection))\n    );\n    verified_stmt(\"SELECT TRY_CAST(id AS BIGINT) FROM customer\");\n\n    verified_stmt(\"SELECT TRY_CAST(id AS NUMERIC) FROM customer\");\n\n    verified_stmt(\"SELECT TRY_CAST(id AS DEC) FROM customer\");\n\n    verified_stmt(\"SELECT TRY_CAST(id AS DECIMAL) FROM customer\");\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_extract", "test": "fn parse_extract() {\n    let sql = \"SELECT EXTRACT(YEAR FROM d)\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Extract {\n            field: DateTimeField::Year,\n            expr: Box::new(Expr::Identifier(Ident::new(\"d\"))),\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n\n    one_statement_parses_to(\"SELECT EXTRACT(year from d)\", \"SELECT EXTRACT(YEAR FROM d)\");\n\n    verified_stmt(\"SELECT EXTRACT(MONTH FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(WEEK FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(DAY FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(DAYOFWEEK FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(DAYOFYEAR FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(DATE FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(HOUR FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(MINUTE FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(SECOND FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(MILLISECOND FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(MICROSECOND FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(NANOSECOND FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(CENTURY FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(DECADE FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(DOW FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(DOY FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(EPOCH FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(ISODOW FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(ISOWEEK FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(ISOYEAR FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(JULIAN FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(MICROSECOND FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(MICROSECONDS FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(MILLENIUM FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(MILLENNIUM FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(MILLISECOND FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(MILLISECONDS FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(QUARTER FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(TIMEZONE FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(TIMEZONE_HOUR FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(TIMEZONE_MINUTE FROM d)\");\n    verified_stmt(\"SELECT EXTRACT(TIME FROM d)\");\n\n    let res = parse_sql_statements(\"SELECT EXTRACT(JIFFY FROM d)\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected date/time field, found: JIFFY\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_ceil_datetime", "test": "fn parse_ceil_datetime() {\n    let sql = \"SELECT CEIL(d TO DAY)\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Ceil {\n            expr: Box::new(Expr::Identifier(Ident::new(\"d\"))),\n            field: DateTimeField::Day,\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n\n    one_statement_parses_to(\"SELECT CEIL(d to day)\", \"SELECT CEIL(d TO DAY)\");\n\n    verified_stmt(\"SELECT CEIL(d TO HOUR) FROM df\");\n    verified_stmt(\"SELECT CEIL(d TO MINUTE) FROM df\");\n    verified_stmt(\"SELECT CEIL(d TO SECOND) FROM df\");\n    verified_stmt(\"SELECT CEIL(d TO MILLISECOND) FROM df\");\n\n    let res = parse_sql_statements(\"SELECT CEIL(d TO JIFFY) FROM df\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected date/time field, found: JIFFY\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_floor_datetime", "test": "fn parse_floor_datetime() {\n    let sql = \"SELECT FLOOR(d TO DAY)\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Floor {\n            expr: Box::new(Expr::Identifier(Ident::new(\"d\"))),\n            field: DateTimeField::Day,\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n\n    one_statement_parses_to(\"SELECT FLOOR(d to day)\", \"SELECT FLOOR(d TO DAY)\");\n\n    verified_stmt(\"SELECT FLOOR(d TO HOUR) FROM df\");\n    verified_stmt(\"SELECT FLOOR(d TO MINUTE) FROM df\");\n    verified_stmt(\"SELECT FLOOR(d TO SECOND) FROM df\");\n    verified_stmt(\"SELECT FLOOR(d TO MILLISECOND) FROM df\");\n\n    let res = parse_sql_statements(\"SELECT FLOOR(d TO JIFFY) FROM df\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected date/time field, found: JIFFY\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_listagg", "test": "fn parse_listagg() {\n    let sql = \"SELECT LISTAGG(DISTINCT dateid, ', ' ON OVERFLOW TRUNCATE '%' WITHOUT COUNT) \\\n               WITHIN GROUP (ORDER BY id, username)\";\n    let select = verified_only_select(sql);\n\n    verified_stmt(\"SELECT LISTAGG(sellerid) WITHIN GROUP (ORDER BY dateid)\");\n    verified_stmt(\"SELECT LISTAGG(dateid)\");\n    verified_stmt(\"SELECT LISTAGG(DISTINCT dateid)\");\n    verified_stmt(\"SELECT LISTAGG(dateid ON OVERFLOW ERROR)\");\n    verified_stmt(\"SELECT LISTAGG(dateid ON OVERFLOW TRUNCATE N'...' WITH COUNT)\");\n    verified_stmt(\"SELECT LISTAGG(dateid ON OVERFLOW TRUNCATE X'deadbeef' WITH COUNT)\");\n\n    let expr = Box::new(Expr::Identifier(Ident::new(\"dateid\")));\n    let on_overflow = Some(ListAggOnOverflow::Truncate {\n        filler: Some(Box::new(Expr::Value(Value::SingleQuotedString(\n            \"%\".to_string(),\n        )))),\n        with_count: false,\n    });\n    let within_group = vec![\n        OrderByExpr {\n            expr: Expr::Identifier(Ident {\n                value: \"id\".to_string(),\n                quote_style: None,\n            }),\n            asc: None,\n            nulls_first: None,\n        },\n        OrderByExpr {\n            expr: Expr::Identifier(Ident {\n                value: \"username\".to_string(),\n                quote_style: None,\n            }),\n            asc: None,\n            nulls_first: None,\n        },\n    ];\n    assert_eq!(\n        &Expr::ListAgg(ListAgg {\n            distinct: true,\n            expr,\n            separator: Some(Box::new(Expr::Value(Value::SingleQuotedString(\n                \", \".to_string()\n            )))),\n            on_overflow,\n            within_group,\n        }),\n        expr_from_projection(only(&select.projection))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_table", "test": "fn parse_create_table() {\n    let sql = \"CREATE TABLE uk_cities (\\\n               name VARCHAR(100) NOT NULL,\\\n               lat DOUBLE NULL,\\\n               lng DOUBLE,\n               constrained INT NULL CONSTRAINT pkey PRIMARY KEY NOT NULL UNIQUE CHECK (constrained > 0),\n               ref INT REFERENCES othertable (a, b),\\\n               ref2 INT references othertable2 on delete cascade on update no action,\\\n               constraint fkey foreign key (lat) references othertable3 (lat) on delete restrict,\\\n               constraint fkey2 foreign key (lat) references othertable4(lat) on delete no action on update restrict, \\\n               foreign key (lat) references othertable4(lat) on update set default on delete cascade, \\\n               FOREIGN KEY (lng) REFERENCES othertable4 (longitude) ON UPDATE SET NULL\n               )\";\n    let ast = one_statement_parses_to(\n        sql,\n        \"CREATE TABLE uk_cities (\\\n         name VARCHAR(100) NOT NULL, \\\n         lat DOUBLE NULL, \\\n         lng DOUBLE, \\\n         constrained INT NULL CONSTRAINT pkey PRIMARY KEY NOT NULL UNIQUE CHECK (constrained > 0), \\\n         ref INT REFERENCES othertable (a, b), \\\n         ref2 INT REFERENCES othertable2 ON DELETE CASCADE ON UPDATE NO ACTION, \\\n         CONSTRAINT fkey FOREIGN KEY (lat) REFERENCES othertable3(lat) ON DELETE RESTRICT, \\\n         CONSTRAINT fkey2 FOREIGN KEY (lat) REFERENCES othertable4(lat) ON DELETE NO ACTION ON UPDATE RESTRICT, \\\n         FOREIGN KEY (lat) REFERENCES othertable4(lat) ON DELETE CASCADE ON UPDATE SET DEFAULT, \\\n         FOREIGN KEY (lng) REFERENCES othertable4(longitude) ON UPDATE SET NULL)\",\n    );\n    match ast {\n        Statement::CreateTable {\n            name,\n            columns,\n            constraints,\n            with_options,\n            if_not_exists: false,\n            external: false,\n            file_format: None,\n            location: None,\n            ..\n        } => {\n            assert_eq!(\"uk_cities\", name.to_string());\n            assert_eq!(\n                columns,\n                vec![\n                    ColumnDef {\n                        name: \"name\".into(),\n                        data_type: DataType::Varchar(Some(CharacterLength {\n                            length: 100,\n                            unit: None,\n                        })),\n                        collation: None,\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::NotNull,\n                        }],\n                    },\n                    ColumnDef {\n                        name: \"lat\".into(),\n                        data_type: DataType::Double,\n                        collation: None,\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::Null,\n                        }],\n                    },\n                    ColumnDef {\n                        name: \"lng\".into(),\n                        data_type: DataType::Double,\n                        collation: None,\n                        options: vec![],\n                    },\n                    ColumnDef {\n                        name: \"constrained\".into(),\n                        data_type: DataType::Int(None),\n                        collation: None,\n                        options: vec![\n                            ColumnOptionDef {\n                                name: None,\n                                option: ColumnOption::Null,\n                            },\n                            ColumnOptionDef {\n                                name: Some(\"pkey\".into()),\n                                option: ColumnOption::Unique { is_primary: true },\n                            },\n                            ColumnOptionDef {\n                                name: None,\n                                option: ColumnOption::NotNull,\n                            },\n                            ColumnOptionDef {\n                                name: None,\n                                option: ColumnOption::Unique { is_primary: false },\n                            },\n                            ColumnOptionDef {\n                                name: None,\n                                option: ColumnOption::Check(verified_expr(\"constrained > 0\")),\n                            },\n                        ],\n                    },\n                    ColumnDef {\n                        name: \"ref\".into(),\n                        data_type: DataType::Int(None),\n                        collation: None,\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::ForeignKey {\n                                foreign_table: ObjectName(vec![\"othertable\".into()]),\n                                referred_columns: vec![\"a\".into(), \"b\".into()],\n                                on_delete: None,\n                                on_update: None,\n                            },\n                        }],\n                    },\n                    ColumnDef {\n                        name: \"ref2\".into(),\n                        data_type: DataType::Int(None),\n                        collation: None,\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::ForeignKey {\n                                foreign_table: ObjectName(vec![\"othertable2\".into()]),\n                                referred_columns: vec![],\n                                on_delete: Some(ReferentialAction::Cascade),\n                                on_update: Some(ReferentialAction::NoAction),\n                            },\n                        },],\n                    },\n                ]\n            );\n            assert_eq!(\n                constraints,\n                vec![\n                    TableConstraint::ForeignKey {\n                        name: Some(\"fkey\".into()),\n                        columns: vec![\"lat\".into()],\n                        foreign_table: ObjectName(vec![\"othertable3\".into()]),\n                        referred_columns: vec![\"lat\".into()],\n                        on_delete: Some(ReferentialAction::Restrict),\n                        on_update: None,\n                    },\n                    TableConstraint::ForeignKey {\n                        name: Some(\"fkey2\".into()),\n                        columns: vec![\"lat\".into()],\n                        foreign_table: ObjectName(vec![\"othertable4\".into()]),\n                        referred_columns: vec![\"lat\".into()],\n                        on_delete: Some(ReferentialAction::NoAction),\n                        on_update: Some(ReferentialAction::Restrict),\n                    },\n                    TableConstraint::ForeignKey {\n                        name: None,\n                        columns: vec![\"lat\".into()],\n                        foreign_table: ObjectName(vec![\"othertable4\".into()]),\n                        referred_columns: vec![\"lat\".into()],\n                        on_delete: Some(ReferentialAction::Cascade),\n                        on_update: Some(ReferentialAction::SetDefault),\n                    },\n                    TableConstraint::ForeignKey {\n                        name: None,\n                        columns: vec![\"lng\".into()],\n                        foreign_table: ObjectName(vec![\"othertable4\".into()]),\n                        referred_columns: vec![\"longitude\".into()],\n                        on_delete: None,\n                        on_update: Some(ReferentialAction::SetNull),\n                    },\n                ]\n            );\n            assert_eq!(with_options, vec![]);\n        }\n        _ => unreachable!(),\n    }\n\n    let res = parse_sql_statements(\"CREATE TABLE t (a int NOT NULL GARBAGE)\");\n    assert!(res\n        .unwrap_err()\n        .to_string()\n        .contains(\"Expected \\',\\' or \\')\\' after column definition, found: GARBAGE\"));\n\n    let res = parse_sql_statements(\"CREATE TABLE t (a int NOT NULL CONSTRAINT foo)\");\n    assert!(res\n        .unwrap_err()\n        .to_string()\n        .contains(\"Expected constraint details after CONSTRAINT <name>\"));\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_schema", "test": "fn parse_create_schema() {\n    let sql = \"CREATE SCHEMA X\";\n\n    match verified_stmt(sql) {\n        Statement::CreateSchema { schema_name, .. } => {\n            assert_eq!(schema_name.to_string(), \"X\".to_owned())\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_schema_with_authorization", "test": "fn parse_create_schema_with_authorization() {\n    let sql = \"CREATE SCHEMA AUTHORIZATION Y\";\n\n    match verified_stmt(sql) {\n        Statement::CreateSchema { schema_name, .. } => {\n            assert_eq!(schema_name.to_string(), \"AUTHORIZATION Y\".to_owned())\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_schema_with_name_and_authorization", "test": "fn parse_create_schema_with_name_and_authorization() {\n    let sql = \"CREATE SCHEMA X AUTHORIZATION Y\";\n\n    match verified_stmt(sql) {\n        Statement::CreateSchema { schema_name, .. } => {\n            assert_eq!(schema_name.to_string(), \"X AUTHORIZATION Y\".to_owned())\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_table_as", "test": "fn parse_create_table_as() {\n    let sql = \"CREATE TABLE t AS SELECT * FROM a\";\n\n    match verified_stmt(sql) {\n        Statement::CreateTable { name, query, .. } => {\n            assert_eq!(name.to_string(), \"t\".to_string());\n            assert_eq!(query, Some(Box::new(verified_query(\"SELECT * FROM a\"))));\n        }\n        _ => unreachable!(),\n    }\n\n    // BigQuery allows specifying table schema in CTAS\n    // ANSI SQL and PostgreSQL let you only specify the list of columns\n    // (without data types) in a CTAS, but we have yet to support that.\n    let sql = \"CREATE TABLE t (a INT, b INT) AS SELECT 1 AS b, 2 AS a\";\n    match verified_stmt(sql) {\n        Statement::CreateTable { columns, query, .. } => {\n            assert_eq!(columns.len(), 2);\n            assert_eq!(columns[0].to_string(), \"a INT\".to_string());\n            assert_eq!(columns[1].to_string(), \"b INT\".to_string());\n            assert_eq!(\n                query,\n                Some(Box::new(verified_query(\"SELECT 1 AS b, 2 AS a\")))\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_table_as_table", "test": "fn parse_create_table_as_table() {\n    let sql1 = \"CREATE TABLE new_table AS TABLE old_table\";\n\n    let expected_query1 = Box::new(Query {\n        with: None,\n        body: Box::new(SetExpr::Table(Box::new(Table {\n            table_name: Some(\"old_table\".to_string()),\n            schema_name: None,\n        }))),\n        order_by: vec![],\n        limit: None,\n        limit_by: vec![],\n        offset: None,\n        fetch: None,\n        locks: vec![],\n    });\n\n    match verified_stmt(sql1) {\n        Statement::CreateTable { query, name, .. } => {\n            assert_eq!(name, ObjectName(vec![Ident::new(\"new_table\")]));\n            assert_eq!(query.unwrap(), expected_query1);\n        }\n        _ => unreachable!(),\n    }\n\n    let sql2 = \"CREATE TABLE new_table AS TABLE schema_name.old_table\";\n\n    let expected_query2 = Box::new(Query {\n        with: None,\n        body: Box::new(SetExpr::Table(Box::new(Table {\n            table_name: Some(\"old_table\".to_string()),\n            schema_name: Some(\"schema_name\".to_string()),\n        }))),\n        order_by: vec![],\n        limit: None,\n        limit_by: vec![],\n        offset: None,\n        fetch: None,\n        locks: vec![],\n    });\n\n    match verified_stmt(sql2) {\n        Statement::CreateTable { query, name, .. } => {\n            assert_eq!(name, ObjectName(vec![Ident::new(\"new_table\")]));\n            assert_eq!(query.unwrap(), expected_query2);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_or_replace_table", "test": "fn parse_create_or_replace_table() {\n    let sql = \"CREATE OR REPLACE TABLE t (a INT)\";\n\n    match verified_stmt(sql) {\n        Statement::CreateTable {\n            name, or_replace, ..\n        } => {\n            assert_eq!(name.to_string(), \"t\".to_string());\n            assert!(or_replace);\n        }\n        _ => unreachable!(),\n    }\n\n    let sql = \"CREATE TABLE t (a INT, b INT) AS SELECT 1 AS b, 2 AS a\";\n    match verified_stmt(sql) {\n        Statement::CreateTable { columns, query, .. } => {\n            assert_eq!(columns.len(), 2);\n            assert_eq!(columns[0].to_string(), \"a INT\".to_string());\n            assert_eq!(columns[1].to_string(), \"b INT\".to_string());\n            assert_eq!(\n                query,\n                Some(Box::new(verified_query(\"SELECT 1 AS b, 2 AS a\")))\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_table_clone", "test": "fn parse_create_table_clone() {\n    let sql = \"CREATE OR REPLACE TABLE a CLONE a_tmp\";\n    match verified_stmt(sql) {\n        Statement::CreateTable { name, clone, .. } => {\n            assert_eq!(ObjectName(vec![Ident::new(\"a\")]), name);\n            assert_eq!(Some(ObjectName(vec![(Ident::new(\"a_tmp\"))])), clone)\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_external_table", "test": "fn parse_create_external_table() {\n    let sql = \"CREATE EXTERNAL TABLE uk_cities (\\\n               name VARCHAR(100) NOT NULL,\\\n               lat DOUBLE NULL,\\\n               lng DOUBLE)\\\n               STORED AS TEXTFILE LOCATION '/tmp/example.csv'\";\n    let ast = one_statement_parses_to(\n        sql,\n        \"CREATE EXTERNAL TABLE uk_cities (\\\n         name VARCHAR(100) NOT NULL, \\\n         lat DOUBLE NULL, \\\n         lng DOUBLE) \\\n         STORED AS TEXTFILE LOCATION '/tmp/example.csv'\",\n    );\n    match ast {\n        Statement::CreateTable {\n            name,\n            columns,\n            constraints,\n            with_options,\n            if_not_exists,\n            external,\n            file_format,\n            location,\n            ..\n        } => {\n            assert_eq!(\"uk_cities\", name.to_string());\n            assert_eq!(\n                columns,\n                vec![\n                    ColumnDef {\n                        name: \"name\".into(),\n                        data_type: DataType::Varchar(Some(CharacterLength {\n                            length: 100,\n                            unit: None,\n                        })),\n                        collation: None,\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::NotNull,\n                        }],\n                    },\n                    ColumnDef {\n                        name: \"lat\".into(),\n                        data_type: DataType::Double,\n                        collation: None,\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::Null,\n                        }],\n                    },\n                    ColumnDef {\n                        name: \"lng\".into(),\n                        data_type: DataType::Double,\n                        collation: None,\n                        options: vec![],\n                    },\n                ]\n            );\n            assert!(constraints.is_empty());\n\n            assert!(external);\n            assert_eq!(FileFormat::TEXTFILE, file_format.unwrap());\n            assert_eq!(\"/tmp/example.csv\", location.unwrap());\n\n            assert_eq!(with_options, vec![]);\n            assert!(!if_not_exists);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_or_replace_external_table", "test": "fn parse_create_or_replace_external_table() {\n    // Supported by at least Snowflake\n    // https://docs.snowflake.com/en/sql-reference/sql/create-external-table.html\n    let sql = \"CREATE OR REPLACE EXTERNAL TABLE uk_cities (\\\n               name VARCHAR(100) NOT NULL)\\\n               STORED AS TEXTFILE LOCATION '/tmp/example.csv'\";\n    let ast = one_statement_parses_to(\n        sql,\n        \"CREATE OR REPLACE EXTERNAL TABLE uk_cities (\\\n         name VARCHAR(100) NOT NULL) \\\n         STORED AS TEXTFILE LOCATION '/tmp/example.csv'\",\n    );\n    match ast {\n        Statement::CreateTable {\n            name,\n            columns,\n            constraints,\n            with_options,\n            if_not_exists,\n            external,\n            file_format,\n            location,\n            or_replace,\n            ..\n        } => {\n            assert_eq!(\"uk_cities\", name.to_string());\n            assert_eq!(\n                columns,\n                vec![ColumnDef {\n                    name: \"name\".into(),\n                    data_type: DataType::Varchar(Some(CharacterLength {\n                        length: 100,\n                        unit: None,\n                    })),\n                    collation: None,\n                    options: vec![ColumnOptionDef {\n                        name: None,\n                        option: ColumnOption::NotNull,\n                    }],\n                },]\n            );\n            assert!(constraints.is_empty());\n\n            assert!(external);\n            assert_eq!(FileFormat::TEXTFILE, file_format.unwrap());\n            assert_eq!(\"/tmp/example.csv\", location.unwrap());\n\n            assert_eq!(with_options, vec![]);\n            assert!(!if_not_exists);\n            assert!(or_replace);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_alter_index", "test": "fn parse_alter_index() {\n    let rename_index = \"ALTER INDEX idx RENAME TO new_idx\";\n    match verified_stmt(rename_index) {\n        Statement::AlterIndex {\n            name,\n            operation: AlterIndexOperation::RenameIndex { index_name },\n        } => {\n            assert_eq!(\"idx\", name.to_string());\n            assert_eq!(\"new_idx\", index_name.to_string())\n        }\n        _ => unreachable!(),\n    };\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_alter_view", "test": "fn parse_alter_view() {\n    let sql = \"ALTER VIEW myschema.myview AS SELECT foo FROM bar\";\n    match verified_stmt(sql) {\n        Statement::AlterView {\n            name,\n            columns,\n            query,\n            with_options,\n        } => {\n            assert_eq!(\"myschema.myview\", name.to_string());\n            assert_eq!(Vec::<Ident>::new(), columns);\n            assert_eq!(\"SELECT foo FROM bar\", query.to_string());\n            assert_eq!(with_options, vec![]);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_alter_view_with_columns", "test": "fn parse_alter_view_with_columns() {\n    let sql = \"ALTER VIEW v (has, cols) AS SELECT 1, 2\";\n    match verified_stmt(sql) {\n        Statement::AlterView {\n            name,\n            columns,\n            query,\n            with_options,\n        } => {\n            assert_eq!(\"v\", name.to_string());\n            assert_eq!(columns, vec![Ident::new(\"has\"), Ident::new(\"cols\")]);\n            assert_eq!(\"SELECT 1, 2\", query.to_string());\n            assert_eq!(with_options, vec![]);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_alter_table_constraints", "test": "fn parse_alter_table_constraints() {\n    check_one(\"CONSTRAINT address_pkey PRIMARY KEY (address_id)\");\n    check_one(\"CONSTRAINT uk_task UNIQUE (report_date, task_id)\");\n    check_one(\n        \"CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) \\\n         REFERENCES public.address(address_id)\",\n    );\n    check_one(\"CONSTRAINT ck CHECK (rtrim(ltrim(REF_CODE)) <> '')\");\n\n    check_one(\"PRIMARY KEY (foo, bar)\");\n    check_one(\"UNIQUE (id)\");\n    check_one(\"FOREIGN KEY (foo, bar) REFERENCES AnotherTable(foo, bar)\");\n    check_one(\"CHECK (end_date > start_date OR end_date IS NULL)\");\n\n    fn check_one(constraint_text: &str) {\n        match alter_table_op(verified_stmt(&format!(\n            \"ALTER TABLE tab ADD {constraint_text}\"\n        ))) {\n            AlterTableOperation::AddConstraint(constraint) => {\n                assert_eq!(constraint_text, constraint.to_string());\n            }\n            _ => unreachable!(),\n        }\n        verified_stmt(&format!(\"CREATE TABLE foo (id INT, {constraint_text})\"));\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_alter_table_drop_column", "test": "fn parse_alter_table_drop_column() {\n    check_one(\"DROP COLUMN IF EXISTS is_active CASCADE\");\n    one_statement_parses_to(\n        \"ALTER TABLE tab DROP IF EXISTS is_active CASCADE\",\n        \"ALTER TABLE tab DROP COLUMN IF EXISTS is_active CASCADE\",\n    );\n    one_statement_parses_to(\n        \"ALTER TABLE tab DROP is_active CASCADE\",\n        \"ALTER TABLE tab DROP COLUMN is_active CASCADE\",\n    );\n\n    fn check_one(constraint_text: &str) {\n        match alter_table_op(verified_stmt(&format!(\"ALTER TABLE tab {constraint_text}\"))) {\n            AlterTableOperation::DropColumn {\n                column_name,\n                if_exists,\n                cascade,\n            } => {\n                assert_eq!(\"is_active\", column_name.to_string());\n                assert!(if_exists);\n                assert!(cascade);\n            }\n            _ => unreachable!(),\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_alter_table_alter_column", "test": "fn parse_alter_table_alter_column() {\n    let alter_stmt = \"ALTER TABLE tab\";\n    match alter_table_op(verified_stmt(&format!(\n        \"{alter_stmt} ALTER COLUMN is_active SET NOT NULL\"\n    ))) {\n        AlterTableOperation::AlterColumn { column_name, op } => {\n            assert_eq!(\"is_active\", column_name.to_string());\n            assert_eq!(op, AlterColumnOperation::SetNotNull {});\n        }\n        _ => unreachable!(),\n    }\n\n    one_statement_parses_to(\n        \"ALTER TABLE tab ALTER is_active DROP NOT NULL\",\n        \"ALTER TABLE tab ALTER COLUMN is_active DROP NOT NULL\",\n    );\n\n    match alter_table_op(verified_stmt(&format!(\n        \"{alter_stmt} ALTER COLUMN is_active SET DEFAULT false\"\n    ))) {\n        AlterTableOperation::AlterColumn { column_name, op } => {\n            assert_eq!(\"is_active\", column_name.to_string());\n            assert_eq!(\n                op,\n                AlterColumnOperation::SetDefault {\n                    value: Expr::Value(Value::Boolean(false))\n                }\n            );\n        }\n        _ => unreachable!(),\n    }\n\n    match alter_table_op(verified_stmt(&format!(\n        \"{alter_stmt} ALTER COLUMN is_active DROP DEFAULT\"\n    ))) {\n        AlterTableOperation::AlterColumn { column_name, op } => {\n            assert_eq!(\"is_active\", column_name.to_string());\n            assert_eq!(op, AlterColumnOperation::DropDefault {});\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_alter_table_alter_column_type", "test": "fn parse_alter_table_alter_column_type() {\n    let alter_stmt = \"ALTER TABLE tab\";\n    match alter_table_op(verified_stmt(\n        \"ALTER TABLE tab ALTER COLUMN is_active SET DATA TYPE TEXT\",\n    )) {\n        AlterTableOperation::AlterColumn { column_name, op } => {\n            assert_eq!(\"is_active\", column_name.to_string());\n            assert_eq!(\n                op,\n                AlterColumnOperation::SetDataType {\n                    data_type: DataType::Text,\n                    using: None,\n                }\n            );\n        }\n        _ => unreachable!(),\n    }\n\n    let dialect = TestedDialects {\n        dialects: vec![Box::new(GenericDialect {})],\n        options: None,\n    };\n\n    let res =\n        dialect.parse_sql_statements(&format!(\"{alter_stmt} ALTER COLUMN is_active TYPE TEXT\"));\n    assert_eq!(\n        ParserError::ParserError(\"Expected SET/DROP NOT NULL, SET DEFAULT, SET DATA TYPE after ALTER COLUMN, found: TYPE\".to_string()),\n        res.unwrap_err()\n    );\n\n    let res = dialect.parse_sql_statements(&format!(\n        \"{alter_stmt} ALTER COLUMN is_active SET DATA TYPE TEXT USING 'text'\"\n    ));\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: USING\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_alter_table_drop_constraint", "test": "fn parse_alter_table_drop_constraint() {\n    let alter_stmt = \"ALTER TABLE tab\";\n    match alter_table_op(verified_stmt(\n        \"ALTER TABLE tab DROP CONSTRAINT constraint_name CASCADE\",\n    )) {\n        AlterTableOperation::DropConstraint {\n            name: constr_name,\n            if_exists,\n            cascade,\n        } => {\n            assert_eq!(\"constraint_name\", constr_name.to_string());\n            assert!(!if_exists);\n            assert!(cascade);\n        }\n        _ => unreachable!(),\n    }\n    match alter_table_op(verified_stmt(\n        \"ALTER TABLE tab DROP CONSTRAINT IF EXISTS constraint_name\",\n    )) {\n        AlterTableOperation::DropConstraint {\n            name: constr_name,\n            if_exists,\n            cascade,\n        } => {\n            assert_eq!(\"constraint_name\", constr_name.to_string());\n            assert!(if_exists);\n            assert!(!cascade);\n        }\n        _ => unreachable!(),\n    }\n\n    let res = parse_sql_statements(&format!(\"{alter_stmt} DROP CONSTRAINT is_active TEXT\"));\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: TEXT\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_bad_constraint", "test": "fn parse_bad_constraint() {\n    let res = parse_sql_statements(\"ALTER TABLE tab ADD\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected identifier, found: EOF\".to_string()),\n        res.unwrap_err()\n    );\n\n    let res = parse_sql_statements(\"CREATE TABLE tab (foo int,\");\n    assert_eq!(\n        ParserError::ParserError(\n            \"Expected column name or constraint definition, found: EOF\".to_string()\n        ),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_scalar_function_in_projection", "test": "fn parse_scalar_function_in_projection() {\n    let names = vec![\"sqrt\", \"foo\"];\n\n    for function_name in names {\n        // like SELECT sqrt(id) FROM foo\n        let sql = dbg!(format!(\"SELECT {function_name}(id) FROM foo\"));\n        let select = verified_only_select(&sql);\n        assert_eq!(\n            &Expr::Function(Function {\n                name: ObjectName(vec![Ident::new(function_name)]),\n                args: vec![FunctionArg::Unnamed(FunctionArgExpr::Expr(\n                    Expr::Identifier(Ident::new(\"id\"))\n                ))],\n                null_treatment: None,\n                filter: None,\n                over: None,\n                distinct: false,\n                special: false,\n                order_by: vec![],\n            }),\n            expr_from_projection(only(&select.projection))\n        );\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_named_argument_function", "test": "fn parse_named_argument_function() {\n    let sql = \"SELECT FUN(a => '1', b => '2') FROM foo\";\n    let select = verified_only_select(sql);\n\n    assert_eq!(\n        &Expr::Function(Function {\n            name: ObjectName(vec![Ident::new(\"FUN\")]),\n            args: vec![\n                FunctionArg::Named {\n                    name: Ident::new(\"a\"),\n                    arg: FunctionArgExpr::Expr(Expr::Value(Value::SingleQuotedString(\n                        \"1\".to_owned()\n                    ))),\n                },\n                FunctionArg::Named {\n                    name: Ident::new(\"b\"),\n                    arg: FunctionArgExpr::Expr(Expr::Value(Value::SingleQuotedString(\n                        \"2\".to_owned()\n                    ))),\n                },\n            ],\n            null_treatment: None,\n            filter: None,\n            over: None,\n            distinct: false,\n            special: false,\n            order_by: vec![],\n        }),\n        expr_from_projection(only(&select.projection))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_window_functions", "test": "fn parse_window_functions() {\n    let sql = \"SELECT row_number() OVER (ORDER BY dt DESC), \\\n               sum(foo) OVER (PARTITION BY a, b ORDER BY c, d \\\n               ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), \\\n               avg(bar) OVER (ORDER BY a \\\n               RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING), \\\n               sum(bar) OVER (ORDER BY a \\\n               RANGE BETWEEN INTERVAL '1' DAY PRECEDING AND INTERVAL '1 MONTH' FOLLOWING), \\\n               COUNT(*) OVER (ORDER BY a \\\n               RANGE BETWEEN INTERVAL '1 DAY' PRECEDING AND INTERVAL '1 DAY' FOLLOWING), \\\n               max(baz) OVER (ORDER BY a \\\n               ROWS UNBOUNDED PRECEDING), \\\n               sum(qux) OVER (ORDER BY a \\\n               GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING) \\\n               FROM foo\";\n    let select = verified_only_select(sql);\n    assert_eq!(7, select.projection.len());\n    assert_eq!(\n        &Expr::Function(Function {\n            name: ObjectName(vec![Ident::new(\"row_number\")]),\n            args: vec![],\n            null_treatment: None,\n            filter: None,\n            over: Some(WindowType::WindowSpec(WindowSpec {\n                partition_by: vec![],\n                order_by: vec![OrderByExpr {\n                    expr: Expr::Identifier(Ident::new(\"dt\")),\n                    asc: Some(false),\n                    nulls_first: None,\n                }],\n                window_frame: None,\n            })),\n            distinct: false,\n            special: false,\n            order_by: vec![],\n        }),\n        expr_from_projection(&select.projection[0])\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_literal_decimal", "test": "fn parse_literal_decimal() {\n    // These numbers were explicitly chosen to not roundtrip if represented as\n    // f64s (i.e., as 64-bit binary floating point numbers).\n    let sql = \"SELECT 0.300000000000000004, 9007199254740993.0\";\n    let select = verified_only_select(sql);\n    assert_eq!(2, select.projection.len());\n    assert_eq!(\n        &Expr::Value(number(\"0.300000000000000004\")),\n        expr_from_projection(&select.projection[0]),\n    );\n    assert_eq!(\n        &Expr::Value(number(\"9007199254740993.0\")),\n        expr_from_projection(&select.projection[1]),\n    )\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_literal_string", "test": "fn parse_literal_string() {\n    let sql = \"SELECT 'one', N'national string', X'deadBEEF'\";\n    let select = verified_only_select(sql);\n    assert_eq!(3, select.projection.len());\n    assert_eq!(\n        &Expr::Value(Value::SingleQuotedString(\"one\".to_string())),\n        expr_from_projection(&select.projection[0])\n    );\n    assert_eq!(\n        &Expr::Value(Value::NationalStringLiteral(\"national string\".to_string())),\n        expr_from_projection(&select.projection[1])\n    );\n    assert_eq!(\n        &Expr::Value(Value::HexStringLiteral(\"deadBEEF\".to_string())),\n        expr_from_projection(&select.projection[2])\n    );\n\n    one_statement_parses_to(\"SELECT x'deadBEEF'\", \"SELECT X'deadBEEF'\");\n    one_statement_parses_to(\"SELECT n'national string'\", \"SELECT N'national string'\");\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_literal_date", "test": "fn parse_literal_date() {\n    let sql = \"SELECT DATE '1999-01-01'\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::Date,\n            value: \"1999-01-01\".into(),\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_literal_time", "test": "fn parse_literal_time() {\n    let sql = \"SELECT TIME '01:23:34'\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::Time(None, TimezoneInfo::None),\n            value: \"01:23:34\".into(),\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_literal_datetime", "test": "fn parse_literal_datetime() {\n    let sql = \"SELECT DATETIME '1999-01-01 01:23:34.45'\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::Datetime(None),\n            value: \"1999-01-01 01:23:34.45\".into(),\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_literal_timestamp_without_time_zone", "test": "fn parse_literal_timestamp_without_time_zone() {\n    let sql = \"SELECT TIMESTAMP '1999-01-01 01:23:34'\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::Timestamp(None, TimezoneInfo::None),\n            value: \"1999-01-01 01:23:34\".into(),\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n\n    one_statement_parses_to(\"SELECT TIMESTAMP '1999-01-01 01:23:34'\", sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_literal_timestamp_with_time_zone", "test": "fn parse_literal_timestamp_with_time_zone() {\n    let sql = \"SELECT TIMESTAMPTZ '1999-01-01 01:23:34Z'\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::Timestamp(None, TimezoneInfo::Tz),\n            value: \"1999-01-01 01:23:34Z\".into(),\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n\n    one_statement_parses_to(\"SELECT TIMESTAMPTZ '1999-01-01 01:23:34Z'\", sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_interval", "test": "fn parse_interval() {\n    let sql = \"SELECT INTERVAL '1-1' YEAR TO MONTH\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Interval(Interval {\n            value: Box::new(Expr::Value(Value::SingleQuotedString(String::from(\"1-1\")))),\n            leading_field: Some(DateTimeField::Year),\n            leading_precision: None,\n            last_field: Some(DateTimeField::Month),\n            fractional_seconds_precision: None,\n        }),\n        expr_from_projection(only(&select.projection)),\n    );\n\n    let sql = \"SELECT INTERVAL '01:01.01' MINUTE (5) TO SECOND (5)\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Interval(Interval {\n            value: Box::new(Expr::Value(Value::SingleQuotedString(String::from(\n                \"01:01.01\"\n            )))),\n            leading_field: Some(DateTimeField::Minute),\n            leading_precision: Some(5),\n            last_field: Some(DateTimeField::Second),\n            fractional_seconds_precision: Some(5),\n        }),\n        expr_from_projection(only(&select.projection)),\n    );\n\n    let sql = \"SELECT INTERVAL '1' SECOND (5, 4)\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Interval(Interval {\n            value: Box::new(Expr::Value(Value::SingleQuotedString(String::from(\"1\")))),\n            leading_field: Some(DateTimeField::Second),\n            leading_precision: Some(5),\n            last_field: None,\n            fractional_seconds_precision: Some(4),\n        }),\n        expr_from_projection(only(&select.projection)),\n    );\n\n    let sql = \"SELECT INTERVAL '10' HOUR\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Interval(Interval {\n            value: Box::new(Expr::Value(Value::SingleQuotedString(String::from(\"10\")))),\n            leading_field: Some(DateTimeField::Hour),\n            leading_precision: None,\n            last_field: None,\n            fractional_seconds_precision: None,\n        }),\n        expr_from_projection(only(&select.projection)),\n    );\n\n    let sql = \"SELECT INTERVAL 5 DAY\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Interval(Interval {\n            value: Box::new(Expr::Value(number(\"5\"))),\n            leading_field: Some(DateTimeField::Day),\n            leading_precision: None,\n            last_field: None,\n            fractional_seconds_precision: None,\n        }),\n        expr_from_projection(only(&select.projection)),\n    );\n\n    let sql = \"SELECT INTERVAL 1 + 1 DAY\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Interval(Interval {\n            value: Box::new(Expr::BinaryOp {\n                left: Box::new(Expr::Value(number(\"1\"))),\n                op: BinaryOperator::Plus,\n                right: Box::new(Expr::Value(number(\"1\"))),\n            }),\n            leading_field: Some(DateTimeField::Day),\n            leading_precision: None,\n            last_field: None,\n            fractional_seconds_precision: None,\n        }),\n        expr_from_projection(only(&select.projection)),\n    );\n\n    let sql = \"SELECT INTERVAL '10' HOUR (1)\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Interval(Interval {\n            value: Box::new(Expr::Value(Value::SingleQuotedString(String::from(\"10\")))),\n            leading_field: Some(DateTimeField::Hour),\n            leading_precision: Some(1),\n            last_field: None,\n            fractional_seconds_precision: None,\n        }),\n        expr_from_projection(only(&select.projection)),\n    );\n\n    let sql = \"SELECT INTERVAL '1 DAY'\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Interval(Interval {\n            value: Box::new(Expr::Value(Value::SingleQuotedString(String::from(\n                \"1 DAY\"\n            )))),\n            leading_field: None,\n            leading_precision: None,\n            last_field: None,\n            fractional_seconds_precision: None,\n        }),\n        expr_from_projection(only(&select.projection)),\n    );\n\n    let result = parse_sql_statements(\"SELECT INTERVAL '1' SECOND TO SECOND\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: SECOND\".to_string()),\n        result.unwrap_err(),\n    );\n\n    let result = parse_sql_statements(\"SELECT INTERVAL '10' HOUR (1) TO HOUR (2)\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: (\".to_string()),\n        result.unwrap_err(),\n    );\n\n    verified_only_select(\"SELECT INTERVAL '1' YEAR\");\n    verified_only_select(\"SELECT INTERVAL '1' MONTH\");\n    verified_only_select(\"SELECT INTERVAL '1' DAY\");\n    verified_only_select(\"SELECT INTERVAL '1' HOUR\");\n    verified_only_select(\"SELECT INTERVAL '1' MINUTE\");\n    verified_only_select(\"SELECT INTERVAL '1' SECOND\");\n    verified_only_select(\"SELECT INTERVAL '1' YEAR TO MONTH\");\n    verified_only_select(\"SELECT INTERVAL '1' DAY TO HOUR\");\n    verified_only_select(\"SELECT INTERVAL '1' DAY TO MINUTE\");\n    verified_only_select(\"SELECT INTERVAL '1' DAY TO SECOND\");\n    verified_only_select(\"SELECT INTERVAL '1' HOUR TO MINUTE\");\n    verified_only_select(\"SELECT INTERVAL '1' HOUR TO SECOND\");\n    verified_only_select(\"SELECT INTERVAL '1' MINUTE TO SECOND\");\n    verified_only_select(\"SELECT INTERVAL '1 YEAR'\");\n    verified_only_select(\"SELECT INTERVAL '1 YEAR' AS one_year\");\n    one_statement_parses_to(\n        \"SELECT INTERVAL '1 YEAR' one_year\",\n        \"SELECT INTERVAL '1 YEAR' AS one_year\",\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_at_timezone", "test": "fn parse_at_timezone() {\n    let zero = Expr::Value(number(\"0\"));\n    let sql = \"SELECT FROM_UNIXTIME(0) AT TIME ZONE 'UTC-06:00' FROM t\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::AtTimeZone {\n            timestamp: Box::new(Expr::Function(Function {\n                name: ObjectName(vec![Ident {\n                    value: \"FROM_UNIXTIME\".to_string(),\n                    quote_style: None,\n                }]),\n                args: vec![FunctionArg::Unnamed(FunctionArgExpr::Expr(zero.clone()))],\n                null_treatment: None,\n                filter: None,\n                over: None,\n                distinct: false,\n                special: false,\n                order_by: vec![],\n            })),\n            time_zone: \"UTC-06:00\".to_string(),\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n\n    let sql = r#\"SELECT DATE_FORMAT(FROM_UNIXTIME(0) AT TIME ZONE 'UTC-06:00', '%Y-%m-%dT%H') AS \"hour\" FROM t\"#;\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &SelectItem::ExprWithAlias {\n            expr: Expr::Function(Function {\n                name: ObjectName(vec![Ident {\n                    value: \"DATE_FORMAT\".to_string(),\n                    quote_style: None,\n                },],),\n                args: vec![\n                    FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::AtTimeZone {\n                        timestamp: Box::new(Expr::Function(Function {\n                            name: ObjectName(vec![Ident {\n                                value: \"FROM_UNIXTIME\".to_string(),\n                                quote_style: None,\n                            },],),\n                            args: vec![FunctionArg::Unnamed(FunctionArgExpr::Expr(zero))],\n                            null_treatment: None,\n                            filter: None,\n                            over: None,\n                            distinct: false,\n                            special: false,\n                            order_by: vec![],\n                        },)),\n                        time_zone: \"UTC-06:00\".to_string(),\n                    },),),\n                    FunctionArg::Unnamed(FunctionArgExpr::Expr(Expr::Value(\n                        Value::SingleQuotedString(\"%Y-%m-%dT%H\".to_string()),\n                    ),),),\n                ],\n                null_treatment: None,\n                filter: None,\n                over: None,\n                distinct: false,\n                special: false,\n                order_by: vec![],\n            },),\n            alias: Ident {\n                value: \"hour\".to_string(),\n                quote_style: Some('\"'),\n            },\n        },\n        only(&select.projection),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_json_keyword", "test": "fn parse_json_keyword() {\n    let sql = r#\"SELECT JSON '{\n  \"id\": 10,\n  \"type\": \"fruit\",\n  \"name\": \"apple\",\n  \"on_menu\": true,\n  \"recipes\":\n    {\n      \"salads\":\n      [\n        { \"id\": 2001, \"type\": \"Walnut Apple Salad\" },\n        { \"id\": 2002, \"type\": \"Apple Spinach Salad\" }\n      ],\n      \"desserts\":\n      [\n        { \"id\": 3001, \"type\": \"Apple Pie\" },\n        { \"id\": 3002, \"type\": \"Apple Scones\" },\n        { \"id\": 3003, \"type\": \"Apple Crumble\" }\n      ]\n    }\n}'\"#;\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::JSON,\n            value: r#\"{\n  \"id\": 10,\n  \"type\": \"fruit\",\n  \"name\": \"apple\",\n  \"on_menu\": true,\n  \"recipes\":\n    {\n      \"salads\":\n      [\n        { \"id\": 2001, \"type\": \"Walnut Apple Salad\" },\n        { \"id\": 2002, \"type\": \"Apple Spinach Salad\" }\n      ],\n      \"desserts\":\n      [\n        { \"id\": 3001, \"type\": \"Apple Pie\" },\n        { \"id\": 3002, \"type\": \"Apple Scones\" },\n        { \"id\": 3003, \"type\": \"Apple Crumble\" }\n      ]\n    }\n}\"#\n            .into()\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_bignumeric_keyword", "test": "fn parse_bignumeric_keyword() {\n    let sql = r#\"SELECT BIGNUMERIC '0'\"#;\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::BigNumeric(ExactNumberInfo::None),\n            value: r#\"0\"#.into()\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n    verified_stmt(\"SELECT BIGNUMERIC '0'\");\n\n    let sql = r#\"SELECT BIGNUMERIC '123456'\"#;\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::BigNumeric(ExactNumberInfo::None),\n            value: r#\"123456\"#.into()\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n    verified_stmt(\"SELECT BIGNUMERIC '123456'\");\n\n    let sql = r#\"SELECT BIGNUMERIC '-3.14'\"#;\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::BigNumeric(ExactNumberInfo::None),\n            value: r#\"-3.14\"#.into()\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n    verified_stmt(\"SELECT BIGNUMERIC '-3.14'\");\n\n    let sql = r#\"SELECT BIGNUMERIC '-0.54321'\"#;\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::BigNumeric(ExactNumberInfo::None),\n            value: r#\"-0.54321\"#.into()\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n    verified_stmt(\"SELECT BIGNUMERIC '-0.54321'\");\n\n    let sql = r#\"SELECT BIGNUMERIC '1.23456e05'\"#;\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::BigNumeric(ExactNumberInfo::None),\n            value: r#\"1.23456e05\"#.into()\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n    verified_stmt(\"SELECT BIGNUMERIC '1.23456e05'\");\n\n    let sql = r#\"SELECT BIGNUMERIC '-9.876e-3'\"#;\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::TypedString {\n            data_type: DataType::BigNumeric(ExactNumberInfo::None),\n            value: r#\"-9.876e-3\"#.into()\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n    verified_stmt(\"SELECT BIGNUMERIC '-9.876e-3'\");\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_parens", "test": "fn parse_parens() {\n    use self::BinaryOperator::*;\n    use self::Expr::*;\n    let sql = \"(a + b) - (c + d)\";\n    assert_eq!(\n        BinaryOp {\n            left: Box::new(Nested(Box::new(BinaryOp {\n                left: Box::new(Identifier(Ident::new(\"a\"))),\n                op: Plus,\n                right: Box::new(Identifier(Ident::new(\"b\"))),\n            }))),\n            op: Minus,\n            right: Box::new(Nested(Box::new(BinaryOp {\n                left: Box::new(Identifier(Ident::new(\"c\"))),\n                op: Plus,\n                right: Box::new(Identifier(Ident::new(\"d\"))),\n            }))),\n        },\n        verified_expr(sql)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_searched_case_expr", "test": "fn parse_searched_case_expr() {\n    let sql = \"SELECT CASE WHEN bar IS NULL THEN 'null' WHEN bar = 0 THEN '=0' WHEN bar >= 0 THEN '>=0' ELSE '<0' END FROM foo\";\n    use self::BinaryOperator::*;\n    use self::Expr::{BinaryOp, Case, Identifier, IsNull};\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Case {\n            operand: None,\n            conditions: vec![\n                IsNull(Box::new(Identifier(Ident::new(\"bar\")))),\n                BinaryOp {\n                    left: Box::new(Identifier(Ident::new(\"bar\"))),\n                    op: Eq,\n                    right: Box::new(Expr::Value(number(\"0\"))),\n                },\n                BinaryOp {\n                    left: Box::new(Identifier(Ident::new(\"bar\"))),\n                    op: GtEq,\n                    right: Box::new(Expr::Value(number(\"0\"))),\n                },\n            ],\n            results: vec![\n                Expr::Value(Value::SingleQuotedString(\"null\".to_string())),\n                Expr::Value(Value::SingleQuotedString(\"=0\".to_string())),\n                Expr::Value(Value::SingleQuotedString(\">=0\".to_string())),\n            ],\n            else_result: Some(Box::new(Expr::Value(Value::SingleQuotedString(\n                \"<0\".to_string()\n            )))),\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_simple_case_expr", "test": "fn parse_simple_case_expr() {\n    // ANSI calls a CASE expression with an operand \"<simple case>\"\n    let sql = \"SELECT CASE foo WHEN 1 THEN 'Y' ELSE 'N' END\";\n    let select = verified_only_select(sql);\n    use self::Expr::{Case, Identifier};\n    assert_eq!(\n        &Case {\n            operand: Some(Box::new(Identifier(Ident::new(\"foo\")))),\n            conditions: vec![Expr::Value(number(\"1\"))],\n            results: vec![Expr::Value(Value::SingleQuotedString(\"Y\".to_string()))],\n            else_result: Some(Box::new(Expr::Value(Value::SingleQuotedString(\n                \"N\".to_string()\n            )))),\n        },\n        expr_from_projection(only(&select.projection)),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_cross_join", "test": "fn parse_cross_join() {\n    let sql = \"SELECT * FROM t1 CROSS JOIN t2\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        Join {\n            relation: TableFactor::Table {\n                name: ObjectName(vec![Ident::new(\"t2\")]),\n                alias: None,\n                args: None,\n                with_hints: vec![],\n                version: None,\n                partitions: vec![],\n            },\n            join_operator: JoinOperator::CrossJoin,\n        },\n        only(only(select.from).joins),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_joins_on", "test": "fn parse_joins_on() {\n    fn join_with_constraint(\n        relation: impl Into<String>,\n        alias: Option<TableAlias>,\n        f: impl Fn(JoinConstraint) -> JoinOperator,\n    ) -> Join {\n        Join {\n            relation: TableFactor::Table {\n                name: ObjectName(vec![Ident::new(relation.into())]),\n                alias,\n                args: None,\n                with_hints: vec![],\n                version: None,\n                partitions: vec![],\n            },\n            join_operator: f(JoinConstraint::On(Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"c1\".into())),\n                op: BinaryOperator::Eq,\n                right: Box::new(Expr::Identifier(\"c2\".into())),\n            })),\n        }\n    }\n    // Test parsing of aliases\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 JOIN t2 AS foo ON c1 = c2\").from).joins,\n        vec![join_with_constraint(\n            \"t2\",\n            table_alias(\"foo\"),\n            JoinOperator::Inner,\n        )]\n    );\n    one_statement_parses_to(\n        \"SELECT * FROM t1 JOIN t2 foo ON c1 = c2\",\n        \"SELECT * FROM t1 JOIN t2 AS foo ON c1 = c2\",\n    );\n    // Test parsing of different join operators\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 JOIN t2 ON c1 = c2\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::Inner)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 LEFT JOIN t2 ON c1 = c2\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::LeftOuter)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 RIGHT JOIN t2 ON c1 = c2\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::RightOuter)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 LEFT SEMI JOIN t2 ON c1 = c2\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::LeftSemi)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 RIGHT SEMI JOIN t2 ON c1 = c2\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::RightSemi)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 LEFT ANTI JOIN t2 ON c1 = c2\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::LeftAnti)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 RIGHT ANTI JOIN t2 ON c1 = c2\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::RightAnti)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 FULL JOIN t2 ON c1 = c2\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::FullOuter)]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_joins_using", "test": "fn parse_joins_using() {\n    fn join_with_constraint(\n        relation: impl Into<String>,\n        alias: Option<TableAlias>,\n        f: impl Fn(JoinConstraint) -> JoinOperator,\n    ) -> Join {\n        Join {\n            relation: TableFactor::Table {\n                name: ObjectName(vec![Ident::new(relation.into())]),\n                alias,\n                args: None,\n                with_hints: vec![],\n                version: None,\n                partitions: vec![],\n            },\n            join_operator: f(JoinConstraint::Using(vec![\"c1\".into()])),\n        }\n    }\n    // Test parsing of aliases\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 JOIN t2 AS foo USING(c1)\").from).joins,\n        vec![join_with_constraint(\n            \"t2\",\n            table_alias(\"foo\"),\n            JoinOperator::Inner,\n        )]\n    );\n    one_statement_parses_to(\n        \"SELECT * FROM t1 JOIN t2 foo USING(c1)\",\n        \"SELECT * FROM t1 JOIN t2 AS foo USING(c1)\",\n    );\n    // Test parsing of different join operators\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 JOIN t2 USING(c1)\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::Inner)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 LEFT JOIN t2 USING(c1)\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::LeftOuter)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 RIGHT JOIN t2 USING(c1)\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::RightOuter)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 LEFT SEMI JOIN t2 USING(c1)\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::LeftSemi)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 RIGHT SEMI JOIN t2 USING(c1)\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::RightSemi)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 LEFT ANTI JOIN t2 USING(c1)\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::LeftAnti)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 RIGHT ANTI JOIN t2 USING(c1)\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::RightAnti)]\n    );\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 FULL JOIN t2 USING(c1)\").from).joins,\n        vec![join_with_constraint(\"t2\", None, JoinOperator::FullOuter)]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_natural_join", "test": "fn parse_natural_join() {\n    fn natural_join(f: impl Fn(JoinConstraint) -> JoinOperator, alias: Option<TableAlias>) -> Join {\n        Join {\n            relation: TableFactor::Table {\n                name: ObjectName(vec![Ident::new(\"t2\")]),\n                alias,\n                args: None,\n                with_hints: vec![],\n                version: None,\n                partitions: vec![],\n            },\n            join_operator: f(JoinConstraint::Natural),\n        }\n    }\n\n    // if not specified, inner join as default\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 NATURAL JOIN t2\").from).joins,\n        vec![natural_join(JoinOperator::Inner, None)]\n    );\n    // left join explicitly\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 NATURAL LEFT JOIN t2\").from).joins,\n        vec![natural_join(JoinOperator::LeftOuter, None)]\n    );\n\n    // right join explicitly\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 NATURAL RIGHT JOIN t2\").from).joins,\n        vec![natural_join(JoinOperator::RightOuter, None)]\n    );\n\n    // full join explicitly\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 NATURAL FULL JOIN t2\").from).joins,\n        vec![natural_join(JoinOperator::FullOuter, None)]\n    );\n\n    // natural join another table with alias\n    assert_eq!(\n        only(&verified_only_select(\"SELECT * FROM t1 NATURAL JOIN t2 AS t3\").from).joins,\n        vec![natural_join(JoinOperator::Inner, table_alias(\"t3\"))]\n    );\n\n    let sql = \"SELECT * FROM t1 natural\";\n    assert_eq!(\n        ParserError::ParserError(\"Expected a join type after NATURAL, found: EOF\".to_string()),\n        parse_sql_statements(sql).unwrap_err(),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_join_nesting", "test": "fn parse_join_nesting() {\n    let sql = \"SELECT * FROM a NATURAL JOIN (b NATURAL JOIN (c NATURAL JOIN d NATURAL JOIN e)) \\\n               NATURAL JOIN (f NATURAL JOIN (g NATURAL JOIN h))\";\n    assert_eq!(\n        only(&verified_only_select(sql).from).joins,\n        vec![\n            join(nest!(table(\"b\"), nest!(table(\"c\"), table(\"d\"), table(\"e\")))),\n            join(nest!(table(\"f\"), nest!(table(\"g\"), table(\"h\")))),\n        ],\n    );\n\n    let sql = \"SELECT * FROM (a NATURAL JOIN b) NATURAL JOIN c\";\n    let select = verified_only_select(sql);\n    let from = only(select.from);\n    assert_eq!(from.relation, nest!(table(\"a\"), table(\"b\")));\n    assert_eq!(from.joins, vec![join(table(\"c\"))]);\n\n    let sql = \"SELECT * FROM (((a NATURAL JOIN b)))\";\n    let select = verified_only_select(sql);\n    let from = only(select.from);\n    assert_eq!(from.relation, nest!(nest!(nest!(table(\"a\"), table(\"b\")))));\n    assert_eq!(from.joins, vec![]);\n\n    let sql = \"SELECT * FROM a NATURAL JOIN (((b NATURAL JOIN c)))\";\n    let select = verified_only_select(sql);\n    let from = only(select.from);\n    assert_eq!(from.relation, table(\"a\"));\n    assert_eq!(\n        from.joins,\n        vec![join(nest!(nest!(nest!(table(\"b\"), table(\"c\")))))]\n    );\n\n    let sql = \"SELECT * FROM (a NATURAL JOIN b) AS c\";\n    let select = verified_only_select(sql);\n    let from = only(select.from);\n    assert_eq!(\n        from.relation,\n        TableFactor::NestedJoin {\n            table_with_joins: Box::new(TableWithJoins {\n                relation: table(\"a\"),\n                joins: vec![join(table(\"b\"))],\n            }),\n            alias: table_alias(\"c\"),\n        }\n    );\n    assert_eq!(from.joins, vec![]);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_join_syntax_variants", "test": "fn parse_join_syntax_variants() {\n    one_statement_parses_to(\n        \"SELECT c1 FROM t1 INNER JOIN t2 USING(c1)\",\n        \"SELECT c1 FROM t1 JOIN t2 USING(c1)\",\n    );\n    one_statement_parses_to(\n        \"SELECT c1 FROM t1 LEFT OUTER JOIN t2 USING(c1)\",\n        \"SELECT c1 FROM t1 LEFT JOIN t2 USING(c1)\",\n    );\n    one_statement_parses_to(\n        \"SELECT c1 FROM t1 RIGHT OUTER JOIN t2 USING(c1)\",\n        \"SELECT c1 FROM t1 RIGHT JOIN t2 USING(c1)\",\n    );\n    one_statement_parses_to(\n        \"SELECT c1 FROM t1 FULL OUTER JOIN t2 USING(c1)\",\n        \"SELECT c1 FROM t1 FULL JOIN t2 USING(c1)\",\n    );\n\n    let res = parse_sql_statements(\"SELECT * FROM a OUTER JOIN b ON 1\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected APPLY, found: JOIN\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_ctes", "test": "fn parse_ctes() {\n    let cte_sqls = vec![\"SELECT 1 AS foo\", \"SELECT 2 AS bar\"];\n    let with = &format!(\n        \"WITH a AS ({}), b AS ({}) SELECT foo + bar FROM a, b\",\n        cte_sqls[0], cte_sqls[1]\n    );\n\n    fn assert_ctes_in_select(expected: &[&str], sel: &Query) {\n        for (i, exp) in expected.iter().enumerate() {\n            let Cte { alias, query, .. } = &sel.with.as_ref().unwrap().cte_tables[i];\n            assert_eq!(*exp, query.to_string());\n            assert_eq!(\n                if i == 0 {\n                    Ident::new(\"a\")\n                } else {\n                    Ident::new(\"b\")\n                },\n                alias.name\n            );\n            assert!(alias.columns.is_empty());\n        }\n    }\n\n    // Top-level CTE\n    assert_ctes_in_select(&cte_sqls, &verified_query(with));\n    // CTE in a subquery\n    let sql = &format!(\"SELECT ({with})\");\n    let select = verified_only_select(sql);\n    match expr_from_projection(only(&select.projection)) {\n        Expr::Subquery(ref subquery) => {\n            assert_ctes_in_select(&cte_sqls, subquery.as_ref());\n        }\n        _ => panic!(\"Expected subquery\"),\n    }\n    // CTE in a derived table\n    let sql = &format!(\"SELECT * FROM ({with})\");\n    let select = verified_only_select(sql);\n    match only(select.from).relation {\n        TableFactor::Derived { subquery, .. } => {\n            assert_ctes_in_select(&cte_sqls, subquery.as_ref())\n        }\n        _ => panic!(\"Expected derived table\"),\n    }\n    // CTE in a view\n    let sql = &format!(\"CREATE VIEW v AS {with}\");\n    match verified_stmt(sql) {\n        Statement::CreateView { query, .. } => assert_ctes_in_select(&cte_sqls, &query),\n        _ => panic!(\"Expected CREATE VIEW\"),\n    }\n    // CTE in a CTE...\n    let sql = &format!(\"WITH outer_cte AS ({with}) SELECT * FROM outer_cte\");\n    let select = verified_query(sql);\n    assert_ctes_in_select(&cte_sqls, &only(&select.with.unwrap().cte_tables).query);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_cte_renamed_columns", "test": "fn parse_cte_renamed_columns() {\n    let sql = \"WITH cte (col1, col2) AS (SELECT foo, bar FROM baz) SELECT * FROM cte\";\n    let query = all_dialects().verified_query(sql);\n    assert_eq!(\n        vec![Ident::new(\"col1\"), Ident::new(\"col2\")],\n        query\n            .with\n            .unwrap()\n            .cte_tables\n            .first()\n            .unwrap()\n            .alias\n            .columns\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_derived_tables", "test": "fn parse_derived_tables() {\n    let sql = \"SELECT a.x, b.y FROM (SELECT x FROM foo) AS a CROSS JOIN (SELECT y FROM bar) AS b\";\n    let _ = verified_only_select(sql);\n    //TODO: add assertions\n\n    let sql = \"SELECT a.x, b.y \\\n               FROM (SELECT x FROM foo) AS a (x) \\\n               CROSS JOIN (SELECT y FROM bar) AS b (y)\";\n    let _ = verified_only_select(sql);\n    //TODO: add assertions\n\n    let sql = \"SELECT * FROM (((SELECT 1)))\";\n    let _ = verified_only_select(sql);\n    // TODO: add assertions\n\n    let sql = \"SELECT * FROM t NATURAL JOIN (((SELECT 1)))\";\n    let _ = verified_only_select(sql);\n    // TODO: add assertions\n\n    let sql = \"SELECT * FROM (((SELECT 1) UNION (SELECT 2)) AS t1 NATURAL JOIN t2)\";\n    let select = verified_only_select(sql);\n    let from = only(select.from);\n    assert_eq!(\n        from.relation,\n        TableFactor::NestedJoin {\n            table_with_joins: Box::new(TableWithJoins {\n                relation: TableFactor::Derived {\n                    lateral: false,\n                    subquery: Box::new(verified_query(\"(SELECT 1) UNION (SELECT 2)\")),\n                    alias: Some(TableAlias {\n                        name: \"t1\".into(),\n                        columns: vec![],\n                    }),\n                },\n                joins: vec![Join {\n                    relation: TableFactor::Table {\n                        name: ObjectName(vec![\"t2\".into()]),\n                        alias: None,\n                        args: None,\n                        with_hints: vec![],\n                        version: None,\n                        partitions: vec![],\n                    },\n                    join_operator: JoinOperator::Inner(JoinConstraint::Natural),\n                }],\n            }),\n            alias: None,\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_multiple_statements", "test": "fn parse_multiple_statements() {\n    fn test_with(sql1: &str, sql2_kw: &str, sql2_rest: &str) {\n        // Check that a string consisting of two statements delimited by a semicolon\n        // parses the same as both statements individually:\n        let res = parse_sql_statements(&(sql1.to_owned() + \";\" + sql2_kw + sql2_rest));\n        assert_eq!(\n            vec![\n                one_statement_parses_to(sql1, \"\"),\n                one_statement_parses_to(&(sql2_kw.to_owned() + sql2_rest), \"\"),\n            ],\n            res.unwrap()\n        );\n        // Check that extra semicolon at the end is stripped by normalization:\n        one_statement_parses_to(&(sql1.to_owned() + \";\"), sql1);\n        // Check that forgetting the semicolon results in an error:\n        let res = parse_sql_statements(&(sql1.to_owned() + \" \" + sql2_kw + sql2_rest));\n        assert_eq!(\n            ParserError::ParserError(\"Expected end of statement, found: \".to_string() + sql2_kw),\n            res.unwrap_err()\n        );\n    }\n    test_with(\"SELECT foo\", \"SELECT\", \" bar\");\n    // ensure that SELECT/WITH is not parsed as a table or column alias if ';'\n    // separating the statements is omitted:\n    test_with(\"SELECT foo FROM baz\", \"SELECT\", \" bar\");\n    test_with(\"SELECT foo\", \"WITH\", \" cte AS (SELECT 1 AS s) SELECT bar\");\n    test_with(\n        \"SELECT foo FROM baz\",\n        \"WITH\",\n        \" cte AS (SELECT 1 AS s) SELECT bar\",\n    );\n    test_with(\"DELETE FROM foo\", \"SELECT\", \" bar\");\n    test_with(\"INSERT INTO foo VALUES (1)\", \"SELECT\", \" bar\");\n    test_with(\"CREATE TABLE foo (baz INT)\", \"SELECT\", \" bar\");\n    // Make sure that empty statements do not cause an error:\n    let res = parse_sql_statements(\";;\");\n    assert_eq!(0, res.unwrap().len());\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_overlay", "test": "fn parse_overlay() {\n    one_statement_parses_to(\n        \"SELECT OVERLAY('abccccde' PLACING 'abc' FROM 3)\",\n        \"SELECT OVERLAY('abccccde' PLACING 'abc' FROM 3)\",\n    );\n    one_statement_parses_to(\n        \"SELECT OVERLAY('abccccde' PLACING 'abc' FROM 3 FOR 12)\",\n        \"SELECT OVERLAY('abccccde' PLACING 'abc' FROM 3 FOR 12)\",\n    );\n    assert_eq!(\n        ParserError::ParserError(\"Expected PLACING, found: FROM\".to_owned()),\n        parse_sql_statements(\"SELECT OVERLAY('abccccde' FROM 3)\").unwrap_err(),\n    );\n\n    let sql = \"SELECT OVERLAY('abcdef' PLACING name FROM 3 FOR id + 1) FROM CUSTOMERS\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        &Expr::Overlay {\n            expr: Box::new(Expr::Value(Value::SingleQuotedString(\"abcdef\".to_string()))),\n            overlay_what: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n            overlay_from: Box::new(Expr::Value(number(\"3\"))),\n            overlay_for: Some(Box::new(Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n                op: BinaryOperator::Plus,\n                right: Box::new(Expr::Value(number(\"1\"))),\n            })),\n        },\n        expr_from_projection(only(&select.projection))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_trim", "test": "fn parse_trim() {\n    one_statement_parses_to(\n        \"SELECT TRIM(BOTH 'xyz' FROM 'xyzfooxyz')\",\n        \"SELECT TRIM(BOTH 'xyz' FROM 'xyzfooxyz')\",\n    );\n\n    one_statement_parses_to(\n        \"SELECT TRIM(LEADING 'xyz' FROM 'xyzfooxyz')\",\n        \"SELECT TRIM(LEADING 'xyz' FROM 'xyzfooxyz')\",\n    );\n\n    one_statement_parses_to(\n        \"SELECT TRIM(TRAILING 'xyz' FROM 'xyzfooxyz')\",\n        \"SELECT TRIM(TRAILING 'xyz' FROM 'xyzfooxyz')\",\n    );\n\n    one_statement_parses_to(\n        \"SELECT TRIM('xyz' FROM 'xyzfooxyz')\",\n        \"SELECT TRIM('xyz' FROM 'xyzfooxyz')\",\n    );\n    one_statement_parses_to(\"SELECT TRIM('   foo   ')\", \"SELECT TRIM('   foo   ')\");\n    one_statement_parses_to(\n        \"SELECT TRIM(LEADING '   foo   ')\",\n        \"SELECT TRIM(LEADING '   foo   ')\",\n    );\n\n    assert_eq!(\n        ParserError::ParserError(\"Expected ), found: 'xyz'\".to_owned()),\n        parse_sql_statements(\"SELECT TRIM(FOO 'xyz' FROM 'xyzfooxyz')\").unwrap_err()\n    );\n\n    //keep Snowflake/BigQuery TRIM syntax failing\n    let all_expected_snowflake = TestedDialects {\n        dialects: vec![\n            //Box::new(GenericDialect {}),\n            Box::new(PostgreSqlDialect {}),\n            Box::new(MsSqlDialect {}),\n            Box::new(AnsiDialect {}),\n            //Box::new(SnowflakeDialect {}),\n            Box::new(HiveDialect {}),\n            Box::new(RedshiftSqlDialect {}),\n            Box::new(MySqlDialect {}),\n            //Box::new(BigQueryDialect {}),\n            Box::new(SQLiteDialect {}),\n            Box::new(DuckDbDialect {}),\n        ],\n        options: None,\n    };\n    assert_eq!(\n        ParserError::ParserError(\"Expected ), found: 'a'\".to_owned()),\n        all_expected_snowflake\n            .parse_sql_statements(\"SELECT TRIM('xyz', 'a')\")\n            .unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_exists_subquery", "test": "fn parse_exists_subquery() {\n    let expected_inner = verified_query(\"SELECT 1\");\n    let sql = \"SELECT * FROM t WHERE EXISTS (SELECT 1)\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        Expr::Exists {\n            negated: false,\n            subquery: Box::new(expected_inner.clone()),\n        },\n        select.selection.unwrap(),\n    );\n\n    let sql = \"SELECT * FROM t WHERE NOT EXISTS (SELECT 1)\";\n    let select = verified_only_select(sql);\n    assert_eq!(\n        Expr::Exists {\n            negated: true,\n            subquery: Box::new(expected_inner),\n        },\n        select.selection.unwrap(),\n    );\n\n    verified_stmt(\"SELECT * FROM t WHERE EXISTS (WITH u AS (SELECT 1) SELECT * FROM u)\");\n    verified_stmt(\"SELECT EXISTS (SELECT 1)\");\n\n    let res = parse_sql_statements(\"SELECT EXISTS (\");\n    assert_eq!(\n        ParserError::ParserError(\n            \"Expected SELECT, VALUES, or a subquery in the query body, found: EOF\".to_string()\n        ),\n        res.unwrap_err(),\n    );\n\n    let res = parse_sql_statements(\"SELECT EXISTS (NULL)\");\n    assert_eq!(\n        ParserError::ParserError(\n            \"Expected SELECT, VALUES, or a subquery in the query body, found: NULL\".to_string()\n        ),\n        res.unwrap_err(),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_database", "test": "fn parse_create_database() {\n    let sql = \"CREATE DATABASE mydb\";\n    match verified_stmt(sql) {\n        Statement::CreateDatabase {\n            db_name,\n            if_not_exists,\n            location,\n            managed_location,\n        } => {\n            assert_eq!(\"mydb\", db_name.to_string());\n            assert!(!if_not_exists);\n            assert_eq!(None, location);\n            assert_eq!(None, managed_location);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_database_ine", "test": "fn parse_create_database_ine() {\n    let sql = \"CREATE DATABASE IF NOT EXISTS mydb\";\n    match verified_stmt(sql) {\n        Statement::CreateDatabase {\n            db_name,\n            if_not_exists,\n            location,\n            managed_location,\n        } => {\n            assert_eq!(\"mydb\", db_name.to_string());\n            assert!(if_not_exists);\n            assert_eq!(None, location);\n            assert_eq!(None, managed_location);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_view", "test": "fn parse_create_view() {\n    let sql = \"CREATE VIEW myschema.myview AS SELECT foo FROM bar\";\n    match verified_stmt(sql) {\n        Statement::CreateView {\n            name,\n            columns,\n            query,\n            or_replace,\n            materialized,\n            with_options,\n            cluster_by,\n            with_no_schema_binding: late_binding,\n            if_not_exists,\n            temporary,\n        } => {\n            assert_eq!(\"myschema.myview\", name.to_string());\n            assert_eq!(Vec::<Ident>::new(), columns);\n            assert_eq!(\"SELECT foo FROM bar\", query.to_string());\n            assert!(!materialized);\n            assert!(!or_replace);\n            assert_eq!(with_options, vec![]);\n            assert_eq!(cluster_by, vec![]);\n            assert!(!late_binding);\n            assert!(!if_not_exists);\n            assert!(!temporary);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_view_with_columns", "test": "fn parse_create_view_with_columns() {\n    let sql = \"CREATE VIEW v (has, cols) AS SELECT 1, 2\";\n    match verified_stmt(sql) {\n        Statement::CreateView {\n            name,\n            columns,\n            or_replace,\n            with_options,\n            query,\n            materialized,\n            cluster_by,\n            with_no_schema_binding: late_binding,\n            if_not_exists,\n            temporary,\n        } => {\n            assert_eq!(\"v\", name.to_string());\n            assert_eq!(columns, vec![Ident::new(\"has\"), Ident::new(\"cols\")]);\n            assert_eq!(with_options, vec![]);\n            assert_eq!(\"SELECT 1, 2\", query.to_string());\n            assert!(!materialized);\n            assert!(!or_replace);\n            assert_eq!(cluster_by, vec![]);\n            assert!(!late_binding);\n            assert!(!if_not_exists);\n            assert!(!temporary);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_view_temporary", "test": "fn parse_create_view_temporary() {\n    let sql = \"CREATE TEMPORARY VIEW myschema.myview AS SELECT foo FROM bar\";\n    match verified_stmt(sql) {\n        Statement::CreateView {\n            name,\n            columns,\n            query,\n            or_replace,\n            materialized,\n            with_options,\n            cluster_by,\n            with_no_schema_binding: late_binding,\n            if_not_exists,\n            temporary,\n        } => {\n            assert_eq!(\"myschema.myview\", name.to_string());\n            assert_eq!(Vec::<Ident>::new(), columns);\n            assert_eq!(\"SELECT foo FROM bar\", query.to_string());\n            assert!(!materialized);\n            assert!(!or_replace);\n            assert_eq!(with_options, vec![]);\n            assert_eq!(cluster_by, vec![]);\n            assert!(!late_binding);\n            assert!(!if_not_exists);\n            assert!(temporary);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_or_replace_view", "test": "fn parse_create_or_replace_view() {\n    let sql = \"CREATE OR REPLACE VIEW v AS SELECT 1\";\n    match verified_stmt(sql) {\n        Statement::CreateView {\n            name,\n            columns,\n            or_replace,\n            with_options,\n            query,\n            materialized,\n            cluster_by,\n            with_no_schema_binding: late_binding,\n            if_not_exists,\n            temporary,\n        } => {\n            assert_eq!(\"v\", name.to_string());\n            assert_eq!(columns, vec![]);\n            assert_eq!(with_options, vec![]);\n            assert_eq!(\"SELECT 1\", query.to_string());\n            assert!(!materialized);\n            assert!(or_replace);\n            assert_eq!(cluster_by, vec![]);\n            assert!(!late_binding);\n            assert!(!if_not_exists);\n            assert!(!temporary);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_or_replace_materialized_view", "test": "fn parse_create_or_replace_materialized_view() {\n    // Supported in BigQuery (Beta)\n    // https://cloud.google.com/bigquery/docs/materialized-views-intro\n    // and Snowflake:\n    // https://docs.snowflake.com/en/sql-reference/sql/create-materialized-view.html\n    let sql = \"CREATE OR REPLACE MATERIALIZED VIEW v AS SELECT 1\";\n    match verified_stmt(sql) {\n        Statement::CreateView {\n            name,\n            columns,\n            or_replace,\n            with_options,\n            query,\n            materialized,\n            cluster_by,\n            with_no_schema_binding: late_binding,\n            if_not_exists,\n            temporary,\n        } => {\n            assert_eq!(\"v\", name.to_string());\n            assert_eq!(columns, vec![]);\n            assert_eq!(with_options, vec![]);\n            assert_eq!(\"SELECT 1\", query.to_string());\n            assert!(materialized);\n            assert!(or_replace);\n            assert_eq!(cluster_by, vec![]);\n            assert!(!late_binding);\n            assert!(!if_not_exists);\n            assert!(!temporary);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_materialized_view", "test": "fn parse_create_materialized_view() {\n    let sql = \"CREATE MATERIALIZED VIEW myschema.myview AS SELECT foo FROM bar\";\n    match verified_stmt(sql) {\n        Statement::CreateView {\n            name,\n            or_replace,\n            columns,\n            query,\n            materialized,\n            with_options,\n            cluster_by,\n            with_no_schema_binding: late_binding,\n            if_not_exists,\n            temporary,\n        } => {\n            assert_eq!(\"myschema.myview\", name.to_string());\n            assert_eq!(Vec::<Ident>::new(), columns);\n            assert_eq!(\"SELECT foo FROM bar\", query.to_string());\n            assert!(materialized);\n            assert_eq!(with_options, vec![]);\n            assert!(!or_replace);\n            assert_eq!(cluster_by, vec![]);\n            assert!(!late_binding);\n            assert!(!if_not_exists);\n            assert!(!temporary);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_materialized_view_with_cluster_by", "test": "fn parse_create_materialized_view_with_cluster_by() {\n    let sql = \"CREATE MATERIALIZED VIEW myschema.myview CLUSTER BY (foo) AS SELECT foo FROM bar\";\n    match verified_stmt(sql) {\n        Statement::CreateView {\n            name,\n            or_replace,\n            columns,\n            query,\n            materialized,\n            with_options,\n            cluster_by,\n            with_no_schema_binding: late_binding,\n            if_not_exists,\n            temporary,\n        } => {\n            assert_eq!(\"myschema.myview\", name.to_string());\n            assert_eq!(Vec::<Ident>::new(), columns);\n            assert_eq!(\"SELECT foo FROM bar\", query.to_string());\n            assert!(materialized);\n            assert_eq!(with_options, vec![]);\n            assert!(!or_replace);\n            assert_eq!(cluster_by, vec![Ident::new(\"foo\")]);\n            assert!(!late_binding);\n            assert!(!if_not_exists);\n            assert!(!temporary);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_drop_view", "test": "fn parse_drop_view() {\n    let sql = \"DROP VIEW myschema.myview\";\n    match verified_stmt(sql) {\n        Statement::Drop {\n            names, object_type, ..\n        } => {\n            assert_eq!(\n                vec![\"myschema.myview\"],\n                names.iter().map(ToString::to_string).collect::<Vec<_>>()\n            );\n            assert_eq!(ObjectType::View, object_type);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_invalid_subquery_without_parens", "test": "fn parse_invalid_subquery_without_parens() {\n    let res = parse_sql_statements(\"SELECT SELECT 1 FROM bar WHERE 1=1 FROM baz\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: 1\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::lateral_derived", "test": "fn lateral_derived() {\n    fn chk(lateral_in: bool) {\n        let lateral_str = if lateral_in { \"LATERAL \" } else { \"\" };\n        let sql = format!(\n            \"SELECT * FROM customer LEFT JOIN {lateral_str}\\\n             (SELECT * FROM order WHERE order.customer = customer.id LIMIT 3) AS order ON true\"\n        );\n        let select = verified_only_select(&sql);\n        let from = only(select.from);\n        assert_eq!(from.joins.len(), 1);\n        let join = &from.joins[0];\n        assert_eq!(\n            join.join_operator,\n            JoinOperator::LeftOuter(JoinConstraint::On(Expr::Value(Value::Boolean(true))))\n        );\n        if let TableFactor::Derived {\n            lateral,\n            ref subquery,\n            alias: Some(ref alias),\n        } = join.relation\n        {\n            assert_eq!(lateral_in, lateral);\n            assert_eq!(Ident::new(\"order\"), alias.name);\n            assert_eq!(\n                subquery.to_string(),\n                \"SELECT * FROM order WHERE order.customer = customer.id LIMIT 3\"\n            );\n        } else {\n            unreachable!()\n        }\n    }\n    chk(false);\n    chk(true);\n\n    let sql = \"SELECT * FROM LATERAL UNNEST ([10,20,30]) as numbers WITH OFFSET;\";\n    let res = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: WITH\".to_string()),\n        res.unwrap_err()\n    );\n\n    let sql = \"SELECT * FROM a LEFT JOIN LATERAL (b CROSS JOIN c)\";\n    let res = parse_sql_statements(sql);\n    assert_eq!(\n        ParserError::ParserError(\n            \"Expected SELECT, VALUES, or a subquery in the query body, found: b\".to_string()\n        ),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_index", "test": "fn parse_create_index() {\n    let sql = \"CREATE UNIQUE INDEX IF NOT EXISTS idx_name ON test(name,age DESC)\";\n    let indexed_columns = vec![\n        OrderByExpr {\n            expr: Expr::Identifier(Ident::new(\"name\")),\n            asc: None,\n            nulls_first: None,\n        },\n        OrderByExpr {\n            expr: Expr::Identifier(Ident::new(\"age\")),\n            asc: Some(false),\n            nulls_first: None,\n        },\n    ];\n    match verified_stmt(sql) {\n        Statement::CreateIndex {\n            name: Some(name),\n            table_name,\n            columns,\n            unique,\n            if_not_exists,\n            ..\n        } => {\n            assert_eq!(\"idx_name\", name.to_string());\n            assert_eq!(\"test\", table_name.to_string());\n            assert_eq!(indexed_columns, columns);\n            assert!(unique);\n            assert!(if_not_exists)\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::test_create_index_with_using_function", "test": "fn test_create_index_with_using_function() {\n    let sql = \"CREATE UNIQUE INDEX IF NOT EXISTS idx_name ON test USING btree (name,age DESC)\";\n    let indexed_columns = vec![\n        OrderByExpr {\n            expr: Expr::Identifier(Ident::new(\"name\")),\n            asc: None,\n            nulls_first: None,\n        },\n        OrderByExpr {\n            expr: Expr::Identifier(Ident::new(\"age\")),\n            asc: Some(false),\n            nulls_first: None,\n        },\n    ];\n    match verified_stmt(sql) {\n        Statement::CreateIndex {\n            name: Some(name),\n            table_name,\n            using,\n            columns,\n            unique,\n            concurrently,\n            if_not_exists,\n            include,\n            nulls_distinct: None,\n            predicate: None,\n        } => {\n            assert_eq!(\"idx_name\", name.to_string());\n            assert_eq!(\"test\", table_name.to_string());\n            assert_eq!(\"btree\", using.unwrap().to_string());\n            assert_eq!(indexed_columns, columns);\n            assert!(unique);\n            assert!(!concurrently);\n            assert!(if_not_exists);\n            assert!(include.is_empty());\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_drop_index", "test": "fn parse_drop_index() {\n    let sql = \"DROP INDEX idx_a\";\n    match verified_stmt(sql) {\n        Statement::Drop {\n            names, object_type, ..\n        } => {\n            assert_eq!(\n                vec![\"idx_a\"],\n                names.iter().map(ToString::to_string).collect::<Vec<_>>()\n            );\n            assert_eq!(ObjectType::Index, object_type);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::test_lock", "test": "fn test_lock() {\n    let sql = \"SELECT * FROM student WHERE id = '1' FOR UPDATE\";\n    let mut ast = verified_query(sql);\n    assert_eq!(ast.locks.len(), 1);\n    let lock = ast.locks.pop().unwrap();\n    assert_eq!(lock.lock_type, LockType::Update);\n    assert!(lock.of.is_none());\n    assert!(lock.nonblock.is_none());\n\n    let sql = \"SELECT * FROM student WHERE id = '1' FOR SHARE\";\n    let mut ast = verified_query(sql);\n    assert_eq!(ast.locks.len(), 1);\n    let lock = ast.locks.pop().unwrap();\n    assert_eq!(lock.lock_type, LockType::Share);\n    assert!(lock.of.is_none());\n    assert!(lock.nonblock.is_none());\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::test_lock_table", "test": "fn test_lock_table() {\n    let sql = \"SELECT * FROM student WHERE id = '1' FOR UPDATE OF school\";\n    let mut ast = verified_query(sql);\n    assert_eq!(ast.locks.len(), 1);\n    let lock = ast.locks.pop().unwrap();\n    assert_eq!(lock.lock_type, LockType::Update);\n    assert_eq!(\n        lock.of.unwrap().0,\n        vec![Ident {\n            value: \"school\".to_string(),\n            quote_style: None\n        }]\n    );\n    assert!(lock.nonblock.is_none());\n\n    let sql = \"SELECT * FROM student WHERE id = '1' FOR SHARE OF school\";\n    let mut ast = verified_query(sql);\n    assert_eq!(ast.locks.len(), 1);\n    let lock = ast.locks.pop().unwrap();\n    assert_eq!(lock.lock_type, LockType::Share);\n    assert_eq!(\n        lock.of.unwrap().0,\n        vec![Ident {\n            value: \"school\".to_string(),\n            quote_style: None\n        }]\n    );\n    assert!(lock.nonblock.is_none());\n\n    let sql = \"SELECT * FROM student WHERE id = '1' FOR SHARE OF school FOR UPDATE OF student\";\n    let mut ast = verified_query(sql);\n    assert_eq!(ast.locks.len(), 2);\n    let lock = ast.locks.remove(0);\n    assert_eq!(lock.lock_type, LockType::Share);\n    assert_eq!(\n        lock.of.unwrap().0,\n        vec![Ident {\n            value: \"school\".to_string(),\n            quote_style: None\n        }]\n    );\n    assert!(lock.nonblock.is_none());\n    let lock = ast.locks.remove(0);\n    assert_eq!(lock.lock_type, LockType::Update);\n    assert_eq!(\n        lock.of.unwrap().0,\n        vec![Ident {\n            value: \"student\".to_string(),\n            quote_style: None\n        }]\n    );\n    assert!(lock.nonblock.is_none());\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::test_lock_nonblock", "test": "fn test_lock_nonblock() {\n    let sql = \"SELECT * FROM student WHERE id = '1' FOR UPDATE OF school SKIP LOCKED\";\n    let mut ast = verified_query(sql);\n    assert_eq!(ast.locks.len(), 1);\n    let lock = ast.locks.pop().unwrap();\n    assert_eq!(lock.lock_type, LockType::Update);\n    assert_eq!(\n        lock.of.unwrap().0,\n        vec![Ident {\n            value: \"school\".to_string(),\n            quote_style: None\n        }]\n    );\n    assert_eq!(lock.nonblock.unwrap(), NonBlock::SkipLocked);\n\n    let sql = \"SELECT * FROM student WHERE id = '1' FOR SHARE OF school NOWAIT\";\n    let mut ast = verified_query(sql);\n    assert_eq!(ast.locks.len(), 1);\n    let lock = ast.locks.pop().unwrap();\n    assert_eq!(lock.lock_type, LockType::Share);\n    assert_eq!(\n        lock.of.unwrap().0,\n        vec![Ident {\n            value: \"school\".to_string(),\n            quote_style: None\n        }]\n    );\n    assert_eq!(lock.nonblock.unwrap(), NonBlock::Nowait);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::test_placeholder", "test": "fn test_placeholder() {\n    let sql = \"SELECT * FROM student WHERE id = ?\";\n    let ast = verified_only_select(sql);\n    assert_eq!(\n        ast.selection,\n        Some(Expr::BinaryOp {\n            left: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            op: BinaryOperator::Eq,\n            right: Box::new(Expr::Value(Value::Placeholder(\"?\".into()))),\n        })\n    );\n\n    let dialects = TestedDialects {\n        dialects: vec![\n            Box::new(GenericDialect {}),\n            Box::new(DuckDbDialect {}),\n            Box::new(PostgreSqlDialect {}),\n            Box::new(MsSqlDialect {}),\n            Box::new(AnsiDialect {}),\n            Box::new(BigQueryDialect {}),\n            Box::new(SnowflakeDialect {}),\n            // Note: `$` is the starting word for the HiveDialect identifier\n            // Box::new(sqlparser::dialect::HiveDialect {}),\n        ],\n        options: None,\n    };\n    let sql = \"SELECT * FROM student WHERE id = $Id1\";\n    let ast = dialects.verified_only_select(sql);\n    assert_eq!(\n        ast.selection,\n        Some(Expr::BinaryOp {\n            left: Box::new(Expr::Identifier(Ident::new(\"id\"))),\n            op: BinaryOperator::Eq,\n            right: Box::new(Expr::Value(Value::Placeholder(\"$Id1\".into()))),\n        })\n    );\n\n    let sql = \"SELECT * FROM student LIMIT $1 OFFSET $2\";\n    let ast = dialects.verified_query(sql);\n    assert_eq!(\n        ast.limit,\n        Some(Expr::Value(Value::Placeholder(\"$1\".into())))\n    );\n    assert_eq!(\n        ast.offset,\n        Some(Offset {\n            value: Expr::Value(Value::Placeholder(\"$2\".into())),\n            rows: OffsetRows::None,\n        }),\n    );\n\n    let sql = \"SELECT $fromage_français, :x, ?123\";\n    let ast = dialects.verified_only_select(sql);\n    assert_eq!(\n        ast.projection,\n        vec![\n            UnnamedExpr(Expr::Value(Value::Placeholder(\"$fromage_français\".into()))),\n            UnnamedExpr(Expr::Value(Value::Placeholder(\":x\".into()))),\n            UnnamedExpr(Expr::Value(Value::Placeholder(\"?123\".into()))),\n        ]\n    );\n}\n\n", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::set_statement_with_minus", "test": "fn set_statement_with_minus() {\n    assert_eq!(\n        hive().verified_stmt(\"SET hive.tez.java.opts = -Xmx4g\"),\n        Statement::SetVariable {\n            local: false,\n            hivevar: false,\n            variable: ObjectName(vec![\n                Ident::new(\"hive\"),\n                Ident::new(\"tez\"),\n                Ident::new(\"java\"),\n                Ident::new(\"opts\")\n            ]),\n            value: vec![Expr::UnaryOp {\n                op: UnaryOperator::Minus,\n                expr: Box::new(Expr::Identifier(Ident::new(\"Xmx4g\")))\n            }],\n        }\n    );\n\n    assert_eq!(\n        hive().parse_sql_statements(\"SET hive.tez.java.opts = -\"),\n        Err(ParserError::ParserError(\n            \"Expected variable value, found: EOF\".to_string()\n        ))\n    )\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_like", "test": "fn parse_like() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that LIKE and NOT LIKE have the same precedence.\n        // This was previously mishandled (#81).\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_hive.rs::parse_similar_to", "test": "fn parse_similar_to() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that SIMILAR TO and NOT SIMILAR TO have the same precedence.\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = hive().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_identifiers", "test": "fn parse_mssql_identifiers() {\n    let sql = \"SELECT @@version, _foo$123 FROM ##temp\";\n    let select = ms_and_generic().verified_only_select(sql);\n    assert_eq!(\n        &Expr::Identifier(Ident::new(\"@@version\")),\n        expr_from_projection(&select.projection[0]),\n    );\n    assert_eq!(\n        &Expr::Identifier(Ident::new(\"_foo$123\")),\n        expr_from_projection(&select.projection[1]),\n    );\n    assert_eq!(2, select.projection.len());\n    match &only(&select.from).relation {\n        TableFactor::Table { name, .. } => {\n            assert_eq!(\"##temp\".to_string(), name.to_string());\n        }\n        _ => unreachable!(),\n    };\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_top_paren", "test": "fn parse_mssql_top_paren() {\n    let sql = \"SELECT TOP (5) * FROM foo\";\n    let select = ms_and_generic().verified_only_select(sql);\n    let top = select.top.unwrap();\n    assert_eq!(Some(Expr::Value(number(\"5\"))), top.quantity);\n    assert!(!top.percent);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_top_percent", "test": "fn parse_mssql_top_percent() {\n    let sql = \"SELECT TOP (5) PERCENT * FROM foo\";\n    let select = ms_and_generic().verified_only_select(sql);\n    let top = select.top.unwrap();\n    assert_eq!(Some(Expr::Value(number(\"5\"))), top.quantity);\n    assert!(top.percent);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_top_with_ties", "test": "fn parse_mssql_top_with_ties() {\n    let sql = \"SELECT TOP (5) WITH TIES * FROM foo\";\n    let select = ms_and_generic().verified_only_select(sql);\n    let top = select.top.unwrap();\n    assert_eq!(Some(Expr::Value(number(\"5\"))), top.quantity);\n    assert!(top.with_ties);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_top_percent_with_ties", "test": "fn parse_mssql_top_percent_with_ties() {\n    let sql = \"SELECT TOP (10) PERCENT WITH TIES * FROM foo\";\n    let select = ms_and_generic().verified_only_select(sql);\n    let top = select.top.unwrap();\n    assert_eq!(Some(Expr::Value(number(\"10\"))), top.quantity);\n    assert!(top.percent);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_mssql_create_role", "test": "fn parse_mssql_create_role() {\n    let sql = \"CREATE ROLE mssql AUTHORIZATION helena\";\n    match ms().verified_stmt(sql) {\n        Statement::CreateRole {\n            names,\n            authorization_owner,\n            ..\n        } => {\n            assert_eq_vec(&[\"mssql\"], &names);\n            assert_eq!(\n                authorization_owner,\n                Some(ObjectName(vec![Ident {\n                    value: \"helena\".into(),\n                    quote_style: None\n                }]))\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_like", "test": "fn parse_like() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = ms_and_generic().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = ms_and_generic().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that LIKE and NOT LIKE have the same precedence.\n        // This was previously mishandled (#81).\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = ms_and_generic().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_similar_to", "test": "fn parse_similar_to() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = ms_and_generic().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = ms_and_generic().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that SIMILAR TO and NOT SIMILAR TO have the same precedence.\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = ms_and_generic().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_substring_in_select", "test": "fn parse_substring_in_select() {\n    let sql = \"SELECT DISTINCT SUBSTRING(description, 0, 1) FROM test\";\n    match ms().one_statement_parses_to(\n        sql,\n        \"SELECT DISTINCT SUBSTRING(description, 0, 1) FROM test\",\n    ) {\n        Statement::Query(query) => {\n            assert_eq!(\n                Box::new(Query {\n                    with: None,\n\n                    body: Box::new(SetExpr::Select(Box::new(Select {\n                        distinct: Some(Distinct::Distinct),\n                        top: None,\n                        projection: vec![SelectItem::UnnamedExpr(Expr::Substring {\n                            expr: Box::new(Expr::Identifier(Ident {\n                                value: \"description\".to_string(),\n                                quote_style: None\n                            })),\n                            substring_from: Some(Box::new(Expr::Value(number(\"0\")))),\n                            substring_for: Some(Box::new(Expr::Value(number(\"1\")))),\n                            special: true,\n                        })],\n                        into: None,\n                        from: vec![TableWithJoins {\n                            relation: TableFactor::Table {\n                                name: ObjectName(vec![Ident {\n                                    value: \"test\".to_string(),\n                                    quote_style: None\n                                }]),\n                                alias: None,\n                                args: None,\n                                with_hints: vec![],\n                                version: None,\n                                partitions: vec![],\n                            },\n                            joins: vec![]\n                        }],\n                        lateral_views: vec![],\n                        selection: None,\n                        group_by: GroupByExpr::Expressions(vec![]),\n                        cluster_by: vec![],\n                        distribute_by: vec![],\n                        sort_by: vec![],\n                        having: None,\n                        named_window: vec![],\n                        qualify: None\n                    }))),\n                    order_by: vec![],\n                    limit: None,\n                    limit_by: vec![],\n                    offset: None,\n                    fetch: None,\n                    locks: vec![],\n                }),\n                query\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_create_table_with_defaults", "test": "fn parse_create_table_with_defaults() {\n    let sql = \"CREATE TABLE public.customer (\n            customer_id integer DEFAULT nextval(public.customer_customer_id_seq),\n            store_id smallint NOT NULL,\n            first_name character varying(45) NOT NULL,\n            last_name character varying(45) COLLATE \\\"es_ES\\\" NOT NULL,\n            email character varying(50),\n            address_id smallint NOT NULL,\n            activebool boolean DEFAULT true NOT NULL,\n            create_date date DEFAULT now()::text NOT NULL,\n            last_update timestamp without time zone DEFAULT now() NOT NULL,\n            active int NOT NULL\n    ) WITH (fillfactor = 20, user_catalog_table = true, autovacuum_vacuum_threshold = 100)\";\n    match pg_and_generic().one_statement_parses_to(sql, \"\") {\n        Statement::CreateTable {\n            name,\n            columns,\n            constraints,\n            with_options,\n            if_not_exists: false,\n            external: false,\n            file_format: None,\n            location: None,\n            ..\n        } => {\n            assert_eq!(\"public.customer\", name.to_string());\n            assert_eq!(\n                columns,\n                vec![\n                    ColumnDef {\n                        name: \"customer_id\".into(),\n                        data_type: DataType::Integer(None),\n                        collation: None,\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::Default(\n                                pg().verified_expr(\"nextval(public.customer_customer_id_seq)\")\n                            )\n                        }],\n                    },\n                    ColumnDef {\n                        name: \"store_id\".into(),\n                        data_type: DataType::SmallInt(None),\n                        collation: None,\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::NotNull,\n                        }],\n                    },\n                    ColumnDef {\n                        name: \"first_name\".into(),\n                        data_type: DataType::CharacterVarying(Some(CharacterLength {\n                            length: 45,\n                            unit: None\n                        })),\n                        collation: None,\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::NotNull,\n                        }],\n                    },\n                    ColumnDef {\n                        name: \"last_name\".into(),\n                        data_type: DataType::CharacterVarying(Some(CharacterLength {\n                            length: 45,\n                            unit: None\n                        })),\n                        collation: Some(ObjectName(vec![Ident::with_quote('\"', \"es_ES\")])),\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::NotNull,\n                        }],\n                    },\n                    ColumnDef {\n                        name: \"email\".into(),\n                        data_type: DataType::CharacterVarying(Some(CharacterLength {\n                            length: 50,\n                            unit: None\n                        })),\n                        collation: None,\n                        options: vec![],\n                    },\n                    ColumnDef {\n                        name: \"address_id\".into(),\n                        data_type: DataType::SmallInt(None),\n                        collation: None,\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::NotNull\n                        }],\n                    },\n                    ColumnDef {\n                        name: \"activebool\".into(),\n                        data_type: DataType::Boolean,\n                        collation: None,\n                        options: vec![\n                            ColumnOptionDef {\n                                name: None,\n                                option: ColumnOption::Default(Expr::Value(Value::Boolean(true))),\n                            },\n                            ColumnOptionDef {\n                                name: None,\n                                option: ColumnOption::NotNull,\n                            }\n                        ],\n                    },\n                    ColumnDef {\n                        name: \"create_date\".into(),\n                        data_type: DataType::Date,\n                        collation: None,\n                        options: vec![\n                            ColumnOptionDef {\n                                name: None,\n                                option: ColumnOption::Default(\n                                    pg().verified_expr(\"CAST(now() AS TEXT)\")\n                                )\n                            },\n                            ColumnOptionDef {\n                                name: None,\n                                option: ColumnOption::NotNull,\n                            }\n                        ],\n                    },\n                    ColumnDef {\n                        name: \"last_update\".into(),\n                        data_type: DataType::Timestamp(None, TimezoneInfo::WithoutTimeZone),\n                        collation: None,\n                        options: vec![\n                            ColumnOptionDef {\n                                name: None,\n                                option: ColumnOption::Default(pg().verified_expr(\"now()\")),\n                            },\n                            ColumnOptionDef {\n                                name: None,\n                                option: ColumnOption::NotNull,\n                            }\n                        ],\n                    },\n                    ColumnDef {\n                        name: \"active\".into(),\n                        data_type: DataType::Int(None),\n                        collation: None,\n                        options: vec![ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::NotNull\n                        }],\n                    },\n                ]\n            );\n            assert!(constraints.is_empty());\n            assert_eq!(\n                with_options,\n                vec![\n                    SqlOption {\n                        name: \"fillfactor\".into(),\n                        value: number(\"20\")\n                    },\n                    SqlOption {\n                        name: \"user_catalog_table\".into(),\n                        value: Value::Boolean(true)\n                    },\n                    SqlOption {\n                        name: \"autovacuum_vacuum_threshold\".into(),\n                        value: number(\"100\")\n                    },\n                ]\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_create_table_constraints_only", "test": "fn parse_create_table_constraints_only() {\n    // Zero-column tables can also have constraints in PostgreSQL\n    let sql = \"CREATE TABLE t (CONSTRAINT positive CHECK (2 > 1))\";\n    let ast = pg_and_generic().verified_stmt(sql);\n    match ast {\n        Statement::CreateTable {\n            name,\n            columns,\n            constraints,\n            ..\n        } => {\n            assert_eq!(\"t\", name.to_string());\n            assert!(columns.is_empty());\n            assert_eq!(\n                only(constraints).to_string(),\n                \"CONSTRAINT positive CHECK (2 > 1)\"\n            );\n        }\n        _ => unreachable!(),\n    };\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_alter_table_constraints_rename", "test": "fn parse_alter_table_constraints_rename() {\n    match alter_table_op(\n        pg().verified_stmt(\"ALTER TABLE tab RENAME CONSTRAINT old_name TO new_name\"),\n    ) {\n        AlterTableOperation::RenameConstraint { old_name, new_name } => {\n            assert_eq!(old_name.to_string(), \"old_name\");\n            assert_eq!(new_name.to_string(), \"new_name\");\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_alter_table_alter_column", "test": "fn parse_alter_table_alter_column() {\n    pg().one_statement_parses_to(\n        \"ALTER TABLE tab ALTER COLUMN is_active TYPE TEXT USING 'text'\",\n        \"ALTER TABLE tab ALTER COLUMN is_active SET DATA TYPE TEXT USING 'text'\",\n    );\n\n    match alter_table_op(\n        pg().verified_stmt(\n            \"ALTER TABLE tab ALTER COLUMN is_active SET DATA TYPE TEXT USING 'text'\",\n        ),\n    ) {\n        AlterTableOperation::AlterColumn { column_name, op } => {\n            assert_eq!(\"is_active\", column_name.to_string());\n            let using_expr = Expr::Value(Value::SingleQuotedString(\"text\".to_string()));\n            assert_eq!(\n                op,\n                AlterColumnOperation::SetDataType {\n                    data_type: DataType::Text,\n                    using: Some(using_expr),\n                }\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_alter_table_add_columns", "test": "fn parse_alter_table_add_columns() {\n    match pg().verified_stmt(\"ALTER TABLE IF EXISTS ONLY tab ADD COLUMN a TEXT, ADD COLUMN b INT\") {\n        Statement::AlterTable {\n            name,\n            if_exists,\n            only,\n            operations,\n        } => {\n            assert_eq!(name.to_string(), \"tab\");\n            assert!(if_exists);\n            assert!(only);\n            assert_eq!(\n                operations,\n                vec![\n                    AlterTableOperation::AddColumn {\n                        column_keyword: true,\n                        if_not_exists: false,\n                        column_def: ColumnDef {\n                            name: \"a\".into(),\n                            data_type: DataType::Text,\n                            collation: None,\n                            options: vec![],\n                        },\n                    },\n                    AlterTableOperation::AddColumn {\n                        column_keyword: true,\n                        if_not_exists: false,\n                        column_def: ColumnDef {\n                            name: \"b\".into(),\n                            data_type: DataType::Int(None),\n                            collation: None,\n                            options: vec![],\n                        },\n                    },\n                ]\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_create_table_if_not_exists", "test": "fn parse_create_table_if_not_exists() {\n    let sql = \"CREATE TABLE IF NOT EXISTS uk_cities ()\";\n    let ast = pg_and_generic().verified_stmt(sql);\n    match ast {\n        Statement::CreateTable {\n            name,\n            if_not_exists: true,\n            ..\n        } => {\n            assert_eq!(\"uk_cities\", name.to_string());\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_bad_if_not_exists", "test": "fn parse_bad_if_not_exists() {\n    let res = pg().parse_sql_statements(\"CREATE TABLE NOT EXISTS uk_cities ()\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: EXISTS\".to_string()),\n        res.unwrap_err()\n    );\n\n    let res = pg().parse_sql_statements(\"CREATE TABLE IF EXISTS uk_cities ()\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: EXISTS\".to_string()),\n        res.unwrap_err()\n    );\n\n    let res = pg().parse_sql_statements(\"CREATE TABLE IF uk_cities ()\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: uk_cities\".to_string()),\n        res.unwrap_err()\n    );\n\n    let res = pg().parse_sql_statements(\"CREATE TABLE IF NOT uk_cities ()\");\n    assert_eq!(\n        ParserError::ParserError(\"Expected end of statement, found: NOT\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_postgres.rs::parse_create_schema_if_not_exists", "test": "fn parse_create_schema_if_not_exists() {\n    let sql = \"CREATE SCHEMA IF NOT EXISTS schema_name\";\n    let ast = pg_and_generic().verified_stmt(sql);\n    match ast {\n        Statement::CreateSchema {\n            if_not_exists: true,\n            schema_name,\n        } => assert_eq!(\"schema_name\", schema_name.to_string()),\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_redshift.rs::test_square_brackets_over_db_schema_table_name", "test": "fn test_square_brackets_over_db_schema_table_name() {\n    let select = redshift().verified_only_select(\"SELECT [col1] FROM [test_schema].[test_table]\");\n    assert_eq!(\n        select.projection[0],\n        SelectItem::UnnamedExpr(Expr::Identifier(Ident {\n            value: \"col1\".to_string(),\n            quote_style: Some('[')\n        })),\n    );\n    assert_eq!(\n        select.from[0],\n        TableWithJoins {\n            relation: TableFactor::Table {\n                name: ObjectName(vec![\n                    Ident {\n                        value: \"test_schema\".to_string(),\n                        quote_style: Some('[')\n                    },\n                    Ident {\n                        value: \"test_table\".to_string(),\n                        quote_style: Some('[')\n                    }\n                ]),\n                alias: None,\n                args: None,\n                with_hints: vec![],\n                version: None,\n                partitions: vec![],\n            },\n            joins: vec![],\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_redshift.rs::brackets_over_db_schema_table_name_with_whites_paces", "test": "fn brackets_over_db_schema_table_name_with_whites_paces() {\n    match redshift().parse_sql_statements(\"SELECT [   col1  ] FROM [  test_schema].[ test_table]\") {\n        Ok(statements) => {\n            assert_eq!(statements.len(), 1);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_redshift.rs::test_double_quotes_over_db_schema_table_name", "test": "fn test_double_quotes_over_db_schema_table_name() {\n    let select =\n        redshift().verified_only_select(\"SELECT \\\"col1\\\" FROM \\\"test_schema\\\".\\\"test_table\\\"\");\n    assert_eq!(\n        select.projection[0],\n        SelectItem::UnnamedExpr(Expr::Identifier(Ident {\n            value: \"col1\".to_string(),\n            quote_style: Some('\"')\n        })),\n    );\n    assert_eq!(\n        select.from[0],\n        TableWithJoins {\n            relation: TableFactor::Table {\n                name: ObjectName(vec![\n                    Ident {\n                        value: \"test_schema\".to_string(),\n                        quote_style: Some('\"')\n                    },\n                    Ident {\n                        value: \"test_table\".to_string(),\n                        quote_style: Some('\"')\n                    }\n                ]),\n                alias: None,\n                args: None,\n                with_hints: vec![],\n                version: None,\n                partitions: vec![],\n            },\n            joins: vec![],\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_redshift.rs::parse_like", "test": "fn parse_like() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = redshift().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = redshift().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that LIKE and NOT LIKE have the same precedence.\n        // This was previously mishandled (#81).\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = redshift().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_redshift.rs::parse_similar_to", "test": "fn parse_similar_to() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = redshift().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = redshift().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that SIMILAR TO and NOT SIMILAR TO have the same precedence.\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = redshift().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_redshift.rs::test_sharp", "test": "fn test_sharp() {\n    let sql = \"SELECT #_of_values\";\n    let select = redshift().verified_only_select(sql);\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::Identifier(Ident::new(\"#_of_values\"))),\n        select.projection[0]\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_snowflake_create_table", "test": "fn test_snowflake_create_table() {\n    let sql = \"CREATE TABLE _my_$table (am00unt number)\";\n    match snowflake_and_generic().verified_stmt(sql) {\n        Statement::CreateTable { name, .. } => {\n            assert_eq!(\"_my_$table\", name.to_string());\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_snowflake_create_transient_table", "test": "fn test_snowflake_create_transient_table() {\n    let sql = \"CREATE TRANSIENT TABLE CUSTOMER (id INT, name VARCHAR(255))\";\n    match snowflake_and_generic().verified_stmt(sql) {\n        Statement::CreateTable {\n            name, transient, ..\n        } => {\n            assert_eq!(\"CUSTOMER\", name.to_string());\n            assert!(transient)\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_single_table_in_parenthesis_with_alias", "test": "fn test_single_table_in_parenthesis_with_alias() {\n    snowflake_and_generic().one_statement_parses_to(\n        \"SELECT * FROM (a NATURAL JOIN (b) c )\",\n        \"SELECT * FROM (a NATURAL JOIN b AS c)\",\n    );\n\n    snowflake_and_generic().one_statement_parses_to(\n        \"SELECT * FROM (a NATURAL JOIN ((b)) c )\",\n        \"SELECT * FROM (a NATURAL JOIN b AS c)\",\n    );\n\n    snowflake_and_generic().one_statement_parses_to(\n        \"SELECT * FROM (a NATURAL JOIN ( (b) c ) )\",\n        \"SELECT * FROM (a NATURAL JOIN b AS c)\",\n    );\n\n    snowflake_and_generic().one_statement_parses_to(\n        \"SELECT * FROM (a NATURAL JOIN ( (b) as c ) )\",\n        \"SELECT * FROM (a NATURAL JOIN b AS c)\",\n    );\n\n    snowflake_and_generic().one_statement_parses_to(\n        \"SELECT * FROM (a alias1 NATURAL JOIN ( (b) c ) )\",\n        \"SELECT * FROM (a AS alias1 NATURAL JOIN b AS c)\",\n    );\n\n    snowflake_and_generic().one_statement_parses_to(\n        \"SELECT * FROM (a as alias1 NATURAL JOIN ( (b) as c ) )\",\n        \"SELECT * FROM (a AS alias1 NATURAL JOIN b AS c)\",\n    );\n\n    snowflake_and_generic().one_statement_parses_to(\n        \"SELECT * FROM (a NATURAL JOIN b) c\",\n        \"SELECT * FROM (a NATURAL JOIN b) AS c\",\n    );\n\n    let res = snowflake().parse_sql_statements(\"SELECT * FROM (a b) c\");\n    assert_eq!(\n        ParserError::ParserError(\"duplicate alias b\".to_string()),\n        res.unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::parse_array", "test": "fn parse_array() {\n    let sql = \"SELECT CAST(a AS ARRAY) FROM customer\";\n    let select = snowflake().verified_only_select(sql);\n    assert_eq!(\n        &Expr::Cast {\n            expr: Box::new(Expr::Identifier(Ident::new(\"a\"))),\n            data_type: DataType::Array(ArrayElemTypeDef::None),\n            format: None,\n        },\n        expr_from_projection(only(&select.projection))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::parse_json_using_colon", "test": "fn parse_json_using_colon() {\n    let sql = \"SELECT a:b FROM t\";\n    let select = snowflake().verified_only_select(sql);\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::JsonAccess {\n            left: Box::new(Expr::Identifier(Ident::new(\"a\"))),\n            operator: JsonOperator::Colon,\n            right: Box::new(Expr::Value(Value::UnQuotedString(\"b\".to_string()))),\n        }),\n        select.projection[0]\n    );\n\n    let sql = \"SELECT a:type FROM t\";\n    let select = snowflake().verified_only_select(sql);\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::JsonAccess {\n            left: Box::new(Expr::Identifier(Ident::new(\"a\"))),\n            operator: JsonOperator::Colon,\n            right: Box::new(Expr::Value(Value::UnQuotedString(\"type\".to_string()))),\n        }),\n        select.projection[0]\n    );\n\n    let sql = \"SELECT a:location FROM t\";\n    let select = snowflake().verified_only_select(sql);\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::JsonAccess {\n            left: Box::new(Expr::Identifier(Ident::new(\"a\"))),\n            operator: JsonOperator::Colon,\n            right: Box::new(Expr::Value(Value::UnQuotedString(\"location\".to_string()))),\n        }),\n        select.projection[0]\n    );\n\n    let sql = \"SELECT a:date FROM t\";\n    let select = snowflake().verified_only_select(sql);\n    assert_eq!(\n        SelectItem::UnnamedExpr(Expr::JsonAccess {\n            left: Box::new(Expr::Identifier(Ident::new(\"a\"))),\n            operator: JsonOperator::Colon,\n            right: Box::new(Expr::Value(Value::UnQuotedString(\"date\".to_string()))),\n        }),\n        select.projection[0]\n    );\n\n    snowflake().one_statement_parses_to(\"SELECT a:b::int FROM t\", \"SELECT CAST(a:b AS INT) FROM t\");\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::parse_like", "test": "fn parse_like() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = snowflake().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = snowflake().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that LIKE and NOT LIKE have the same precedence.\n        // This was previously mishandled (#81).\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = snowflake().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::parse_similar_to", "test": "fn parse_similar_to() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = snowflake().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = snowflake().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that SIMILAR TO and NOT SIMILAR TO have the same precedence.\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = snowflake().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_array_agg_func", "test": "fn test_array_agg_func() {\n    for sql in [\n        \"SELECT ARRAY_AGG(x) WITHIN GROUP (ORDER BY x) AS a FROM T\",\n        \"SELECT ARRAY_AGG(DISTINCT x) WITHIN GROUP (ORDER BY x ASC) FROM tbl\",\n    ] {\n        snowflake().verified_stmt(sql);\n    }\n\n    let sql = \"select array_agg(x order by x) as a from T\";\n    let result = snowflake().parse_sql_statements(sql);\n    assert_eq!(\n        result,\n        Err(ParserError::ParserError(String::from(\n            \"Expected ), found: order\"\n        )))\n    )\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_alter_table_swap_with", "test": "fn test_alter_table_swap_with() {\n    let sql = \"ALTER TABLE tab1 SWAP WITH tab2\";\n    match alter_table_op_with_name(snowflake_and_generic().verified_stmt(sql), \"tab1\") {\n        AlterTableOperation::SwapWith { table_name } => {\n            assert_eq!(\"tab2\", table_name.to_string());\n        }\n        _ => unreachable!(),\n    };\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_create_stage_with_stage_params", "test": "fn test_create_stage_with_stage_params() {\n    let sql = concat!(\n        \"CREATE OR REPLACE STAGE my_ext_stage \",\n        \"URL='s3://load/files/' \",\n        \"STORAGE_INTEGRATION=myint \",\n        \"ENDPOINT='<s3_api_compatible_endpoint>' \",\n        \"CREDENTIALS=(AWS_KEY_ID='1a2b3c' AWS_SECRET_KEY='4x5y6z') \",\n        \"ENCRYPTION=(MASTER_KEY='key' TYPE='AWS_SSE_KMS')\"\n    );\n\n    match snowflake().verified_stmt(sql) {\n        Statement::CreateStage { stage_params, .. } => {\n            assert_eq!(\"s3://load/files/\", stage_params.url.unwrap());\n            assert_eq!(\"myint\", stage_params.storage_integration.unwrap());\n            assert_eq!(\n                \"<s3_api_compatible_endpoint>\",\n                stage_params.endpoint.unwrap()\n            );\n            assert!(stage_params\n                .credentials\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"AWS_KEY_ID\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"1a2b3c\".to_string()\n                }));\n            assert!(stage_params\n                .credentials\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"AWS_SECRET_KEY\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"4x5y6z\".to_string()\n                }));\n            assert!(stage_params\n                .encryption\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"MASTER_KEY\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"key\".to_string()\n                }));\n            assert!(stage_params\n                .encryption\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"TYPE\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"AWS_SSE_KMS\".to_string()\n                }));\n        }\n        _ => unreachable!(),\n    };\n\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_create_stage_with_directory_table_params", "test": "fn test_create_stage_with_directory_table_params() {\n    let sql = concat!(\n        \"CREATE OR REPLACE STAGE my_ext_stage \",\n        \"URL='s3://load/files/' \",\n        \"DIRECTORY=(ENABLE=TRUE REFRESH_ON_CREATE=FALSE NOTIFICATION_INTEGRATION='some-string')\"\n    );\n\n    match snowflake().verified_stmt(sql) {\n        Statement::CreateStage {\n            directory_table_params,\n            ..\n        } => {\n            assert!(directory_table_params.options.contains(&DataLoadingOption {\n                option_name: \"ENABLE\".to_string(),\n                option_type: DataLoadingOptionType::BOOLEAN,\n                value: \"TRUE\".to_string()\n            }));\n            assert!(directory_table_params.options.contains(&DataLoadingOption {\n                option_name: \"REFRESH_ON_CREATE\".to_string(),\n                option_type: DataLoadingOptionType::BOOLEAN,\n                value: \"FALSE\".to_string()\n            }));\n            assert!(directory_table_params.options.contains(&DataLoadingOption {\n                option_name: \"NOTIFICATION_INTEGRATION\".to_string(),\n                option_type: DataLoadingOptionType::STRING,\n                value: \"some-string\".to_string()\n            }));\n        }\n        _ => unreachable!(),\n    };\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_create_stage_with_file_format", "test": "fn test_create_stage_with_file_format() {\n    let sql = concat!(\n        \"CREATE OR REPLACE STAGE my_ext_stage \",\n        \"URL='s3://load/files/' \",\n        \"FILE_FORMAT=(COMPRESSION=AUTO BINARY_FORMAT=HEX ESCAPE='\\\\')\"\n    );\n\n    match snowflake().verified_stmt(sql) {\n        Statement::CreateStage { file_format, .. } => {\n            assert!(file_format.options.contains(&DataLoadingOption {\n                option_name: \"COMPRESSION\".to_string(),\n                option_type: DataLoadingOptionType::ENUM,\n                value: \"AUTO\".to_string()\n            }));\n            assert!(file_format.options.contains(&DataLoadingOption {\n                option_name: \"BINARY_FORMAT\".to_string(),\n                option_type: DataLoadingOptionType::ENUM,\n                value: \"HEX\".to_string()\n            }));\n            assert!(file_format.options.contains(&DataLoadingOption {\n                option_name: \"ESCAPE\".to_string(),\n                option_type: DataLoadingOptionType::STRING,\n                value: \"\\\\\".to_string()\n            }));\n        }\n        _ => unreachable!(),\n    };\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_create_stage_with_copy_options", "test": "fn test_create_stage_with_copy_options() {\n    let sql = concat!(\n        \"CREATE OR REPLACE STAGE my_ext_stage \",\n        \"URL='s3://load/files/' \",\n        \"COPY_OPTIONS=(ON_ERROR=CONTINUE FORCE=TRUE)\"\n    );\n    match snowflake().verified_stmt(sql) {\n        Statement::CreateStage { copy_options, .. } => {\n            assert!(copy_options.options.contains(&DataLoadingOption {\n                option_name: \"ON_ERROR\".to_string(),\n                option_type: DataLoadingOptionType::ENUM,\n                value: \"CONTINUE\".to_string()\n            }));\n            assert!(copy_options.options.contains(&DataLoadingOption {\n                option_name: \"FORCE\".to_string(),\n                option_type: DataLoadingOptionType::BOOLEAN,\n                value: \"TRUE\".to_string()\n            }));\n        }\n        _ => unreachable!(),\n    };\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_copy_into", "test": "fn test_copy_into() {\n    let sql = concat!(\n        \"COPY INTO my_company.emp_basic \",\n        \"FROM 'gcs://mybucket/./../a.csv'\"\n    );\n    match snowflake().verified_stmt(sql) {\n        Statement::CopyIntoSnowflake {\n            into,\n            from_stage,\n            files,\n            pattern,\n            validation_mode,\n            ..\n        } => {\n            assert_eq!(\n                into,\n                ObjectName(vec![Ident::new(\"my_company\"), Ident::new(\"emp_basic\")])\n            );\n            assert_eq!(\n                from_stage,\n                ObjectName(vec![Ident::with_quote('\\'', \"gcs://mybucket/./../a.csv\")])\n            );\n            assert!(files.is_none());\n            assert!(pattern.is_none());\n            assert!(validation_mode.is_none());\n        }\n        _ => unreachable!(),\n    };\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_copy_into_with_stage_params", "test": "fn test_copy_into_with_stage_params() {\n    let sql = concat!(\n        \"COPY INTO my_company.emp_basic \",\n        \"FROM 's3://load/files/' \",\n        \"STORAGE_INTEGRATION=myint \",\n        \"ENDPOINT='<s3_api_compatible_endpoint>' \",\n        \"CREDENTIALS=(AWS_KEY_ID='1a2b3c' AWS_SECRET_KEY='4x5y6z') \",\n        \"ENCRYPTION=(MASTER_KEY='key' TYPE='AWS_SSE_KMS')\"\n    );\n\n    match snowflake().verified_stmt(sql) {\n        Statement::CopyIntoSnowflake {\n            from_stage,\n            stage_params,\n            ..\n        } => {\n            //assert_eq!(\"s3://load/files/\", stage_params.url.unwrap());\n            assert_eq!(\n                from_stage,\n                ObjectName(vec![Ident::with_quote('\\'', \"s3://load/files/\")])\n            );\n            assert_eq!(\"myint\", stage_params.storage_integration.unwrap());\n            assert_eq!(\n                \"<s3_api_compatible_endpoint>\",\n                stage_params.endpoint.unwrap()\n            );\n            assert!(stage_params\n                .credentials\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"AWS_KEY_ID\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"1a2b3c\".to_string()\n                }));\n            assert!(stage_params\n                .credentials\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"AWS_SECRET_KEY\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"4x5y6z\".to_string()\n                }));\n            assert!(stage_params\n                .encryption\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"MASTER_KEY\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"key\".to_string()\n                }));\n            assert!(stage_params\n                .encryption\n                .options\n                .contains(&DataLoadingOption {\n                    option_name: \"TYPE\".to_string(),\n                    option_type: DataLoadingOptionType::STRING,\n                    value: \"AWS_SSE_KMS\".to_string()\n                }));\n        }\n        _ => unreachable!(),\n    };\n\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n\n    // stage params within copy into with transformations\n    let sql = concat!(\n        \"COPY INTO my_company.emp_basic FROM \",\n        \"(SELECT t1.$1 FROM 's3://load/files/' STORAGE_INTEGRATION=myint)\",\n    );\n\n    match snowflake().verified_stmt(sql) {\n        Statement::CopyIntoSnowflake {\n            from_stage,\n            stage_params,\n            ..\n        } => {\n            assert_eq!(\n                from_stage,\n                ObjectName(vec![Ident::with_quote('\\'', \"s3://load/files/\")])\n            );\n            assert_eq!(\"myint\", stage_params.storage_integration.unwrap());\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_copy_into_with_files_and_pattern_and_verification", "test": "fn test_copy_into_with_files_and_pattern_and_verification() {\n    let sql = concat!(\n        \"COPY INTO my_company.emp_basic \",\n        \"FROM 'gcs://mybucket/./../a.csv' AS some_alias \",\n        \"FILES = ('file1.json', 'file2.json') \",\n        \"PATTERN = '.*employees0[1-5].csv.gz' \",\n        \"VALIDATION_MODE = RETURN_7_ROWS\"\n    );\n\n    match snowflake().verified_stmt(sql) {\n        Statement::CopyIntoSnowflake {\n            files,\n            pattern,\n            validation_mode,\n            from_stage_alias,\n            ..\n        } => {\n            assert_eq!(files.unwrap(), vec![\"file1.json\", \"file2.json\"]);\n            assert_eq!(pattern.unwrap(), \".*employees0[1-5].csv.gz\");\n            assert_eq!(validation_mode.unwrap(), \"RETURN_7_ROWS\");\n            assert_eq!(from_stage_alias.unwrap(), Ident::new(\"some_alias\"));\n        }\n        _ => unreachable!(),\n    }\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_copy_into_with_transformations", "test": "fn test_copy_into_with_transformations() {\n    let sql = concat!(\n        \"COPY INTO my_company.emp_basic FROM \",\n        \"(SELECT t1.$1:st AS st, $1:index, t2.$1 FROM @schema.general_finished AS T) \",\n        \"FILES = ('file1.json', 'file2.json') \",\n        \"PATTERN = '.*employees0[1-5].csv.gz' \",\n        \"VALIDATION_MODE = RETURN_7_ROWS\"\n    );\n\n    match snowflake().verified_stmt(sql) {\n        Statement::CopyIntoSnowflake {\n            from_stage,\n            from_transformations,\n            ..\n        } => {\n            assert_eq!(\n                from_stage,\n                ObjectName(vec![Ident::new(\"@schema\"), Ident::new(\"general_finished\")])\n            );\n            assert_eq!(\n                from_transformations.as_ref().unwrap()[0],\n                StageLoadSelectItem {\n                    alias: Some(Ident::new(\"t1\")),\n                    file_col_num: 1,\n                    element: Some(Ident::new(\"st\")),\n                    item_as: Some(Ident::new(\"st\"))\n                }\n            );\n            assert_eq!(\n                from_transformations.as_ref().unwrap()[1],\n                StageLoadSelectItem {\n                    alias: None,\n                    file_col_num: 1,\n                    element: Some(Ident::new(\"index\")),\n                    item_as: None\n                }\n            );\n            assert_eq!(\n                from_transformations.as_ref().unwrap()[2],\n                StageLoadSelectItem {\n                    alias: Some(Ident::new(\"t2\")),\n                    file_col_num: 1,\n                    element: None,\n                    item_as: None\n                }\n            );\n        }\n        _ => unreachable!(),\n    }\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_copy_into_file_format", "test": "fn test_copy_into_file_format() {\n    let sql = concat!(\n        \"COPY INTO my_company.emp_basic \",\n        \"FROM 'gcs://mybucket/./../a.csv' \",\n        \"FILES = ('file1.json', 'file2.json') \",\n        \"PATTERN = '.*employees0[1-5].csv.gz' \",\n        \"FILE_FORMAT=(COMPRESSION=AUTO BINARY_FORMAT=HEX ESCAPE='\\\\')\"\n    );\n\n    match snowflake().verified_stmt(sql) {\n        Statement::CopyIntoSnowflake { file_format, .. } => {\n            assert!(file_format.options.contains(&DataLoadingOption {\n                option_name: \"COMPRESSION\".to_string(),\n                option_type: DataLoadingOptionType::ENUM,\n                value: \"AUTO\".to_string()\n            }));\n            assert!(file_format.options.contains(&DataLoadingOption {\n                option_name: \"BINARY_FORMAT\".to_string(),\n                option_type: DataLoadingOptionType::ENUM,\n                value: \"HEX\".to_string()\n            }));\n            assert!(file_format.options.contains(&DataLoadingOption {\n                option_name: \"ESCAPE\".to_string(),\n                option_type: DataLoadingOptionType::STRING,\n                value: \"\\\\\".to_string()\n            }));\n        }\n        _ => unreachable!(),\n    }\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_copy_into_copy_options", "test": "fn test_copy_into_copy_options() {\n    let sql = concat!(\n        \"COPY INTO my_company.emp_basic \",\n        \"FROM 'gcs://mybucket/./../a.csv' \",\n        \"FILES = ('file1.json', 'file2.json') \",\n        \"PATTERN = '.*employees0[1-5].csv.gz' \",\n        \"COPY_OPTIONS=(ON_ERROR=CONTINUE FORCE=TRUE)\"\n    );\n\n    match snowflake().verified_stmt(sql) {\n        Statement::CopyIntoSnowflake { copy_options, .. } => {\n            assert!(copy_options.options.contains(&DataLoadingOption {\n                option_name: \"ON_ERROR\".to_string(),\n                option_type: DataLoadingOptionType::ENUM,\n                value: \"CONTINUE\".to_string()\n            }));\n            assert!(copy_options.options.contains(&DataLoadingOption {\n                option_name: \"FORCE\".to_string(),\n                option_type: DataLoadingOptionType::BOOLEAN,\n                value: \"TRUE\".to_string()\n            }));\n        }\n        _ => unreachable!(),\n    };\n    assert_eq!(snowflake().verified_stmt(sql).to_string(), sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_snowflake_trim", "test": "fn test_snowflake_trim() {\n    let real_sql = r#\"SELECT customer_id, TRIM(sub_items.value:item_price_id, '\"', \"a\") AS item_price_id FROM models_staging.subscriptions\"#;\n    assert_eq!(snowflake().verified_stmt(real_sql).to_string(), real_sql);\n\n    let sql_only_select = \"SELECT TRIM('xyz', 'a')\";\n    let select = snowflake().verified_only_select(sql_only_select);\n    assert_eq!(\n        &Expr::Trim {\n            expr: Box::new(Expr::Value(Value::SingleQuotedString(\"xyz\".to_owned()))),\n            trim_where: None,\n            trim_what: None,\n            trim_characters: Some(vec![Expr::Value(Value::SingleQuotedString(\"a\".to_owned()))]),\n        },\n        expr_from_projection(only(&select.projection))\n    );\n\n    // missing comma separation\n    let error_sql = \"SELECT TRIM('xyz' 'a')\";\n    assert_eq!(\n        ParserError::ParserError(\"Expected ), found: 'a'\".to_owned()),\n        snowflake().parse_sql_statements(error_sql).unwrap_err()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_snowflake.rs::test_number_placeholder", "test": "fn test_number_placeholder() {\n    let sql_only_select = \"SELECT :1\";\n    let select = snowflake().verified_only_select(sql_only_select);\n    assert_eq!(\n        &Expr::Value(Value::Placeholder(\":1\".into())),\n        expr_from_projection(only(&select.projection))\n    );\n\n    snowflake()\n        .parse_sql_statements(\"alter role 1 with name = 'foo'\")\n        .expect_err(\"should have failed\");\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::pragma_no_value", "test": "fn pragma_no_value() {\n    let sql = \"PRAGMA cache_size\";\n    match sqlite_and_generic().verified_stmt(sql) {\n        Statement::Pragma {\n            name,\n            value: None,\n            is_eq: false,\n        } => {\n            assert_eq!(\"cache_size\", name.to_string());\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::pragma_eq_style", "test": "fn pragma_eq_style() {\n    let sql = \"PRAGMA cache_size = 10\";\n    match sqlite_and_generic().verified_stmt(sql) {\n        Statement::Pragma {\n            name,\n            value: Some(val),\n            is_eq: true,\n        } => {\n            assert_eq!(\"cache_size\", name.to_string());\n            assert_eq!(\"10\", val.to_string());\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::pragma_funciton_style", "test": "fn pragma_funciton_style() {\n    let sql = \"PRAGMA cache_size(10)\";\n    match sqlite_and_generic().verified_stmt(sql) {\n        Statement::Pragma {\n            name,\n            value: Some(val),\n            is_eq: false,\n        } => {\n            assert_eq!(\"cache_size\", name.to_string());\n            assert_eq!(\"10\", val.to_string());\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::parse_create_table_without_rowid", "test": "fn parse_create_table_without_rowid() {\n    let sql = \"CREATE TABLE t (a INT) WITHOUT ROWID\";\n    match sqlite_and_generic().verified_stmt(sql) {\n        Statement::CreateTable {\n            name,\n            without_rowid: true,\n            ..\n        } => {\n            assert_eq!(\"t\", name.to_string());\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::parse_create_virtual_table", "test": "fn parse_create_virtual_table() {\n    let sql = \"CREATE VIRTUAL TABLE IF NOT EXISTS t USING module_name (arg1, arg2)\";\n    match sqlite_and_generic().verified_stmt(sql) {\n        Statement::CreateVirtualTable {\n            name,\n            if_not_exists: true,\n            module_name,\n            module_args,\n        } => {\n            let args = vec![Ident::new(\"arg1\"), Ident::new(\"arg2\")];\n            assert_eq!(\"t\", name.to_string());\n            assert_eq!(\"module_name\", module_name.to_string());\n            assert_eq!(args, module_args);\n        }\n        _ => unreachable!(),\n    }\n\n    let sql = \"CREATE VIRTUAL TABLE t USING module_name\";\n    sqlite_and_generic().verified_stmt(sql);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::parse_create_view_temporary_if_not_exists", "test": "fn parse_create_view_temporary_if_not_exists() {\n    let sql = \"CREATE TEMPORARY VIEW IF NOT EXISTS myschema.myview AS SELECT foo FROM bar\";\n    match sqlite_and_generic().verified_stmt(sql) {\n        Statement::CreateView {\n            name,\n            columns,\n            query,\n            or_replace,\n            materialized,\n            with_options,\n            cluster_by,\n            with_no_schema_binding: late_binding,\n            if_not_exists,\n            temporary,\n        } => {\n            assert_eq!(\"myschema.myview\", name.to_string());\n            assert_eq!(Vec::<Ident>::new(), columns);\n            assert_eq!(\"SELECT foo FROM bar\", query.to_string());\n            assert!(!materialized);\n            assert!(!or_replace);\n            assert_eq!(with_options, vec![]);\n            assert_eq!(cluster_by, vec![]);\n            assert!(!late_binding);\n            assert!(if_not_exists);\n            assert!(temporary);\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::parse_create_table_auto_increment", "test": "fn parse_create_table_auto_increment() {\n    let sql = \"CREATE TABLE foo (bar INT PRIMARY KEY AUTOINCREMENT)\";\n    match sqlite_and_generic().verified_stmt(sql) {\n        Statement::CreateTable { name, columns, .. } => {\n            assert_eq!(name.to_string(), \"foo\");\n            assert_eq!(\n                vec![ColumnDef {\n                    name: \"bar\".into(),\n                    data_type: DataType::Int(None),\n                    collation: None,\n                    options: vec![\n                        ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::Unique { is_primary: true },\n                        },\n                        ColumnOptionDef {\n                            name: None,\n                            option: ColumnOption::DialectSpecific(vec![Token::make_keyword(\n                                \"AUTOINCREMENT\"\n                            )]),\n                        },\n                    ],\n                }],\n                columns\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::parse_create_sqlite_quote", "test": "fn parse_create_sqlite_quote() {\n    let sql = \"CREATE TABLE `PRIMARY` (\\\"KEY\\\" INT, [INDEX] INT)\";\n    match sqlite().verified_stmt(sql) {\n        Statement::CreateTable { name, columns, .. } => {\n            assert_eq!(name.to_string(), \"`PRIMARY`\");\n            assert_eq!(\n                vec![\n                    ColumnDef {\n                        name: Ident::with_quote('\"', \"KEY\"),\n                        data_type: DataType::Int(None),\n                        collation: None,\n                        options: vec![],\n                    },\n                    ColumnDef {\n                        name: Ident::with_quote('[', \"INDEX\"),\n                        data_type: DataType::Int(None),\n                        collation: None,\n                        options: vec![],\n                    },\n                ],\n                columns\n            );\n        }\n        _ => unreachable!(),\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::test_placeholder", "test": "fn test_placeholder() {\n    // In postgres, this would be the absolute value operator '@' applied to the column 'xxx'\n    // But in sqlite, this is a named parameter.\n    // see https://www.sqlite.org/lang_expr.html#varparam\n    let sql = \"SELECT @xxx\";\n    let ast = sqlite().verified_only_select(sql);\n    assert_eq!(\n        ast.projection[0],\n        UnnamedExpr(Expr::Value(Value::Placeholder(\"@xxx\".into()))),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::parse_like", "test": "fn parse_like() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = sqlite().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = sqlite().verified_only_select(sql);\n        assert_eq!(\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that LIKE and NOT LIKE have the same precedence.\n        // This was previously mishandled (#81).\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}LIKE '%a' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = sqlite().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::Like {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::parse_similar_to", "test": "fn parse_similar_to() {\n    fn chk(negated: bool) {\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = sqlite().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: None,\n            },\n            select.selection.unwrap()\n        );\n\n        // Test with escape char\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\'\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = sqlite().verified_only_select(sql);\n        assert_eq!(\n            Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            },\n            select.selection.unwrap()\n        );\n\n        // This statement tests that SIMILAR TO and NOT SIMILAR TO have the same precedence.\n        let sql = &format!(\n            \"SELECT * FROM customers WHERE name {}SIMILAR TO '%a' ESCAPE '\\\\' IS NULL\",\n            if negated { \"NOT \" } else { \"\" }\n        );\n        let select = sqlite().verified_only_select(sql);\n        assert_eq!(\n            Expr::IsNull(Box::new(Expr::SimilarTo {\n                expr: Box::new(Expr::Identifier(Ident::new(\"name\"))),\n                negated,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"%a\".to_string()))),\n                escape_char: Some('\\\\'),\n            })),\n            select.selection.unwrap()\n        );\n    }\n    chk(false);\n    chk(true);\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::parse_create_table_with_strict", "test": "fn parse_create_table_with_strict() {\n    let sql = \"CREATE TABLE Fruits (id TEXT NOT NULL PRIMARY KEY) STRICT\";\n    if let Statement::CreateTable { name, strict, .. } = sqlite().verified_stmt(sql) {\n        assert_eq!(name.to_string(), \"Fruits\");\n        assert!(strict);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_sqlite.rs::parse_window_function_with_filter", "test": "fn parse_window_function_with_filter() {\n    for func_name in [\n        \"row_number\",\n        \"rank\",\n        \"max\",\n        \"count\",\n        \"user_defined_function\",\n    ] {\n        let sql = format!(\"SELECT {}(x) FILTER (WHERE y) OVER () FROM t\", func_name);\n        let select = sqlite().verified_only_select(&sql);\n        assert_eq!(select.to_string(), sql);\n        assert_eq!(\n            select.projection,\n            vec![SelectItem::UnnamedExpr(Expr::Function(Function {\n                name: ObjectName(vec![Ident::new(func_name)]),\n                args: vec![FunctionArg::Unnamed(FunctionArgExpr::Expr(\n                    Expr::Identifier(Ident::new(\"x\"))\n                ))],\n                null_treatment: None,\n                over: Some(WindowType::WindowSpec(WindowSpec {\n                    partition_by: vec![],\n                    order_by: vec![],\n                    window_frame: None,\n                })),\n                filter: Some(Box::new(Expr::Identifier(Ident::new(\"y\")))),\n                distinct: false,\n                special: false,\n                order_by: vec![]\n            }))]\n        );\n    }\n}", "error": "Not Definition Found"}
