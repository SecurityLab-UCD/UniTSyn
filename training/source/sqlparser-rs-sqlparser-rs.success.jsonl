{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_bigquery.rs::parse_invalid_brackets", "test": "fn parse_invalid_brackets() {\n    let sql = \"SELECT STRUCT<INT64>>(NULL)\";\n    assert_eq!(\n        bigquery().parse_sql_statements(sql).unwrap_err(),\n        ParserError::ParserError(\"unmatched > in STRUCT literal\".to_string())\n    );\n\n    let sql = \"SELECT STRUCT<STRUCT<INT64>>>(NULL)\";\n    assert_eq!(\n        bigquery().parse_sql_statements(sql).unwrap_err(),\n        ParserError::ParserError(\"Expected (, found: >\".to_string())\n    );\n\n    let sql = \"CREATE TABLE table (x STRUCT<STRUCT<INT64>>>)\";\n    assert_eq!(\n        bigquery().parse_sql_statements(sql).unwrap_err(),\n        ParserError::ParserError(\n            \"Expected ',' or ')' after column definition, found: >\".to_string()\n        )\n    );\n}", "code_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/src/test_utils.rs::parse_sql_statements", "code": "pub fn parse_sql_statements(&self, sql: &str) -> Result<Vec<Statement>, ParserError> {\n        self.one_of_identical_results(|dialect| {\n            let mut tokenizer = Tokenizer::new(dialect, sql);\n            if let Some(options) = &self.options {\n                tokenizer = tokenizer.with_unescape(options.unescape);\n            }\n            let tokens = tokenizer.tokenize()?;\n            self.new_parser(dialect)\n                .with_tokens(tokens)\n                .parse_statements()\n        })\n        // To fail the `ensure_multiple_dialects_are_tested` test:\n        // Parser::parse_sql(&**self.dialects.first().unwrap(), sql)\n    }", "docstring": null}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_not_precedence", "test": "fn parse_not_precedence() {\n    // NOT has higher precedence than OR/AND, so the following must parse as (NOT true) OR true\n    let sql = \"NOT true OR true\";\n    assert_matches!(\n        verified_expr(sql),\n        Expr::BinaryOp {\n            op: BinaryOperator::Or,\n            ..\n        }\n    );\n\n    // But NOT has lower precedence than comparison operators, so the following parses as NOT (a IS NULL)\n    let sql = \"NOT a IS NULL\";\n    assert_matches!(\n        verified_expr(sql),\n        Expr::UnaryOp {\n            op: UnaryOperator::Not,\n            ..\n        }\n    );\n\n    // NOT has lower precedence than BETWEEN, so the following parses as NOT (1 NOT BETWEEN 1 AND 2)\n    let sql = \"NOT 1 NOT BETWEEN 1 AND 2\";\n    assert_eq!(\n        verified_expr(sql),\n        Expr::UnaryOp {\n            op: UnaryOperator::Not,\n            expr: Box::new(Expr::Between {\n                expr: Box::new(Expr::Value(number(\"1\"))),\n                low: Box::new(Expr::Value(number(\"1\"))),\n                high: Box::new(Expr::Value(number(\"2\"))),\n                negated: true,\n            }),\n        },\n    );\n\n    // NOT has lower precedence than LIKE, so the following parses as NOT ('a' NOT LIKE 'b')\n    let sql = \"NOT 'a' NOT LIKE 'b'\";\n    assert_eq!(\n        verified_expr(sql),\n        Expr::UnaryOp {\n            op: UnaryOperator::Not,\n            expr: Box::new(Expr::Like {\n                expr: Box::new(Expr::Value(Value::SingleQuotedString(\"a\".into()))),\n                negated: true,\n                pattern: Box::new(Expr::Value(Value::SingleQuotedString(\"b\".into()))),\n                escape_char: None,\n            }),\n        },\n    );\n\n    // NOT has lower precedence than IN, so the following parses as NOT (a NOT IN 'a')\n    let sql = \"NOT a NOT IN ('a')\";\n    assert_eq!(\n        verified_expr(sql),\n        Expr::UnaryOp {\n            op: UnaryOperator::Not,\n            expr: Box::new(Expr::InList {\n                expr: Box::new(Expr::Identifier(\"a\".into())),\n                list: vec![Expr::Value(Value::SingleQuotedString(\"a\".into()))],\n                negated: true,\n            }),\n        },\n    );\n}", "code_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/src/test_utils.rs::verified_expr", "code": "pub fn verified_expr(&self, sql: &str) -> Expr {\n        self.expr_parses_to(sql, sql)\n    }", "docstring": null}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_create_table_on_cluster", "test": "fn parse_create_table_on_cluster() {\n    // Using single-quote literal to define current cluster\n    let sql = \"CREATE TABLE t ON CLUSTER '{cluster}' (a INT, b INT)\";\n    match verified_stmt(sql) {\n        Statement::CreateTable { on_cluster, .. } => {\n            assert_eq!(on_cluster.unwrap(), \"{cluster}\".to_string());\n        }\n        _ => unreachable!(),\n    }\n\n    // Using explicitly declared cluster name\n    let sql = \"CREATE TABLE t ON CLUSTER my_cluster (a INT, b INT)\";\n    match verified_stmt(sql) {\n        Statement::CreateTable { on_cluster, .. } => {\n            assert_eq!(on_cluster.unwrap(), \"my_cluster\".to_string());\n        }\n        _ => unreachable!(),\n    }\n}", "code_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/src/ast/helpers/stmt_create_table.rs::on_cluster", "code": "pub fn on_cluster(mut self, on_cluster: Option<String>) -> Self {\n        self.on_cluster = on_cluster;\n        self\n    }", "docstring": null}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_common.rs::parse_scalar_subqueries", "test": "fn parse_scalar_subqueries() {\n    let sql = \"(SELECT 1) + (SELECT 2)\";\n    assert_matches!(\n        verified_expr(sql),\n        Expr::BinaryOp {\n            op: BinaryOperator::Plus,\n            ..\n        }\n    );\n}", "code_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/src/test_utils.rs::verified_expr", "code": "pub fn verified_expr(&self, sql: &str) -> Expr {\n        self.expr_parses_to(sql, sql)\n    }", "docstring": null}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_create_procedure", "test": "fn parse_create_procedure() {\n    let sql = \"CREATE OR ALTER PROCEDURE test (@foo INT, @bar VARCHAR(256)) AS BEGIN SELECT 1 END\";\n\n    assert_eq!(\n        ms().verified_stmt(sql),\n        Statement::CreateProcedure {\n            or_alter: true,\n            body: vec![Statement::Query(Box::new(Query {\n                with: None,\n                limit: None,\n                limit_by: vec![],\n                offset: None,\n                fetch: None,\n                locks: vec![],\n                order_by: vec![],\n                body: Box::new(SetExpr::Select(Box::new(Select {\n                    distinct: None,\n                    top: None,\n                    projection: vec![SelectItem::UnnamedExpr(Expr::Value(number(\"1\")))],\n                    into: None,\n                    from: vec![],\n                    lateral_views: vec![],\n                    selection: None,\n                    group_by: GroupByExpr::Expressions(vec![]),\n                    cluster_by: vec![],\n                    distribute_by: vec![],\n                    sort_by: vec![],\n                    having: None,\n                    named_window: vec![],\n                    qualify: None\n                })))\n            }))],\n            params: Some(vec![\n                ProcedureParam {\n                    name: Ident {\n                        value: \"@foo\".into(),\n                        quote_style: None\n                    },\n                    data_type: DataType::Int(None)\n                },\n                ProcedureParam {\n                    name: Ident {\n                        value: \"@bar\".into(),\n                        quote_style: None\n                    },\n                    data_type: DataType::Varchar(Some(CharacterLength {\n                        length: 256,\n                        unit: None\n                    }))\n                }\n            ]),\n            name: ObjectName(vec![Ident {\n                value: \"test\".into(),\n                quote_style: None\n            }])\n        }\n    )\n}", "code_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/src/test_utils.rs::verified_stmt", "code": "pub fn verified_stmt(&self, sql: &str) -> Statement {\n        self.one_statement_parses_to(sql, sql)\n    }", "docstring": null}
{"test_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/tests/sqlparser_mssql.rs::parse_alter_role", "test": "fn parse_alter_role() {\n    let sql = \"ALTER ROLE old_name WITH NAME = new_name\";\n    assert_eq!(\n        ms().parse_sql_statements(sql).unwrap(),\n        [Statement::AlterRole {\n            name: Ident {\n                value: \"old_name\".into(),\n                quote_style: None\n            },\n            operation: AlterRoleOperation::RenameRole {\n                role_name: Ident {\n                    value: \"new_name\".into(),\n                    quote_style: None\n                }\n            },\n        }]\n    );\n\n    let sql = \"ALTER ROLE role_name ADD MEMBER new_member\";\n    assert_eq!(\n        ms().verified_stmt(sql),\n        Statement::AlterRole {\n            name: Ident {\n                value: \"role_name\".into(),\n                quote_style: None\n            },\n            operation: AlterRoleOperation::AddMember {\n                member_name: Ident {\n                    value: \"new_member\".into(),\n                    quote_style: None\n                }\n            },\n        }\n    );\n\n    let sql = \"ALTER ROLE role_name DROP MEMBER old_member\";\n    assert_eq!(\n        ms().verified_stmt(sql),\n        Statement::AlterRole {\n            name: Ident {\n                value: \"role_name\".into(),\n                quote_style: None\n            },\n            operation: AlterRoleOperation::DropMember {\n                member_name: Ident {\n                    value: \"old_member\".into(),\n                    quote_style: None\n                }\n            },\n        }\n    );\n}", "code_id": "sqlparser-rs-sqlparser-rs/sqlparser-rs-sqlparser-rs-964aee1/src/test_utils.rs::parse_sql_statements", "code": "pub fn parse_sql_statements(&self, sql: &str) -> Result<Vec<Statement>, ParserError> {\n        self.one_of_identical_results(|dialect| {\n            let mut tokenizer = Tokenizer::new(dialect, sql);\n            if let Some(options) = &self.options {\n                tokenizer = tokenizer.with_unescape(options.unescape);\n            }\n            let tokens = tokenizer.tokenize()?;\n            self.new_parser(dialect)\n                .with_tokens(tokens)\n                .parse_statements()\n        })\n        // To fail the `ensure_multiple_dialects_are_tested` test:\n        // Parser::parse_sql(&**self.dialects.first().unwrap(), sql)\n    }", "docstring": null}
