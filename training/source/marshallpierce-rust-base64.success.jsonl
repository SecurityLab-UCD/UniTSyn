{"test_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/tests/encode.rs::encode_all_bytes_url", "test": "fn encode_all_bytes_url() {\n    let bytes: Vec<u8> = (0..=255).collect();\n\n    assert_eq!(\n        \"AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0\\\n         -P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn\\\n         -AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq\\\n         -wsbKztLW2t7i5uru8vb6_wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t_g4eLj5OXm5-jp6uvs7e7v8PHy\\\n         8_T19vf4-fr7_P3-_w==\",\n        &engine::GeneralPurpose::new(&URL_SAFE, PAD).encode(bytes)\n    );\n}", "code_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/src/engine/mod.rs::encode", "code": "fn encode<T: AsRef<[u8]>>(&self, input: T) -> String {\n        fn inner<E>(engine: &E, input_bytes: &[u8]) -> String\n        where\n            E: Engine + ?Sized,\n        {\n            let encoded_size = encoded_len(input_bytes.len(), engine.config().encode_padding())\n                .expect(\"integer overflow when calculating buffer size\");\n\n            let mut buf = vec![0; encoded_size];\n\n            encode_with_padding(input_bytes, &mut buf[..], engine, encoded_size);\n\n            String::from_utf8(buf).expect(\"Invalid UTF8\")\n        }\n\n        inner(self, input.as_ref())\n    }", "docstring": null}
{"test_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/tests/encode.rs::encoded_len_unpadded", "test": "fn encoded_len_unpadded() {\n    assert_eq!(0, encoded_len(0, false).unwrap());\n    assert_eq!(2, encoded_len(1, false).unwrap());\n    assert_eq!(3, encoded_len(2, false).unwrap());\n    assert_eq!(4, encoded_len(3, false).unwrap());\n    assert_eq!(6, encoded_len(4, false).unwrap());\n    assert_eq!(7, encoded_len(5, false).unwrap());\n    assert_eq!(8, encoded_len(6, false).unwrap());\n    assert_eq!(10, encoded_len(7, false).unwrap());\n}", "code_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/src/encode.rs::encoded_len", "code": "pub const fn encoded_len(bytes_len: usize, padding: bool) -> Option<usize> {\n    let rem = bytes_len % 3;\n\n    let complete_input_chunks = bytes_len / 3;\n    // `let Some(_) = _ else` requires 1.65.0, whereas this messier one works on 1.48\n    let complete_chunk_output =\n        if let Some(complete_chunk_output) = complete_input_chunks.checked_mul(4) {\n            complete_chunk_output\n        } else {\n            return None;\n        };\n\n    if rem > 0 {\n        if padding {\n            complete_chunk_output.checked_add(4)\n        } else {\n            let encoded_rem = match rem {\n                1 => 2,\n                // only other possible remainder is 2\n                // can't use a separate _ => unreachable!() in const fns in ancient rust versions\n                _ => 3,\n            };\n            complete_chunk_output.checked_add(encoded_rem)\n        }\n    } else {\n        Some(complete_chunk_output)\n    }\n}", "docstring": null}
{"test_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/tests/encode.rs::encoded_len_padded", "test": "fn encoded_len_padded() {\n    assert_eq!(0, encoded_len(0, true).unwrap());\n    assert_eq!(4, encoded_len(1, true).unwrap());\n    assert_eq!(4, encoded_len(2, true).unwrap());\n    assert_eq!(4, encoded_len(3, true).unwrap());\n    assert_eq!(8, encoded_len(4, true).unwrap());\n    assert_eq!(8, encoded_len(5, true).unwrap());\n    assert_eq!(8, encoded_len(6, true).unwrap());\n    assert_eq!(12, encoded_len(7, true).unwrap());\n}", "code_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/src/encode.rs::encoded_len", "code": "pub const fn encoded_len(bytes_len: usize, padding: bool) -> Option<usize> {\n    let rem = bytes_len % 3;\n\n    let complete_input_chunks = bytes_len / 3;\n    // `let Some(_) = _ else` requires 1.65.0, whereas this messier one works on 1.48\n    let complete_chunk_output =\n        if let Some(complete_chunk_output) = complete_input_chunks.checked_mul(4) {\n            complete_chunk_output\n        } else {\n            return None;\n        };\n\n    if rem > 0 {\n        if padding {\n            complete_chunk_output.checked_add(4)\n        } else {\n            let encoded_rem = match rem {\n                1 => 2,\n                // only other possible remainder is 2\n                // can't use a separate _ => unreachable!() in const fns in ancient rust versions\n                _ => 3,\n            };\n            complete_chunk_output.checked_add(encoded_rem)\n        }\n    } else {\n        Some(complete_chunk_output)\n    }\n}", "docstring": null}
{"test_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/tests/tests.rs::display_wrapper_matches_normal_encode", "test": "fn display_wrapper_matches_normal_encode() {\n    let mut bytes = Vec::<u8>::with_capacity(256);\n\n    for i in 0..255 {\n        bytes.push(i);\n    }\n    bytes.push(255);\n\n    assert_eq!(\n        STANDARD.encode(&bytes),\n        format!(\"{}\", display::Base64Display::new(&bytes, &STANDARD))\n    );\n}", "code_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/src/encode.rs::encode", "code": "pub fn encode<T: AsRef<[u8]>>(input: T) -> String {\n    STANDARD.encode(input)\n}", "docstring": null}
{"test_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/tests/tests.rs::encode_engine_slice_error_when_buffer_too_small", "test": "fn encode_engine_slice_error_when_buffer_too_small() {\n    for num_triples in 1..100 {\n        let input = \"AAA\".repeat(num_triples);\n        let mut vec = vec![0; (num_triples - 1) * 4];\n        assert_eq!(\n            EncodeSliceError::OutputSliceTooSmall,\n            STANDARD.encode_slice(&input, &mut vec).unwrap_err()\n        );\n        vec.push(0);\n        assert_eq!(\n            EncodeSliceError::OutputSliceTooSmall,\n            STANDARD.encode_slice(&input, &mut vec).unwrap_err()\n        );\n        vec.push(0);\n        assert_eq!(\n            EncodeSliceError::OutputSliceTooSmall,\n            STANDARD.encode_slice(&input, &mut vec).unwrap_err()\n        );\n        vec.push(0);\n        assert_eq!(\n            EncodeSliceError::OutputSliceTooSmall,\n            STANDARD.encode_slice(&input, &mut vec).unwrap_err()\n        );\n        vec.push(0);\n        assert_eq!(\n            num_triples * 4,\n            STANDARD.encode_slice(&input, &mut vec).unwrap()\n        );\n    }\n}", "code_id": "marshallpierce-rust-base64/marshallpierce-rust-base64-4ef33cc/src/engine/mod.rs::encode_slice", "code": "fn encode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output_buf: &mut [u8],\n    ) -> Result<usize, EncodeSliceError> {\n        fn inner<E>(\n            engine: &E,\n            input_bytes: &[u8],\n            output_buf: &mut [u8],\n        ) -> Result<usize, EncodeSliceError>\n        where\n            E: Engine + ?Sized,\n        {\n            let encoded_size = encoded_len(input_bytes.len(), engine.config().encode_padding())\n                .expect(\"usize overflow when calculating buffer size\");\n\n            if output_buf.len() < encoded_size {\n                return Err(EncodeSliceError::OutputSliceTooSmall);\n            }\n\n            let b64_output = &mut output_buf[0..encoded_size];\n\n            encode_with_padding(input_bytes, b64_output, engine, encoded_size);\n\n            Ok(encoded_size)\n        }\n\n        inner(self, input.as_ref(), output_buf)\n    }", "docstring": null}
