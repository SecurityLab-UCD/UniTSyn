{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::version_negotiate_client", "test": "fn version_negotiate_client() {\n    let _guard = subscribe();\n    let server_addr = \"[::2]:7890\".parse().unwrap();\n    let cid_generator_factory: fn() -> Box<dyn ConnectionIdGenerator> =\n        || Box::new(RandomConnectionIdGenerator::new(0));\n    let mut client = Endpoint::new(\n        Arc::new(EndpointConfig {\n            connection_id_generator_factory: Arc::new(cid_generator_factory),\n            ..Default::default()\n        }),\n        None,\n        true,\n    );\n    let (_, mut client_ch) = client\n        .connect(client_config(), server_addr, \"localhost\")\n        .unwrap();\n    let now = Instant::now();\n    let opt_event = client.handle(\n        now,\n        server_addr,\n        None,\n        None,\n        // Version negotiation packet for reserved version\n        hex!(\n            \"80 00000000 04 00000000 04 00000000\n             0a1a2a3a\"\n        )[..]\n            .into(),\n    );\n    if let Some((_, DatagramEvent::ConnectionEvent(event))) = opt_event {\n        client_ch.handle_event(event);\n    }\n    assert_matches!(\n        client_ch.poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::VersionMismatch,\n        })\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/connection/streams/state.rs::poll", "code": "pub(crate) fn poll(&mut self) -> Option<StreamEvent> {\n        if let Some(dir) = Dir::iter().find(|&i| mem::replace(&mut self.opened[i as usize], false))\n        {\n            return Some(StreamEvent::Opened { dir });\n        }\n\n        if self.write_limit() > 0 {\n            while let Some(id) = self.connection_blocked.pop() {\n                let stream = match self.send.get_mut(&id) {\n                    None => continue,\n                    Some(s) => s,\n                };\n\n                debug_assert!(stream.connection_blocked);\n                stream.connection_blocked = false;\n\n                // If it's no longer sensible to write to a stream (even to detect an error) then don't\n                // report it.\n                if stream.is_writable() && stream.max_data > stream.offset() {\n                    return Some(StreamEvent::Writable { id });\n                }\n            }\n        }\n\n        self.events.pop_front()\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::lifecycle", "test": "fn lifecycle() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert!(pair.client_conn_mut(client_ch).using_ecn());\n    assert!(pair.server_conn_mut(server_ch).using_ecn());\n\n    const REASON: &[u8] = b\"whee\";\n    info!(\"closing\");\n    pair.client.connections.get_mut(&client_ch).unwrap().close(\n        pair.time,\n        VarInt(42),\n        REASON.into(),\n    );\n    pair.drive();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(),\n                    Some(Event::ConnectionLost { reason: ConnectionError::ApplicationClosed(\n                        ApplicationClose { error_code: VarInt(42), ref reason }\n                    )}) if reason == REASON);\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert_eq!(pair.client.known_connections(), 0);\n    assert_eq!(pair.client.known_cids(), 0);\n    assert_eq!(pair.server.known_connections(), 0);\n    assert_eq!(pair.server.known_cids(), 0);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::draft_version_compat", "test": "fn draft_version_compat() {\n    let _guard = subscribe();\n\n    let mut client_config = client_config();\n    client_config.version(0xff00_0020);\n\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect_with(client_config);\n\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert!(pair.client_conn_mut(client_ch).using_ecn());\n    assert!(pair.server_conn_mut(server_ch).using_ecn());\n\n    const REASON: &[u8] = b\"whee\";\n    info!(\"closing\");\n    pair.client.connections.get_mut(&client_ch).unwrap().close(\n        pair.time,\n        VarInt(42),\n        REASON.into(),\n    );\n    pair.drive();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(),\n                    Some(Event::ConnectionLost { reason: ConnectionError::ApplicationClosed(\n                        ApplicationClose { error_code: VarInt(42), ref reason }\n                    )}) if reason == REASON);\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert_eq!(pair.client.known_connections(), 0);\n    assert_eq!(pair.client.known_cids(), 0);\n    assert_eq!(pair.server.known_connections(), 0);\n    assert_eq!(pair.server.known_cids(), 0);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::server_stateless_reset", "test": "fn server_stateless_reset() {\n    let _guard = subscribe();\n    let mut reset_key = vec![0; 64];\n    let mut rng = rand::thread_rng();\n    rng.fill_bytes(&mut reset_key);\n    let reset_key = hmac::Key::new(hmac::HMAC_SHA256, &reset_key);\n\n    let endpoint_config = Arc::new(EndpointConfig::new(Arc::new(reset_key)));\n\n    let mut pair = Pair::new(endpoint_config.clone(), server_config());\n    let (client_ch, _) = pair.connect();\n    pair.drive(); // Flush any post-handshake frames\n    pair.server.endpoint = Endpoint::new(endpoint_config, Some(Arc::new(server_config())), true);\n    // Force the server to generate the smallest possible stateless reset\n    pair.client.connections.get_mut(&client_ch).unwrap().ping();\n    info!(\"resetting\");\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::Reset\n        })\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::client_stateless_reset", "test": "fn client_stateless_reset() {\n    let _guard = subscribe();\n    let mut reset_key = vec![0; 64];\n    let mut rng = rand::thread_rng();\n    rng.fill_bytes(&mut reset_key);\n    let reset_key = hmac::Key::new(hmac::HMAC_SHA256, &reset_key);\n\n    let endpoint_config = Arc::new(EndpointConfig::new(Arc::new(reset_key)));\n\n    let mut pair = Pair::new(endpoint_config.clone(), server_config());\n    let (_, server_ch) = pair.connect();\n    pair.client.endpoint = Endpoint::new(endpoint_config, Some(Arc::new(server_config())), true);\n    // Send something big enough to allow room for a smaller stateless reset.\n    pair.server.connections.get_mut(&server_ch).unwrap().close(\n        pair.time,\n        VarInt(42),\n        (&[0xab; 128][..]).into(),\n    );\n    info!(\"resetting\");\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::Reset\n        })\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::finish_stream_simple", "test": "fn finish_stream_simple() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    assert_eq!(pair.client_streams(client_ch).send_streams(), 1);\n    pair.client_send(client_ch, s).finish().unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Stream(StreamEvent::Finished { id })) if id == s\n    );\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert_eq!(pair.client_streams(client_ch).send_streams(), 0);\n    assert_eq!(pair.server_conn_mut(client_ch).streams().send_streams(), 0);\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    // Receive-only streams do not get `StreamFinished` events\n    assert_eq!(pair.server_conn_mut(client_ch).streams().send_streams(), 0);\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(\n        chunks.next(usize::MAX),\n        Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == MSG\n    );\n    assert_matches!(chunks.next(usize::MAX), Ok(None));\n    let _ = chunks.finalize();\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/connection/streams/mod.rs::send_streams", "code": "pub fn send_streams(&self) -> usize {\n        self.state.send_streams\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::reset_stream", "test": "fn reset_stream() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n\n    info!(\"resetting stream\");\n    const ERROR: VarInt = VarInt(42);\n    pair.client_send(client_ch, s).reset(ERROR).unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(chunks.next(usize::MAX), Err(ReadError::Reset(ERROR)));\n    let _ = chunks.finalize();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::stop_stream", "test": "fn stop_stream() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n\n    info!(\"stopping stream\");\n    const ERROR: VarInt = VarInt(42);\n    pair.server_recv(server_ch, s).stop(ERROR).unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n\n    assert_matches!(\n        pair.client_send(client_ch, s).write(b\"foo\"),\n        Err(WriteError::Stopped(ERROR))\n    );\n    assert_matches!(\n        pair.client_send(client_ch, s).finish(),\n        Err(FinishError::Stopped(ERROR))\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::reject_self_signed_server_cert", "test": "fn reject_self_signed_server_cert() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    info!(\"connecting\");\n    let client_ch = pair.begin_connect(client_config_with_certs(vec![]));\n    pair.drive();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(),\n                    Some(Event::ConnectionLost { reason: ConnectionError::TransportError(ref error)})\n                    if error.code == TransportErrorCode::crypto(AlertDescription::UnknownCA.get_u8()));\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::reject_missing_client_cert", "test": "fn reject_missing_client_cert() {\n    let _guard = subscribe();\n\n    let key = rustls::PrivateKey(CERTIFICATE.serialize_private_key_der());\n    let cert = util::CERTIFICATE.serialize_der().unwrap();\n\n    let config = rustls::ServerConfig::builder()\n        .with_safe_default_cipher_suites()\n        .with_safe_default_kx_groups()\n        .with_protocol_versions(&[&rustls::version::TLS13])\n        .unwrap()\n        .with_client_cert_verifier(Arc::new(rustls::server::AllowAnyAuthenticatedClient::new(\n            rustls::RootCertStore::empty(),\n        )))\n        .with_single_cert(vec![rustls::Certificate(cert)], key)\n        .unwrap();\n\n    let mut pair = Pair::new(\n        Default::default(),\n        ServerConfig::with_crypto(Arc::new(config)),\n    );\n\n    info!(\"connecting\");\n    let client_ch = pair.begin_connect(client_config());\n    pair.drive();\n\n    // The client completes the connection, but finds it immediately closed\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected)\n    );\n    assert_matches!(pair.client_conn_mut(client_ch).poll(),\n                    Some(Event::ConnectionLost { reason: ConnectionError::ConnectionClosed(ref close)})\n                    if close.error_code == TransportErrorCode::crypto(AlertDescription::CertificateRequired.get_u8()));\n\n    // The server never completes the connection\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(pair.server_conn_mut(server_ch).poll(),\n                    Some(Event::ConnectionLost { reason: ConnectionError::TransportError(ref error)})\n                    if error.code == TransportErrorCode::crypto(AlertDescription::CertificateRequired.get_u8()));\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::zero_rtt_happypath", "test": "fn zero_rtt_happypath() {\n    let _guard = subscribe();\n    let mut pair = Pair::new(\n        Default::default(),\n        ServerConfig {\n            use_retry: true,\n            ..server_config()\n        },\n    );\n    let config = client_config();\n\n    // Establish normal connection\n    let client_ch = pair.begin_connect(config.clone());\n    pair.drive();\n    pair.server.assert_accept();\n    pair.client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .close(pair.time, VarInt(0), [][..].into());\n    pair.drive();\n\n    pair.client.addr = SocketAddr::new(\n        Ipv6Addr::LOCALHOST.into(),\n        CLIENT_PORTS.lock().unwrap().next().unwrap(),\n    );\n    info!(\"resuming session\");\n    let client_ch = pair.begin_connect(config);\n    assert!(pair.client_conn_mut(client_ch).has_0rtt());\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"Hello, 0-RTT!\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected)\n    );\n\n    assert!(pair.client_conn_mut(client_ch).accepted_0rtt());\n    let server_ch = pair.server.assert_accept();\n\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    // We don't currently preserve stream event order wrt. connection events\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Connected)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(\n        chunks.next(usize::MAX),\n        Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == MSG\n    );\n    let _ = chunks.finalize();\n    assert_eq!(pair.client_conn_mut(client_ch).lost_packets(), 0);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/connection/mod.rs::has_0rtt", "code": "pub fn has_0rtt(&self) -> bool {\n        self.zero_rtt_enabled\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::zero_rtt_rejection", "test": "fn zero_rtt_rejection() {\n    let _guard = subscribe();\n    let mut server_crypto = server_crypto();\n    server_crypto.alpn_protocols = vec![\"foo\".into(), \"bar\".into()];\n    let server_config = ServerConfig::with_crypto(Arc::new(server_crypto));\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config);\n    let mut client_crypto = client_crypto();\n    client_crypto.alpn_protocols = vec![\"foo\".into()];\n    let client_config = ClientConfig::new(Arc::new(client_crypto.clone()));\n\n    // Establish normal connection\n    let client_ch = pair.begin_connect(client_config);\n    pair.drive();\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Connected)\n    );\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    pair.client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .close(pair.time, VarInt(0), [][..].into());\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::ConnectionLost { .. })\n    );\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    pair.client.connections.clear();\n    pair.server.connections.clear();\n\n    // Changing protocols invalidates 0-RTT\n    client_crypto.alpn_protocols = vec![\"bar\".into()];\n    let client_config = ClientConfig::new(Arc::new(client_crypto));\n    info!(\"resuming session\");\n    let client_ch = pair.begin_connect(client_config);\n    assert!(pair.client_conn_mut(client_ch).has_0rtt());\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"Hello, 0-RTT!\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n    assert!(!pair.client_conn_mut(client_ch).accepted_0rtt());\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Connected)\n    );\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    let s2 = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    assert_eq!(s, s2);\n\n    let mut recv = pair.server_recv(server_ch, s2);\n    let mut chunks = recv.read(false).unwrap();\n    assert_eq!(chunks.next(usize::MAX), Err(ReadError::Blocked));\n    let _ = chunks.finalize();\n    assert_eq!(pair.client_conn_mut(client_ch).lost_packets(), 0);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::alpn_success", "test": "fn alpn_success() {\n    let _guard = subscribe();\n    let mut server_crypto = server_crypto();\n    server_crypto.alpn_protocols = vec![\"foo\".into(), \"bar\".into(), \"baz\".into()];\n    let server_config = ServerConfig::with_crypto(Arc::new(server_crypto));\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config);\n    let mut client_crypto = client_crypto();\n    client_crypto.alpn_protocols = vec![\"bar\".into(), \"quux\".into(), \"corge\".into()];\n    let client_config = ClientConfig::new(Arc::new(client_crypto));\n\n    // Establish normal connection\n    let client_ch = pair.begin_connect(client_config);\n    pair.drive();\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Connected)\n    );\n\n    let hd = pair\n        .client_conn_mut(client_ch)\n        .crypto_session()\n        .handshake_data()\n        .unwrap()\n        .downcast::<crate::crypto::rustls::HandshakeData>()\n        .unwrap();\n    assert_eq!(hd.protocol.unwrap(), &b\"bar\"[..]);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::server_alpn_unset", "test": "fn server_alpn_unset() {\n    let _guard = subscribe();\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config());\n\n    let mut client_crypto = client_crypto();\n    client_crypto.alpn_protocols = vec![\"foo\".into()];\n    let client_config = ClientConfig::new(Arc::new(client_crypto));\n\n    let client_ch = pair.begin_connect(client_config);\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::ConnectionLost { reason: ConnectionError::ConnectionClosed(err) }) if err.error_code == TransportErrorCode::crypto(0x78)\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::client_alpn_unset", "test": "fn client_alpn_unset() {\n    let _guard = subscribe();\n    let mut server_crypto = server_crypto();\n    server_crypto.alpn_protocols = vec![\"foo\".into(), \"bar\".into(), \"baz\".into()];\n    let server_config = ServerConfig::with_crypto(Arc::new(server_crypto));\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config);\n\n    let client_ch = pair.begin_connect(client_config());\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::ConnectionLost { reason: ConnectionError::ConnectionClosed(err) }) if err.error_code == TransportErrorCode::crypto(0x78)\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::alpn_mismatch", "test": "fn alpn_mismatch() {\n    let _guard = subscribe();\n    let mut server_crypto = server_crypto();\n    server_crypto.alpn_protocols = vec![\"foo\".into(), \"bar\".into(), \"baz\".into()];\n    let server_config = ServerConfig::with_crypto(Arc::new(server_crypto));\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config);\n\n    let mut client_crypto = client_crypto();\n    client_crypto.alpn_protocols = vec![\"quux\".into(), \"corge\".into()];\n    let client_config = ClientConfig::new(Arc::new(client_crypto));\n\n    let client_ch = pair.begin_connect(client_config);\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::ConnectionLost { reason: ConnectionError::ConnectionClosed(err) }) if err.error_code == TransportErrorCode::crypto(0x78)\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::stream_id_limit", "test": "fn stream_id_limit() {\n    let _guard = subscribe();\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            max_concurrent_uni_streams: 1u32.into(),\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair\n        .client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .streams()\n        .open(Dir::Uni)\n        .expect(\"couldn't open first stream\");\n    assert_eq!(\n        pair.client_streams(client_ch).open(Dir::Uni),\n        None,\n        \"only one stream is permitted at a time\"\n    );\n    // Generate some activity to allow the server to see the stream\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.client_send(client_ch, s).finish().unwrap();\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Stream(StreamEvent::Finished { id })) if id == s\n    );\n    assert_eq!(\n        pair.client_streams(client_ch).open(Dir::Uni),\n        None,\n        \"server does not immediately grant additional credit\"\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(\n        chunks.next(usize::MAX),\n        Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == MSG\n    );\n    assert_eq!(chunks.next(usize::MAX), Ok(None));\n    let _ = chunks.finalize();\n\n    // Server will only send MAX_STREAM_ID now that the application's been notified\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Stream(StreamEvent::Available { dir: Dir::Uni }))\n    );\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n\n    // Try opening the second stream again, now that we've made room\n    let s = pair\n        .client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .streams()\n        .open(Dir::Uni)\n        .expect(\"didn't get stream id budget\");\n    pair.client_send(client_ch, s).finish().unwrap();\n    pair.drive();\n    // Make sure the server actually processes data on the newly-available stream\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(chunks.next(usize::MAX), Ok(None));\n    let _ = chunks.finalize();\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/crypto/ring.rs::open", "code": "fn open<'a>(\n        &self,\n        data: &'a mut [u8],\n        additional_data: &[u8],\n    ) -> Result<&'a mut [u8], CryptoError> {\n        let aad = ring::aead::Aad::from(additional_data);\n        let zero_nonce = ring::aead::Nonce::assume_unique_for_key([0u8; 12]);\n        Ok(self.open_in_place(zero_nonce, aad, data)?)\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::key_update_simple", "test": "fn key_update_simple() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    let s = pair\n        .client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .streams()\n        .open(Dir::Bi)\n        .expect(\"couldn't open first stream\");\n\n    const MSG1: &[u8] = b\"hello1\";\n    pair.client_send(client_ch, s).write(MSG1).unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Bi }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Bi), Some(stream) if stream == s);\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(\n        chunks.next(usize::MAX),\n        Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == MSG1\n    );\n    let _ = chunks.finalize();\n\n    info!(\"initiating key update\");\n    pair.client_conn_mut(client_ch).initiate_key_update();\n\n    const MSG2: &[u8] = b\"hello2\";\n    pair.client_send(client_ch, s).write(MSG2).unwrap();\n    pair.drive();\n\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), Some(Event::Stream(StreamEvent::Readable { id })) if id == s);\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(\n        chunks.next(usize::MAX),\n        Ok(Some(chunk)) if chunk.offset == 6 && chunk.bytes == MSG2\n    );\n    let _ = chunks.finalize();\n\n    assert_eq!(pair.client_conn_mut(client_ch).lost_packets(), 0);\n    assert_eq!(pair.server_conn_mut(server_ch).lost_packets(), 0);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::key_update_reordered", "test": "fn key_update_reordered() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    let s = pair\n        .client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .streams()\n        .open(Dir::Bi)\n        .expect(\"couldn't open first stream\");\n\n    const MSG1: &[u8] = b\"1\";\n    pair.client_send(client_ch, s).write(MSG1).unwrap();\n    pair.client.drive(pair.time, pair.server.addr);\n    assert!(!pair.client.outbound.is_empty());\n    pair.client.delay_outbound();\n\n    pair.client_conn_mut(client_ch).initiate_key_update();\n    info!(\"updated keys\");\n\n    const MSG2: &[u8] = b\"two\";\n    pair.client_send(client_ch, s).write(MSG2).unwrap();\n    pair.client.drive(pair.time, pair.server.addr);\n    pair.client.finish_delay();\n    pair.drive();\n\n    assert_eq!(pair.client_conn_mut(client_ch).lost_packets(), 0);\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Bi }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Bi), Some(stream) if stream == s);\n\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(true).unwrap();\n    let buf1 = chunks.next(usize::MAX).unwrap().unwrap();\n    assert_matches!(&*buf1.bytes, MSG1);\n    let buf2 = chunks.next(usize::MAX).unwrap().unwrap();\n    assert_eq!(buf2.bytes, MSG2);\n    let _ = chunks.finalize();\n\n    assert_eq!(pair.client_conn_mut(client_ch).lost_packets(), 0);\n    assert_eq!(pair.server_conn_mut(server_ch).lost_packets(), 0);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::is_empty", "code": "fn is_empty(&self) -> bool {\n        self.senders.is_empty()\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::initial_retransmit", "test": "fn initial_retransmit() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let client_ch = pair.begin_connect(client_config());\n    pair.client.drive(pair.time, pair.server.addr);\n    pair.client.outbound.clear(); // Drop initial\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected { .. })\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::instant_close_1", "test": "fn instant_close_1() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    info!(\"connecting\");\n    let client_ch = pair.begin_connect(client_config());\n    pair.client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .close(pair.time, VarInt(0), Bytes::new());\n    pair.drive();\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::ConnectionClosed(ConnectionClose {\n                error_code: TransportErrorCode::APPLICATION_ERROR,\n                ..\n            }),\n        })\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::instant_close_2", "test": "fn instant_close_2() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    info!(\"connecting\");\n    let client_ch = pair.begin_connect(client_config());\n    // Unlike `instant_close`, the server sees a valid Initial packet first.\n    pair.drive_client();\n    pair.client\n        .connections\n        .get_mut(&client_ch)\n        .unwrap()\n        .close(pair.time, VarInt(42), Bytes::new());\n    pair.drive();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::ConnectionClosed(ConnectionClose {\n                error_code: TransportErrorCode::APPLICATION_ERROR,\n                ..\n            }),\n        })\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::concurrent_connections_full", "test": "fn concurrent_connections_full() {\n    let _guard = subscribe();\n    let mut pair = Pair::new(\n        Default::default(),\n        ServerConfig {\n            concurrent_connections: 0,\n            ..server_config()\n        },\n    );\n    let client_ch = pair.begin_connect(client_config());\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::ConnectionClosed(frame::ConnectionClose {\n                error_code: TransportErrorCode::CONNECTION_REFUSED,\n                ..\n            }),\n        })\n    );\n    assert_eq!(pair.server.connections.len(), 0);\n    assert_eq!(pair.server.known_connections(), 0);\n    assert_eq!(pair.server.known_cids(), 0);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::server_hs_retransmit", "test": "fn server_hs_retransmit() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let client_ch = pair.begin_connect(client_config());\n    pair.step();\n    assert!(!pair.client.inbound.is_empty()); // Initial + Handshakes\n    pair.client.inbound.clear();\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected { .. })\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::is_empty", "code": "fn is_empty(&self) -> bool {\n        self.senders.is_empty()\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::stop_opens_bidi", "test": "fn stop_opens_bidi() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    assert_eq!(pair.client_streams(client_ch).send_streams(), 0);\n    let s = pair.client_streams(client_ch).open(Dir::Bi).unwrap();\n    assert_eq!(pair.client_streams(client_ch).send_streams(), 1);\n    const ERROR: VarInt = VarInt(42);\n    pair.client\n        .connections\n        .get_mut(&server_ch)\n        .unwrap()\n        .recv_stream(s)\n        .stop(ERROR)\n        .unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Bi }))\n    );\n    assert_eq!(pair.server_conn_mut(client_ch).streams().send_streams(), 0);\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Bi), Some(stream) if stream == s);\n    assert_eq!(pair.server_conn_mut(client_ch).streams().send_streams(), 1);\n\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(chunks.next(usize::MAX), Err(ReadError::Blocked));\n    let _ = chunks.finalize();\n\n    assert_matches!(\n        pair.server_send(server_ch, s).write(b\"foo\"),\n        Err(WriteError::Stopped(ERROR))\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Stopped {\n            id: _,\n            error_code: ERROR\n        }))\n    );\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/connection/streams/mod.rs::send_streams", "code": "pub fn send_streams(&self) -> usize {\n        self.state.send_streams\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::implicit_open", "test": "fn implicit_open() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    let s1 = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    let s2 = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    pair.client_send(client_ch, s2).write(b\"hello\").unwrap();\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    assert_eq!(pair.server_streams(server_ch).accept(Dir::Uni), Some(s1));\n    assert_eq!(pair.server_streams(server_ch).accept(Dir::Uni), Some(s2));\n    assert_eq!(pair.server_streams(server_ch).accept(Dir::Uni), None);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::keep_alive", "test": "fn keep_alive() {\n    let _guard = subscribe();\n    const IDLE_TIMEOUT: u64 = 10;\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            keep_alive_interval: Some(Duration::from_millis(IDLE_TIMEOUT / 2)),\n            max_idle_timeout: Some(VarInt(IDLE_TIMEOUT)),\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    // Run a good while longer than the idle timeout\n    let end = pair.time + Duration::from_millis(20 * IDLE_TIMEOUT);\n    while pair.time < end {\n        if !pair.step() {\n            if let Some(time) = min_opt(pair.client.next_wakeup(), pair.server.next_wakeup()) {\n                pair.time = time;\n            }\n        }\n        assert!(!pair.client_conn_mut(client_ch).is_closed());\n        assert!(!pair.server_conn_mut(server_ch).is_closed());\n    }\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/connection/mod.rs::is_closed", "code": "pub fn is_closed(&self) -> bool {\n        self.state.is_closed()\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::cid_retirement", "test": "fn cid_retirement() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    // Server retires current active remote CIDs\n    pair.server_conn_mut(server_ch)\n        .rotate_local_cid(1, Instant::now());\n    pair.drive();\n    // Any unexpected behavior may trigger TransportError::CONNECTION_ID_LIMIT_ERROR\n    assert!(!pair.client_conn_mut(client_ch).is_closed());\n    assert!(!pair.server_conn_mut(server_ch).is_closed());\n    assert_matches!(pair.client_conn_mut(client_ch).active_rem_cid_seq(), 1);\n\n    use crate::cid_queue::CidQueue;\n    use crate::LOC_CID_COUNT;\n    let mut active_cid_num = CidQueue::LEN as u64;\n    active_cid_num = active_cid_num.min(LOC_CID_COUNT);\n\n    let next_retire_prior_to = active_cid_num + 1;\n    pair.client_conn_mut(client_ch).ping();\n    // Server retires all valid remote CIDs\n    pair.server_conn_mut(server_ch)\n        .rotate_local_cid(next_retire_prior_to, Instant::now());\n    pair.drive();\n    assert!(!pair.client_conn_mut(client_ch).is_closed());\n    assert!(!pair.server_conn_mut(server_ch).is_closed());\n    assert_matches!(\n        pair.client_conn_mut(client_ch).active_rem_cid_seq(),\n        _next_retire_prior_to\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/connection/mod.rs::is_closed", "code": "pub fn is_closed(&self) -> bool {\n        self.state.is_closed()\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::finish_stream_flow_control_reordered", "test": "fn finish_stream_flow_control_reordered() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive_client(); // Send stream data\n    pair.server.drive(pair.time, pair.client.addr); // Receive\n\n    // Issue flow control credit\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(\n        chunks.next(usize::MAX),\n        Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == MSG\n    );\n    let _ = chunks.finalize();\n\n    pair.server.drive(pair.time, pair.client.addr);\n    pair.server.delay_outbound(); // Delay it\n\n    pair.client_send(client_ch, s).finish().unwrap();\n    pair.drive_client(); // Send FIN\n    pair.server.drive(pair.time, pair.client.addr); // Acknowledge\n    pair.server.finish_delay(); // Add flow control packets after\n    pair.drive();\n\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Stream(StreamEvent::Finished { id })) if id == s\n    );\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))\n    );\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(chunks.next(usize::MAX), Ok(None));\n    let _ = chunks.finalize();\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/cid_queue.rs::next", "code": "pub(crate) fn next(&mut self) -> Option<(ResetToken, Range<u64>)> {\n        let (i, cid_data) = self.iter().nth(1)?;\n        self.buffer[self.cursor] = None;\n\n        let orig_offset = self.offset;\n        self.offset += i as u64;\n        self.cursor = (self.cursor + i) % Self::LEN;\n        Some((cid_data.1.unwrap(), orig_offset..self.offset))\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::stop_before_finish", "test": "fn stop_before_finish() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n\n    info!(\"stopping stream\");\n    const ERROR: VarInt = VarInt(42);\n    pair.server_recv(server_ch, s).stop(ERROR).unwrap();\n    pair.drive();\n\n    assert_matches!(\n        pair.client_send(client_ch, s).finish(),\n        Err(FinishError::Stopped(ERROR))\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/packet.rs::finish", "code": "pub(crate) fn finish(\n        self,\n        header_crypto: Option<&dyn crypto::HeaderKey>,\n    ) -> Result<Packet, PacketDecodeError> {\n        use self::PlainHeader::*;\n        let Self {\n            plain_header,\n            mut buf,\n        } = self;\n\n        if let Initial {\n            dst_cid,\n            src_cid,\n            token_pos,\n            version,\n            ..\n        } = plain_header\n        {\n            let number = Self::decrypt_header(&mut buf, header_crypto.unwrap())?;\n            let header_len = buf.position() as usize;\n            let mut bytes = buf.into_inner();\n\n            let header_data = bytes.split_to(header_len).freeze();\n            let token = header_data.slice(token_pos.start..token_pos.end);\n            return Ok(Packet {\n                header: Header::Initial {\n                    dst_cid,\n                    src_cid,\n                    token,\n                    number,\n                    version,\n                },\n                header_data,\n                payload: bytes,\n            });\n        }\n\n        let header = match plain_header {\n            Long {\n                ty,\n                dst_cid,\n                src_cid,\n                version,\n                ..\n            } => Header::Long {\n                ty,\n                dst_cid,\n                src_cid,\n                number: Self::decrypt_header(&mut buf, header_crypto.unwrap())?,\n                version,\n            },\n            Retry {\n                dst_cid,\n                src_cid,\n                version,\n            } => Header::Retry {\n                dst_cid,\n                src_cid,\n                version,\n            },\n            Short { spin, dst_cid, .. } => {\n                let number = Self::decrypt_header(&mut buf, header_crypto.unwrap())?;\n                let key_phase = buf.get_ref()[0] & KEY_PHASE_BIT != 0;\n                Header::Short {\n                    spin,\n                    key_phase,\n                    dst_cid,\n                    number,\n                }\n            }\n            VersionNegotiate {\n                random,\n                dst_cid,\n                src_cid,\n            } => Header::VersionNegotiate {\n                random,\n                dst_cid,\n                src_cid,\n            },\n            Initial { .. } => unreachable!(),\n        };\n\n        let header_len = buf.position() as usize;\n        let mut bytes = buf.into_inner();\n        Ok(Packet {\n            header,\n            header_data: bytes.split_to(header_len).freeze(),\n            payload: bytes,\n        })\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::stop_during_finish", "test": "fn stop_during_finish() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.drive();\n\n    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);\n    info!(\"stopping and finishing stream\");\n    const ERROR: VarInt = VarInt(42);\n    pair.server_recv(server_ch, s).stop(ERROR).unwrap();\n    pair.drive_server();\n    pair.client_send(client_ch, s).finish().unwrap();\n    pair.drive_client();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Stream(StreamEvent::Stopped { id, error_code: ERROR })) if id == s\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::accept", "code": "pub fn accept(&self) -> Accept<'_> {\n        Accept {\n            endpoint: self,\n            notify: self.inner.shared.incoming.notified(),\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::datagram_send_recv", "test": "fn datagram_send_recv() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    assert_matches!(pair.client_datagrams(client_ch).max_size(), Some(x) if x > 0);\n\n    const DATA: &[u8] = b\"whee\";\n    pair.client_datagrams(client_ch).send(DATA.into()).unwrap();\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::DatagramReceived)\n    );\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA);\n    assert_matches!(pair.server_datagrams(server_ch).recv(), None);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::datagram_recv_buffer_overflow", "test": "fn datagram_recv_buffer_overflow() {\n    let _guard = subscribe();\n    const WINDOW: usize = 100;\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            datagram_receive_buffer_size: Some(WINDOW),\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    assert_eq!(\n        pair.client_conn_mut(client_ch).datagrams().max_size(),\n        Some(WINDOW - Datagram::SIZE_BOUND)\n    );\n\n    const DATA1: &[u8] = &[0xAB; (WINDOW / 3) + 1];\n    const DATA2: &[u8] = &[0xBC; (WINDOW / 3) + 1];\n    const DATA3: &[u8] = &[0xCD; (WINDOW / 3) + 1];\n    pair.client_datagrams(client_ch).send(DATA1.into()).unwrap();\n    pair.client_datagrams(client_ch).send(DATA2.into()).unwrap();\n    pair.client_datagrams(client_ch).send(DATA3.into()).unwrap();\n    pair.drive();\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::DatagramReceived)\n    );\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA2);\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA3);\n    assert_matches!(pair.server_datagrams(server_ch).recv(), None);\n\n    pair.client_datagrams(client_ch).send(DATA1.into()).unwrap();\n    pair.drive();\n    assert_eq!(pair.server_datagrams(server_ch).recv().unwrap(), DATA1);\n    assert_matches!(pair.server_datagrams(server_ch).recv(), None);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::datagram_unsupported", "test": "fn datagram_unsupported() {\n    let _guard = subscribe();\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            datagram_receive_buffer_size: None,\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);\n    assert_matches!(pair.client_datagrams(client_ch).max_size(), None);\n\n    match pair.client_datagrams(client_ch).send(Bytes::new()) {\n        Err(SendDatagramError::UnsupportedByPeer) => {}\n        Err(e) => panic!(\"unexpected error: {e}\"),\n        Ok(_) => panic!(\"unexpected success\"),\n    }\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::large_initial", "test": "fn large_initial() {\n    let _guard = subscribe();\n    let mut server_crypto = server_crypto();\n    server_crypto.alpn_protocols = vec![vec![0, 0, 0, 42]];\n    let server_config = ServerConfig::with_crypto(Arc::new(server_crypto));\n\n    let mut pair = Pair::new(Arc::new(EndpointConfig::default()), server_config);\n    let mut client_crypto = client_crypto();\n    let protocols = (0..1000u32)\n        .map(|x| x.to_be_bytes().to_vec())\n        .collect::<Vec<_>>();\n    client_crypto.alpn_protocols = protocols;\n    let cfg = ClientConfig::new(Arc::new(client_crypto));\n    let client_ch = pair.begin_connect(cfg);\n    pair.drive();\n    let server_ch = pair.server.assert_accept();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected { .. })\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::Connected { .. })\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::repeated_request_response", "test": "fn repeated_request_response() {\n    let _guard = subscribe();\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            max_concurrent_bidi_streams: 1u32.into(),\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    const REQUEST: &[u8] = b\"hello\";\n    const RESPONSE: &[u8] = b\"world\";\n    for _ in 0..3 {\n        let s = pair.client_streams(client_ch).open(Dir::Bi).unwrap();\n\n        pair.client_send(client_ch, s).write(REQUEST).unwrap();\n        pair.client_send(client_ch, s).finish().unwrap();\n\n        pair.drive();\n\n        assert_eq!(pair.server_streams(server_ch).accept(Dir::Bi), Some(s));\n        let mut recv = pair.server_recv(server_ch, s);\n        let mut chunks = recv.read(false).unwrap();\n        assert_matches!(\n            chunks.next(usize::MAX),\n            Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == REQUEST\n        );\n\n        assert_matches!(chunks.next(usize::MAX), Ok(None));\n        let _ = chunks.finalize();\n        pair.server_send(server_ch, s).write(RESPONSE).unwrap();\n        pair.server_send(server_ch, s).finish().unwrap();\n\n        pair.drive();\n\n        let mut recv = pair.client_recv(client_ch, s);\n        let mut chunks = recv.read(false).unwrap();\n        assert_matches!(\n            chunks.next(usize::MAX),\n            Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == RESPONSE\n        );\n        assert_matches!(chunks.next(usize::MAX), Ok(None));\n        let _ = chunks.finalize();\n    }\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::accept", "code": "pub fn accept(&self) -> Accept<'_> {\n        Accept {\n            endpoint: self,\n            notify: self.inner.shared.incoming.notified(),\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::handshake_anti_deadlock_probe", "test": "fn handshake_anti_deadlock_probe() {\n    let _guard = subscribe();\n\n    let (cert, key) = big_cert_and_key();\n    let server = server_config_with_cert(cert.clone(), key);\n    let client = client_config_with_certs(vec![cert]);\n    let mut pair = Pair::new(Default::default(), server);\n\n    let client_ch = pair.begin_connect(client);\n    // Client sends initial\n    pair.drive_client();\n    // Server sends first flight, gets blocked on anti-amplification\n    pair.drive_server();\n    // Client acks...\n    pair.drive_client();\n    // ...but it's lost, so the server doesn't get anti-amplification credit from it\n    pair.server.inbound.clear();\n    // Client sends an anti-deadlock probe, and the handshake completes as usual.\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected { .. })\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::poll", "code": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let mut endpoint = self.0.state.lock().unwrap();\n        if endpoint.driver.is_none() {\n            endpoint.driver = Some(cx.waker().clone());\n        }\n\n        let now = Instant::now();\n        let mut keep_going = false;\n        keep_going |= endpoint.drive_recv(cx, now)?;\n        keep_going |= endpoint.handle_events(cx, &self.0.shared);\n        keep_going |= endpoint.drive_send(cx)?;\n\n        if !endpoint.incoming.is_empty() {\n            self.0.shared.incoming.notify_waiters();\n        }\n\n        if endpoint.ref_count == 0 && endpoint.connections.is_empty() {\n            Poll::Ready(Ok(()))\n        } else {\n            drop(endpoint);\n            // If there is more work to do schedule the endpoint task again.\n            // `wake_by_ref()` is called outside the lock to minimize\n            // lock contention on a multithreaded runtime.\n            if keep_going {\n                cx.waker().wake_by_ref();\n            }\n            Poll::Pending\n        }\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::server_can_send_3_inital_packets", "test": "fn server_can_send_3_inital_packets() {\n    let _guard = subscribe();\n\n    let (cert, key) = big_cert_and_key();\n    let server = server_config_with_cert(cert.clone(), key);\n    let client = client_config_with_certs(vec![cert]);\n    let mut pair = Pair::new(Default::default(), server);\n\n    let client_ch = pair.begin_connect(client);\n    // Client sends initial\n    pair.drive_client();\n    // Server sends first flight, gets blocked on anti-amplification\n    pair.drive_server();\n    // Server should have queued 3 packets at this time\n    assert_eq!(pair.client.inbound.len(), 3);\n\n    pair.drive();\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::HandshakeDataReady)\n    );\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::Connected { .. })\n    );\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/frame.rs::len", "code": "fn len(self) -> bool {\n        self.0 & 0x02 != 0\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::packet_loss_and_retry_too_low_mtu", "test": "fn packet_loss_and_retry_too_low_mtu() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    pair.client_send(client_ch, s).write(b\"hello\").unwrap();\n    pair.drive();\n\n    // Nothing will get past this mtu\n    pair.mtu = 10;\n    pair.client_send(client_ch, s).write(b\" world\").unwrap();\n    pair.drive_client();\n\n    // The packet was dropped\n    assert!(pair.client.outbound.is_empty());\n    assert!(pair.server.inbound.is_empty());\n\n    // Restore the default mtu, so future packets are properly transmitted\n    pair.mtu = DEFAULT_MTU;\n\n    // The lost packet is resent\n    pair.drive();\n    assert!(pair.client.outbound.is_empty());\n\n    let recv = pair.server_recv(server_ch, s);\n    let buf = stream_chunks(recv);\n\n    assert_eq!(buf, b\"hello world\".as_slice());\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn/src/endpoint.rs::is_empty", "code": "fn is_empty(&self) -> bool {\n        self.senders.is_empty()\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::packet_splitting_with_default_mtu", "test": "fn packet_splitting_with_default_mtu() {\n    let _guard = subscribe();\n\n    // The payload needs to be split in 2 in order to be sent, because it is higher than the max MTU\n    let payload = vec![42; 1300];\n\n    let mut pair = Pair::default();\n    let (client_ch, _) = pair.connect();\n    pair.drive();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    pair.client_send(client_ch, s).write(&payload).unwrap();\n    pair.client.drive(pair.time, pair.server.addr);\n    assert_eq!(pair.client.outbound.len(), 2);\n\n    pair.drive_client();\n    assert_eq!(pair.server.inbound.len(), 2);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/frame.rs::len", "code": "fn len(self) -> bool {\n        self.0 & 0x02 != 0\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::packet_splitting_not_necessary_after_higher_mtu_discovered", "test": "fn packet_splitting_not_necessary_after_higher_mtu_discovered() {\n    let _guard = subscribe();\n    let payload = vec![42; 1300];\n\n    let mut pair = Pair::default();\n    pair.mtu = 1500;\n\n    let (client_ch, _) = pair.connect();\n    pair.drive();\n\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n\n    pair.client_send(client_ch, s).write(&payload).unwrap();\n    pair.client.drive(pair.time, pair.server.addr);\n    assert_eq!(pair.client.outbound.len(), 1);\n\n    pair.drive_client();\n    assert_eq!(pair.server.inbound.len(), 1);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/frame.rs::len", "code": "fn len(self) -> bool {\n        self.0 & 0x02 != 0\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/tests-gen/packet.rs::test_something", "test": "fn test_something() {\n    let data = [];\n    let len = data.buf.len();\n    let supported_versions = DEFAULT_SUPPORTED_VERSIONS.to_vec();\n    if let Ok(decoded) = PartialDecode::new(\n        data.buf,\n        data.local_cid_len,\n        &supported_versions,\n        data.grease_quic_bit,\n    ) {\n        match decoded.1 {\n            Some(x) => assert_eq!(len, decoded.0.len() + x.len()),\n            None => assert_eq!(len, decoded.0.len()),\n        }\n    }\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/packet.rs::len", "code": "pub fn len(&self) -> usize {\n        self.buf.get_ref().len()\n    }", "docstring": null}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/tests-gen/streamid.rs::test_something", "test": "fn test_something() {\n    let data = [];\n    let s = StreamId::new(data.side, data.dir, data.index);\n    assert_eq!(s.initiator(), data.side);\n    assert_eq!(s.dir(), data.dir);\n}", "code_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/lib.rs::initiator", "code": "pub fn initiator(self) -> Side {\n        if self.0 & 0x1 == 0 {\n            Side::Client\n        } else {\n            Side::Server\n        }\n    }", "docstring": null}
