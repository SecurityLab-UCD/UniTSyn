{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/cli/tests/run.rs::test_simple_print", "test": "fn test_simple_print() {\n    let mut cmd = get_cmd();\n    let assert = cmd.arg(get_bin_path(\"simple_print\")).assert();\n    let output = assert.get_output();\n    let stdout = &output.stdout;\n    assert!(contains_slice(stdout, b\"Hello World\"));\n    if !(contains_slice(stdout, b\"Hello World\\n\")) {\n        eprint!(\"UNEQUAL: {}\", std::str::from_utf8(stdout).unwrap());\n    }\n}", "code_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/cli/tests/run.rs::contains_slice", "code": "fn contains_slice<T>(slice: &[T], other: &[T]) -> bool\nwhere\n    T: Eq,\n{\n    if other.is_empty() {\n        return true;\n    }\n    slice.windows(other.len()).any(|window| window == other)\n}", "docstring": null}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/fuel_metering.rs::metered_i32_add", "test": "fn metered_i32_add() {\n    let wasm = wat2wasm(\n        r#\"\n        (module\n            (func (export \"test\") (param $a i32) (param $b i32) (result i32)\n                (i32.add\n                    (local.get $a)\n                    (local.get $b)\n                )\n            )\n        )\n    \"#,\n    );\n    let (mut store, func) = default_test_setup(&wasm);\n    let func = func.typed::<(i32, i32), i32>(&store).unwrap();\n    // No fuel -> no success.\n    assert_out_of_fuel(func.call(&mut store, (1, 2)));\n    assert_eq!(store.fuel_consumed(), Some(0));\n    // Now add too little fuel for a start, so still no success.\n    store.add_fuel(1).unwrap();\n    assert_out_of_fuel(func.call(&mut store, (1, 2)));\n    assert_eq!(store.fuel_consumed(), Some(0));\n    // Now add enough fuel, so execution should succeed.\n    store.add_fuel(10).unwrap();\n    assert_success(func.call(&mut store, (1, 2)));\n    assert_eq!(store.fuel_consumed(), Some(5));\n}", "code_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/src/store.rs::fuel_consumed", "code": "pub fn fuel_consumed(&self) -> u64 {\n        self.total.wrapping_sub(self.remaining)\n    }", "docstring": null}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::static_add2_works", "test": "fn static_add2_works() {\n    let (mut store, add2, add2_dyn) = setup_add2();\n    let add2 = add2.typed::<(i32, i32), i32>(&mut store).unwrap();\n    let add2_dyn = add2_dyn.typed::<(i32, i32), i32>(&mut store).unwrap();\n    for a in 0..10 {\n        for b in 0..10 {\n            let expected = a + b;\n            assert_eq!(add2.call(&mut store, (a, b)).unwrap(), expected);\n            assert_eq!(add2_dyn.call(&mut store, (a, b)).unwrap(), expected);\n        }\n    }\n}", "code_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/src/func/mod.rs::call", "code": "pub fn call(\n        &self,\n        mut ctx: impl AsContextMut<UserState = T>,\n        instance: Option<&Instance>,\n        params: FuncParams,\n    ) -> Result<FuncFinished, Trap> {\n        let caller = <Caller<T>>::new(&mut ctx, instance);\n        (self.closure)(caller, params)\n    }", "docstring": null}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::static_add3_works", "test": "fn static_add3_works() {\n    let (mut store, add3, add3_dyn) = setup_add3();\n    let add3 = add3.typed::<(i32, i32, i32), i32>(&mut store).unwrap();\n    let add3_dyn = add3_dyn.typed::<(i32, i32, i32), i32>(&mut store).unwrap();\n    for a in 0..5 {\n        for b in 0..5 {\n            for c in 0..5 {\n                let expected = a + b + c;\n                assert_eq!(add3.call(&mut store, (a, b, c)).unwrap(), expected);\n                assert_eq!(add3_dyn.call(&mut store, (a, b, c)).unwrap(), expected);\n            }\n        }\n    }\n}", "code_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/src/func/mod.rs::call", "code": "pub fn call(\n        &self,\n        mut ctx: impl AsContextMut<UserState = T>,\n        instance: Option<&Instance>,\n        params: FuncParams,\n    ) -> Result<FuncFinished, Trap> {\n        let caller = <Caller<T>>::new(&mut ctx, instance);\n        (self.closure)(caller, params)\n    }", "docstring": null}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::static_duplicate_works", "test": "fn static_duplicate_works() {\n    let (mut store, duplicate, duplicate_dyn) = setup_duplicate();\n    let duplicate = duplicate.typed::<i32, (i32, i32)>(&mut store).unwrap();\n    let duplicate_dyn = duplicate_dyn.typed::<i32, (i32, i32)>(&mut store).unwrap();\n    for input in 0..10 {\n        assert_eq!(duplicate.call(&mut store, input).unwrap(), (input, input));\n        assert_eq!(\n            duplicate_dyn.call(&mut store, input).unwrap(),\n            (input, input)\n        );\n    }\n}", "code_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/src/func/typed_func.rs::call", "code": "pub fn call(&self, mut ctx: impl AsContextMut, params: Params) -> Result<Results, Trap> {\n        // Note: Cloning an [`Engine`] is intentionally a cheap operation.\n        ctx.as_context().store.engine().clone().execute_func(\n            ctx.as_context_mut(),\n            &self.func,\n            params,\n            <CallResultsTuple<Results>>::default(),\n        )\n    }", "docstring": null}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/func.rs::dynamic_type_check_works", "test": "fn dynamic_type_check_works() {\n    let mut store = test_setup();\n    let identity = Func::wrap(&mut store, |value: i32| value);\n    let mut result = Value::I32(0);\n    // Case: Too few inputs given to function.\n    assert_matches!(\n        identity.call(&mut store, &[], core::slice::from_mut(&mut result)),\n        Err(Error::Func(FuncError::MismatchingParameterLen))\n    );\n    // Case: Too many inputs given to function.\n    assert_matches!(\n        identity.call(\n            &mut store,\n            &[Value::I32(0), Value::I32(1)],\n            core::slice::from_mut(&mut result)\n        ),\n        Err(Error::Func(FuncError::MismatchingParameterLen))\n    );\n    // Case: Too few outputs given to function.\n    assert_matches!(\n        identity.call(&mut store, &[Value::I32(0)], &mut [],),\n        Err(Error::Func(FuncError::MismatchingResultLen))\n    );\n    // Case: Too many outputs given to function.\n    assert_matches!(\n        identity.call(\n            &mut store,\n            &[Value::I32(0)],\n            &mut [Value::I32(0), Value::I32(1)],\n        ),\n        Err(Error::Func(FuncError::MismatchingResultLen))\n    );\n    // Case: Mismatching type given as input to function.\n    for input in &[\n        Value::I64(0),\n        Value::F32(0.0.into()),\n        Value::F64(0.0.into()),\n    ] {\n        assert_matches!(\n            identity.call(\n                &mut store,\n                core::slice::from_ref(input),\n                core::slice::from_mut(&mut result)\n            ),\n            Err(Error::Func(FuncError::MismatchingParameterType))\n        );\n    }\n    // Case: Allow for incorrect result type.\n    //\n    // The result type will be overwritten anyways.\n    assert_matches!(\n        identity.call(&mut store, &[Value::I32(0)], &mut [Value::I64(0)]),\n        Ok(_)\n    );\n}", "code_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/src/func/typed_func.rs::call", "code": "pub fn call(&self, mut ctx: impl AsContextMut, params: Params) -> Result<Results, Trap> {\n        // Note: Cloning an [`Engine`] is intentionally a cheap operation.\n        ctx.as_context().store.engine().clone().execute_func(\n            ctx.as_context_mut(),\n            &self.func,\n            params,\n            <CallResultsTuple<Results>>::default(),\n        )\n    }", "docstring": null}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resumable_call.rs::resumable_call_smoldot_tail_01", "test": "fn resumable_call_smoldot_tail_01() {\n    let (mut store, wasm_fn) = resumable_call_smoldot_common(\n        r#\"\n        (module\n            (import \"env\" \"host_fn\" (func $host_fn (result i32)))\n            (func (export \"test\") (result i32)\n                (return_call $host_fn)\n            )\n        )\n        \"#,\n    );\n    assert_eq!(\n        wasm_fn\n            .call_resumable(&mut store, ())\n            .unwrap_err()\n            .i32_exit_status(),\n        Some(100),\n    );\n}", "code_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/core/src/trap.rs::i32_exit_status", "code": "pub fn i32_exit_status(&self) -> Option<i32> {\n        if let Self::I32Exit(status) = self {\n            return Some(*status);\n        }\n        None\n    }", "docstring": null}
{"test_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/wasmi/tests/e2e/v1/resumable_call.rs::resumable_call_host", "test": "fn resumable_call_host() {\n    let (mut store, _linker) = test_setup();\n    let host_fn = Func::wrap(&mut store, || -> Result<(), Trap> {\n        Err(Trap::i32_exit(100))\n    });\n    // Even though the called host function traps we expect a normal error\n    // since the host function is the root function of the call and therefore\n    // it would not make sense to resume it.\n    let error = host_fn\n        .call_resumable(&mut store, &[], &mut [])\n        .unwrap_err();\n    match error {\n        Error::Trap(trap) => {\n            assert_eq!(trap.i32_exit_status(), Some(100));\n        }\n        _ => panic!(\"expected Wasm trap\"),\n    }\n    // The same test for `TypedFunc`:\n    let trap = host_fn\n        .typed::<(), ()>(&store)\n        .unwrap()\n        .call_resumable(&mut store, ())\n        .unwrap_err();\n    assert_eq!(trap.i32_exit_status(), Some(100));\n}", "code_id": "paritytech-wasmi/paritytech-wasmi-d66f271/crates/core/src/trap.rs::i32_exit_status", "code": "pub fn i32_exit_status(&self) -> Option<i32> {\n        if let Self::I32Exit(status) = self {\n            return Some(*status);\n        }\n        None\n    }", "docstring": null}
