{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/common_test.rs::test_float_to_bits", "test": "fn test_float_to_bits() {\n    assert_eq!(0, 0.0_f32.to_bits());\n    assert_eq!(0x40490fda, 3.1415926_f32.to_bits());\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/common_test.rs::test_double_to_bits", "test": "fn test_double_to_bits() {\n    assert_eq!(0, 0.0_f64.to_bits());\n    assert_eq!(\n        0x400921FB54442D18,\n        3.1415926535897932384626433_f64.to_bits(),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/d2s_table_test.rs::test_compute_pow5", "test": "fn test_compute_pow5() {\n    for (i, entry) in DOUBLE_POW5_SPLIT.iter().enumerate() {\n        assert_eq!(*entry, unsafe { compute_pow5(i as u32) }, \"entry {}\", i);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/d2s_table_test.rs::test_compute_inv_pow5", "test": "fn test_compute_inv_pow5() {\n    for (i, entry) in DOUBLE_POW5_INV_SPLIT[..292].iter().enumerate() {\n        assert_eq!(*entry, unsafe { compute_inv_pow5(i as u32) }, \"entry {}\", i);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/d2s_test.rs::test_random", "test": "fn test_random() {\n    let n = if cfg!(miri) { 100 } else { 1000000 };\n    let mut buffer = ryu::Buffer::new();\n    for _ in 0..n {\n        let f: f64 = rand::random();\n        assert_eq!(f, buffer.format_finite(f).parse().unwrap());\n    }\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/d2s_test.rs::test_min_and_max", "test": "fn test_min_and_max() {\n    assert_eq!(f64::from_bits(0x7fefffffffffffff), 1.7976931348623157e308);\n    check!(1.7976931348623157e308);\n    assert_eq!(f64::from_bits(1), 5e-324);\n    check!(5e-324);\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/exhaustive.rs::test_exhaustive", "test": "fn test_exhaustive() {\n    const BATCH_SIZE: u32 = 1_000_000;\n    let counter = Arc::new(AtomicUsize::new(0));\n    let finished = Arc::new(AtomicUsize::new(0));\n\n    let mut workers = Vec::new();\n    for _ in 0..num_cpus::get() {\n        let counter = counter.clone();\n        let finished = finished.clone();\n        workers.push(thread::spawn(move || loop {\n            let batch = counter.fetch_add(1, Ordering::Relaxed) as u32;\n            if batch > u32::max_value() / BATCH_SIZE {\n                return;\n            }\n\n            let min = batch * BATCH_SIZE;\n            let max = if batch == u32::max_value() / BATCH_SIZE {\n                u32::max_value()\n            } else {\n                min + BATCH_SIZE - 1\n            };\n\n            let mut bytes = [0u8; 24];\n            let mut buffer = ryu::Buffer::new();\n            for u in min..=max {\n                let f = f32::from_bits(u);\n                if !f.is_finite() {\n                    continue;\n                }\n                let n = unsafe { ryu::raw::format32(f, &mut bytes[0]) };\n                assert_eq!(Ok(Ok(f)), str::from_utf8(&bytes[..n]).map(str::parse));\n                assert_eq!(Ok(f), buffer.format_finite(f).parse());\n            }\n\n            let increment = (max - min + 1) as usize;\n            let update = finished.fetch_add(increment, Ordering::Relaxed);\n            println!(\"{}\", update + increment);\n        }));\n    }\n\n    for w in workers {\n        w.join().unwrap();\n    }\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/f2s_test.rs::test_random", "test": "fn test_random() {\n    let n = if cfg!(miri) { 100 } else { 1000000 };\n    let mut buffer = ryu::Buffer::new();\n    for _ in 0..n {\n        let f: f32 = rand::random();\n        assert_eq!(f, buffer.format_finite(f).parse().unwrap());\n    }\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/f2s_test.rs::test_min_and_max", "test": "fn test_min_and_max() {\n    assert_eq!(f32::from_bits(0x7f7fffff), 3.4028235e38);\n    check!(3.4028235e38);\n    assert_eq!(f32::from_bits(1), 1e-45);\n    check!(1e-45);\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_min_max", "test": "fn test_min_max() {\n    assert_eq!(\n        1.7976931348623157e308,\n        s2d(b\"1.7976931348623157e308\").unwrap(),\n    );\n    assert_eq!(5E-324, s2d(b\"5E-324\").unwrap());\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_mantissa_rounding_overflow", "test": "fn test_mantissa_rounding_overflow() {\n    // This results in binary mantissa that is all ones and requires rounding up\n    // because it is closer to 1 than to the next smaller float. This is a\n    // regression test that the mantissa overflow is handled correctly by\n    // increasing the exponent.\n    assert_eq!(1.0, s2d(b\"0.99999999999999999\").unwrap());\n    // This number overflows the mantissa *and* the IEEE exponent.\n    assert_eq!(f64::INFINITY, s2d(b\"1.7976931348623159e308\").unwrap());\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_underflow", "test": "fn test_underflow() {\n    assert_eq!(0.0, s2d(b\"2.4e-324\").unwrap());\n    assert_eq!(0.0, s2d(b\"1e-324\").unwrap());\n    assert_eq!(0.0, s2d(b\"9.99999e-325\").unwrap());\n    // These are just about halfway between 0 and the smallest float.\n    // The first is just below the halfway point, the second just above.\n    assert_eq!(0.0, s2d(b\"2.4703282292062327e-324\").unwrap());\n    assert_eq!(5e-324, s2d(b\"2.4703282292062328e-324\").unwrap());\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_table_size_denormal", "test": "fn test_table_size_denormal() {\n    assert_eq!(5e-324, s2d(b\"4.9406564584124654e-324\").unwrap());\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_issue157", "test": "fn test_issue157() {\n    assert_eq!(\n        1.2999999999999999E+154,\n        s2d(b\"1.2999999999999999E+154\").unwrap(),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_issue173", "test": "fn test_issue173() {\n    // Denormal boundary\n    assert_eq!(\n        2.2250738585072012e-308,\n        s2d(b\"2.2250738585072012e-308\").unwrap(),\n    );\n    assert_eq!(\n        2.2250738585072013e-308,\n        s2d(b\"2.2250738585072013e-308\").unwrap(),\n    );\n    assert_eq!(\n        2.2250738585072014e-308,\n        s2d(b\"2.2250738585072014e-308\").unwrap(),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2f_test.rs::test_mantissa_rounding_overflow", "test": "fn test_mantissa_rounding_overflow() {\n    assert_eq!(1.0, s2f(b\"0.999999999\").unwrap());\n    assert_eq!(f32::INFINITY, s2f(b\"3.4028236e+38\").unwrap());\n    assert_eq!(1.1754944e-38, s2f(b\"1.17549430e-38\").unwrap()); // FLT_MIN\n    assert_eq!(1.1754944e-38, s2f(b\"1.17549431e-38\").unwrap());\n    assert_eq!(1.1754944e-38, s2f(b\"1.17549432e-38\").unwrap());\n    assert_eq!(1.1754944e-38, s2f(b\"1.17549433e-38\").unwrap());\n    assert_eq!(1.1754944e-38, s2f(b\"1.17549434e-38\").unwrap());\n    assert_eq!(1.1754944e-38, s2f(b\"1.17549435e-38\").unwrap());\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2f_test.rs::test_trailing_zeros", "test": "fn test_trailing_zeros() {\n    assert_eq!(26843550.0, s2f(b\"26843549.5\").unwrap());\n    assert_eq!(50000004.0, s2f(b\"50000002.5\").unwrap());\n    assert_eq!(99999992.0, s2f(b\"99999989.5\").unwrap());\n}", "error": "Not Definition Found"}
