{"test_id": "gimli-rs-gimli/gimli-rs-gimli-3947879/tests/convert_self.rs::test_convert_debug_info", "test": "fn test_convert_debug_info() {\n    // Convert existing sections\n    let debug_abbrev = read_section(\"debug_abbrev\");\n    let debug_abbrev = read::DebugAbbrev::new(&debug_abbrev, LittleEndian);\n\n    let debug_info = read_section(\"debug_info\");\n    let debug_info = read::DebugInfo::new(&debug_info, LittleEndian);\n\n    let debug_line = read_section(\"debug_line\");\n    let debug_line = read::DebugLine::new(&debug_line, LittleEndian);\n\n    let debug_str = read_section(\"debug_str\");\n    let debug_str = read::DebugStr::new(&debug_str, LittleEndian);\n\n    let debug_ranges = read_section(\"debug_ranges\");\n    let debug_ranges = read::DebugRanges::new(&debug_ranges, LittleEndian);\n\n    let debug_rnglists = read::DebugRngLists::new(&[], LittleEndian);\n\n    let ranges = gimli::RangeLists::new(debug_ranges, debug_rnglists);\n\n    let debug_loc = read_section(\"debug_loc\");\n    let debug_loc = read::DebugLoc::new(&debug_loc, LittleEndian);\n\n    let debug_loclists = read::DebugLocLists::new(&[], LittleEndian);\n\n    let locations = gimli::LocationLists::new(debug_loc, debug_loclists);\n\n    let dwarf = read::Dwarf {\n        debug_abbrev,\n        debug_info,\n        debug_line,\n        debug_str,\n        ranges,\n        locations,\n        ..Default::default()\n    };\n\n    let mut dwarf = write::Dwarf::from(&dwarf, &|address| Some(Address::Constant(address)))\n        .expect(\"Should convert DWARF information\");\n\n    assert_eq!(dwarf.units.count(), 23);\n    let entries: usize = (0..dwarf.units.count())\n        .map(|i| dwarf.units.get(dwarf.units.id(i)).count())\n        .sum();\n    assert_eq!(entries, 29_560);\n    assert_eq!(dwarf.line_strings.count(), 0);\n    assert_eq!(dwarf.strings.count(), 3921);\n\n    // Write to new sections\n    let mut write_sections = write::Sections::new(EndianVec::new(LittleEndian));\n    dwarf\n        .write(&mut write_sections)\n        .expect(\"Should write DWARF information\");\n    let debug_info_data = write_sections.debug_info.slice();\n    let debug_abbrev_data = write_sections.debug_abbrev.slice();\n    let debug_line_data = write_sections.debug_line.slice();\n    let debug_ranges_data = write_sections.debug_ranges.slice();\n    let debug_loc_data = write_sections.debug_loc.slice();\n    let debug_str_data = write_sections.debug_str.slice();\n    assert_eq!(debug_info_data.len(), 394_930);\n    assert_eq!(debug_abbrev_data.len(), 9701);\n    assert_eq!(debug_line_data.len(), 105_797);\n    assert_eq!(debug_ranges_data.len(), 155_712);\n    assert_eq!(debug_loc_data.len(), 245_168);\n    assert_eq!(debug_str_data.len(), 144_731);\n\n    // Convert new sections\n    let debug_abbrev = read::DebugAbbrev::new(debug_abbrev_data, LittleEndian);\n    let debug_info = read::DebugInfo::new(debug_info_data, LittleEndian);\n    let debug_line = read::DebugLine::new(debug_line_data, LittleEndian);\n    let debug_str = read::DebugStr::new(debug_str_data, LittleEndian);\n    let debug_ranges = read::DebugRanges::new(debug_ranges_data, LittleEndian);\n    let debug_rnglists = read::DebugRngLists::new(&[], LittleEndian);\n    let debug_loc = read::DebugLoc::new(debug_loc_data, LittleEndian);\n    let debug_loclists = read::DebugLocLists::new(&[], LittleEndian);\n\n    let ranges = gimli::RangeLists::new(debug_ranges, debug_rnglists);\n    let locations = gimli::LocationLists::new(debug_loc, debug_loclists);\n\n    let dwarf = read::Dwarf {\n        debug_abbrev,\n        debug_info,\n        debug_line,\n        debug_str,\n        ranges,\n        locations,\n        ..Default::default()\n    };\n\n    let dwarf = write::Dwarf::from(&dwarf, &|address| Some(Address::Constant(address)))\n        .expect(\"Should convert DWARF information\");\n\n    assert_eq!(dwarf.units.count(), 23);\n    let entries: usize = (0..dwarf.units.count())\n        .map(|i| dwarf.units.get(dwarf.units.id(i)).count())\n        .sum();\n    assert_eq!(entries, 29_560);\n    assert_eq!(dwarf.strings.count(), 3921);\n}", "code_id": "gimli-rs-gimli/gimli-rs-gimli-3947879/src/write/unit.rs::count", "code": "pub fn count(&self) -> usize {\n        self.units.len()\n    }", "docstring": null}
{"test_id": "gimli-rs-gimli/gimli-rs-gimli-3947879/tests/convert_self.rs::test_convert_eh_frame", "test": "fn test_convert_eh_frame() {\n    // Convert existing section\n    let eh_frame = read_section(\"eh_frame\");\n    let mut eh_frame = read::EhFrame::new(&eh_frame, LittleEndian);\n    // The `.eh_frame` fixture data was created on a 64-bit machine.\n    eh_frame.set_address_size(8);\n    let frames = write::FrameTable::from(&eh_frame, &|address| Some(Address::Constant(address)))\n        .expect(\"Should convert eh_frame information\");\n    assert_eq!(frames.cie_count(), 2);\n    assert_eq!(frames.fde_count(), 3482);\n\n    // Write to new section\n    let mut write_eh_frame = write::EhFrame(EndianVec::new(LittleEndian));\n    frames\n        .write_eh_frame(&mut write_eh_frame)\n        .expect(\"Should write eh_frame information\");\n    let eh_frame = write_eh_frame.slice();\n    assert_eq!(eh_frame.len(), 147144);\n\n    // Convert new section\n    let mut eh_frame = read::EhFrame::new(&eh_frame, LittleEndian);\n    eh_frame.set_address_size(8);\n    let frames = write::FrameTable::from(&eh_frame, &|address| Some(Address::Constant(address)))\n        .expect(\"Should convert eh_frame information\");\n    assert_eq!(frames.cie_count(), 2);\n    assert_eq!(frames.fde_count(), 3482);\n}", "code_id": "gimli-rs-gimli/gimli-rs-gimli-3947879/src/write/cfi.rs::cie_count", "code": "pub fn cie_count(&self) -> usize {\n        self.cies.len()\n    }", "docstring": null}
{"test_id": "gimli-rs-gimli/gimli-rs-gimli-3947879/tests/parse_self.rs::test_parse_self_debug_line", "test": "fn test_parse_self_debug_line() {\n    let debug_info = read_section(\"debug_info\");\n    let debug_info = DebugInfo::new(&debug_info, LittleEndian);\n\n    let debug_abbrev = read_section(\"debug_abbrev\");\n    let debug_abbrev = DebugAbbrev::new(&debug_abbrev, LittleEndian);\n\n    let debug_line = read_section(\"debug_line\");\n    let debug_line = DebugLine::new(&debug_line, LittleEndian);\n\n    let debug_str = read_section(\"debug_str\");\n    let debug_str = DebugStr::new(&debug_str, LittleEndian);\n\n    let mut iter = debug_info.units();\n    while let Some(unit) = iter.next().expect(\"Should parse compilation unit\") {\n        let abbrevs = unit\n            .abbreviations(&debug_abbrev)\n            .expect(\"Should parse abbreviations\");\n\n        let mut cursor = unit.entries(&abbrevs);\n        cursor.next_dfs().expect(\"Should parse next dfs\");\n\n        let unit_entry = cursor.current().expect(\"Should have a root entry\");\n\n        let comp_dir = unit_entry\n            .attr_value(gimli::DW_AT_comp_dir)\n            .expect(\"Should parse comp_dir attribute\")\n            .and_then(|val| val.string_value(&debug_str));\n        let comp_name = unit_entry\n            .attr_value(gimli::DW_AT_name)\n            .expect(\"Should parse name attribute\")\n            .and_then(|val| val.string_value(&debug_str));\n\n        if let Some(AttributeValue::DebugLineRef(offset)) = unit_entry\n            .attr_value(gimli::DW_AT_stmt_list)\n            .expect(\"Should parse stmt_list\")\n        {\n            let program = debug_line\n                .program(offset, unit.address_size(), comp_dir, comp_name)\n                .expect(\"should parse line number program header\");\n\n            let mut results = Vec::new();\n            let mut rows = program.rows();\n            while let Some((_, row)) = rows\n                .next_row()\n                .expect(\"Should parse and execute all rows in the line number program\")\n            {\n                results.push(*row);\n            }\n            results.reverse();\n\n            let program = debug_line\n                .program(offset, unit.address_size(), comp_dir, comp_name)\n                .expect(\"should parse line number program header\");\n            let (program, sequences) = program\n                .sequences()\n                .expect(\"should parse and execute the entire line number program\");\n            assert!(!sequences.is_empty()); // Should be at least one sequence.\n            for sequence in sequences {\n                let mut rows = program.resume_from(&sequence);\n                while let Some((_, row)) = rows\n                    .next_row()\n                    .expect(\"Should parse and execute all rows after resuming\")\n                {\n                    let other_row = results.pop().unwrap();\n                    assert!(row.address() >= sequence.start);\n                    assert!(row.address() <= sequence.end);\n                    assert_eq!(row.address(), other_row.address());\n                    assert_eq!(row.line(), other_row.line());\n                }\n            }\n            assert!(results.is_empty());\n        }\n    }\n}", "code_id": "gimli-rs-gimli/gimli-rs-gimli-3947879/src/read/endian_slice.rs::is_empty", "code": "fn is_empty(&self) -> bool {\n        self.slice.is_empty()\n    }", "docstring": null}
