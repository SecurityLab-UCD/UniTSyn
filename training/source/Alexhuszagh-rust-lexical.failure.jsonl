{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/api_tests.rs::f32_decimal_test", "test": "fn f32_decimal_test() {\n    // integer test\n    assert_eq!(0.0, f32::from_lexical(b\"0\").unwrap());\n    assert_eq!(1.0, f32::from_lexical(b\"1\").unwrap());\n    assert_eq!(12.0, f32::from_lexical(b\"12\").unwrap());\n    assert_eq!(123.0, f32::from_lexical(b\"123\").unwrap());\n    assert_eq!(1234.0, f32::from_lexical(b\"1234\").unwrap());\n    assert_eq!(12345.0, f32::from_lexical(b\"12345\").unwrap());\n    assert_eq!(123456.0, f32::from_lexical(b\"123456\").unwrap());\n    assert_eq!(1234567.0, f32::from_lexical(b\"1234567\").unwrap());\n    assert_eq!(12345678.0, f32::from_lexical(b\"12345678\").unwrap());\n\n    // No fraction after decimal point test\n    assert_eq!(1.0, f32::from_lexical(b\"1.\").unwrap());\n    assert_eq!(12.0, f32::from_lexical(b\"12.\").unwrap());\n    assert_eq!(1234567.0, f32::from_lexical(b\"1234567.\").unwrap());\n\n    // No integer before decimal point test\n    assert_eq!(0.1, f32::from_lexical(b\".1\").unwrap());\n    assert_eq!(0.12, f32::from_lexical(b\".12\").unwrap());\n    assert_eq!(0.1234567, f32::from_lexical(b\".1234567\").unwrap());\n\n    // decimal test\n    assert_eq!(123.1, f32::from_lexical(b\"123.1\").unwrap());\n    assert_eq!(123.12, f32::from_lexical(b\"123.12\").unwrap());\n    assert_eq!(123.123, f32::from_lexical(b\"123.123\").unwrap());\n    assert_eq!(123.1234, f32::from_lexical(b\"123.1234\").unwrap());\n    assert_eq!(123.12345, f32::from_lexical(b\"123.12345\").unwrap());\n\n    // rounding test\n    assert_eq!(123456790.0, f32::from_lexical(b\"123456789\").unwrap());\n    assert_eq!(123456790.0, f32::from_lexical(b\"123456789.1\").unwrap());\n    assert_eq!(123456790.0, f32::from_lexical(b\"123456789.12\").unwrap());\n    assert_eq!(123456790.0, f32::from_lexical(b\"123456789.123\").unwrap());\n    assert_eq!(123456790.0, f32::from_lexical(b\"123456789.1234\").unwrap());\n    assert_eq!(123456790.0, f32::from_lexical(b\"123456789.12345\").unwrap());\n\n    // exponent test\n    assert_eq!(123456789.12345, f32::from_lexical(b\"1.2345678912345e8\").unwrap());\n    assert_eq!(123450000.0, f32::from_lexical(b\"1.2345e+8\").unwrap());\n    assert_eq!(1.2345e+11, f32::from_lexical(b\"1.2345e+11\").unwrap());\n    assert_eq!(1.2345e+11, f32::from_lexical(b\"123450000000\").unwrap());\n    assert_eq!(1.2345e+38, f32::from_lexical(b\"1.2345e+38\").unwrap());\n    assert_eq!(1.2345e+38, f32::from_lexical(b\"123450000000000000000000000000000000000\").unwrap());\n    assert_eq!(1.2345e-8, f32::from_lexical(b\"1.2345e-8\").unwrap());\n    assert_eq!(1.2345e-8, f32::from_lexical(b\"0.000000012345\").unwrap());\n    assert_eq!(1.2345e-38, f32::from_lexical(b\"1.2345e-38\").unwrap());\n    assert_eq!(\n        1.2345e-38,\n        f32::from_lexical(b\"0.000000000000000000000000000000000000012345\").unwrap()\n    );\n\n    assert!(f32::from_lexical(b\"NaN\").unwrap().is_nan());\n    assert!(f32::from_lexical(b\"nan\").unwrap().is_nan());\n    assert!(f32::from_lexical(b\"NAN\").unwrap().is_nan());\n    assert!(f32::from_lexical(b\"inf\").unwrap().is_infinite());\n    assert!(f32::from_lexical(b\"INF\").unwrap().is_infinite());\n    assert!(f32::from_lexical(b\"+inf\").unwrap().is_infinite());\n    assert!(f32::from_lexical(b\"-inf\").unwrap().is_infinite());\n\n    // Check various expected failures.\n    assert_eq!(Err(Error::Empty(0)), f32::from_lexical(b\"\"));\n    assert_eq!(Err(Error::EmptyMantissa(0)), f32::from_lexical(b\"e\"));\n    assert_eq!(Err(Error::EmptyMantissa(0)), f32::from_lexical(b\"E\"));\n    assert_eq!(Err(Error::EmptyMantissa(1)), f32::from_lexical(b\".e1\"));\n    assert_eq!(Err(Error::EmptyMantissa(1)), f32::from_lexical(b\".e-1\"));\n    assert_eq!(Err(Error::EmptyMantissa(0)), f32::from_lexical(b\"e1\"));\n    assert_eq!(Err(Error::EmptyMantissa(0)), f32::from_lexical(b\"e-1\"));\n    assert_eq!(Err(Error::Empty(1)), f32::from_lexical(b\"+\"));\n    assert_eq!(Err(Error::Empty(1)), f32::from_lexical(b\"-\"));\n\n    // Bug fix for Issue #8\n    assert_eq!(Ok(5.002868148396374), f32::from_lexical(b\"5.002868148396374\"));\n\n    // Other bug fixes\n    assert_eq!(Ok(7.2625224e+37), f32::from_lexical(b\"72625224000000000000000000000000000000\"));\n    assert_eq!(Ok(7.2625224e+37), f32::from_lexical(b\"72625224000000000000000000000000000000.0\"));\n    assert_eq!(Ok(-7.2625224e+37), f32::from_lexical(b\"-72625224000000000000000000000000000000\"));\n    assert_eq!(Ok(-7.2625224e+37), f32::from_lexical(b\"-72625224000000000000000000000000000000.0\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/api_tests.rs::f64_decimal_test", "test": "fn f64_decimal_test() {\n    // integer test\n    assert_eq!(0.0, f64::from_lexical(b\"0\").unwrap());\n    assert_eq!(1.0, f64::from_lexical(b\"1\").unwrap());\n    assert_eq!(12.0, f64::from_lexical(b\"12\").unwrap());\n    assert_eq!(123.0, f64::from_lexical(b\"123\").unwrap());\n    assert_eq!(1234.0, f64::from_lexical(b\"1234\").unwrap());\n    assert_eq!(12345.0, f64::from_lexical(b\"12345\").unwrap());\n    assert_eq!(123456.0, f64::from_lexical(b\"123456\").unwrap());\n    assert_eq!(1234567.0, f64::from_lexical(b\"1234567\").unwrap());\n    assert_eq!(12345678.0, f64::from_lexical(b\"12345678\").unwrap());\n\n    // No fraction after decimal point test\n    assert_eq!(1.0, f64::from_lexical(b\"1.\").unwrap());\n    assert_eq!(12.0, f64::from_lexical(b\"12.\").unwrap());\n    assert_eq!(1234567.0, f64::from_lexical(b\"1234567.\").unwrap());\n\n    // No integer before decimal point test\n    assert_eq!(0.1, f64::from_lexical(b\".1\").unwrap());\n    assert_eq!(0.12, f64::from_lexical(b\".12\").unwrap());\n    assert_eq!(0.1234567, f64::from_lexical(b\".1234567\").unwrap());\n\n    // decimal test\n    assert_eq!(123456789.0, f64::from_lexical(b\"123456789\").unwrap());\n    assert_eq!(123456789.1, f64::from_lexical(b\"123456789.1\").unwrap());\n    assert_eq!(123456789.12, f64::from_lexical(b\"123456789.12\").unwrap());\n    assert_eq!(123456789.123, f64::from_lexical(b\"123456789.123\").unwrap());\n    assert_eq!(123456789.1234, f64::from_lexical(b\"123456789.1234\").unwrap());\n    assert_eq!(123456789.12345, f64::from_lexical(b\"123456789.12345\").unwrap());\n    assert_eq!(123456789.123456, f64::from_lexical(b\"123456789.123456\").unwrap());\n    assert_eq!(123456789.1234567, f64::from_lexical(b\"123456789.1234567\").unwrap());\n    assert_eq!(123456789.12345678, f64::from_lexical(b\"123456789.12345678\").unwrap());\n\n    // rounding test\n    assert_eq!(123456789.12345679, f64::from_lexical(b\"123456789.123456789\").unwrap());\n    assert_eq!(123456789.12345679, f64::from_lexical(b\"123456789.1234567890\").unwrap());\n    assert_eq!(123456789.12345679, f64::from_lexical(b\"123456789.123456789012\").unwrap());\n    assert_eq!(123456789.12345679, f64::from_lexical(b\"123456789.1234567890123\").unwrap());\n    assert_eq!(123456789.12345679, f64::from_lexical(b\"123456789.12345678901234\").unwrap());\n\n    // exponent test\n    assert_eq!(123456789.12345, f64::from_lexical(b\"1.2345678912345e8\").unwrap());\n    assert_eq!(123450000.0, f64::from_lexical(b\"1.2345e+8\").unwrap());\n    assert_eq!(1.2345e+11, f64::from_lexical(b\"123450000000\").unwrap());\n    assert_eq!(1.2345e+11, f64::from_lexical(b\"1.2345e+11\").unwrap());\n    assert_eq!(1.2345e+38, f64::from_lexical(b\"1.2345e+38\").unwrap());\n    assert_eq!(1.2345e+38, f64::from_lexical(b\"123450000000000000000000000000000000000\").unwrap());\n    assert_eq!(1.2345e+308, f64::from_lexical(b\"1.2345e+308\").unwrap());\n    assert_eq!(1.2345e+308, f64::from_lexical(b\"123450000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\").unwrap());\n    assert_eq!(0.000000012345, f64::from_lexical(b\"1.2345e-8\").unwrap());\n    assert_eq!(1.2345e-8, f64::from_lexical(b\"0.000000012345\").unwrap());\n    assert_eq!(1.2345e-38, f64::from_lexical(b\"1.2345e-38\").unwrap());\n    assert_eq!(\n        1.2345e-38,\n        f64::from_lexical(b\"0.000000000000000000000000000000000000012345\").unwrap()\n    );\n\n    // denormalized (try extremely low values)\n    assert_eq!(1.2345e-308, f64::from_lexical(b\"1.2345e-308\").unwrap());\n\n    // due to issues in how the data is parsed, manually extracting\n    // non-exponents of 1.<e-299 is prone to error\n    // test the limit of our ability\n    // We tend to get relative errors of 1e-16, even at super low values.\n    assert_eq!(1.2345e-299, f64::from_lexical(b\"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012345\").unwrap());\n\n    // Keep pushing from -300 to -324\n    assert_eq!(1.2345e-300, f64::from_lexical(b\"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012345\").unwrap());\n\n    assert_eq!(1.2345e-310, f64::from_lexical(b\"0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012345\").unwrap());\n    assert_eq!(1.2345e-320, f64::from_lexical(b\"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012345\").unwrap());\n    assert_eq!(1.2345e-321, f64::from_lexical(b\"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012345\").unwrap());\n    assert_eq!(1.24e-322, f64::from_lexical(b\"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000124\").unwrap());\n    assert_eq!(Ok(1e-323), f64::from_lexical(b\"0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\"));\n    assert_eq!(Ok(5e-324), f64::from_lexical(b\"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005\"));\n\n    assert!(f64::from_lexical(b\"NaN\").unwrap().is_nan());\n    assert!(f64::from_lexical(b\"nan\").unwrap().is_nan());\n    assert!(f64::from_lexical(b\"NAN\").unwrap().is_nan());\n    assert!(f64::from_lexical(b\"inf\").unwrap().is_infinite());\n    assert!(f64::from_lexical(b\"INF\").unwrap().is_infinite());\n    assert!(f64::from_lexical(b\"+inf\").unwrap().is_infinite());\n    assert!(f64::from_lexical(b\"-inf\").unwrap().is_infinite());\n\n    // Check various expected failures.\n    assert_eq!(Err(Error::Empty(0)), f64::from_lexical(b\"\"));\n    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b\"e\"));\n    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b\"E\"));\n    assert_eq!(Err(Error::EmptyMantissa(1)), f64::from_lexical(b\".e1\"));\n    assert_eq!(Err(Error::EmptyMantissa(1)), f64::from_lexical(b\".e-1\"));\n    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b\"e1\"));\n    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b\"e-1\"));\n\n    // Check various reports from a fuzzer.\n    assert_eq!(Err(Error::EmptyExponent(2)), f64::from_lexical(b\"0e\"));\n    assert_eq!(Err(Error::EmptyExponent(4)), f64::from_lexical(b\"0.0e\"));\n    assert_eq!(Err(Error::EmptyMantissa(1)), f64::from_lexical(b\".E\"));\n    assert_eq!(Err(Error::EmptyMantissa(1)), f64::from_lexical(b\".e\"));\n    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b\"E2252525225\"));\n    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b\"e2252525225\"));\n    assert_eq!(Ok(f64::INFINITY), f64::from_lexical(b\"2E200000000000\"));\n\n    // Add various unittests from proptests.\n    assert_eq!(Err(Error::EmptyExponent(2)), f64::from_lexical(b\"0e\"));\n    assert_eq!(Err(Error::EmptyMantissa(1)), f64::from_lexical(b\".\"));\n    assert_eq!(Err(Error::EmptyMantissa(2)), f64::from_lexical(b\"+.\"));\n    assert_eq!(Err(Error::EmptyMantissa(2)), f64::from_lexical(b\"-.\"));\n    assert_eq!(Err(Error::Empty(1)), f64::from_lexical(b\"+\"));\n    assert_eq!(Err(Error::Empty(1)), f64::from_lexical(b\"-\"));\n\n    // Bug fix for Issue #8\n    assert_eq!(Ok(5.002868148396374), f64::from_lexical(b\"5.002868148396374\"));\n\n    // Other bug fixes\n    assert_eq!(Ok(1.620515050981309e+308), f64::from_lexical(b\"162051505098130900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"));\n    assert_eq!(Ok(1.620515050981309e+308), f64::from_lexical(b\"162051505098130900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0\"));\n    assert_eq!(Ok(-1.620515050981309e+308), f64::from_lexical(b\"-162051505098130900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"));\n    assert_eq!(Ok(-1.620515050981309e+308), f64::from_lexical(b\"-162051505098130900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/api_tests.rs::parse_f64_large_zeros_test", "test": "fn parse_f64_large_zeros_test() {\n    // Test numbers with a massive number of 0s in the integer component.\n    let parse = move |x| f64::from_lexical_partial(x);\n    assert_eq!(Ok((71610528364411830000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0, 308)), parse(b\"71610528364411830000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"));\n    assert_eq!(Ok((126769393745745060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0, 309)), parse(b\"126769393745745060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"));\n    assert_eq!(Ok((38652960461239320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0, 308)), parse(b\"38652960461239320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/api_tests.rs::parse_f32_lossy_test", "test": "fn parse_f32_lossy_test() {\n    const FORMAT: u128 = STANDARD;\n    let options = Options::builder().lossy(true).build().unwrap();\n    let parse = move |x| f32::from_lexical_partial_with_options::<FORMAT>(x, &options);\n\n    assert_eq!(Ok((1.2345, 6)), parse(b\"1.2345\"));\n    assert_eq!(Ok((12.345, 6)), parse(b\"12.345\"));\n    assert_eq!(Ok((12345.6789, 10)), parse(b\"12345.6789\"));\n    assert_eq!(Ok((1.2345e10, 9)), parse(b\"1.2345e10\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/api_tests.rs::parse_f64_lossy_test", "test": "fn parse_f64_lossy_test() {\n    const FORMAT: u128 = STANDARD;\n    let options = Options::builder().lossy(true).build().unwrap();\n    let parse = move |x| f64::from_lexical_partial_with_options::<FORMAT>(x, &options);\n\n    assert_eq!(Ok((1.2345, 6)), parse(b\"1.2345\"));\n    assert_eq!(Ok((12.345, 6)), parse(b\"12.345\"));\n    assert_eq!(Ok((12345.6789, 10)), parse(b\"12345.6789\"));\n    assert_eq!(Ok((1.2345e10, 9)), parse(b\"1.2345e10\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/api_tests.rs::f32_lossy_decimal_test", "test": "fn f32_lossy_decimal_test() {\n    const FORMAT: u128 = STANDARD;\n\n    let options = Options::builder().lossy(true).build().unwrap();\n    assert_eq!(\n        Err(Error::EmptyMantissa(1)),\n        f32::from_lexical_with_options::<FORMAT>(b\".\", &options)\n    );\n    assert_eq!(Err(Error::Empty(0)), f32::from_lexical_with_options::<FORMAT>(b\"\", &options));\n    assert_eq!(Ok(0.0), f32::from_lexical_with_options::<FORMAT>(b\"0.0\", &options));\n    assert_eq!(\n        Err((Error::InvalidDigit(1)).into()),\n        f32::from_lexical_with_options::<FORMAT>(b\"1a\", &options)\n    );\n\n    // Bug fix for Issue #8\n    assert_eq!(\n        Ok(5.002868148396374),\n        f32::from_lexical_with_options::<FORMAT>(b\"5.002868148396374\", &options)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/api_tests.rs::f64_lossy_decimal_test", "test": "fn f64_lossy_decimal_test() {\n    const FORMAT: u128 = STANDARD;\n\n    let options = Options::builder().lossy(true).build().unwrap();\n    assert_eq!(\n        Err(Error::EmptyMantissa(1)),\n        f64::from_lexical_with_options::<FORMAT>(b\".\", &options)\n    );\n    assert_eq!(Err(Error::Empty(0)), f64::from_lexical_with_options::<FORMAT>(b\"\", &options));\n    assert_eq!(Ok(0.0), f64::from_lexical_with_options::<FORMAT>(b\"0.0\", &options));\n    assert_eq!(\n        Err((Error::InvalidDigit(1)).into()),\n        f64::from_lexical_with_options::<FORMAT>(b\"1a\", &options)\n    );\n\n    // Bug fix for Issue #8\n    assert_eq!(\n        Ok(5.002868148396374),\n        f64::from_lexical_with_options::<FORMAT>(b\"5.002868148396374\", &options)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/bigfloat_tests.rs::leading_zeros_test", "test": "fn leading_zeros_test() {\n    assert_eq!(Bigfloat::new().leading_zeros(), 0);\n\n    assert_eq!(Bigfloat::from_u32(0xFF).leading_zeros(), LIMB_BITS as u32 - 8);\n    assert_eq!(Bigfloat::from_u64(0xFF00000000).leading_zeros(), 24);\n\n    assert_eq!(Bigfloat::from_u32(0xF).leading_zeros(), LIMB_BITS as u32 - 4);\n    assert_eq!(Bigfloat::from_u64(0xF00000000).leading_zeros(), 28);\n\n    assert_eq!(Bigfloat::from_u32(0xF0).leading_zeros(), LIMB_BITS as u32 - 8);\n    assert_eq!(Bigfloat::from_u64(0xF000000000).leading_zeros(), 24);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/bigint_tests.rs::simple_test", "test": "fn simple_test() {\n    let x = Bigint::new();\n    assert_eq!(x.hi64(), (0, false));\n\n    let x = Bigint::from_u32(1);\n    assert_eq!(&*x.data, &[1]);\n\n    let mut x = Bigint::from_u64(1);\n    assert_eq!(&*x.data, &[1]);\n\n    x.pow(10, 10);\n    let expected = vec_from_u32(&[1410065408, 2]);\n    assert!(x.data == expected, \"failed\");\n    assert_eq!(x.bit_length(), 34);\n\n    let y = Bigint::from_u64(5);\n    x *= &y;\n    let expected = vec_from_u32(&[2755359744, 11]);\n    assert!(x.data == expected, \"failed\");\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/binary_tests.rs::computef32_test", "test": "fn computef32_test() {\n    // Halfway, round-down tests\n    assert_eq!(compute_float32::<BINARY>(0, 16777216, false), (151, 0));\n    assert_eq!(compute_float32::<BINARY>(0, 16777217, false), (151, 0));\n    assert_eq!(compute_float32::<BINARY>(0, 16777218, false), (151, 1));\n\n    assert_eq!(compute_float32::<BINARY>(0, 33554432, false), (152, 0));\n    assert_eq!(compute_float32::<BINARY>(0, 33554434, false), (152, 0));\n    assert_eq!(compute_float32::<BINARY>(0, 33554436, false), (152, 1));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/binary_tests.rs::halfway_round_down_test", "test": "fn halfway_round_down_test() {\n    // Halfway, round-down tests\n    assert_eq!(compute_float64::<BINARY>(0, 9007199254740992, false), (1076, 0));\n    assert_eq!(compute_float64::<BINARY>(0, 9007199254740993, false), (1076, 0));\n    assert_eq!(compute_float64::<BINARY>(0, 9007199254740994, false), (1076, 1));\n\n    assert_eq!(compute_float64::<BINARY>(0, 18014398509481984, false), (1077, 0));\n    assert_eq!(compute_float64::<BINARY>(0, 18014398509481986, false), (1077, 0));\n    assert_eq!(compute_float64::<BINARY>(0, 18014398509481988, false), (1077, 1));\n\n    assert_eq!(compute_float64::<BINARY>(0, 9223372036854775808, false), (1086, 0));\n    assert_eq!(compute_float64::<BINARY>(0, 9223372036854776832, false), (1086, 0));\n    assert_eq!(compute_float64::<BINARY>(0, 9223372036854777856, false), (1086, 1));\n\n    // Add a 0 but say we're truncated.\n    assert_eq!(compute_float64::<BINARY>(-10, 9223372036854775808, true), (1076, 0));\n    assert_eq!(\n        compute_float64::<BINARY>(-10, 9223372036854776832, true),\n        (-31703, 9223372036854776832)\n    );\n    assert_eq!(compute_float64::<BINARY>(-10, 9223372036854777856, true), (1076, 1));\n\n    // Check other bases.\n    assert_eq!(compute_float64::<BASE4>(-2, 144115188075855872, false), (1076, 0));\n    assert_eq!(compute_float64::<BASE4>(-2, 144115188075855888, false), (1076, 0));\n    assert_eq!(compute_float64::<BASE4>(-2, 144115188075855904, false), (1076, 1));\n\n    assert_eq!(compute_float64::<OCTAL>(-2, 576460752303423488, false), (1076, 0));\n    assert_eq!(compute_float64::<OCTAL>(-2, 576460752303423552, false), (1076, 0));\n    assert_eq!(compute_float64::<OCTAL>(-2, 576460752303423616, false), (1076, 1));\n\n    assert_eq!(compute_float64::<HEX>(-1, 144115188075855872, false), (1076, 0));\n    assert_eq!(compute_float64::<HEX>(-1, 144115188075855888, false), (1076, 0));\n    assert_eq!(compute_float64::<HEX>(-1, 144115188075855904, false), (1076, 1));\n\n    assert_eq!(compute_float64::<BASE32>(-1, 288230376151711744, false), (1076, 0));\n    assert_eq!(compute_float64::<BASE32>(-1, 288230376151711776, false), (1076, 0));\n    assert_eq!(compute_float64::<BASE32>(-1, 288230376151711808, false), (1076, 1));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/binary_tests.rs::test_halfway_round_up", "test": "fn test_halfway_round_up() {\n    // Halfway, round-up tests\n    assert_eq!(compute_float64::<BINARY>(0, 9007199254740994, false), (1076, 1));\n    assert_eq!(compute_float64::<BINARY>(0, 9007199254740995, false), (1076, 2));\n    assert_eq!(compute_float64::<BINARY>(0, 9007199254740996, false), (1076, 2));\n\n    assert_eq!(compute_float64::<BINARY>(0, 18014398509481988, false), (1077, 1));\n    assert_eq!(compute_float64::<BINARY>(0, 18014398509481990, false), (1077, 2));\n    assert_eq!(compute_float64::<BINARY>(0, 18014398509481992, false), (1077, 2));\n\n    assert_eq!(compute_float64::<BINARY>(0, 9223372036854777856, false), (1086, 1));\n    assert_eq!(compute_float64::<BINARY>(0, 9223372036854778880, false), (1086, 2));\n    assert_eq!(compute_float64::<BINARY>(0, 9223372036854779904, false), (1086, 2));\n\n    // Add a 0 but say we're truncated.\n    assert_eq!(compute_float64::<BINARY>(-10, 9223372036854777856, true), (1076, 1));\n    assert_eq!(compute_float64::<BINARY>(-10, 9223372036854778879, true), (1076, 1));\n    assert_eq!(compute_float64::<BINARY>(-10, 9223372036854778880, true), (1076, 2));\n    assert_eq!(compute_float64::<BINARY>(-10, 9223372036854779904, true), (1076, 2));\n\n    // Check other bases.\n    assert_eq!(compute_float64::<BASE4>(-2, 144115188075855904, false), (1076, 1));\n    assert_eq!(compute_float64::<BASE4>(-2, 144115188075855920, false), (1076, 2));\n    assert_eq!(compute_float64::<BASE4>(-2, 144115188075855936, false), (1076, 2));\n\n    assert_eq!(compute_float64::<OCTAL>(-2, 576460752303423616, false), (1076, 1));\n    assert_eq!(compute_float64::<OCTAL>(-2, 576460752303423680, false), (1076, 2));\n    assert_eq!(compute_float64::<OCTAL>(-2, 576460752303423744, false), (1076, 2));\n\n    assert_eq!(compute_float64::<HEX>(-1, 144115188075855904, false), (1076, 1));\n    assert_eq!(compute_float64::<HEX>(-1, 144115188075855920, false), (1076, 2));\n    assert_eq!(compute_float64::<HEX>(-1, 144115188075855936, false), (1076, 2));\n\n    assert_eq!(compute_float64::<BASE32>(-1, 288230376151711808, false), (1076, 1));\n    assert_eq!(compute_float64::<BASE32>(-1, 288230376151711840, false), (1076, 2));\n    assert_eq!(compute_float64::<BASE32>(-1, 288230376151711872, false), (1076, 2));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/binary_tests.rs::test_slow", "test": "fn test_slow() {\n    let i = b\"100000000000000000000000000000000000000000000000000001\";\n    let f = b\"0000000000000\";\n    assert_eq!(compute_float64_slow::<BINARY>(i, Some(f), -10), (1076, 0));\n\n    let i = b\"100000000000000000000000000000000000000000000000000001\";\n    let f = b\"000000000000000000001\";\n    assert_eq!(compute_float64_slow::<BINARY>(i, Some(f), -10), (1076, 1));\n\n    let i = b\"100000000000000000000000000000000000000000000000000001\";\n    let f = b\"000000000000010000000\";\n    assert_eq!(compute_float64_slow::<BINARY>(i, Some(f), -10), (1076, 1));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/float_tests.rs::exponent_fast_path_test", "test": "fn exponent_fast_path_test() {\n    assert_eq!(f32::min_exponent_fast_path(10), -10);\n    assert_eq!(f32::max_exponent_fast_path(10), 10);\n    assert_eq!(f32::max_exponent_disguised_fast_path(10), 17);\n\n    assert_eq!(f64::min_exponent_fast_path(10), -22);\n    assert_eq!(f64::max_exponent_fast_path(10), 22);\n    assert_eq!(f64::max_exponent_disguised_fast_path(10), 37);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::fabsf_sanity_test", "test": "fn fabsf_sanity_test() {\n    assert_eq!(libm::fabsf(-1.0), 1.0);\n    assert_eq!(libm::fabsf(2.8), 2.8);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::sqrtf_sanity_test", "test": "fn sqrtf_sanity_test() {\n    assert_eq!(libm::sqrtf(100.0), 10.0);\n    assert_eq!(libm::sqrtf(4.0), 2.0);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::normal_cases", "test": "fn normal_cases() {\n    assert_eq!(libm::powd(2.0, 20.0), (1 << 20) as f64);\n    assert_eq!(libm::powd(-1.0, 9.0), -1.0);\n    assert!(libm::powd(-1.0, 2.2).is_nan());\n    assert!(libm::powd(-1.0, -1.14).is_nan());\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::fabsd_sanity_test", "test": "fn fabsd_sanity_test() {\n    assert_eq!(libm::fabsd(-1.0), 1.0);\n    assert_eq!(libm::fabsd(2.8), 2.8);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::sqrtd_sanity_test", "test": "fn sqrtd_sanity_test() {\n    assert_eq!(libm::sqrtd(100.0), 10.0);\n    assert_eq!(libm::sqrtd(4.0), 2.0);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/limits_tests.rs::mantissa_limit_test", "test": "fn mantissa_limit_test() {\n    assert_eq!(f32::mantissa_limit(10), 7);\n    assert_eq!(f64::mantissa_limit(10), 15);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/limits_tests.rs::exponent_limit_test", "test": "fn exponent_limit_test() {\n    assert_eq!(f32::exponent_limit(10), (-10, 10));\n    assert_eq!(f64::exponent_limit(10), (-22, 22));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/limits_tests.rs::power_limit_test", "test": "fn power_limit_test() {\n    assert_eq!(limits::u32_power_limit(5), 13);\n    assert_eq!(limits::u32_power_limit(10), 9);\n    assert_eq!(limits::u64_power_limit(5), 27);\n    assert_eq!(limits::u64_power_limit(10), 19);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/limits_tests.rs::max_digit_test", "test": "fn max_digit_test() {\n    assert_eq!(f32::max_digits(10), Some(114));\n    assert_eq!(f64::max_digits(10), Some(769));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/mask_tests.rs::lower_n_mask_test", "test": "fn lower_n_mask_test() {\n    assert_eq!(mask::lower_n_mask(2), 0b11);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/mask_tests.rs::lower_n_halfway_test", "test": "fn lower_n_halfway_test() {\n    assert_eq!(mask::lower_n_halfway(2), 0b10);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/mask_tests.rs::nth_bit_test", "test": "fn nth_bit_test() {\n    assert_eq!(mask::nth_bit(2), 0b100);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/number_tests.rs::is_fast_path_test", "test": "fn is_fast_path_test() {\n    let mut number = Number {\n        exponent: -4,\n        mantissa: 12345,\n        is_negative: false,\n        many_digits: false,\n        integer: &[],\n        fraction: None,\n    };\n    assert_eq!(number.is_fast_path::<f32, { STANDARD }>(), true);\n    assert_eq!(number.is_fast_path::<f64, { STANDARD }>(), true);\n\n    number.exponent = -15;\n    assert_eq!(number.is_fast_path::<f32, { STANDARD }>(), false);\n    assert_eq!(number.is_fast_path::<f64, { STANDARD }>(), true);\n\n    number.exponent = -25;\n    assert_eq!(number.is_fast_path::<f32, { STANDARD }>(), false);\n    assert_eq!(number.is_fast_path::<f64, { STANDARD }>(), false);\n\n    number.exponent = 25;\n    assert_eq!(number.is_fast_path::<f32, { STANDARD }>(), false);\n    assert_eq!(number.is_fast_path::<f64, { STANDARD }>(), true);\n\n    number.exponent = 36;\n    assert_eq!(number.is_fast_path::<f32, { STANDARD }>(), false);\n    assert_eq!(number.is_fast_path::<f64, { STANDARD }>(), true);\n\n    number.exponent = 38;\n    assert_eq!(number.is_fast_path::<f32, { STANDARD }>(), false);\n    assert_eq!(number.is_fast_path::<f64, { STANDARD }>(), false);\n\n    number.mantissa = 1 << 25;\n    number.exponent = 0;\n    assert_eq!(number.is_fast_path::<f32, { STANDARD }>(), false);\n    assert_eq!(number.is_fast_path::<f64, { STANDARD }>(), true);\n\n    number.mantissa = 1 << 54;\n    assert_eq!(number.is_fast_path::<f32, { STANDARD }>(), false);\n    assert_eq!(number.is_fast_path::<f64, { STANDARD }>(), false);\n\n    number.mantissa = 1 << 52;\n    assert_eq!(number.is_fast_path::<f32, { STANDARD }>(), false);\n    assert_eq!(number.is_fast_path::<f64, { STANDARD }>(), true);\n\n    number.many_digits = true;\n    assert_eq!(number.is_fast_path::<f32, { STANDARD }>(), false);\n    assert_eq!(number.is_fast_path::<f64, { STANDARD }>(), false);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/number_tests.rs::try_fast_path_test", "test": "fn try_fast_path_test() {\n    let mut number = Number {\n        exponent: -4,\n        mantissa: 12345,\n        is_negative: false,\n        many_digits: false,\n        integer: &[],\n        fraction: None,\n    };\n    assert_eq!(number.try_fast_path::<f32, { STANDARD }>(), Some(1.2345));\n    assert_eq!(number.try_fast_path::<f64, { STANDARD }>(), Some(1.2345));\n\n    number.exponent = -10;\n    assert_eq!(number.try_fast_path::<f32, { STANDARD }>(), Some(1.2345e-6));\n    assert_eq!(number.try_fast_path::<f64, { STANDARD }>(), Some(1.2345e-6));\n\n    number.exponent = -20;\n    assert_eq!(number.try_fast_path::<f32, { STANDARD }>(), None);\n    assert_eq!(number.try_fast_path::<f64, { STANDARD }>(), Some(1.2345e-16));\n\n    number.exponent = -25;\n    assert_eq!(number.try_fast_path::<f32, { STANDARD }>(), None);\n    assert_eq!(number.try_fast_path::<f64, { STANDARD }>(), None);\n\n    number.exponent = 12;\n    assert_eq!(number.try_fast_path::<f32, { STANDARD }>(), Some(1.2345e16));\n    assert_eq!(number.try_fast_path::<f64, { STANDARD }>(), Some(1.2345e16));\n\n    number.exponent = 25;\n    assert_eq!(number.try_fast_path::<f32, { STANDARD }>(), None);\n    assert_eq!(number.try_fast_path::<f64, { STANDARD }>(), Some(1.2345e29));\n\n    number.exponent = 32;\n    assert_eq!(number.try_fast_path::<f32, { STANDARD }>(), None);\n    assert_eq!(number.try_fast_path::<f64, { STANDARD }>(), Some(1.2345e36));\n\n    number.exponent = 36;\n    assert_eq!(number.try_fast_path::<f32, { STANDARD }>(), None);\n    assert_eq!(number.try_fast_path::<f64, { STANDARD }>(), None);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/parse_tests.rs::parse_complete_test", "test": "fn parse_complete_test() {\n    const FORMAT: u128 = STANDARD;\n    let options = Options::new();\n    let string = b\"1.2345e10\";\n    let result = parse::parse_complete::<f64, FORMAT>(string, &options);\n    assert_eq!(result, Ok(1.2345e10));\n\n    let string = b\"1.2345e\";\n    let result = parse::parse_complete::<f64, FORMAT>(string, &options);\n    assert!(result.is_err());\n\n    let string = b\"1.2345 \";\n    let result = parse::parse_complete::<f64, FORMAT>(string, &options);\n    assert!(result.is_err());\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/parse_tests.rs::fast_path_complete_test", "test": "fn fast_path_complete_test() {\n    const FORMAT: u128 = STANDARD;\n    let options = Options::new();\n    let string = b\"1.2345e10\";\n    let result = parse::fast_path_complete::<f64, FORMAT>(string, &options);\n    assert_eq!(result, Ok(1.2345e10));\n\n    let string = b\"1.2345e\";\n    let result = parse::fast_path_complete::<f64, FORMAT>(string, &options);\n    assert!(result.is_err());\n\n    let string = b\"1.2345 \";\n    let result = parse::fast_path_complete::<f64, FORMAT>(string, &options);\n    assert!(result.is_err());\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/parse_tests.rs::parse_partial_test", "test": "fn parse_partial_test() {\n    const FORMAT: u128 = STANDARD;\n    let options = Options::new();\n    let string = b\"1.2345e10\";\n    let result = parse::parse_partial::<f64, FORMAT>(string, &options);\n    assert_eq!(result, Ok((1.2345e10, 9)));\n\n    let string = b\"1.2345e\";\n    let result = parse::parse_partial::<f64, FORMAT>(string, &options);\n    assert!(result.is_err());\n\n    let string = b\"1.2345 \";\n    let result = parse::parse_partial::<f64, FORMAT>(string, &options);\n    assert_eq!(result, Ok((1.2345, 6)));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/parse_tests.rs::fast_path_partial_test", "test": "fn fast_path_partial_test() {\n    const FORMAT: u128 = STANDARD;\n    let options = Options::new();\n    let string = b\"1.2345e10\";\n    let result = parse::fast_path_partial::<f64, FORMAT>(string, &options);\n    assert_eq!(result, Ok((1.2345e10, 9)));\n\n    let string = b\"1.2345e\";\n    let result = parse::fast_path_partial::<f64, FORMAT>(string, &options);\n    assert!(result.is_err());\n\n    let string = b\"1.2345 \";\n    let result = parse::fast_path_partial::<f64, FORMAT>(string, &options);\n    assert_eq!(result, Ok((1.2345, 6)));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/parse_tests.rs::parse_number_test", "test": "fn parse_number_test() {\n    const FORMAT: u128 = STANDARD;\n    let options = Options::new();\n    let string = b\"1.2345e10\";\n    let byte = string.bytes::<{ FORMAT }>();\n    let result = parse::parse_number(byte, false, &options);\n    assert!(result.is_ok());\n    let num = result.unwrap();\n    assert_eq!(num.mantissa, 12345);\n    assert_eq!(num.exponent, 6);\n    assert_eq!(num.many_digits, false);\n\n    let string = b\"1.2345e\";\n    let byte = string.bytes::<{ FORMAT }>();\n    let result = parse::parse_number(byte, false, &options);\n    assert!(result.is_err());\n\n    let string = b\"1.2345 \";\n    let byte = string.bytes::<{ FORMAT }>();\n    let result = parse::parse_number(byte, false, &options);\n    assert!(result.is_err());\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/parse_tests.rs::parse_partial_number_test", "test": "fn parse_partial_number_test() {\n    const FORMAT: u128 = STANDARD;\n    let options = Options::new();\n    let string = b\"1.2345e10\";\n    let byte = string.bytes::<{ FORMAT }>();\n    let result = parse::parse_partial_number(byte, false, &options);\n    assert!(result.is_ok());\n    let (num, count) = result.unwrap();\n    assert_eq!(num.mantissa, 12345);\n    assert_eq!(num.exponent, 6);\n    assert_eq!(num.many_digits, false);\n    assert_eq!(count, 9);\n\n    let string = b\"1.2345e\";\n    let byte = string.bytes::<{ FORMAT }>();\n    let result = parse::parse_partial_number(byte, false, &options);\n    assert!(result.is_err());\n\n    let string = b\"1.2345 \";\n    let byte = string.bytes::<{ FORMAT }>();\n    let result = parse::parse_partial_number(byte, false, &options);\n    assert!(result.is_ok());\n    let (num, count) = result.unwrap();\n    assert_eq!(num.mantissa, 12345);\n    assert_eq!(num.exponent, -4);\n    assert_eq!(num.many_digits, false);\n    assert_eq!(count, 6);\n\n    // Leading zeros\n    let string = b\"00000000000000000000001.2345 \";\n    let byte = string.bytes::<{ FORMAT }>();\n    let result = parse::parse_partial_number(byte, false, &options);\n    assert!(result.is_ok());\n    let (num, count) = result.unwrap();\n    assert_eq!(num.mantissa, 12345);\n    assert_eq!(num.exponent, -4);\n    assert_eq!(num.many_digits, false);\n    assert_eq!(count, 28);\n\n    // Leading zeros\n    let string = b\"0.00000000000000000000012345 \";\n    let byte = string.bytes::<{ FORMAT }>();\n    let result = parse::parse_partial_number(byte, false, &options);\n    assert!(result.is_ok());\n    let (num, count) = result.unwrap();\n    assert_eq!(num.mantissa, 12345);\n    assert_eq!(num.exponent, -26);\n    assert_eq!(num.many_digits, false);\n    assert_eq!(count, 28);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/parse_tests.rs::is_special_eq_test", "test": "fn is_special_eq_test() {\n    const FORMAT: u128 = STANDARD;\n\n    let digits = b\"NaN\";\n    let byte = digits.bytes::<{ FORMAT }>();\n    assert_eq!(parse::is_special_eq::<FORMAT>(byte.clone(), b\"nan\"), 3);\n\n    let byte = digits.bytes::<{ FORMAT }>();\n    assert_eq!(parse::is_special_eq::<FORMAT>(byte.clone(), b\"NaN\"), 3);\n\n    let byte = digits.bytes::<{ FORMAT }>();\n    assert_eq!(parse::is_special_eq::<FORMAT>(byte.clone(), b\"inf\"), 0);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/parse_tests.rs::parse_parse_special_test", "test": "fn parse_parse_special_test() {\n    const FORMAT: u128 = STANDARD;\n\n    let options = Options::new();\n    let digits = b\"NaN\";\n    let byte = digits.bytes::<{ FORMAT }>();\n    let result = parse::parse_special::<f64, FORMAT>(byte, true, &options).unwrap();\n    assert!(f64::is_nan(result));\n    assert!(f64::is_sign_negative(result));\n\n    let digits = b\"NaN1\";\n    let byte = digits.bytes::<{ FORMAT }>();\n    let result = parse::parse_special::<f64, FORMAT>(byte, true, &options);\n    assert_eq!(result, None);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/shared_tests.rs::calculate_shift_test", "test": "fn calculate_shift_test() {\n    assert_eq!(shared::calculate_shift::<f64>(-63), 64);\n    assert_eq!(shared::calculate_shift::<f64>(-15), 16);\n    assert_eq!(shared::calculate_shift::<f64>(-8), 11);\n    assert_eq!(shared::calculate_shift::<f64>(0), 11);\n    assert_eq!(shared::calculate_shift::<f64>(50), 11);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/shared_tests.rs::log2_test", "test": "fn log2_test() {\n    assert_eq!(shared::log2(2), 1);\n    assert_eq!(shared::log2(4), 2);\n    assert_eq!(shared::log2(10), 1);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/shared_tests.rs::starts_with_test", "test": "fn starts_with_test() {\n    assert_eq!(shared::starts_with(b\"NaN\".iter(), b\"nAN\".iter()), false);\n    assert_eq!(shared::starts_with(b\"nAN\".iter(), b\"nAN\".iter()), true);\n    assert_eq!(shared::starts_with(b\"nAN1\".iter(), b\"nAN\".iter()), true);\n    assert_eq!(shared::starts_with(b\"nAN1\".iter(), b\"nAN12\".iter()), false);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/shared_tests.rs::case_insensitive_starts_with_test", "test": "fn case_insensitive_starts_with_test() {\n    assert_eq!(shared::case_insensitive_starts_with(b\"NaN\".iter(), b\"nAN\".iter()), true);\n    assert_eq!(shared::case_insensitive_starts_with(b\"nAN\".iter(), b\"nAN\".iter()), true);\n    assert_eq!(shared::case_insensitive_starts_with(b\"nAN1\".iter(), b\"nAN\".iter()), true);\n    assert_eq!(shared::case_insensitive_starts_with(b\"nAN1\".iter(), b\"nAN12\".iter()), false);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/slow_tests.rs::scientific_exponent_test", "test": "fn scientific_exponent_test() {\n    let mut number = Number {\n        exponent: -4,\n        mantissa: 12345,\n        is_negative: false,\n        many_digits: false,\n        integer: &[],\n        fraction: None,\n    };\n    assert_eq!(slow::scientific_exponent::<{ STANDARD }>(&number), 0);\n\n    number.exponent = -15;\n    assert_eq!(slow::scientific_exponent::<{ STANDARD }>(&number), -11);\n\n    number.mantissa = 1234567890123456;\n    assert_eq!(slow::scientific_exponent::<{ STANDARD }>(&number), 0);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::bounds_test", "test": "fn bounds_test() {\n    type ShortVec = StackVec<2>;\n    let mut x = ShortVec::from_u32(1);\n    assert_eq!(x.try_push(2), Some(()));\n    assert_eq!(x.try_push(5), None);\n\n    assert_eq!(x.try_resize(0, 0), Some(()));\n    assert_eq!(x.try_resize(3, 0), None);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::hi32_test", "test": "fn hi32_test() {\n    assert_eq!(VecType::from_u16(0xA).hi32(), (0xA0000000, false));\n    assert_eq!(VecType::from_u32(0xAB).hi32(), (0xAB000000, false));\n    assert_eq!(VecType::from_u64(0xAB00000000).hi32(), (0xAB000000, false));\n    assert_eq!(VecType::from_u64(0xA23456789A).hi32(), (0xA2345678, true));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::hi64_test", "test": "fn hi64_test() {\n    assert_eq!(VecType::from_u16(0xA).hi64(), (0xA000000000000000, false));\n    assert_eq!(VecType::from_u32(0xAB).hi64(), (0xAB00000000000000, false));\n    assert_eq!(VecType::from_u64(0xAB00000000).hi64(), (0xAB00000000000000, false));\n    assert_eq!(VecType::from_u64(0xA23456789A).hi64(), (0xA23456789A000000, false));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::math_test", "test": "fn math_test() {\n    let mut x = VecType::try_from(&[0, 1, 9]).unwrap();\n    assert_eq!(x.is_normalized(), true);\n    x.try_push(0).unwrap();\n    assert_eq!(&*x, &[0, 1, 9, 0]);\n    assert_eq!(x.is_normalized(), false);\n    x.normalize();\n    assert_eq!(&*x, &[0, 1, 9]);\n    assert_eq!(x.is_normalized(), true);\n\n    x.add_small(1);\n    assert_eq!(&*x, &[1, 1, 9]);\n    x.add_small(Limb::MAX);\n    assert_eq!(&*x, &[0, 2, 9]);\n\n    x.mul_small(3);\n    assert_eq!(&*x, &[0, 6, 27]);\n    x.mul_small(Limb::MAX);\n    let expected: VecType = if LIMB_BITS == 32 {\n        vec_from_u32(&[0, 4294967290, 4294967274, 26])\n    } else {\n        vec_from_u32(&[0, 0, 4294967290, 4294967295, 4294967274, 4294967295, 26])\n    };\n    assert_eq!(&*x, &*expected);\n\n    #[cfg(feature = \"radix\")]\n    {\n        let mut x: VecType = vec_from_u32(&[0, 0, 0, 536870912]);\n        let y: VecType = vec_from_u32(&[3358091099, 2770363594, 2782716766, 217327764]);\n        assert_eq!(x.quorem(&y), 2);\n        let expected: VecType = vec_from_u32(&[1873752394, 3049207402, 3024501058, 102215382]);\n        assert_eq!(&*x, &*expected);\n    }\n\n    let mut x = VecType::from_u32(0xFFFFFFFF);\n    let y = VecType::from_u32(5);\n    x *= &y;\n    let expected: VecType = vec_from_u32(&[0xFFFFFFFB, 0x4]);\n    assert_eq!(&*x, &*expected);\n\n    // Test with carry\n    let mut x = VecType::from_u32(1);\n    assert_eq!(&*x, &[1]);\n    x.add_small(Limb::MAX);\n    assert_eq!(&*x, &[0, 1]);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::hi_test", "test": "fn hi_test() {\n    assert_eq!(unsafe { bigint::nonzero(&[0, 0, 0], 0) }, false);\n    assert_eq!(unsafe { bigint::nonzero(&[1, 0, 0], 0) }, true);\n\n    assert_eq!(bigint::u32_to_hi16_1(1), (0x8000, false));\n    assert_eq!(bigint::u32_to_hi16_2(1, 4), (0x8000, true));\n    assert_eq!(bigint::u32_to_hi32_1(1), (0x80000000, false));\n    assert_eq!(bigint::u32_to_hi32_2(1, 4), (0x80000002, false));\n    assert_eq!(bigint::u32_to_hi64_1(1), (0x8000000000000000, false));\n    assert_eq!(bigint::u32_to_hi64_2(1, 4), (0x8000000200000000, false));\n    assert_eq!(bigint::u32_to_hi64_2(1, 5), (0x8000000280000000, false));\n    assert_eq!(bigint::u32_to_hi64_3(1, 5, 4), (0x8000000280000002, false));\n    assert_eq!(bigint::u32_to_hi64_3(1, 5, 5), (0x8000000280000002, true));\n\n    assert_eq!(bigint::u64_to_hi16_1(1), (0x8000, false));\n    assert_eq!(bigint::u64_to_hi16_2(1, 4), (0x8000, true));\n    assert_eq!(bigint::u64_to_hi32_1(1), (0x80000000, false));\n    assert_eq!(bigint::u64_to_hi32_2(1, 4), (0x80000000, true));\n    assert_eq!(bigint::u64_to_hi64_1(1), (0x8000000000000000, false));\n    assert_eq!(bigint::u64_to_hi64_2(1, 4), (0x8000000000000002, false));\n    assert_eq!(bigint::u64_to_hi64_2(1, 5), (0x8000000000000002, true));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::scalar_add_test", "test": "fn scalar_add_test() {\n    assert_eq!(bigint::scalar_add(5, 5), (10, false));\n    assert_eq!(bigint::scalar_add(Limb::MAX, 1), (0, true));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::scalar_mul_test", "test": "fn scalar_mul_test() {\n    assert_eq!(bigint::scalar_mul(5, 5, 0), (25, 0));\n    assert_eq!(bigint::scalar_mul(5, 5, 1), (26, 0));\n    assert_eq!(bigint::scalar_mul(Limb::MAX, 2, 0), (Limb::MAX - 1, 1));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::bit_length_test", "test": "fn bit_length_test() {\n    let x: VecType = vec_from_u32(&[0, 0, 0, 1]);\n    assert_eq!(bigint::bit_length(&x), 97);\n\n    let x: VecType = vec_from_u32(&[0, 0, 0, 3]);\n    assert_eq!(bigint::bit_length(&x), 98);\n\n    let x = VecType::from_u32(1 << 31);\n    assert_eq!(bigint::bit_length(&x), 32);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::split_radix_test", "test": "fn split_radix_test() {\n    assert_eq!(bigint::split_radix(10), (5, 1));\n    if cfg!(feature = \"radix\") {\n        assert_eq!(bigint::split_radix(2), (0, 1));\n        assert_eq!(bigint::split_radix(4), (0, 2));\n        assert_eq!(bigint::split_radix(8), (0, 3));\n        assert_eq!(bigint::split_radix(16), (0, 4));\n        assert_eq!(bigint::split_radix(32), (0, 5));\n        assert_eq!(bigint::split_radix(14), (7, 1));\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/algorithm_tests.rs::test_is_4digits", "test": "fn test_is_4digits() {\n    let value: u32 = 0x31_32_33_34;\n    #[cfg(feature = \"power-of-two\")]\n    assert!(!algorithm::is_4digits::<{ from_radix(4) }>(value));\n    #[cfg(feature = \"radix\")]\n    assert!(algorithm::is_4digits::<{ from_radix(5) }>(value));\n    assert!(algorithm::is_4digits::<{ STANDARD }>(value));\n\n    let value: u32 = 0x29_30_39_38;\n    assert!(!algorithm::is_4digits::<{ STANDARD }>(value));\n\n    let value: u32 = 0x31_32_33_40;\n    assert!(!algorithm::is_4digits::<{ STANDARD }>(value));\n\n    let value: u32 = 0x31_32_33_39;\n    #[cfg(feature = \"radix\")]\n    assert!(!algorithm::is_4digits::<{ from_radix(9) }>(value));\n    assert!(algorithm::is_4digits::<{ STANDARD }>(value));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/algorithm_tests.rs::test_parse_4digits", "test": "fn test_parse_4digits() {\n    assert_eq!(algorithm::parse_4digits::<{ STANDARD }>(0x31_32_33_34), 4321);\n    #[cfg(feature = \"radix\")]\n    assert_eq!(algorithm::parse_4digits::<{ from_radix(5) }>(0x31_32_33_34), 586);\n    assert_eq!(algorithm::parse_4digits::<{ STANDARD }>(0x36_37_38_39), 9876);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/algorithm_tests.rs::test_is_8digits", "test": "fn test_is_8digits() {\n    let value: u64 = 0x31_32_33_34_35_36_37_38;\n    #[cfg(feature = \"power-of-two\")]\n    assert!(!algorithm::is_8digits::<{ from_radix(4) }>(value));\n    #[cfg(feature = \"radix\")]\n    assert!(!algorithm::is_8digits::<{ from_radix(5) }>(value));\n    assert!(algorithm::is_8digits::<{ STANDARD }>(value));\n\n    let value: u64 = 0x29_30_31_32_33_34_35_36;\n    assert!(!algorithm::is_8digits::<{ STANDARD }>(value));\n\n    let value: u64 = 0x30_31_32_33_34_35_36_40;\n    assert!(!algorithm::is_8digits::<{ STANDARD }>(value));\n\n    let value: u64 = 0x31_32_33_34_35_36_37_39;\n    #[cfg(feature = \"radix\")]\n    assert!(!algorithm::is_8digits::<{ from_radix(9) }>(value));\n    assert!(algorithm::is_8digits::<{ STANDARD }>(value));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/algorithm_tests.rs::test_parse_8digits", "test": "fn test_parse_8digits() {\n    // 10000000\n    let value: u64 = 0x30_30_30_30_30_30_30_31;\n    assert_eq!(algorithm::parse_8digits::<{ STANDARD }>(value), 10000000);\n    #[cfg(feature = \"radix\")]\n    assert_eq!(algorithm::parse_8digits::<{ from_radix(5) }>(value), 78125);\n\n    // 00000010\n    let value: u64 = 0x30_31_30_30_30_30_30_30;\n    assert_eq!(algorithm::parse_8digits::<{ STANDARD }>(value), 10);\n    #[cfg(feature = \"radix\")]\n    assert_eq!(algorithm::parse_8digits::<{ from_radix(5) }>(value), 5);\n\n    // 12344321\n    let value: u64 = 0x31_32_33_34_34_33_32_31;\n    assert_eq!(algorithm::parse_8digits::<{ STANDARD }>(value), 12344321);\n    #[cfg(feature = \"power-of-two\")]\n    assert_eq!(algorithm::parse_8digits::<{ from_radix(8) }>(value), 2738385);\n\n    #[cfg(feature = \"radix\")]\n    {\n        assert_eq!(algorithm::parse_8digits::<{ from_radix(9) }>(value), 6052420);\n        assert_eq!(algorithm::parse_8digits::<{ from_radix(7) }>(value), 1120400);\n        assert_eq!(algorithm::parse_8digits::<{ from_radix(6) }>(value), 402745);\n        assert_eq!(algorithm::parse_8digits::<{ from_radix(5) }>(value), 121836);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/algorithm_tests.rs::algorithm_test", "test": "fn algorithm_test() {\n    let parse_u32 = |bytes: &[u8]| algorithm::algorithm_partial::<u32, u32, STANDARD>(bytes);\n    let parse_i32 = |bytes: &[u8]| algorithm::algorithm_partial::<i32, u32, STANDARD>(bytes);\n\n    assert_eq!(parse_u32(b\"12345\"), Ok((12345, 5)));\n    assert_eq!(parse_u32(b\"+12345\"), Ok((12345, 6)));\n    assert_eq!(parse_u32(b\"-12345\"), Ok((0, 0)));\n    assert_eq!(parse_i32(b\"12345\"), Ok((12345, 5)));\n    assert_eq!(parse_i32(b\"-12345\"), Ok((-12345, 6)));\n    assert_eq!(parse_i32(b\"+12345\"), Ok((12345, 6)));\n    assert_eq!(parse_i32(b\"+123.45\"), Ok((123, 4)));\n\n    // Need to try with other radixes here, especially to ensure no regressions with #71.\n    // Issue: https://github.com/Alexhuszagh/rust-lexical/issues/71\n    #[cfg(feature = \"power-of-two\")]\n    {\n        // This should try to invoke `parse_4digits` since it's more than\n        // 4 digits, and unsigned.\n        assert_eq!(parse_radix!(4)(b\"12345\"), Ok((27, 3)));\n        assert_eq!(parse_radix!(8)(b\"12345\"), Ok((5349, 5)));\n        assert_eq!(parse_radix!(16)(b\"12345\"), Ok((74565, 5)));\n        assert_eq!(parse_radix!(32)(b\"12345\"), Ok((1117317, 5)));\n    }\n\n    #[cfg(feature = \"radix\")]\n    {\n        assert_eq!(parse_radix!(6)(b\"12345\"), Ok((1865, 5)));\n        assert_eq!(parse_radix!(12)(b\"12345\"), Ok((24677, 5)));\n        assert_eq!(parse_radix!(24)(b\"12345\"), Ok((361253, 5)));\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/algorithm_tests.rs::algorithm_128_test", "test": "fn algorithm_128_test() {\n    let parse_u128 = |bytes: &[u8]| algorithm::algorithm_partial::<u128, u128, STANDARD>(bytes);\n    let parse_i128 = |bytes: &[u8]| algorithm::algorithm_partial::<i128, u128, STANDARD>(bytes);\n\n    assert_eq!(parse_u128(b\"12345\"), Ok((12345, 5)));\n    assert_eq!(parse_u128(b\"+12345\"), Ok((12345, 6)));\n    assert_eq!(parse_u128(b\"-12345\"), Ok((0, 0)));\n    assert_eq!(parse_i128(b\"12345\"), Ok((12345, 5)));\n    assert_eq!(parse_i128(b\"-12345\"), Ok((-12345, 6)));\n    assert_eq!(parse_i128(b\"+12345\"), Ok((12345, 6)));\n    assert_eq!(parse_i128(b\"+123.45\"), Ok((123, 4)));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/api_tests.rs::u8_decimal_test", "test": "fn u8_decimal_test() {\n    assert_eq!(Ok(0), u8::from_lexical(b\"0\"));\n    assert_eq!(Ok(127), u8::from_lexical(b\"127\"));\n    assert_eq!(Ok(128), u8::from_lexical(b\"128\"));\n    assert_eq!(Ok(255), u8::from_lexical(b\"255\"));\n    assert_eq!(Err(Error::InvalidDigit(0)), u8::from_lexical(b\"-1\"));\n    assert_eq!(Err(Error::InvalidDigit(1)), u8::from_lexical(b\"1a\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/api_tests.rs::i8_decimal_test", "test": "fn i8_decimal_test() {\n    assert_eq!(Ok(0), i8::from_lexical(b\"0\"));\n    assert_eq!(Ok(127), i8::from_lexical(b\"127\"));\n    assert_eq!(Err(Error::Overflow(2)), i8::from_lexical(b\"128\"));\n    assert_eq!(Err(Error::Overflow(2)), i8::from_lexical(b\"255\"));\n    assert_eq!(Ok(-1), i8::from_lexical(b\"-1\"));\n    assert_eq!(Err(Error::InvalidDigit(1)), i8::from_lexical(b\"1a\"));\n\n    assert_eq!(Ok((1, 1)), i8::from_lexical_partial(b\"1\"));\n    assert_eq!(Ok((1, 1)), i8::from_lexical_partial(b\"1a\"));\n    assert_eq!(Ok((-1, 2)), i8::from_lexical_partial(b\"-1\"));\n    assert_eq!(Ok((-1, 2)), i8::from_lexical_partial(b\"-1a\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/api_tests.rs::u16_decimal_test", "test": "fn u16_decimal_test() {\n    assert_eq!(Ok(0), u16::from_lexical(b\"0\"));\n    assert_eq!(Ok(32767), u16::from_lexical(b\"32767\"));\n    assert_eq!(Ok(32768), u16::from_lexical(b\"32768\"));\n    assert_eq!(Ok(65535), u16::from_lexical(b\"65535\"));\n    assert_eq!(Err(Error::InvalidDigit(0)), u16::from_lexical(b\"-1\"));\n    assert_eq!(Err(Error::InvalidDigit(1)), u16::from_lexical(b\"1a\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/api_tests.rs::i16_decimal_test", "test": "fn i16_decimal_test() {\n    assert_eq!(Ok(0), i16::from_lexical(b\"0\"));\n    assert_eq!(Ok(32767), i16::from_lexical(b\"32767\"));\n    assert_eq!(Err(Error::Overflow(4)), i16::from_lexical(b\"32768\"));\n    assert_eq!(Err(Error::Overflow(4)), i16::from_lexical(b\"65535\"));\n    assert_eq!(Ok(-1), i16::from_lexical(b\"-1\"));\n    assert_eq!(Err(Error::InvalidDigit(1)), i16::from_lexical(b\"1a\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/api_tests.rs::u32_decimal_test", "test": "fn u32_decimal_test() {\n    assert_eq!(Ok(0), u32::from_lexical(b\"0\"));\n    assert_eq!(Ok(2147483647), u32::from_lexical(b\"2147483647\"));\n    assert_eq!(Ok(2147483648), u32::from_lexical(b\"2147483648\"));\n    assert_eq!(Ok(4294967295), u32::from_lexical(b\"4294967295\"));\n    assert_eq!(Err(Error::InvalidDigit(0)), u32::from_lexical(b\"-1\"));\n    assert_eq!(Err(Error::InvalidDigit(1)), u32::from_lexical(b\"1a\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/api_tests.rs::i32_decimal_test", "test": "fn i32_decimal_test() {\n    assert_eq!(Ok(0), i32::from_lexical(b\"0\"));\n    assert_eq!(Ok(2147483647), i32::from_lexical(b\"2147483647\"));\n    assert_eq!(Err(Error::Overflow(9)), i32::from_lexical(b\"2147483648\"));\n    assert_eq!(Err(Error::Overflow(9)), i32::from_lexical(b\"4294967295\"));\n    assert_eq!(Ok(-1), i32::from_lexical(b\"-1\"));\n    assert_eq!(Err(Error::InvalidDigit(1)), i32::from_lexical(b\"1a\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/api_tests.rs::u64_decimal_test", "test": "fn u64_decimal_test() {\n    assert_eq!(Ok(0), u64::from_lexical(b\"0\"));\n    assert_eq!(Ok(9223372036854775807), u64::from_lexical(b\"9223372036854775807\"));\n    assert_eq!(Ok(9223372036854775808), u64::from_lexical(b\"9223372036854775808\"));\n    assert_eq!(Ok(18446744073709551615), u64::from_lexical(b\"18446744073709551615\"));\n    assert_eq!(Err(Error::InvalidDigit(0)), u64::from_lexical(b\"-1\"));\n    assert_eq!(Err(Error::InvalidDigit(1)), u64::from_lexical(b\"1a\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/api_tests.rs::i64_decimal_test", "test": "fn i64_decimal_test() {\n    assert_eq!(Ok(0), i64::from_lexical(b\"0\"));\n    assert_eq!(Ok(9223372036854775807), i64::from_lexical(b\"9223372036854775807\"));\n    assert_eq!(Err(Error::Overflow(18)), i64::from_lexical(b\"9223372036854775808\"));\n    assert_eq!(Err(Error::Overflow(19)), i64::from_lexical(b\"18446744073709551615\"));\n    assert_eq!(Ok(-1), i64::from_lexical(b\"-1\"));\n    assert_eq!(Err(Error::InvalidDigit(1)), i64::from_lexical(b\"1a\"));\n\n    // Add tests discovered via fuzzing. This won't necessarily be the\n    // proper index, since we use multi-digit parsing.\n    assert!(i64::from_lexical(b\"406260572150672006000066000000060060007667760000000000000000000+00000006766767766666767665670000000000000000000000666\").err().unwrap().is_invalid_digit());\n    assert!(i64::from_lexical(b\"406260572150672006000066000000060060007667760000000000000000000\")\n        .err()\n        .unwrap()\n        .is_overflow());\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/api_tests.rs::u128_decimal_test", "test": "fn u128_decimal_test() {\n    assert_eq!(Ok(0), u128::from_lexical(b\"0\"));\n    assert_eq!(\n        Ok(170141183460469231731687303715884105727),\n        u128::from_lexical(b\"170141183460469231731687303715884105727\")\n    );\n    assert_eq!(\n        Ok(170141183460469231731687303715884105728),\n        u128::from_lexical(b\"170141183460469231731687303715884105728\")\n    );\n    assert_eq!(\n        Ok(340282366920938463463374607431768211455),\n        u128::from_lexical(b\"340282366920938463463374607431768211455\")\n    );\n    assert_eq!(Err(Error::InvalidDigit(0)), u128::from_lexical(b\"-1\"));\n    assert_eq!(Err(Error::InvalidDigit(1)), u128::from_lexical(b\"1a\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/api_tests.rs::i128_decimal_test", "test": "fn i128_decimal_test() {\n    assert_eq!(Ok(0), i128::from_lexical(b\"0\"));\n    assert_eq!(\n        Ok(170141183460469231731687303715884105727),\n        i128::from_lexical(b\"170141183460469231731687303715884105727\")\n    );\n    assert_eq!(\n        Err(Error::Overflow(38)),\n        i128::from_lexical(b\"170141183460469231731687303715884105728\")\n    );\n    assert_eq!(\n        Err(Error::Overflow(38)),\n        i128::from_lexical(b\"340282366920938463463374607431768211455\")\n    );\n    assert_eq!(Ok(-1), i128::from_lexical(b\"-1\"));\n    assert_eq!(Err(Error::InvalidDigit(1)), i128::from_lexical(b\"1a\"));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/api_tests.rs::options_test", "test": "fn options_test() {\n    let options = Options::new();\n    assert_eq!(Ok(0), i128::from_lexical_with_options::<STANDARD>(b\"0\", &options));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/compact_tests.rs::algorithm_test", "test": "fn algorithm_test() {\n    let parse_u32 = |digits: &[u8]| compact::algorithm_partial::<u32, u32, STANDARD>(digits);\n    let parse_i32 = |digits: &[u8]| compact::algorithm_partial::<i32, u32, STANDARD>(digits);\n\n    assert_eq!(parse_u32(b\"12345\"), Ok((12345, 5)));\n    assert_eq!(parse_u32(b\"+12345\"), Ok((12345, 6)));\n    // This just parses 0 digits, since it's an unsigned type.\n    assert_eq!(parse_u32(b\"-12345\"), Ok((0, 0)));\n    assert_eq!(parse_i32(b\"12345\"), Ok((12345, 5)));\n    assert_eq!(parse_i32(b\"-12345\"), Ok((-12345, 6)));\n    assert_eq!(parse_i32(b\"+12345\"), Ok((12345, 6)));\n    assert_eq!(parse_i32(b\"+123.45\"), Ok((123, 4)));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/partial_tests.rs::u8_decimal_test", "test": "fn u8_decimal_test() {\n    assert_eq!(Ok((0, 1)), u8::from_lexical_partial(b\"0\"));\n    assert_eq!(Ok((127, 3)), u8::from_lexical_partial(b\"127\"));\n    assert_eq!(Ok((128, 3)), u8::from_lexical_partial(b\"128\"));\n    assert_eq!(Ok((255, 3)), u8::from_lexical_partial(b\"255\"));\n    assert_eq!(Err(Error::InvalidDigit(0)), u8::from_lexical(b\"-1\"));\n    assert_eq!(Ok((1, 1)), u8::from_lexical_partial(b\"1a\"));\n\n    let options = Options::default();\n    assert_eq!(Ok((0, 1)), u8::from_lexical_partial_with_options::<{ STANDARD }>(b\"0\", &options));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/ascii_tests.rs::is_valid_ascii_test", "test": "fn is_valid_ascii_test() {\n    assert_eq!(ascii::is_valid_ascii(b'\\x00'), false);\n    assert_eq!(ascii::is_valid_ascii(b'\\n'), true);\n    assert_eq!(ascii::is_valid_ascii(b'\\r'), true);\n    assert_eq!(ascii::is_valid_ascii(b'\\x1b'), false);\n    assert_eq!(ascii::is_valid_ascii(b' '), true);\n    assert_eq!(ascii::is_valid_ascii(b'0'), true);\n    assert_eq!(ascii::is_valid_ascii(b'9'), true);\n    assert_eq!(ascii::is_valid_ascii(b':'), true);\n    assert_eq!(ascii::is_valid_ascii(b'A'), true);\n    assert_eq!(ascii::is_valid_ascii(b'Z'), true);\n    assert_eq!(ascii::is_valid_ascii(b']'), true);\n    assert_eq!(ascii::is_valid_ascii(b'a'), true);\n    assert_eq!(ascii::is_valid_ascii(b'z'), true);\n    assert_eq!(ascii::is_valid_ascii(b'~'), true);\n    assert_eq!(ascii::is_valid_ascii(b'\\x7f'), false);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/ascii_tests.rs::is_valid_ascii_slice_test", "test": "fn is_valid_ascii_slice_test() {\n    assert_eq!(ascii::is_valid_ascii_slice(b\" 09a\"), true);\n    assert_eq!(ascii::is_valid_ascii_slice(b\" 09a\\x1b\"), false);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/ascii_tests.rs::is_valid_letter_test", "test": "fn is_valid_letter_test() {\n    assert_eq!(ascii::is_valid_letter(b'\\x00'), false);\n    assert_eq!(ascii::is_valid_letter(b'\\n'), false);\n    assert_eq!(ascii::is_valid_letter(b'\\r'), false);\n    assert_eq!(ascii::is_valid_letter(b'\\x1b'), false);\n    assert_eq!(ascii::is_valid_letter(b' '), false);\n    assert_eq!(ascii::is_valid_letter(b'0'), false);\n    assert_eq!(ascii::is_valid_letter(b'9'), false);\n    assert_eq!(ascii::is_valid_letter(b':'), false);\n    assert_eq!(ascii::is_valid_letter(b'A'), true);\n    assert_eq!(ascii::is_valid_letter(b'Z'), true);\n    assert_eq!(ascii::is_valid_letter(b']'), false);\n    assert_eq!(ascii::is_valid_letter(b'a'), true);\n    assert_eq!(ascii::is_valid_letter(b'z'), true);\n    assert_eq!(ascii::is_valid_letter(b'~'), false);\n    assert_eq!(ascii::is_valid_letter(b'\\x7f'), false);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/ascii_tests.rs::is_valid_letter_slice_test", "test": "fn is_valid_letter_slice_test() {\n    assert_eq!(ascii::is_valid_letter_slice(b\" 09a\"), false);\n    assert_eq!(ascii::is_valid_letter_slice(b\"aZAz\"), true);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::pow32_test", "test": "fn pow32_test() {\n    assert_eq!(algorithm::pow32(10, 1), 10);\n    assert_eq!(algorithm::pow32(10, 2), 100);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::pow64_test", "test": "fn pow64_test() {\n    assert_eq!(algorithm::pow64(10, 1), 10);\n    assert_eq!(algorithm::pow64(10, 2), 100);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::count_factors_test", "test": "fn count_factors_test() {\n    assert_eq!(algorithm::count_factors(5, 25), 2);\n    assert_eq!(algorithm::count_factors(5, 30), 1);\n    assert_eq!(algorithm::count_factors(5, 125), 3);\n    assert_eq!(algorithm::count_factors(5, 126), 0);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::floor_log2_test", "test": "fn floor_log2_test() {\n    assert_eq!(algorithm::floor_log2(25), 4);\n    assert_eq!(algorithm::floor_log2(30), 4);\n    assert_eq!(algorithm::floor_log2(125), 6);\n    assert_eq!(algorithm::floor_log2(126), 6);\n    assert_eq!(algorithm::floor_log2(128), 7);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::to_decimal_test", "test": "fn to_decimal_test() {\n    assert_eq!(to_decimal_f32(0.0), (0, 0));\n    assert_eq!(to_decimal_f32(0.5), (5, -1));\n    assert_eq!(to_decimal_f32(1.0), (1, 0));\n    assert_eq!(to_decimal_f32(1.5), (15, -1));\n    assert_eq!(to_decimal_f32(1.23456), (123456, -5));\n    assert_eq!(to_decimal_f32(2.3786281e+38), (23786281, 31));\n    assert_eq!(to_decimal_f32(2147481600.0), (21474816, 2));\n    assert_eq!(to_decimal_f32(2147483600.0), (21474836, 2));\n    assert_eq!(to_decimal_f32(2762159900.0), (27621599, 2));\n    assert_eq!(to_decimal_f32(77371252000000000000000000.0), (77371252, 18));\n\n    assert_eq!(to_decimal_f64(0.0), (0, 0));\n    assert_eq!(to_decimal_f64(0.5), (5, -1));\n    assert_eq!(to_decimal_f64(1.0), (1, 0));\n    assert_eq!(to_decimal_f64(1.5), (15, -1));\n    assert_eq!(to_decimal_f64(1.23456), (123456, -5));\n    assert_eq!(to_decimal_f64(2.2250738585072014e-308), (22250738585072014, -324));\n    assert_eq!(to_decimal_f64(1.7976931348623157e+308), (17976931348623157, 292));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::compute_nearest_shorter_test", "test": "fn compute_nearest_shorter_test() {\n    assert_eq!(compute_nearest_shorter(0.5), (5, -1));\n    assert_eq!(compute_nearest_shorter(1.0), (1, 0));\n    assert_eq!(compute_nearest_shorter(2.0), (2, 0));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::compute_nearest_normal_test", "test": "fn compute_nearest_normal_test() {\n    assert_eq!(compute_nearest_normal(1.23456), (123456, -5));\n    assert_eq!(compute_nearest_normal(13.9999999999999982236431606), (13999999999999998, -15));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::compute_left_closed_directed_test", "test": "fn compute_left_closed_directed_test() {\n    assert_eq!(compute_left_closed_directed(1.23456), (12345600000000002, -16));\n    assert_eq!(\n        compute_left_closed_directed(13.9999999999999982236431606),\n        (13999999999999999, -15)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::compute_right_closed_directed_test", "test": "fn compute_right_closed_directed_test() {\n    assert_eq!(compute_right_closed_directed(1.23456), (123456, -5));\n    assert_eq!(\n        compute_right_closed_directed(13.9999999999999982236431606),\n        (13999999999999982, -15)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::f32_roundtrip_test", "test": "fn f32_roundtrip_test() {\n    let mut buffer = [b'\\x00'; BUFFER_SIZE];\n    let options = Options::builder().build().unwrap();\n    for &float in F32_DATA.iter() {\n        let count = unsafe { algorithm::write_float::<_, DECIMAL>(float, &mut buffer, &options) };\n        let actual = unsafe { std::str::from_utf8_unchecked(&buffer[..count]) };\n        let roundtrip = actual.parse::<f32>();\n        assert_eq!(roundtrip, Ok(float));\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::f64_roundtrip_test", "test": "fn f64_roundtrip_test() {\n    let mut buffer = [b'\\x00'; BUFFER_SIZE];\n    let options = Options::builder().build().unwrap();\n    for &float in F64_DATA.iter() {\n        let count = unsafe { algorithm::write_float::<_, DECIMAL>(float, &mut buffer, &options) };\n        let actual = unsafe { std::str::from_utf8_unchecked(&buffer[..count]) };\n        let roundtrip = actual.parse::<f64>();\n        assert_eq!(roundtrip, Ok(float));\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::is_endpoint_test", "test": "fn is_endpoint_test() {\n    assert_eq!(algorithm::is_endpoint(5, 2, 10), true);\n    assert_eq!(algorithm::is_endpoint(5, 6, 10), false);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::is_right_endpoint_test", "test": "fn is_right_endpoint_test() {\n    assert_eq!(algorithm::is_right_endpoint::<f64>(1), true);\n    assert_eq!(algorithm::is_right_endpoint::<f64>(2), true);\n    assert_eq!(algorithm::is_right_endpoint::<f64>(3), true);\n    assert_eq!(algorithm::is_right_endpoint::<f64>(4), false);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/algorithm_tests.rs::is_left_endpoint_test", "test": "fn is_left_endpoint_test() {\n    assert_eq!(algorithm::is_left_endpoint::<f64>(1), false);\n    assert_eq!(algorithm::is_left_endpoint::<f64>(2), true);\n    assert_eq!(algorithm::is_left_endpoint::<f64>(3), true);\n    assert_eq!(algorithm::is_left_endpoint::<f64>(4), false);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/api_tests.rs::error_tests", "test": "fn error_tests() {\n    let mut buffer = [b'\\x00'; BUFFER_SIZE];\n    let f = 2762159900.0f32;\n    let actual = unsafe { std::str::from_utf8_unchecked(f.to_lexical(&mut buffer)) };\n    let roundtrip = actual.parse::<f32>();\n    assert_eq!(Ok(f), roundtrip);\n\n    let f = 77371252000000000000000000.0f32;\n    let actual = unsafe { std::str::from_utf8_unchecked(f.to_lexical(&mut buffer)) };\n    let roundtrip = actual.parse::<f32>();\n    assert_eq!(Ok(f), roundtrip);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/api_tests.rs::fuzz_tests", "test": "fn fuzz_tests() {\n    let mut buffer = [b'\\x00'; BUFFER_SIZE];\n    let f = 355259285044678240000000000000000000000000000000000000000000f64;\n    let actual = unsafe { std::str::from_utf8_unchecked(f.to_lexical(&mut buffer)) };\n    let roundtrip = actual.parse::<f64>();\n    assert_eq!(Ok(f), roundtrip);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/binary_tests.rs::fast_log2_test", "test": "fn fast_log2_test() {\n    assert_eq!(binary::fast_log2(2), 1);\n    assert_eq!(binary::fast_log2(4), 2);\n    assert_eq!(binary::fast_log2(8), 3);\n    assert_eq!(binary::fast_log2(16), 4);\n    assert_eq!(binary::fast_log2(32), 5);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/binary_tests.rs::significant_bits_test", "test": "fn significant_bits_test() {\n    assert_eq!(binary::significant_bits(0u32), 0);\n    assert_eq!(binary::significant_bits(1u32), 1);\n    assert_eq!(binary::significant_bits(2u32), 2);\n    assert_eq!(binary::significant_bits(3u32), 2);\n    assert_eq!(binary::significant_bits(4u32), 3);\n    assert_eq!(binary::significant_bits(5u32), 3);\n    assert_eq!(binary::significant_bits(8u32), 4);\n    assert_eq!(binary::significant_bits(9u32), 4);\n    assert_eq!(binary::significant_bits(15u32), 4);\n    assert_eq!(binary::significant_bits(16u32), 5);\n    assert_eq!(binary::significant_bits(17u32), 5);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/binary_tests.rs::fast_ceildiv_test", "test": "fn fast_ceildiv_test() {\n    assert_eq!(binary::fast_ceildiv(10, 4), 3);\n    assert_eq!(binary::fast_ceildiv(10, 5), 2);\n    assert_eq!(binary::fast_ceildiv(10, 6), 2);\n    assert_eq!(binary::fast_ceildiv(0, 5), 0);\n    assert_eq!(binary::fast_ceildiv(4, 5), 1);\n    assert_eq!(binary::fast_ceildiv(5, 5), 1);\n    assert_eq!(binary::fast_ceildiv(6, 5), 2);\n    assert_eq!(binary::fast_ceildiv(9, 5), 2);\n    assert_eq!(binary::fast_ceildiv(11, 5), 3);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/binary_tests.rs::inverse_remainder_test", "test": "fn inverse_remainder_test() {\n    assert_eq!(binary::inverse_remainder(0, 8), 0);\n    assert_eq!(binary::inverse_remainder(1, 8), 7);\n    assert_eq!(binary::inverse_remainder(2, 8), 6);\n    assert_eq!(binary::inverse_remainder(3, 8), 5);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/binary_tests.rs::calculate_shl_test", "test": "fn calculate_shl_test() {\n    // Binary will always be a 0 shift.\n    assert_eq!(binary::calculate_shl(2, 1), 0);\n    assert_eq!(binary::calculate_shl(3, 1), 0);\n    assert_eq!(binary::calculate_shl(5, 1), 0);\n    assert_eq!(binary::calculate_shl(-5, 1), 0);\n    assert_eq!(binary::calculate_shl(-3, 1), 0);\n    assert_eq!(binary::calculate_shl(-2, 1), 0);\n\n    // Can have a 0 or 1 shift for base 4.\n    assert_eq!(binary::calculate_shl(2, 2), 0);\n    assert_eq!(binary::calculate_shl(3, 2), 1);\n    assert_eq!(binary::calculate_shl(4, 2), 0);\n    assert_eq!(binary::calculate_shl(-4, 2), 0);\n    assert_eq!(binary::calculate_shl(-3, 2), 1);\n    assert_eq!(binary::calculate_shl(-2, 2), 0);\n\n    // Octal can have a `[0, 2]` shift.\n    assert_eq!(binary::calculate_shl(2, 3), 2);\n    assert_eq!(binary::calculate_shl(3, 3), 0);\n    assert_eq!(binary::calculate_shl(4, 3), 1);\n    assert_eq!(binary::calculate_shl(-3, 3), 0);\n    assert_eq!(binary::calculate_shl(-2, 3), 1);\n    assert_eq!(binary::calculate_shl(-1, 3), 2);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/binary_tests.rs::scale_sci_exp_test", "test": "fn scale_sci_exp_test() {\n    // Binary is always the same.\n    assert_eq!(binary::scale_sci_exp(2, 1), 2);\n    assert_eq!(binary::scale_sci_exp(1, 1), 1);\n    assert_eq!(binary::scale_sci_exp(0, 1), 0);\n    assert_eq!(binary::scale_sci_exp(-1, 1), -1);\n    assert_eq!(binary::scale_sci_exp(-2, 1), -2);\n\n    // Base 4 will always be the round-to-negative-infinity div.\n    assert_eq!(binary::scale_sci_exp(2, 2), 1);\n    assert_eq!(binary::scale_sci_exp(1, 2), 0);\n    assert_eq!(binary::scale_sci_exp(0, 2), 0);\n    assert_eq!(binary::scale_sci_exp(-1, 2), -1);\n    assert_eq!(binary::scale_sci_exp(-2, 2), -1);\n    assert_eq!(binary::scale_sci_exp(-3, 2), -2);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/binary_tests.rs::truncate_and_round_test", "test": "fn truncate_and_round_test() {\n    let truncate = Options::builder()\n        .max_significant_digits(num::NonZeroUsize::new(4))\n        .round_mode(RoundMode::Truncate)\n        .build()\n        .unwrap();\n    let round = Options::builder()\n        .max_significant_digits(num::NonZeroUsize::new(4))\n        .round_mode(RoundMode::Round)\n        .build()\n        .unwrap();\n\n    // Above halfway\n    assert_eq!(binary::truncate_and_round(6602499140956772u64, 2, &round), (12, 53));\n    assert_eq!(binary::truncate_and_round(6602499140956772u64, 2, &truncate), (11, 53));\n\n    // At halfway\n    assert_eq!(binary::truncate_and_round(6473924464345088u64, 2, &round), (12, 53));\n    assert_eq!(binary::truncate_and_round(6473924464345088u64, 2, &truncate), (11, 53));\n\n    // Below halfway.\n    assert_eq!(binary::truncate_and_round(6473924464345087u64, 2, &round), (11, 53));\n    assert_eq!(binary::truncate_and_round(6473924464345087u64, 2, &truncate), (11, 53));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/compact_tests.rs::from_f32_test", "test": "fn from_f32_test() {\n    assert_eq!(\n        compact::from_float(0.0f32),\n        ExtendedFloat80 {\n            mant: 0,\n            exp: -149\n        }\n    );\n    assert_eq!(\n        compact::from_float(-0.0f32),\n        ExtendedFloat80 {\n            mant: 0,\n            exp: -149\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e-45f32),\n        ExtendedFloat80 {\n            mant: 1,\n            exp: -149\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e-40f32),\n        ExtendedFloat80 {\n            mant: 71362,\n            exp: -149\n        }\n    );\n    assert_eq!(\n        compact::from_float(2e-40f32),\n        ExtendedFloat80 {\n            mant: 142725,\n            exp: -149\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e-20f32),\n        ExtendedFloat80 {\n            mant: 12379400,\n            exp: -90\n        }\n    );\n    assert_eq!(\n        compact::from_float(2e-20f32),\n        ExtendedFloat80 {\n            mant: 12379400,\n            exp: -89\n        }\n    );\n    assert_eq!(\n        compact::from_float(1.0f32),\n        ExtendedFloat80 {\n            mant: 8388608,\n            exp: -23\n        }\n    );\n    assert_eq!(\n        compact::from_float(2.0f32),\n        ExtendedFloat80 {\n            mant: 8388608,\n            exp: -22\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e20f32),\n        ExtendedFloat80 {\n            mant: 11368684,\n            exp: 43\n        }\n    );\n    assert_eq!(\n        compact::from_float(2e20f32),\n        ExtendedFloat80 {\n            mant: 11368684,\n            exp: 44\n        }\n    );\n    assert_eq!(\n        compact::from_float(3.402823e38f32),\n        ExtendedFloat80 {\n            mant: 16777213,\n            exp: 104\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/compact_tests.rs::from_f64_test", "test": "fn from_f64_test() {\n    assert_eq!(\n        compact::from_float(0.0f64),\n        ExtendedFloat80 {\n            mant: 0,\n            exp: -1074\n        }\n    );\n    assert_eq!(\n        compact::from_float(-0.0f64),\n        ExtendedFloat80 {\n            mant: 0,\n            exp: -1074\n        }\n    );\n    assert_eq!(\n        compact::from_float(5e-324f64),\n        ExtendedFloat80 {\n            mant: 1,\n            exp: -1074\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e-250f64),\n        ExtendedFloat80 {\n            mant: 6448907850777164,\n            exp: -883\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e-150f64),\n        ExtendedFloat80 {\n            mant: 7371020360979573,\n            exp: -551\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e-45f64),\n        ExtendedFloat80 {\n            mant: 6427752177035961,\n            exp: -202\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e-40f64),\n        ExtendedFloat80 {\n            mant: 4903985730770844,\n            exp: -185\n        }\n    );\n    assert_eq!(\n        compact::from_float(2e-40f64),\n        ExtendedFloat80 {\n            mant: 4903985730770844,\n            exp: -184\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e-20f64),\n        ExtendedFloat80 {\n            mant: 6646139978924579,\n            exp: -119\n        }\n    );\n    assert_eq!(\n        compact::from_float(2e-20f64),\n        ExtendedFloat80 {\n            mant: 6646139978924579,\n            exp: -118\n        }\n    );\n    assert_eq!(\n        compact::from_float(1.0f64),\n        ExtendedFloat80 {\n            mant: 4503599627370496,\n            exp: -52\n        }\n    );\n    assert_eq!(\n        compact::from_float(2.0f64),\n        ExtendedFloat80 {\n            mant: 4503599627370496,\n            exp: -51\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e20f64),\n        ExtendedFloat80 {\n            mant: 6103515625000000,\n            exp: 14\n        }\n    );\n    assert_eq!(\n        compact::from_float(2e20f64),\n        ExtendedFloat80 {\n            mant: 6103515625000000,\n            exp: 15\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e40f64),\n        ExtendedFloat80 {\n            mant: 8271806125530277,\n            exp: 80\n        }\n    );\n    assert_eq!(\n        compact::from_float(2e40f64),\n        ExtendedFloat80 {\n            mant: 8271806125530277,\n            exp: 81\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e150f64),\n        ExtendedFloat80 {\n            mant: 5503284107318959,\n            exp: 446\n        }\n    );\n    assert_eq!(\n        compact::from_float(1e250f64),\n        ExtendedFloat80 {\n            mant: 6290184345309700,\n            exp: 778\n        }\n    );\n    assert_eq!(\n        compact::from_float(1.7976931348623157e308),\n        ExtendedFloat80 {\n            mant: 9007199254740991,\n            exp: 971\n        }\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/compact_tests.rs::f32_roundtrip_test", "test": "fn f32_roundtrip_test() {\n    let mut buffer = [b'\\x00'; BUFFER_SIZE];\n    let options = Options::builder().build().unwrap();\n    for &float in F32_DATA.iter() {\n        let count = unsafe { compact::write_float::<_, DECIMAL>(float, &mut buffer, &options) };\n        let actual = unsafe { std::str::from_utf8_unchecked(&buffer[..count]) };\n        let roundtrip = actual.parse::<f32>();\n        assert_eq!(roundtrip, Ok(float));\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/compact_tests.rs::f64_roundtrip_test", "test": "fn f64_roundtrip_test() {\n    let mut buffer = [b'\\x00'; BUFFER_SIZE];\n    let options = Options::builder().build().unwrap();\n    for &float in F64_DATA.iter() {\n        let count = unsafe { compact::write_float::<_, DECIMAL>(float, &mut buffer, &options) };\n        let actual = unsafe { std::str::from_utf8_unchecked(&buffer[..count]) };\n        let roundtrip = actual.parse::<f64>();\n        assert_eq!(roundtrip, Ok(float));\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::builder_test", "test": "fn builder_test() {\n    let mut builder = OptionsBuilder::default();\n\n    builder = builder.max_significant_digits(num::NonZeroUsize::new(10));\n    builder = builder.min_significant_digits(num::NonZeroUsize::new(5));\n    builder = builder.positive_exponent_break(num::NonZeroI32::new(9));\n    builder = builder.negative_exponent_break(num::NonZeroI32::new(-9));\n    builder = builder.round_mode(options::RoundMode::Truncate);\n    builder = builder.trim_floats(true);\n    builder = builder.exponent(b'^');\n    builder = builder.decimal_point(b',');\n    builder = builder.nan_string(Some(b\"nan\"));\n    builder = builder.inf_string(Some(b\"Infinity\"));\n\n    assert_eq!(builder.get_max_significant_digits().unwrap().get(), 10);\n    assert_eq!(builder.get_min_significant_digits().unwrap().get(), 5);\n    assert_eq!(builder.get_positive_exponent_break().unwrap().get(), 9);\n    assert_eq!(builder.get_negative_exponent_break().unwrap().get(), -9);\n    assert_eq!(builder.get_round_mode(), options::RoundMode::Truncate);\n    assert_eq!(builder.get_trim_floats(), true);\n    assert_eq!(builder.get_exponent(), b'^');\n    assert_eq!(builder.get_decimal_point(), b',');\n    assert_eq!(builder.get_nan_string(), Some(\"nan\".as_bytes()));\n    assert_eq!(builder.get_inf_string(), Some(\"Infinity\".as_bytes()));\n\n    assert!(builder.is_valid());\n    assert_eq!(builder.build(), Ok(unsafe { builder.build_unchecked() }));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::options_test", "test": "fn options_test() {\n    let mut opts = Options::new();\n\n    unsafe {\n        opts.set_max_significant_digits(num::NonZeroUsize::new(10));\n        opts.set_min_significant_digits(num::NonZeroUsize::new(5));\n        opts.set_positive_exponent_break(num::NonZeroI32::new(9));\n        opts.set_negative_exponent_break(num::NonZeroI32::new(-9));\n        opts.set_round_mode(options::RoundMode::Truncate);\n        opts.set_trim_floats(true);\n        opts.set_exponent(b'^');\n        opts.set_decimal_point(b',');\n        opts.set_nan_string(Some(b\"nan\"));\n        opts.set_inf_string(Some(b\"Infinity\"));\n    }\n\n    assert_eq!(opts.max_significant_digits().unwrap().get(), 10);\n    assert_eq!(opts.min_significant_digits().unwrap().get(), 5);\n    assert_eq!(opts.positive_exponent_break().unwrap().get(), 9);\n    assert_eq!(opts.negative_exponent_break().unwrap().get(), -9);\n    assert_eq!(opts.round_mode(), options::RoundMode::Truncate);\n    assert_eq!(opts.trim_floats(), true);\n    assert_eq!(opts.exponent(), b'^');\n    assert_eq!(opts.decimal_point(), b',');\n    assert_eq!(opts.nan_string(), Some(\"nan\".as_bytes()));\n    assert_eq!(opts.inf_string(), Some(\"Infinity\".as_bytes()));\n    assert!(opts.is_valid());\n\n    assert_eq!(Options::builder(), OptionsBuilder::new());\n    assert_eq!(opts.rebuild().build(), Ok(opts));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u8_test", "test": "fn u8_test() {\n    let mut buffer = [b'\\x00'; 16];\n    assert_eq!(b\"0\", 0u8.to_lexical(&mut buffer));\n    assert_eq!(b\"1\", 1u8.to_lexical(&mut buffer));\n    assert_eq!(b\"5\", 5u8.to_lexical(&mut buffer));\n    assert_eq!(b\"127\", 127u8.to_lexical(&mut buffer));\n    assert_eq!(b\"128\", 128u8.to_lexical(&mut buffer));\n    assert_eq!(b\"255\", 255u8.to_lexical(&mut buffer));\n    assert_eq!(b\"255\", (-1i8 as u8).to_lexical(&mut buffer));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::i8_test", "test": "fn i8_test() {\n    let mut buffer = [b'\\x00'; 16];\n    assert_eq!(b\"0\", 0i8.to_lexical(&mut buffer));\n    assert_eq!(b\"1\", 1i8.to_lexical(&mut buffer));\n    assert_eq!(b\"5\", 5i8.to_lexical(&mut buffer));\n    assert_eq!(b\"127\", 127i8.to_lexical(&mut buffer));\n    assert_eq!(b\"-128\", (128u8 as i8).to_lexical(&mut buffer));\n    assert_eq!(b\"-1\", (255u8 as i8).to_lexical(&mut buffer));\n    assert_eq!(b\"-1\", (-1i8).to_lexical(&mut buffer));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u16_test", "test": "fn u16_test() {\n    let mut buffer = [b'\\x00'; 16];\n    assert_eq!(b\"0\", 0u16.to_lexical(&mut buffer));\n    assert_eq!(b\"1\", 1u16.to_lexical(&mut buffer));\n    assert_eq!(b\"5\", 5u16.to_lexical(&mut buffer));\n    assert_eq!(b\"32767\", 32767u16.to_lexical(&mut buffer));\n    assert_eq!(b\"32768\", 32768u16.to_lexical(&mut buffer));\n    assert_eq!(b\"65535\", 65535u16.to_lexical(&mut buffer));\n    assert_eq!(b\"65535\", (-1i16 as u16).to_lexical(&mut buffer));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::i16_test", "test": "fn i16_test() {\n    let mut buffer = [b'\\x00'; 16];\n    assert_eq!(b\"0\", 0i16.to_lexical(&mut buffer));\n    assert_eq!(b\"1\", 1i16.to_lexical(&mut buffer));\n    assert_eq!(b\"5\", 5i16.to_lexical(&mut buffer));\n    assert_eq!(b\"32767\", 32767i16.to_lexical(&mut buffer));\n    assert_eq!(b\"-32768\", (32768u16 as i16).to_lexical(&mut buffer));\n    assert_eq!(b\"-1\", (65535u16 as i16).to_lexical(&mut buffer));\n    assert_eq!(b\"-1\", (-1i16).to_lexical(&mut buffer));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u32_test", "test": "fn u32_test() {\n    let mut buffer = [b'\\x00'; 16];\n    assert_eq!(b\"0\", 0u32.to_lexical(&mut buffer));\n    assert_eq!(b\"1\", 1u32.to_lexical(&mut buffer));\n    assert_eq!(b\"5\", 5u32.to_lexical(&mut buffer));\n    assert_eq!(b\"2147483647\", 2147483647u32.to_lexical(&mut buffer));\n    assert_eq!(b\"2147483648\", 2147483648u32.to_lexical(&mut buffer));\n    assert_eq!(b\"4294967295\", 4294967295u32.to_lexical(&mut buffer));\n    assert_eq!(b\"4294967295\", (-1i32 as u32).to_lexical(&mut buffer));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::i32_test", "test": "fn i32_test() {\n    let mut buffer = [b'\\x00'; 16];\n    assert_eq!(b\"0\", 0i32.to_lexical(&mut buffer));\n    assert_eq!(b\"1\", 1i32.to_lexical(&mut buffer));\n    assert_eq!(b\"5\", 5i32.to_lexical(&mut buffer));\n    assert_eq!(b\"2147483647\", 2147483647i32.to_lexical(&mut buffer));\n    assert_eq!(b\"-2147483648\", (2147483648u32 as i32).to_lexical(&mut buffer));\n    assert_eq!(b\"-1\", (4294967295u32 as i32).to_lexical(&mut buffer));\n    assert_eq!(b\"-1\", (-1i32).to_lexical(&mut buffer));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u64_test", "test": "fn u64_test() {\n    let mut buffer = [b'\\x00'; 32];\n    assert_eq!(b\"0\", 0u64.to_lexical(&mut buffer));\n    assert_eq!(b\"1\", 1u64.to_lexical(&mut buffer));\n    assert_eq!(b\"5\", 5u64.to_lexical(&mut buffer));\n    assert_eq!(b\"9223372036854775807\", 9223372036854775807u64.to_lexical(&mut buffer));\n    assert_eq!(b\"9223372036854775808\", 9223372036854775808u64.to_lexical(&mut buffer));\n    assert_eq!(b\"18446744073709551615\", 18446744073709551615u64.to_lexical(&mut buffer));\n    assert_eq!(b\"18446744073709551615\", (-1i64 as u64).to_lexical(&mut buffer));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::i64_test", "test": "fn i64_test() {\n    let mut buffer = [b'\\x00'; 32];\n    assert_eq!(b\"0\", 0i64.to_lexical(&mut buffer));\n    assert_eq!(b\"1\", 1i64.to_lexical(&mut buffer));\n    assert_eq!(b\"5\", 5i64.to_lexical(&mut buffer));\n    assert_eq!(b\"9223372036854775807\", 9223372036854775807i64.to_lexical(&mut buffer));\n    assert_eq!(b\"-9223372036854775808\", (9223372036854775808u64 as i64).to_lexical(&mut buffer));\n    assert_eq!(b\"-1\", (18446744073709551615u64 as i64).to_lexical(&mut buffer));\n    assert_eq!(b\"-1\", (-1i64).to_lexical(&mut buffer));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u128_test", "test": "fn u128_test() {\n    let mut buffer = [b'\\x00'; 48];\n    assert_eq!(b\"0\", 0u128.to_lexical(&mut buffer));\n    assert_eq!(b\"1\", 1u128.to_lexical(&mut buffer));\n    assert_eq!(b\"5\", 5u128.to_lexical(&mut buffer));\n    assert_eq!(\n        &b\"170141183460469231731687303715884105727\"[..],\n        170141183460469231731687303715884105727u128.to_lexical(&mut buffer)\n    );\n    assert_eq!(\n        &b\"170141183460469231731687303715884105728\"[..],\n        170141183460469231731687303715884105728u128.to_lexical(&mut buffer)\n    );\n    assert_eq!(\n        &b\"340282366920938463463374607431768211455\"[..],\n        340282366920938463463374607431768211455u128.to_lexical(&mut buffer)\n    );\n    assert_eq!(\n        &b\"340282366920938463463374607431768211455\"[..],\n        (-1i128 as u128).to_lexical(&mut buffer)\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::i128_test", "test": "fn i128_test() {\n    let mut buffer = [b'\\x00'; 48];\n    assert_eq!(b\"0\", 0i128.to_lexical(&mut buffer));\n    assert_eq!(b\"1\", 1i128.to_lexical(&mut buffer));\n    assert_eq!(b\"5\", 5i128.to_lexical(&mut buffer));\n    assert_eq!(\n        &b\"170141183460469231731687303715884105727\"[..],\n        170141183460469231731687303715884105727i128.to_lexical(&mut buffer)\n    );\n    assert_eq!(\n        &b\"-170141183460469231731687303715884105728\"[..],\n        (170141183460469231731687303715884105728u128 as i128).to_lexical(&mut buffer)\n    );\n    assert_eq!(\n        b\"-1\",\n        (340282366920938463463374607431768211455u128 as i128).to_lexical(&mut buffer)\n    );\n    assert_eq!(b\"-1\", (-1i128).to_lexical(&mut buffer));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::options_test", "test": "fn options_test() {\n    let mut buffer = [b'\\x00'; 48];\n    let options = Options::new();\n    assert_eq!(b\"0\", 0u8.to_lexical_with_options::<{ STANDARD }>(&mut buffer, &options));\n    assert_eq!(b\"0\", 0u16.to_lexical_with_options::<{ STANDARD }>(&mut buffer, &options));\n    assert_eq!(b\"0\", 0u32.to_lexical_with_options::<{ STANDARD }>(&mut buffer, &options));\n    assert_eq!(b\"0\", 0u64.to_lexical_with_options::<{ STANDARD }>(&mut buffer, &options));\n    assert_eq!(b\"0\", 0u128.to_lexical_with_options::<{ STANDARD }>(&mut buffer, &options));\n    assert_eq!(b\"0\", 0i8.to_lexical_with_options::<{ STANDARD }>(&mut buffer, &options));\n    assert_eq!(b\"0\", 0i16.to_lexical_with_options::<{ STANDARD }>(&mut buffer, &options));\n    assert_eq!(b\"0\", 0i32.to_lexical_with_options::<{ STANDARD }>(&mut buffer, &options));\n    assert_eq!(b\"0\", 0i64.to_lexical_with_options::<{ STANDARD }>(&mut buffer, &options));\n    assert_eq!(b\"0\", 0i128.to_lexical_with_options::<{ STANDARD }>(&mut buffer, &options));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/decimal_tests.rs::fast_log2_test", "test": "fn fast_log2_test() {\n    // Check the first, even if illogical case works.\n    assert_eq!(decimal::fast_log2(0u32), 0);\n    assert_eq!(decimal::fast_log2(1u32), 0);\n    assert_eq!(decimal::fast_log2(2u32), 1);\n    assert_eq!(decimal::fast_log2(3u32), 1);\n\n    assert_eq!(decimal::fast_log2((1u32 << 16) - 1), 15);\n    assert_eq!(decimal::fast_log2(1u32 << 16), 16);\n    assert_eq!(decimal::fast_log2((1u32 << 16) + 1), 16);\n\n    assert_eq!(decimal::fast_log2(u32::MAX), 31);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/decimal_tests.rs::fast_log10_test", "test": "fn fast_log10_test() {\n    // Check the first, even if illogical case works.\n    assert_eq!(decimal::fast_log10(0u32), 0);\n    assert_eq!(decimal::fast_log10(10u32), 0);\n    assert_eq!(decimal::fast_log10(15u32), 0);\n    assert_eq!(decimal::fast_log10(20u32), 1);\n    assert_eq!(decimal::fast_log10(100u32), 1);\n    assert_eq!(decimal::fast_log10(200u32), 2);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/decimal_tests.rs::u32_digit_count_test", "test": "fn u32_digit_count_test() {\n    assert_eq!(u32::digit_count(0), 1);\n    assert_eq!(u32::digit_count(1), 1);\n    assert_eq!(u32::digit_count(9), 1);\n    assert_eq!(u32::digit_count(10), 2);\n    assert_eq!(u32::digit_count(11), 2);\n\n    assert_eq!(u32::digit_count((1 << 16) - 1), 5);\n    assert_eq!(u32::digit_count(1 << 16), 5);\n    assert_eq!(u32::digit_count((1 << 16) + 1), 5);\n\n    assert_eq!(u32::digit_count(u32::MAX), 10);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/decimal_tests.rs::u64_digit_count_test", "test": "fn u64_digit_count_test() {\n    assert_eq!(u64::digit_count(0), 1);\n    assert_eq!(u64::digit_count(1), 1);\n    assert_eq!(u64::digit_count(9), 1);\n    assert_eq!(u64::digit_count(10), 2);\n    assert_eq!(u64::digit_count(11), 2);\n\n    assert_eq!(u64::digit_count((1 << 16) - 1), 5);\n    assert_eq!(u64::digit_count(1 << 16), 5);\n    assert_eq!(u64::digit_count((1 << 16) + 1), 5);\n\n    assert_eq!(u64::digit_count(u32::MAX as u64), 10);\n    assert_eq!(u64::digit_count(u64::MAX), 20);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/decimal_tests.rs::u128_digit_count_test", "test": "fn u128_digit_count_test() {\n    assert_eq!(u128::digit_count(u128::MAX), 39);\n}", "error": "Not Definition Found"}
