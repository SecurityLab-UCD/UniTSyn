{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_derive_input.rs::test_fields_on_unit_struct", "test": "fn test_fields_on_unit_struct() {\n    let input = quote! {\n        struct S;\n    };\n\n    snapshot!(input as DeriveInput, @r###\"\n    DeriveInput {\n        vis: Visibility::Inherited,\n        ident: \"S\",\n        generics: Generics,\n        data: Data::Struct {\n            fields: Fields::Unit,\n            semi_token: Some,\n        },\n    }\n    \"###);\n\n    let data = match input.data {\n        Data::Struct(data) => data,\n        _ => panic!(\"expected a struct\"),\n    };\n\n    assert_eq!(0, data.fields.iter().count());\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_expr.rs::test_tuple_multi_index", "test": "fn test_tuple_multi_index() {\n    let expected = snapshot!(\"tuple.0.0\" as Expr, @r###\"\n    Expr::Field {\n        base: Expr::Field {\n            base: Expr::Path {\n                path: Path {\n                    segments: [\n                        PathSegment {\n                            ident: \"tuple\",\n                        },\n                    ],\n                },\n            },\n            member: Member::Unnamed(Index {\n                index: 0,\n            }),\n        },\n        member: Member::Unnamed(Index {\n            index: 0,\n        }),\n    }\n    \"###);\n\n    for &input in &[\n        \"tuple .0.0\",\n        \"tuple. 0.0\",\n        \"tuple.0 .0\",\n        \"tuple.0. 0\",\n        \"tuple . 0 . 0\",\n    ] {\n        assert_eq!(expected, syn::parse_str(input).unwrap());\n    }\n\n    for tokens in [\n        quote!(tuple.0.0),\n        quote!(tuple .0.0),\n        quote!(tuple. 0.0),\n        quote!(tuple.0 .0),\n        quote!(tuple.0. 0),\n        quote!(tuple . 0 . 0),\n    ] {\n        assert_eq!(expected, syn::parse2(tokens).unwrap());\n    }\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_iterators.rs::pairs", "test": "fn pairs() {\n    let mut p: Punctuated<_, Token![,]> = punctuated!(2, 3, 4);\n\n    check_exact_size_iterator!(p.pairs());\n    check_exact_size_iterator!(p.pairs_mut());\n    check_exact_size_iterator!(p.into_pairs());\n\n    let mut p: Punctuated<_, Token![,]> = punctuated!(2, 3, 4);\n\n    assert_eq!(p.pairs().next_back().map(Pair::into_value), Some(&4));\n    assert_eq!(\n        p.pairs_mut().next_back().map(Pair::into_value),\n        Some(&mut 4)\n    );\n    assert_eq!(p.into_pairs().next_back().map(Pair::into_value), Some(4));\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_meta.rs::test_parse_meta_name_value", "test": "fn test_parse_meta_name_value() {\n    let input = \"foo = 5\";\n    let (inner, meta) = (input, input);\n\n    snapshot!(inner as MetaNameValue, @r###\"\n    MetaNameValue {\n        path: Path {\n            segments: [\n                PathSegment {\n                    ident: \"foo\",\n                },\n            ],\n        },\n        value: Expr::Lit {\n            lit: 5,\n        },\n    }\n    \"###);\n\n    snapshot!(meta as Meta, @r###\"\n    Meta::NameValue {\n        path: Path {\n            segments: [\n                PathSegment {\n                    ident: \"foo\",\n                },\n            ],\n        },\n        value: Expr::Lit {\n            lit: 5,\n        },\n    }\n    \"###);\n\n    assert_eq!(meta, inner.into());\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_meta.rs::test_parse_meta_item_list_lit", "test": "fn test_parse_meta_item_list_lit() {\n    let input = \"foo(5)\";\n    let (inner, meta) = (input, input);\n\n    snapshot!(inner as MetaList, @r###\"\n    MetaList {\n        path: Path {\n            segments: [\n                PathSegment {\n                    ident: \"foo\",\n                },\n            ],\n        },\n        delimiter: MacroDelimiter::Paren,\n        tokens: TokenStream(`5`),\n    }\n    \"###);\n\n    snapshot!(meta as Meta, @r###\"\n    Meta::List {\n        path: Path {\n            segments: [\n                PathSegment {\n                    ident: \"foo\",\n                },\n            ],\n        },\n        delimiter: MacroDelimiter::Paren,\n        tokens: TokenStream(`5`),\n    }\n    \"###);\n\n    assert_eq!(meta, inner.into());\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_meta.rs::test_parse_meta_item_multiple", "test": "fn test_parse_meta_item_multiple() {\n    let input = \"foo(word, name = 5, list(name2 = 6), word2)\";\n    let (inner, meta) = (input, input);\n\n    snapshot!(inner as MetaList, @r###\"\n    MetaList {\n        path: Path {\n            segments: [\n                PathSegment {\n                    ident: \"foo\",\n                },\n            ],\n        },\n        delimiter: MacroDelimiter::Paren,\n        tokens: TokenStream(`word , name = 5 , list (name2 = 6) , word2`),\n    }\n    \"###);\n\n    snapshot!(meta as Meta, @r###\"\n    Meta::List {\n        path: Path {\n            segments: [\n                PathSegment {\n                    ident: \"foo\",\n                },\n            ],\n        },\n        delimiter: MacroDelimiter::Paren,\n        tokens: TokenStream(`word , name = 5 , list (name2 = 6) , word2`),\n    }\n    \"###);\n\n    assert_eq!(meta, inner.into());\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_size.rs::test_expr_size", "test": "fn test_expr_size() {\n    assert_eq!(mem::size_of::<Expr>(), 176);\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_size.rs::test_item_size", "test": "fn test_item_size() {\n    assert_eq!(mem::size_of::<Item>(), 360);\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_size.rs::test_type_size", "test": "fn test_type_size() {\n    assert_eq!(mem::size_of::<Type>(), 232);\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_size.rs::test_pat_size", "test": "fn test_pat_size() {\n    assert_eq!(mem::size_of::<Pat>(), 184);\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_size.rs::test_lit_size", "test": "fn test_lit_size() {\n    assert_eq!(mem::size_of::<Lit>(), 32);\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_stmt.rs::test_raw_invalid", "test": "fn test_raw_invalid() {\n    assert!(syn::parse_str::<Stmt>(\"let _ = &raw x;\").is_err());\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_visibility.rs::test_pub", "test": "fn test_pub() {\n    assert_vis_parse!(\"pub\", Ok(Visibility::Public(_)));\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_visibility.rs::test_inherited", "test": "fn test_inherited() {\n    assert_vis_parse!(\"\", Ok(Visibility::Inherited));\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_visibility.rs::test_in", "test": "fn test_in() {\n    assert_vis_parse!(\"pub(in foo::bar)\", Ok(Visibility::Restricted(_)));\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_visibility.rs::test_pub_crate", "test": "fn test_pub_crate() {\n    assert_vis_parse!(\"pub(crate)\", Ok(Visibility::Restricted(_)));\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_visibility.rs::test_pub_self", "test": "fn test_pub_self() {\n    assert_vis_parse!(\"pub(self)\", Ok(Visibility::Restricted(_)));\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_visibility.rs::test_pub_super", "test": "fn test_pub_super() {\n    assert_vis_parse!(\"pub(super)\", Ok(Visibility::Restricted(_)));\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_visibility.rs::test_missing_in", "test": "fn test_missing_in() {\n    assert_vis_parse!(\"pub(foo::bar)\", Ok(Visibility::Public(_)) + \"(foo::bar)\");\n}", "error": "Not Definition Found"}
{"test_id": "dtolnay-syn/dtolnay-syn-b1a038c/tests/test_visibility.rs::test_crate_path", "test": "fn test_crate_path() {\n    assert_vis_parse!(\n        \"pub(crate::A, crate::B)\",\n        Ok(Visibility::Public(_)) + \"(crate::A, crate::B)\"\n    );\n}", "error": "Not Definition Found"}
