{"test_id": "bincode-org-bincode/bincode-org-bincode-aada4bb/tests/error_size.rs::decode_error_size", "test": "fn decode_error_size() {\n    assert_eq!(std::mem::size_of::<bincode::error::DecodeError>(), 32);\n}", "error": "Not Definition Found"}
{"test_id": "bincode-org-bincode/bincode-org-bincode-aada4bb/tests/error_size.rs::encode_error_size", "test": "fn encode_error_size() {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    assert_eq!(std::mem::size_of::<bincode::error::EncodeError>(), 32);\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    assert_eq!(std::mem::size_of::<bincode::error::EncodeError>(), 24);\n}", "error": "Not Definition Found"}
{"test_id": "bincode-org-bincode/bincode-org-bincode-aada4bb/tests/std.rs::test_std_commons", "test": "fn test_std_commons() {\n    the_same(CString::new(\"Hello world\").unwrap());\n    the_same(PathBuf::from(\"C:/Program Files/Foo\"));\n    the_same(Ipv4Addr::LOCALHOST);\n    the_same(Ipv6Addr::LOCALHOST);\n    the_same(IpAddr::V4(Ipv4Addr::LOCALHOST));\n    the_same(IpAddr::V6(Ipv6Addr::LOCALHOST));\n    the_same(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 12345));\n    the_same(SocketAddrV6::new(Ipv6Addr::LOCALHOST, 12345, 0, 0));\n    the_same(SocketAddr::V4(SocketAddrV4::new(\n        Ipv4Addr::LOCALHOST,\n        12345,\n    )));\n    the_same(SocketAddr::V6(SocketAddrV6::new(\n        Ipv6Addr::LOCALHOST,\n        12345,\n        0,\n        0,\n    )));\n    the_same_with_comparer(Mutex::new(\"Hello world\".to_string()), |a, b| {\n        *a.lock().unwrap() == *b.lock().unwrap()\n    });\n    the_same_with_comparer(RwLock::new(\"Hello world\".to_string()), |a, b| {\n        *a.read().unwrap() == *b.read().unwrap()\n    });\n\n    let mut map = std::collections::HashMap::new();\n    map.insert(\"Hello\".to_owned(), \"world\".to_owned());\n    map.insert(\"How\".to_owned(), \"are\".to_owned());\n    map.insert(\"you\".to_owned(), \"doing?\".to_owned());\n    the_same(map);\n\n    let mut set = std::collections::HashSet::new();\n    set.insert(\"Hello\".to_string());\n    set.insert(\"World\".to_string());\n    the_same(set);\n\n    // HashMap and HashSet with custom hash algorithm\n    type MyBuildHasher = std::hash::BuildHasherDefault<ExampleCustomHasher>;\n    let mut custom_map: std::collections::HashMap<String, String, MyBuildHasher> =\n        Default::default();\n    custom_map.insert(\"Hello\".to_owned(), \"world\".to_owned());\n    custom_map.insert(\"How\".to_owned(), \"are\".to_owned());\n    custom_map.insert(\"you\".to_owned(), \"doing?\".to_owned());\n    the_same(custom_map);\n\n    let mut custom_set: std::collections::HashSet<String, MyBuildHasher> = Default::default();\n    custom_set.insert(\"Hello\".to_string());\n    custom_set.insert(\"World\".to_string());\n    the_same(custom_set);\n\n    // Borrowed values\n    let config = bincode::config::standard();\n    let mut buffer = [0u8; 1024];\n\n    // &CStr\n    let cstr = CStr::from_bytes_with_nul(b\"Hello world\\0\").unwrap();\n    let len = bincode::encode_into_slice(cstr, &mut buffer, config).unwrap();\n    let (decoded, len): (CString, usize) =\n        bincode::decode_from_slice(&buffer[..len], config).unwrap();\n    assert_eq!(cstr, decoded.as_c_str());\n    assert_eq!(len, 12);\n\n    // Path\n    let path = Path::new(\"C:/Program Files/Foo\");\n    let len = bincode::encode_into_slice(path, &mut buffer, config).unwrap();\n    let (decoded, len): (&Path, usize) =\n        bincode::borrow_decode_from_slice(&buffer[..len], config).unwrap();\n    assert_eq!(path, decoded);\n    assert_eq!(len, 21);\n}", "error": "Not Definition Found"}
{"test_id": "bincode-org-bincode/bincode-org-bincode-aada4bb/tests/std.rs::test_system_time_out_of_range", "test": "fn test_system_time_out_of_range() {\n    let input = [0xfd, 0x90, 0x0c, 0xfd, 0xfd, 0x90, 0x0c, 0xfd, 0x90, 0x90];\n\n    let result: Result<(std::time::SystemTime, usize), _> =\n        bincode::decode_from_slice(&input, bincode::config::standard());\n\n    match result {\n        Ok(_) => panic!(\"Expected the decode to fail, but it succeeded\"),\n        Err(DecodeError::InvalidSystemTime { duration }) => {\n            assert_eq!(\n                duration,\n                std::time::Duration::new(10447520527445462160, 144)\n            )\n        }\n        Err(e) => panic!(\"Expected DecodeError::InvalidSystemTime, got {e:?}\"),\n    }\n}", "error": "Not Definition Found"}
