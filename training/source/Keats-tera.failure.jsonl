{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/lexer.rs::lex_macro_definition", "test": "fn lex_macro_definition() {\n    let inputs = vec![\n        \"hello()\",\n        \"hello(name, admin)\",\n        \"hello(name, admin=1)\",\n        \"hello(name=\\\"bob\\\", admin)\",\n        \"hello(name=\\\"bob\\\",admin=true)\",\n    ];\n    for i in inputs {\n        // The () are not counted as tokens for some reasons so can't use the macro\n        assert!(TeraParser::parse(Rule::macro_fn, i).is_ok());\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/lexer.rs::lex_test", "test": "fn lex_test() {\n    let inputs =\n        vec![\"a is defined\", \"a is defined()\", \"a is divisibleby(2)\", \"a is in([1, 2, something])\"];\n    for i in inputs {\n        // The () are not counted as tokens for some reasons so can't use the macro\n        assert!(TeraParser::parse(Rule::test, i).is_ok());\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/lexer.rs::lex_include_tag", "test": "fn lex_include_tag() {\n    assert!(TeraParser::parse(Rule::include_tag, \"{% include \\\"index.html\\\" %}\").is_ok());\n    assert!(TeraParser::parse(Rule::include_tag, \"{% include [\\\"index.html\\\"] %}\").is_ok());\n    assert!(TeraParser::parse(Rule::include_tag, \"{% include [\\\"index.html\\\"] ignore missing %}\")\n        .is_ok());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/lexer.rs::lex_import_macro_tag", "test": "fn lex_import_macro_tag() {\n    assert!(TeraParser::parse(Rule::import_macro_tag, \"{% import \\\"macros.html\\\" as macros %}\",)\n        .is_ok());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/lexer.rs::lex_extends_tag", "test": "fn lex_extends_tag() {\n    assert!(TeraParser::parse(Rule::extends_tag, \"{% extends \\\"index.html\\\" %}\").is_ok());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/lexer.rs::lex_else_tag", "test": "fn lex_else_tag() {\n    assert!(TeraParser::parse(Rule::else_tag, \"{% else %}\").is_ok());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/lexer.rs::lex_break_tag", "test": "fn lex_break_tag() {\n    assert!(TeraParser::parse(Rule::break_tag, \"{% break %}\").is_ok());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/lexer.rs::lex_continue_tag", "test": "fn lex_continue_tag() {\n    assert!(TeraParser::parse(Rule::continue_tag, \"{% continue %}\").is_ok());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_text", "test": "fn parse_text() {\n    let ast = parse(\"hello world\").unwrap();\n    assert_eq!(ast[0], Node::Text(\"hello world\".to_string()));\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_text_with_whitespace", "test": "fn parse_text_with_whitespace() {\n    let ast = parse(\" hello world \").unwrap();\n    assert_eq!(ast[0], Node::Text(\" hello world \".to_string()));\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_include_tag", "test": "fn parse_include_tag() {\n    let ast = parse(\"{% include \\\"index.html\\\" -%}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::Include(WS { left: false, right: true }, vec![\"index.html\".to_string()], false,),\n    );\n    let ast =\n        parse(\"{% include [\\\"custom/index.html\\\", \\\"index.html\\\"] ignore missing %}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::Include(\n            WS { left: false, right: false },\n            vec![\"custom/index.html\".to_string(), \"index.html\".to_string()],\n            true,\n        ),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_extends", "test": "fn parse_extends() {\n    let ast = parse(\"{% extends \\\"index.html\\\" -%}\").unwrap();\n    assert_eq!(ast[0], Node::Extends(WS { left: false, right: true }, \"index.html\".to_string(),),);\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_comments_before_extends", "test": "fn parse_comments_before_extends() {\n    let ast = parse(\"{# A comment #}{% extends \\\"index.html\\\" -%}\").unwrap();\n    assert_eq!(ast[0], Node::Extends(WS { left: false, right: true }, \"index.html\".to_string(),),);\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_import_macro", "test": "fn parse_import_macro() {\n    let ast = parse(\"\\n{% import \\\"macros.html\\\" as macros -%}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::ImportMacro(\n            WS { left: false, right: true },\n            \"macros.html\".to_string(),\n            \"macros\".to_string(),\n        ),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_with_whitespace_trimming", "test": "fn parse_variable_with_whitespace_trimming() {\n    let ast = parse(\"{{- id }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS { left: true, right: false },\n            Expr::new(ExprVal::Ident(\"id\".to_string()))\n        ),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_ident", "test": "fn parse_variable_tag_ident() {\n    let ast = parse(\"{{ id }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(WS::default(), Expr::new(ExprVal::Ident(\"id\".to_string()))),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_ident_with_simple_filters", "test": "fn parse_variable_tag_ident_with_simple_filters() {\n    let ast = parse(\"{{ arr | first | join(n=2) }}\").unwrap();\n    let mut join_args = HashMap::new();\n    join_args.insert(\"n\".to_string(), Expr::new(ExprVal::Int(2)));\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::with_filters(\n                ExprVal::Ident(\"arr\".to_string()),\n                vec![\n                    FunctionCall { name: \"first\".to_string(), args: HashMap::new() },\n                    FunctionCall { name: \"join\".to_string(), args: join_args },\n                ],\n            )\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_lit", "test": "fn parse_variable_tag_lit() {\n    let ast = parse(\"{{ 2 }}{{ 3.18 }}{{ \\\"hey\\\" }}{{ true }}\").unwrap();\n    assert_eq!(ast[0], Node::VariableBlock(WS::default(), Expr::new(ExprVal::Int(2))));\n    assert_eq!(ast[1], Node::VariableBlock(WS::default(), Expr::new(ExprVal::Float(3.18))));\n    assert_eq!(\n        ast[2],\n        Node::VariableBlock(WS::default(), Expr::new(ExprVal::String(\"hey\".to_string()))),\n    );\n    assert_eq!(ast[3], Node::VariableBlock(WS::default(), Expr::new(ExprVal::Bool(true))));\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_array_lit", "test": "fn parse_variable_tag_array_lit() {\n    let ast = parse(\"{{ [1, 2, 3] }}\").unwrap();\n    let mut join_args = HashMap::new();\n    join_args.insert(\"n\".to_string(), Expr::new(ExprVal::Int(2)));\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Array(vec![\n                Expr::new(ExprVal::Int(1)),\n                Expr::new(ExprVal::Int(2)),\n                Expr::new(ExprVal::Int(3))\n            ]),)\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_array_lit_with_filter", "test": "fn parse_variable_tag_array_lit_with_filter() {\n    let ast = parse(\"{{ [1, 2, 3] | length }}\").unwrap();\n    let mut join_args = HashMap::new();\n    join_args.insert(\"n\".to_string(), Expr::new(ExprVal::Int(2)));\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::with_filters(\n                ExprVal::Array(vec![\n                    Expr::new(ExprVal::Int(1)),\n                    Expr::new(ExprVal::Int(2)),\n                    Expr::new(ExprVal::Int(3))\n                ]),\n                vec![FunctionCall { name: \"length\".to_string(), args: HashMap::new() },],\n            )\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_lit_math_expression", "test": "fn parse_variable_tag_lit_math_expression() {\n    let ast = parse(\"{{ count + 1 * 2.5 }}\").unwrap();\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Math(MathExpr {\n                lhs: Box::new(Expr::new(ExprVal::Ident(\"count\".to_string()))),\n                operator: MathOperator::Add,\n                rhs: Box::new(Expr::new(ExprVal::Math(MathExpr {\n                    lhs: Box::new(Expr::new(ExprVal::Int(1))),\n                    operator: MathOperator::Mul,\n                    rhs: Box::new(Expr::new(ExprVal::Float(2.5))),\n                },))),\n            },))\n        ),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_lit_math_expression_with_parentheses", "test": "fn parse_variable_tag_lit_math_expression_with_parentheses() {\n    let ast = parse(\"{{ (count + 1) * 2.5 }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Math(MathExpr {\n                lhs: Box::new(Expr::new(ExprVal::Math(MathExpr {\n                    lhs: Box::new(Expr::new(ExprVal::Ident(\"count\".to_string()))),\n                    operator: MathOperator::Add,\n                    rhs: Box::new(Expr::new(ExprVal::Int(1))),\n                },))),\n                operator: MathOperator::Mul,\n                rhs: Box::new(Expr::new(ExprVal::Float(2.5))),\n            },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_lit_math_expression_with_parentheses_and_filter", "test": "fn parse_variable_tag_lit_math_expression_with_parentheses_and_filter() {\n    let ast = parse(\"{{ (count + 1) * 2.5 | round }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::with_filters(\n                ExprVal::Math(MathExpr {\n                    lhs: Box::new(Expr::new(ExprVal::Math(MathExpr {\n                        lhs: Box::new(Expr::new(ExprVal::Ident(\"count\".to_string()))),\n                        operator: MathOperator::Add,\n                        rhs: Box::new(Expr::new(ExprVal::Int(1))),\n                    },))),\n                    operator: MathOperator::Mul,\n                    rhs: Box::new(Expr::new(ExprVal::Float(2.5))),\n                },),\n                vec![FunctionCall { name: \"round\".to_string(), args: HashMap::new() },],\n            )\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_math_on_filter", "test": "fn parse_variable_math_on_filter() {\n    let ast = parse(\"{{ a | length - 1 }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Math(MathExpr {\n                lhs: Box::new(Expr::with_filters(\n                    ExprVal::Ident(\"a\".to_string()),\n                    vec![FunctionCall { name: \"length\".to_string(), args: HashMap::new() },],\n                )),\n                operator: MathOperator::Sub,\n                rhs: Box::new(Expr::new(ExprVal::Int(1))),\n            },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_simple_logic_expression", "test": "fn parse_variable_tag_simple_logic_expression() {\n    let ast = parse(\"{{ 1 > 2 }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Logic(LogicExpr {\n                lhs: Box::new(Expr::new(ExprVal::Int(1))),\n                operator: LogicOperator::Gt,\n                rhs: Box::new(Expr::new(ExprVal::Int(2))),\n            },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_math_and_logic_expression", "test": "fn parse_variable_tag_math_and_logic_expression() {\n    let ast = parse(\"{{ count + 1 * 2.5 and admin }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Logic(LogicExpr {\n                lhs: Box::new(Expr::new(ExprVal::Math(MathExpr {\n                    lhs: Box::new(Expr::new(ExprVal::Ident(\"count\".to_string()))),\n                    operator: MathOperator::Add,\n                    rhs: Box::new(Expr::new(ExprVal::Math(MathExpr {\n                        lhs: Box::new(Expr::new(ExprVal::Int(1))),\n                        operator: MathOperator::Mul,\n                        rhs: Box::new(Expr::new(ExprVal::Float(2.5))),\n                    },))),\n                },))),\n                operator: LogicOperator::And,\n                rhs: Box::new(Expr::new(ExprVal::Ident(\"admin\".to_string()))),\n            },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_math_with_filters_and_logic_expression", "test": "fn parse_variable_tag_math_with_filters_and_logic_expression() {\n    let ast = parse(\"{{ count + 1 * 2.5 | round and admin }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Logic(LogicExpr {\n                lhs: Box::new(Expr::with_filters(\n                    ExprVal::Math(MathExpr {\n                        lhs: Box::new(Expr::new(ExprVal::Ident(\"count\".to_string()))),\n                        operator: MathOperator::Add,\n                        rhs: Box::new(Expr::new(ExprVal::Math(MathExpr {\n                            lhs: Box::new(Expr::new(ExprVal::Int(1))),\n                            operator: MathOperator::Mul,\n                            rhs: Box::new(Expr::new(ExprVal::Float(2.5))),\n                        },))),\n                    },),\n                    vec![FunctionCall { name: \"round\".to_string(), args: HashMap::new() },],\n                )),\n                operator: LogicOperator::And,\n                rhs: Box::new(Expr::new(ExprVal::Ident(\"admin\".to_string()))),\n            },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_simple_negated_expr", "test": "fn parse_variable_tag_simple_negated_expr() {\n    let ast = parse(\"{{ not id }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(WS::default(), Expr::new_negated(ExprVal::Ident(\"id\".to_string())))\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_test", "test": "fn parse_test() {\n    let ast = parse(\"{{ a is divisibleby(2) }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Test(Test {\n                ident: \"a\".to_string(),\n                negated: false,\n                name: \"divisibleby\".to_string(),\n                args: vec![Expr::new(ExprVal::Int(2))]\n            }))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_negated_expr", "test": "fn parse_variable_tag_negated_expr() {\n    let ast = parse(\"{{ not id and not true and not 1 + 1 }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Logic(LogicExpr {\n                lhs: Box::new(Expr::new(ExprVal::Logic(LogicExpr {\n                    lhs: Box::new(Expr::new_negated(ExprVal::Ident(\"id\".to_string()))),\n                    operator: LogicOperator::And,\n                    rhs: Box::new(Expr::new_negated(ExprVal::Bool(true))),\n                },))),\n                operator: LogicOperator::And,\n                rhs: Box::new(Expr::new_negated(ExprVal::Math(MathExpr {\n                    lhs: Box::new(Expr::new(ExprVal::Int(1))),\n                    operator: MathOperator::Add,\n                    rhs: Box::new(Expr::new(ExprVal::Int(1))),\n                },))),\n            },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_simple_test", "test": "fn parse_variable_tag_simple_test() {\n    let ast = parse(\"{{ id is defined }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Test(Test {\n                ident: \"id\".to_string(),\n                negated: false,\n                name: \"defined\".to_string(),\n                args: vec![],\n            },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_simple_negated_test", "test": "fn parse_variable_tag_simple_negated_test() {\n    let ast = parse(\"{{ id is not defined }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Test(Test {\n                ident: \"id\".to_string(),\n                negated: true,\n                name: \"defined\".to_string(),\n                args: vec![],\n            },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_test_as_expression", "test": "fn parse_variable_tag_test_as_expression() {\n    let ast = parse(\"{{ user is defined and user.admin }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::Logic(LogicExpr {\n                lhs: Box::new(Expr::new(ExprVal::Test(Test {\n                    ident: \"user\".to_string(),\n                    negated: false,\n                    name: \"defined\".to_string(),\n                    args: vec![],\n                },))),\n                operator: LogicOperator::And,\n                rhs: Box::new(Expr::new(ExprVal::Ident(\"user.admin\".to_string()))),\n            },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_macro_call", "test": "fn parse_variable_tag_macro_call() {\n    let ast = parse(\"{{ macros::get_time(some=1) }}\").unwrap();\n    let mut args = HashMap::new();\n    args.insert(\"some\".to_string(), Expr::new(ExprVal::Int(1)));\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::MacroCall(MacroCall {\n                namespace: \"macros\".to_string(),\n                name: \"get_time\".to_string(),\n                args,\n            },)),\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_allow_block_in_filter_section", "test": "fn parse_allow_block_in_filter_section() {\n    let ast =\n        parse(\"{% filter upper %}{% block content %}Hello{% endblock %}{% endfilter %}\").unwrap();\n\n    assert_eq!(\n        ast[0],\n        Node::FilterSection(\n            WS::default(),\n            FilterSection {\n                filter: FunctionCall { name: \"upper\".to_owned(), args: HashMap::default() },\n                body: vec![Node::Block(\n                    WS::default(),\n                    Block {\n                        name: \"content\".to_owned(),\n                        body: vec![Node::Text(\"Hello\".to_owned())]\n                    },\n                    WS::default(),\n                )],\n            },\n            WS::default(),\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_macro_call_with_array", "test": "fn parse_variable_tag_macro_call_with_array() {\n    let ast = parse(\"{{ macros::get_time(some=[1, 2]) }}\").unwrap();\n    let mut args = HashMap::new();\n    args.insert(\n        \"some\".to_string(),\n        Expr::new(ExprVal::Array(vec![Expr::new(ExprVal::Int(1)), Expr::new(ExprVal::Int(2))])),\n    );\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::MacroCall(MacroCall {\n                namespace: \"macros\".to_string(),\n                name: \"get_time\".to_string(),\n                args,\n            },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_macro_call_with_array_with_filters", "test": "fn parse_variable_tag_macro_call_with_array_with_filters() {\n    let ast = parse(\"{{ macros::get_time(some=[1, 2] | reverse) }}\").unwrap();\n    let mut args = HashMap::new();\n    args.insert(\n        \"some\".to_string(),\n        Expr::with_filters(\n            ExprVal::Array(vec![Expr::new(ExprVal::Int(1)), Expr::new(ExprVal::Int(2))]),\n            vec![FunctionCall { name: \"reverse\".to_string(), args: HashMap::new() }],\n        ),\n    );\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::MacroCall(MacroCall {\n                namespace: \"macros\".to_string(),\n                name: \"get_time\".to_string(),\n                args,\n            },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_macro_call_with_filter", "test": "fn parse_variable_tag_macro_call_with_filter() {\n    let ast = parse(\"{{ macros::get_time(some=1) | round }}\").unwrap();\n    let mut args = HashMap::new();\n    args.insert(\"some\".to_string(), Expr::new(ExprVal::Int(1)));\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::with_filters(\n                ExprVal::MacroCall(MacroCall {\n                    namespace: \"macros\".to_string(),\n                    name: \"get_time\".to_string(),\n                    args,\n                },),\n                vec![FunctionCall { name: \"round\".to_string(), args: HashMap::new() },],\n            )\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_global_function", "test": "fn parse_variable_tag_global_function() {\n    let ast = parse(\"{{ get_time(some=1) }}\").unwrap();\n    let mut args = HashMap::new();\n    args.insert(\"some\".to_string(), Expr::new(ExprVal::Int(1)));\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::FunctionCall(FunctionCall { name: \"get_time\".to_string(), args },))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_in_condition", "test": "fn parse_in_condition() {\n    let ast = parse(\"{{ b in c }}\").unwrap();\n    let mut args = HashMap::new();\n    args.insert(\"some\".to_string(), Expr::new(ExprVal::Int(1)));\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::In(In {\n                lhs: Box::new(Expr::new(ExprVal::Ident(\"b\".to_string()))),\n                rhs: Box::new(Expr::new(ExprVal::Ident(\"c\".to_string()))),\n                negated: false,\n            }))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_negated_in_condition", "test": "fn parse_negated_in_condition() {\n    let ast = parse(\"{{ b not in c }}\").unwrap();\n    let mut args = HashMap::new();\n    args.insert(\"some\".to_string(), Expr::new(ExprVal::Int(1)));\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::In(In {\n                lhs: Box::new(Expr::new(ExprVal::Ident(\"b\".to_string()))),\n                rhs: Box::new(Expr::new(ExprVal::Ident(\"c\".to_string()))),\n                negated: true,\n            }))\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_variable_tag_global_function_with_filter", "test": "fn parse_variable_tag_global_function_with_filter() {\n    let ast = parse(\"{{ get_time(some=1) | round | upper }}\").unwrap();\n    let mut args = HashMap::new();\n    args.insert(\"some\".to_string(), Expr::new(ExprVal::Int(1)));\n\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::with_filters(\n                ExprVal::FunctionCall(FunctionCall { name: \"get_time\".to_string(), args },),\n                vec![\n                    FunctionCall { name: \"round\".to_string(), args: HashMap::new() },\n                    FunctionCall { name: \"upper\".to_string(), args: HashMap::new() },\n                ],\n            )\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_comment_tag", "test": "fn parse_comment_tag() {\n    let ast = parse(\"{# hey #}\").unwrap();\n    assert!(ast.is_empty());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_set_tag_lit", "test": "fn parse_set_tag_lit() {\n    let ast = parse(\"{% set hello = \\\"hi\\\" %}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::Set(\n            WS::default(),\n            Set {\n                key: \"hello\".to_string(),\n                value: Expr::new(ExprVal::String(\"hi\".to_string())),\n                global: false,\n            },\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_set_tag_macro_call", "test": "fn parse_set_tag_macro_call() {\n    let ast = parse(\"{% set hello = macros::something() %}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::Set(\n            WS::default(),\n            Set {\n                key: \"hello\".to_string(),\n                value: Expr::new(ExprVal::MacroCall(MacroCall {\n                    namespace: \"macros\".to_string(),\n                    name: \"something\".to_string(),\n                    args: HashMap::new(),\n                },)),\n                global: false,\n            },\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_set_tag_fn_call", "test": "fn parse_set_tag_fn_call() {\n    let ast = parse(\"{% set hello = utcnow() %}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::Set(\n            WS::default(),\n            Set {\n                key: \"hello\".to_string(),\n                value: Expr::new(ExprVal::FunctionCall(FunctionCall {\n                    name: \"utcnow\".to_string(),\n                    args: HashMap::new(),\n                },)),\n                global: false,\n            },\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_set_array", "test": "fn parse_set_array() {\n    let ast = parse(\"{% set hello = [1, true, 'hello'] %}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::Set(\n            WS::default(),\n            Set {\n                key: \"hello\".to_string(),\n                value: Expr::new(ExprVal::Array(vec![\n                    Expr::new(ExprVal::Int(1)),\n                    Expr::new(ExprVal::Bool(true)),\n                    Expr::new(ExprVal::String(\"hello\".to_string())),\n                ])),\n                global: false,\n            },\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_set_array_with_filter", "test": "fn parse_set_array_with_filter() {\n    let ast = parse(\"{% set hello = [1, true, 'hello'] | length %}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::Set(\n            WS::default(),\n            Set {\n                key: \"hello\".to_string(),\n                value: Expr::with_filters(\n                    ExprVal::Array(vec![\n                        Expr::new(ExprVal::Int(1)),\n                        Expr::new(ExprVal::Bool(true)),\n                        Expr::new(ExprVal::String(\"hello\".to_string())),\n                    ]),\n                    vec![FunctionCall { name: \"length\".to_string(), args: HashMap::new() },],\n                ),\n                global: false,\n            },\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_set_global_tag", "test": "fn parse_set_global_tag() {\n    let ast = parse(\"{% set_global hello = utcnow() %}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::Set(\n            WS::default(),\n            Set {\n                key: \"hello\".to_string(),\n                value: Expr::new(ExprVal::FunctionCall(FunctionCall {\n                    name: \"utcnow\".to_string(),\n                    args: HashMap::new(),\n                },)),\n                global: true,\n            },\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_raw_tag", "test": "fn parse_raw_tag() {\n    let ast = parse(\"{% raw -%}{{hey}}{%- endraw %}\").unwrap();\n    let start_ws = WS { right: true, ..Default::default() };\n    let end_ws = WS { left: true, ..Default::default() };\n\n    assert_eq!(ast[0], Node::Raw(start_ws, \"{{hey}}\".to_string(), end_ws));\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_raw_tag_with_ws", "test": "fn parse_raw_tag_with_ws() {\n    // println!(\"{}\", parse(\"{% raw %}    yaml_test:     {% endraw %}\").unwrap_err());\n    let ast = parse(\"{% raw %}    yaml_test:     {% endraw %}\").unwrap();\n    let start_ws = WS::default();\n    let end_ws = WS::default();\n\n    assert_eq!(ast[0], Node::Raw(start_ws, \"    yaml_test:     \".to_string(), end_ws));\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_filter_section_without_args", "test": "fn parse_filter_section_without_args() {\n    let ast = parse(\"{% filter upper -%}A{%- endfilter %}\").unwrap();\n    let start_ws = WS { right: true, ..Default::default() };\n    let end_ws = WS { left: true, ..Default::default() };\n\n    assert_eq!(\n        ast[0],\n        Node::FilterSection(\n            start_ws,\n            FilterSection {\n                filter: FunctionCall { name: \"upper\".to_string(), args: HashMap::new() },\n                body: vec![Node::Text(\"A\".to_string())],\n            },\n            end_ws,\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_filter_section_with_args", "test": "fn parse_filter_section_with_args() {\n    let ast = parse(\"{% filter upper(attr=1) -%}A{%- endfilter %}\").unwrap();\n    let start_ws = WS { right: true, ..Default::default() };\n    let end_ws = WS { left: true, ..Default::default() };\n\n    let mut args = HashMap::new();\n    args.insert(\"attr\".to_string(), Expr::new(ExprVal::Int(1)));\n\n    assert_eq!(\n        ast[0],\n        Node::FilterSection(\n            start_ws,\n            FilterSection {\n                filter: FunctionCall { name: \"upper\".to_string(), args },\n                body: vec![Node::Text(\"A\".to_string())],\n            },\n            end_ws,\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_filter_section_preserves_ws", "test": "fn parse_filter_section_preserves_ws() {\n    let ast = parse(\"{% filter upper %}  {{a}}  B  {% endfilter %}\").unwrap();\n\n    assert_eq!(\n        ast[0],\n        Node::FilterSection(\n            WS::default(),\n            FilterSection {\n                filter: FunctionCall { name: \"upper\".to_string(), args: HashMap::new() },\n                body: vec![\n                    Node::Text(\"  \".to_string()),\n                    Node::VariableBlock(WS::default(), Expr::new(ExprVal::Ident(\"a\".to_string()))),\n                    Node::Text(\"  B  \".to_string())\n                ]\n            },\n            WS::default(),\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_block", "test": "fn parse_block() {\n    let ast = parse(\"{% block hello %}{{super()}} hey{%- endblock hello %}\").unwrap();\n    let start_ws = WS::default();\n    let end_ws = WS { left: true, ..Default::default() };\n\n    assert_eq!(\n        ast[0],\n        Node::Block(\n            start_ws,\n            Block {\n                name: \"hello\".to_string(),\n                body: vec![Node::Super, Node::Text(\" hey\".to_string())],\n            },\n            end_ws,\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_simple_macro_definition", "test": "fn parse_simple_macro_definition() {\n    let ast = parse(\"{% macro hello(a=1, b='hello', c) %}A: {{a}}{% endmacro %}\").unwrap();\n    let mut args = HashMap::new();\n    args.insert(\"a\".to_string(), Some(Expr::new(ExprVal::Int(1))));\n    args.insert(\"b\".to_string(), Some(Expr::new(ExprVal::String(\"hello\".to_string()))));\n    args.insert(\"c\".to_string(), None);\n\n    assert_eq!(\n        ast[0],\n        Node::MacroDefinition(\n            WS::default(),\n            MacroDefinition {\n                name: \"hello\".to_string(),\n                args,\n                body: vec![\n                    Node::Text(\"A: \".to_string()),\n                    Node::VariableBlock(WS::default(), Expr::new(ExprVal::Ident(\"a\".to_string()))),\n                ],\n            },\n            WS::default(),\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_value_forloop", "test": "fn parse_value_forloop() {\n    let ast = parse(\"{% for item in items | reverse %}A{%- endfor %}\").unwrap();\n    let start_ws = WS::default();\n    let end_ws = WS { left: true, ..Default::default() };\n\n    assert_eq!(\n        ast[0],\n        Node::Forloop(\n            start_ws,\n            Forloop {\n                key: None,\n                value: \"item\".to_string(),\n                container: Expr::with_filters(\n                    ExprVal::Ident(\"items\".to_string()),\n                    vec![FunctionCall { name: \"reverse\".to_string(), args: HashMap::new() },],\n                ),\n                body: vec![Node::Text(\"A\".to_string())],\n                empty_body: None,\n            },\n            end_ws,\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_key_value_forloop", "test": "fn parse_key_value_forloop() {\n    let ast = parse(\"{% for key, item in get_map() %}A{%- endfor %}\").unwrap();\n    let start_ws = WS::default();\n    let end_ws = WS { left: true, ..Default::default() };\n\n    assert_eq!(\n        ast[0],\n        Node::Forloop(\n            start_ws,\n            Forloop {\n                key: Some(\"key\".to_string()),\n                value: \"item\".to_string(),\n                container: Expr::new(ExprVal::FunctionCall(FunctionCall {\n                    name: \"get_map\".to_string(),\n                    args: HashMap::new(),\n                },)),\n                body: vec![Node::Text(\"A\".to_string())],\n                empty_body: None,\n            },\n            end_ws,\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_value_forloop_array", "test": "fn parse_value_forloop_array() {\n    let ast = parse(\"{% for item in [1,2,] %}A{%- endfor %}\").unwrap();\n    let start_ws = WS::default();\n    let end_ws = WS { left: true, ..Default::default() };\n\n    assert_eq!(\n        ast[0],\n        Node::Forloop(\n            start_ws,\n            Forloop {\n                key: None,\n                value: \"item\".to_string(),\n                container: Expr::new(ExprVal::Array(vec![\n                    Expr::new(ExprVal::Int(1)),\n                    Expr::new(ExprVal::Int(2)),\n                ])),\n                body: vec![Node::Text(\"A\".to_string())],\n                empty_body: None,\n            },\n            end_ws,\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_value_forloop_array_with_filter", "test": "fn parse_value_forloop_array_with_filter() {\n    let ast = parse(\"{% for item in [1,2,] | reverse %}A{%- endfor %}\").unwrap();\n    let start_ws = WS::default();\n    let end_ws = WS { left: true, ..Default::default() };\n\n    assert_eq!(\n        ast[0],\n        Node::Forloop(\n            start_ws,\n            Forloop {\n                key: None,\n                value: \"item\".to_string(),\n                container: Expr::with_filters(\n                    ExprVal::Array(vec![Expr::new(ExprVal::Int(1)), Expr::new(ExprVal::Int(2)),]),\n                    vec![FunctionCall { name: \"reverse\".to_string(), args: HashMap::new() },],\n                ),\n                body: vec![Node::Text(\"A\".to_string())],\n                empty_body: None,\n            },\n            end_ws,\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_value_forloop_empty", "test": "fn parse_value_forloop_empty() {\n    let ast = parse(\"{% for item in [1,2,] %}A{% else %}B{%- endfor %}\").unwrap();\n    let start_ws = WS::default();\n    let end_ws = WS { left: true, ..Default::default() };\n\n    assert_eq!(\n        ast[0],\n        Node::Forloop(\n            start_ws,\n            Forloop {\n                key: None,\n                value: \"item\".to_string(),\n                container: Expr::new(ExprVal::Array(vec![\n                    Expr::new(ExprVal::Int(1)),\n                    Expr::new(ExprVal::Int(2)),\n                ])),\n                body: vec![Node::Text(\"A\".to_string())],\n                empty_body: Some(vec![Node::Text(\"B\".to_string())]),\n            },\n            end_ws,\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_if", "test": "fn parse_if() {\n    let ast = parse(\"{% if item or admin %}A {%- elif 1 > 2 %}B{% else -%} C{%- endif %}\").unwrap();\n    let end_ws = WS { left: true, ..Default::default() };\n    let else_ws = WS { right: true, ..Default::default() };\n\n    assert_eq!(\n        ast[0],\n        Node::If(\n            If {\n                conditions: vec![\n                    (\n                        WS::default(),\n                        Expr::new(ExprVal::Logic(LogicExpr {\n                            lhs: Box::new(Expr::new(ExprVal::Ident(\"item\".to_string()))),\n                            operator: LogicOperator::Or,\n                            rhs: Box::new(Expr::new(ExprVal::Ident(\"admin\".to_string()))),\n                        })),\n                        vec![Node::Text(\"A \".to_string())],\n                    ),\n                    (\n                        end_ws,\n                        Expr::new(ExprVal::Logic(LogicExpr {\n                            lhs: Box::new(Expr::new(ExprVal::Int(1))),\n                            operator: LogicOperator::Gt,\n                            rhs: Box::new(Expr::new(ExprVal::Int(2))),\n                        })),\n                        vec![Node::Text(\"B\".to_string())],\n                    ),\n                ],\n                otherwise: Some((else_ws, vec![Node::Text(\" C\".to_string())])),\n            },\n            end_ws,\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_break", "test": "fn parse_break() {\n    let ast = parse(\"{% for item in items %}{% break -%}{% endfor %}\").unwrap();\n    let for_ws = WS::default();\n    assert_eq!(\n        ast[0],\n        Node::Forloop(\n            for_ws,\n            Forloop {\n                key: None,\n                value: \"item\".to_string(),\n                container: Expr::new(ExprVal::Ident(\"items\".to_string())),\n                body: vec![Node::Break(WS { left: false, right: true }),],\n                empty_body: None,\n            },\n            for_ws,\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_continue", "test": "fn parse_continue() {\n    let ast = parse(\"{% for item in items %}{% continue -%}{% endfor %}\").unwrap();\n    let for_ws = WS::default();\n    assert_eq!(\n        ast[0],\n        Node::Forloop(\n            for_ws,\n            Forloop {\n                key: None,\n                value: \"item\".to_string(),\n                container: Expr::new(ExprVal::Ident(\"items\".to_string())),\n                body: vec![Node::Continue(WS { left: false, right: true }),],\n                empty_body: None,\n            },\n            for_ws,\n        )\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_string_concat_can_merge", "test": "fn parse_string_concat_can_merge() {\n    let ast = parse(\"{{ `hello` ~ 'hey' }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(WS::default(), Expr::new(ExprVal::String(\"hellohey\".to_string()))),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_string_concat", "test": "fn parse_string_concat() {\n    let ast = parse(\"{{ `hello` ~ ident }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::StringConcat(StringConcat {\n                values: vec![\n                    ExprVal::String(\"hello\".to_string()),\n                    ExprVal::Ident(\"ident\".to_string()),\n                ]\n            }))\n        ),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/parser.rs::parse_string_concat_multiple", "test": "fn parse_string_concat_multiple() {\n    let ast = parse(\"{{ `hello` ~ ident ~ 'ho' }}\").unwrap();\n    assert_eq!(\n        ast[0],\n        Node::VariableBlock(\n            WS::default(),\n            Expr::new(ExprVal::StringConcat(StringConcat {\n                values: vec![\n                    ExprVal::String(\"hello\".to_string()),\n                    ExprVal::Ident(\"ident\".to_string()),\n                    ExprVal::String(\"ho\".to_string()),\n                ]\n            }))\n        ),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/parser/tests/whitespace.rs::do_nothing_if_unneeded", "test": "fn do_nothing_if_unneeded() {\n    let ast = vec![Node::Text(\"hey \".to_string())];\n    assert_eq!(remove_whitespace(ast.clone(), None), ast);\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_simple_string", "test": "fn render_simple_string() {\n    let result = render_template(\"<h1>Hello world</h1>\", &Context::new());\n    assert_eq!(result.unwrap(), \"<h1>Hello world</h1>\".to_owned());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_variable_block_autoescaping_disabled", "test": "fn render_variable_block_autoescaping_disabled() {\n    let mut context = Context::new();\n    context.insert(\"name\", &\"john\");\n    context.insert(\"malicious\", &\"<html>\");\n\n    let inputs = vec![\n        (\"{{ name }}\", \"john\"),\n        (\"{{ malicious }}\", \"<html>\"),\n        (\"{{ malicious | safe }}\", \"<html>\"),\n        (\"{{ malicious | upper }}\", \"<HTML>\"),\n        (\"{{ malicious | upper | safe }}\", \"<HTML>\"),\n        (\"{{ malicious | safe | upper }}\", \"<HTML>\"),\n    ];\n\n    for (input, expected) in inputs {\n        let mut tera = Tera::default();\n        tera.add_raw_template(\"hello.sql\", input).unwrap();\n        assert_eq!(tera.render(\"hello.sql\", &context).unwrap(), expected);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_include_tag", "test": "fn render_include_tag() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"world\", \"world\"),\n        (\"hello\", \"<h1>Hello {% include \\\"world\\\" %}</h1>\"),\n    ])\n    .unwrap();\n    let result = tera.render(\"hello\", &Context::new()).unwrap();\n    assert_eq!(result, \"<h1>Hello world</h1>\".to_owned());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_include_array_tag", "test": "fn render_include_array_tag() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"world\", \"world\"),\n        (\"hello\", \"<h1>Hello {% include [\\\"custom/world\\\", \\\"world\\\"] %}</h1>\"),\n    ])\n    .unwrap();\n    let result = tera.render(\"hello\", &Context::new()).unwrap();\n    assert_eq!(result, \"<h1>Hello world</h1>\".to_owned());\n\n    tera.add_raw_template(\"custom/world\", \"custom world\").unwrap();\n    let result = tera.render(\"hello\", &Context::new()).unwrap();\n    assert_eq!(result, \"<h1>Hello custom world</h1>\".to_owned());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_include_tag_missing", "test": "fn render_include_tag_missing() {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello\", \"<h1>Hello {% include \\\"world\\\" %}</h1>\").unwrap();\n    let result = tera.render(\"hello\", &Context::new());\n    assert!(result.is_err());\n\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"hello\", \"<h1>Hello {% include \\\"world\\\" ignore missing %}</h1>\")\n        .unwrap();\n    let result = tera.render(\"hello\", &Context::new()).unwrap();\n    assert_eq!(result, \"<h1>Hello </h1>\".to_owned());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::can_set_variables_in_included_templates", "test": "fn can_set_variables_in_included_templates() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"world\", r#\"{% set a = \"world\" %}{{a}}\"#),\n        (\"hello\", \"<h1>Hello {% include \\\"world\\\" %}</h1>\"),\n    ])\n    .unwrap();\n    let result = tera.render(\"hello\", &Context::new()).unwrap();\n    assert_eq!(result, \"<h1>Hello world</h1>\".to_owned());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_magic_variable_isnt_escaped", "test": "fn render_magic_variable_isnt_escaped() {\n    let mut context = Context::new();\n    context.insert(\"html\", &\"<html>\");\n\n    let result = render_template(\"{{ __tera_context }}\", &context);\n\n    assert_eq!(\n        result.unwrap(),\n        r#\"{\n  \"html\": \"<html>\"\n}\"#\n        .to_owned()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::can_set_variable_in_global_context_in_forloop", "test": "fn can_set_variable_in_global_context_in_forloop() {\n    let mut context = Context::new();\n    context.insert(\"tags\", &vec![1, 2, 3]);\n    context.insert(\"default\", &\"default\");\n\n    let result = render_template(\n        r#\"\n{%- for i in tags -%}\n{%- set default = 1 -%}\n{%- set_global global_val = i -%}\n{%- endfor -%}\n{{ default }}{{ global_val }}\"#,\n        &context,\n    );\n\n    assert_eq!(result.unwrap(), \"default3\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::can_fail_rendering_from_template", "test": "fn can_fail_rendering_from_template() {\n    let mut context = Context::new();\n    context.insert(\"title\", \"hello\");\n\n    let res = render_template(\n        r#\"{{ throw(message=\"Error: \" ~ title ~ \" did not include a summary\") }}\"#,\n        &context,\n    );\n\n    let err = res.expect_err(\"This should always fail to render\");\n    let source = err.source().expect(\"Must have a source\");\n    assert_eq!(source.to_string(), \"Function call 'throw' failed\");\n\n    let source = source.source().expect(\"Should have a nested error\");\n    assert_eq!(source.to_string(), \"Error: hello did not include a summary\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_magic_variable_gets_all_contexts", "test": "fn render_magic_variable_gets_all_contexts() {\n    let mut context = Context::new();\n    context.insert(\"html\", &\"<html>\");\n    context.insert(\"num\", &1);\n    context.insert(\"i\", &10);\n\n    let result = render_template(\n        \"{% set some_val = 1 %}{% for i in range(start=0, end=1) %}{% set for_val = i %}{{ __tera_context }}{% endfor %}\",\n        &context\n    );\n\n    assert_eq!(\n        result.unwrap(),\n        r#\"{\n  \"for_val\": 0,\n  \"html\": \"<html>\",\n  \"i\": 0,\n  \"num\": 1,\n  \"some_val\": 1\n}\"#\n        .to_owned()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::render_magic_variable_macro_doesnt_leak", "test": "fn render_magic_variable_macro_doesnt_leak() {\n    let mut context = Context::new();\n    context.insert(\"html\", &\"<html>\");\n    context.insert(\"num\", &1);\n    context.insert(\"i\", &10);\n\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello(arg=1) %}{{ __tera_context }}{% endmacro hello %}\"),\n        (\"tpl\", \"{% import \\\"macros\\\" as macros %}{{macros::hello()}}\"),\n    ])\n    .unwrap();\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(\n        result.unwrap(),\n        r#\"{\n  \"arg\": 1\n}\"#\n        .to_owned()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::redefining_loop_value_doesnt_break_loop", "test": "fn redefining_loop_value_doesnt_break_loop() {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\n        \"tpl\",\n        r#\"\n{%- set string = \"abcdefghdijklm\" | split(pat=\"d\") -%}\n{% for i in string -%}\n    {%- set j = i ~ \"lol\" ~ \" \" -%}\n    {{ j }}\n{%- endfor -%}\n        \"#,\n    )\n    .unwrap();\n    let context = Context::new();\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(result.unwrap(), \"abclol efghlol ijklmlol \");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::can_use_concat_to_push_to_array", "test": "fn can_use_concat_to_push_to_array() {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\n        \"tpl\",\n        r#\"\n{%- set ids = [] -%}\n{% for i in range(end=5) -%}\n{%- set_global ids = ids | concat(with=i) -%}\n{%- endfor -%}\n{{ids}}\"#,\n    )\n    .unwrap();\n    let context = Context::new();\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(result.unwrap(), \"[0, 1, 2, 3, 4]\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::stateful_global_fn", "test": "fn stateful_global_fn() {\n    fn make_tera() -> Tera {\n        let mut tera = Tera::default();\n        tera.add_raw_template(\n            \"fn.html\",\n            \"<h1>{{ get_next() }}, {{ get_next_shared() }}, {{ get_next() }}...</h1>\",\n        )\n        .unwrap();\n\n        tera.register_function(\"get_next\", Next(AtomicUsize::new(1)));\n        tera.register_function(\"get_next_shared\", NEXT_GLOBAL.clone());\n        tera\n    }\n\n    assert_eq!(\n        make_tera().render(\"fn.html\", &Context::new()).unwrap(),\n        \"<h1>1, 1, 2...</h1>\".to_owned()\n    );\n    assert_eq!(\n        make_tera().render(\"fn.html\", &Context::new()).unwrap(),\n        \"<h1>1, 2, 2...</h1>\".to_owned()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::split_on_context_value", "test": "fn split_on_context_value() {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"split.html\", r#\"{{ body | split(pat=\"\\n\") }}\"#).unwrap();\n    let mut context = Context::new();\n    context.insert(\"body\", \"multi\\nple\\nlines\");\n    let res = tera.render(\"split.html\", &context);\n    assert_eq!(res.unwrap(), \"[multi, ple, lines]\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::default_filter_works_in_condition", "test": "fn default_filter_works_in_condition() {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\"test.html\", r#\"{% if frobnicate|default(value=True) %}here{% endif %}\"#)\n        .unwrap();\n    let res = tera.render(\"test.html\", &Context::new());\n    assert_eq!(res.unwrap(), \"here\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::safe_filter_works", "test": "fn safe_filter_works() {\n    struct Safe;\n    impl crate::Filter for Safe {\n        fn filter(&self, value: &Value, _args: &HashMap<String, Value>) -> Result<Value> {\n            Ok(Value::String(format!(\"<div>{}</div>\", value.as_str().unwrap())))\n        }\n\n        fn is_safe(&self) -> bool {\n            true\n        }\n    }\n\n    let mut tera = Tera::default();\n    tera.register_filter(\"safe_filter\", Safe);\n    tera.add_raw_template(\"test.html\", r#\"{{ \"Hello\" | safe_filter }}\"#).unwrap();\n\n    let res = tera.render(\"test.html\", &Context::new());\n    assert_eq!(res.unwrap(), \"<div>Hello</div>\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/basic.rs::safe_function_works", "test": "fn safe_function_works() {\n    struct Safe;\n    impl crate::Function for Safe {\n        fn call(&self, _args: &HashMap<String, Value>) -> Result<Value> {\n            Ok(Value::String(\"<div>Hello</div>\".to_owned()))\n        }\n\n        fn is_safe(&self) -> bool {\n            true\n        }\n    }\n\n    let mut tera = Tera::default();\n    tera.register_function(\"safe_function\", Safe);\n    tera.add_raw_template(\"test.html\", \"{{ safe_function() }}\").unwrap();\n\n    let res = tera.render(\"test.html\", &Context::new());\n    assert_eq!(res.unwrap(), \"<div>Hello</div>\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_location_basic", "test": "fn error_location_basic() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![(\"tpl\", \"{{ 1 + true }}\")]).unwrap();\n\n    let result = tera.render(\"tpl\", &Context::new());\n\n    assert_eq!(result.unwrap_err().to_string(), \"Failed to render \\'tpl\\'\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_location_inside_macro", "test": "fn error_location_inside_macro() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}{{ 1 + true }}{% endmacro hello %}\"),\n        (\"tpl\", \"{% import \\\"macros\\\" as macros %}{{ macros::hello() }}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"tpl\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().to_string(),\n        \"Failed to render \\'tpl\\': error while rendering macro `macros::hello`\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_loading_macro_from_unloaded_namespace", "test": "fn error_loading_macro_from_unloaded_namespace() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}{{ 1 + true }}{% endmacro hello %}\"),\n        (\"tpl\", \"{% import \\\"macros\\\" as macros %}{{ macro::hello() }}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"tpl\", &Context::new());\n    println!(\"{:#?}\", result);\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Macro namespace `macro` was not found in template `tpl`. Have you maybe forgotten to import it, or misspelled it?\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_location_base_template", "test": "fn error_location_base_template() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"parent\", \"Hello {{ greeting + 1}} {% block bob %}{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block bob %}Hey{% endblock bob %}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().to_string(),\n        \"Failed to render \\'child\\' (error happened in 'parent').\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_location_in_parent_block", "test": "fn error_location_in_parent_block() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"parent\", \"Hello {{ greeting }} {% block bob %}{{ 1 + true }}{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block bob %}{{ super() }}Hey{% endblock bob %}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().to_string(),\n        \"Failed to render \\'child\\' (error happened in 'parent').\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_location_in_parent_in_macro", "test": "fn error_location_in_parent_in_macro() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}{{ 1 + true }}{% endmacro hello %}\"),\n        (\"parent\", \"{% import \\\"macros\\\" as macros %}{{ macros::hello() }}{% block bob %}{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block bob %}{{ super() }}Hey{% endblock bob %}\"),\n    ]).unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().to_string(),\n        \"Failed to render \\'child\\': error while rendering macro `macros::hello` (error happened in \\'parent\\').\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_out_of_range_index", "test": "fn error_out_of_range_index() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![(\"tpl\", \"{{ arr[10] }}\")]).unwrap();\n    let mut context = Context::new();\n    context.insert(\"arr\", &[1, 2, 3]);\n\n    let result = tera.render(\"tpl\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Variable `arr[10]` not found in context while rendering \\'tpl\\': the evaluated version was `arr.10`. Maybe the index is out of bounds?\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_unknown_index_variable", "test": "fn error_unknown_index_variable() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![(\"tpl\", \"{{ arr[a] }}\")]).unwrap();\n    let mut context = Context::new();\n    context.insert(\"arr\", &[1, 2, 3]);\n\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Variable arr[a] can not be evaluated because: Variable `a` not found in context while rendering \\'tpl\\'\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_invalid_type_index_variable", "test": "fn error_invalid_type_index_variable() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![(\"tpl\", \"{{ arr[a] }}\")]).unwrap();\n\n    let mut context = Context::new();\n    context.insert(\"arr\", &[1, 2, 3]);\n    context.insert(\"a\", &true);\n\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Only variables evaluating to String or Number can be used as index (`a` of `arr[a]`)\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_when_missing_macro_templates", "test": "fn error_when_missing_macro_templates() {\n    let mut tera = Tera::default();\n    let result = tera.add_raw_templates(vec![(\n        \"parent\",\n        \"{% import \\\"macros\\\" as macros %}{{ macros::hello() }}{% block bob %}{% endblock bob %}\",\n    )]);\n    assert_eq!(\n        result.unwrap_err().to_string(),\n        \"Template `parent` loads macros from `macros` which isn\\'t present in Tera\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_when_using_variable_set_in_included_templates_outside", "test": "fn error_when_using_variable_set_in_included_templates_outside() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"included\", r#\"{{a}}{% set b = \"hi\" %}-{{b}}\"#),\n        (\"base\", r#\"{{a}}{% include \"included\" %}{{b}}\"#),\n    ])\n    .unwrap();\n    let mut context = Context::new();\n    context.insert(\"a\", &10);\n    let result = tera.render(\"base\", &context);\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Variable `b` not found in context while rendering \\'base\\'\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::right_variable_name_is_needed_in_for_loop", "test": "fn right_variable_name_is_needed_in_for_loop() {\n    let mut data = HashMap::new();\n    data.insert(\"content\", \"hello\");\n    let mut context = Context::new();\n    context.insert(\"comments\", &vec![data]);\n    let mut tera = Tera::default();\n    tera.add_raw_template(\n        \"tpl\",\n        r#\"\n{%- for comment in comments -%}\n<p>{{ comment.content }}</p>\n<p>{{ whocares.content }}</p>\n<p>{{ doesntmatter.content }}</p>\n{% endfor -%}\"#,\n    )\n    .unwrap();\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Variable `whocares.content` not found in context while rendering \\'tpl\\'\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::errors_when_calling_macros_defined_in_file", "test": "fn errors_when_calling_macros_defined_in_file() {\n    let mut tera = Tera::default();\n    tera.add_raw_template(\n        \"tpl\",\n        r#\"\n{% macro path_item(path) %}\n    <span class=\"path\" title=\"{{ path }}\">{{ path }}</span>\n{% endmacro path_item %}\n\n...\n\n<td>{{ self::path_item(path=hello) }}</td>\n        \"#,\n    )\n    .unwrap();\n    let mut context = Context::new();\n    context.insert(\"hello\", &true);\n    let result = tera.render(\"tpl\", &context);\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Invalid macro definition: `path_item`\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::errors_with_inheritance_in_included_template", "test": "fn errors_with_inheritance_in_included_template() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"base\", \"Base - {% include \\\"child\\\" %}\"),\n        (\"parent\", \"{% block title %}Parent{% endblock %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block title %}{{ super() }} - Child{% endblock %}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"base\", &Context::new());\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Inheritance in included templates is currently not supported: extended `parent`\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_string_concat_math_logic", "test": "fn error_string_concat_math_logic() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![(\"tpl\", \"{{ 'ho' ~ name < 10 }}\")]).unwrap();\n    let mut context = Context::new();\n    context.insert(\"name\", &\"john\");\n\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Tried to do math with a string concatenation: 'ho' ~ name\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/errors.rs::error_gives_source_on_tests", "test": "fn error_gives_source_on_tests() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![(\"tpl\", \"{% if a is undefined(1) %}-{% endif %}\")]).unwrap();\n    let result = tera.render(\"tpl\", &Context::new());\n    println!(\"{:?}\", result);\n    let err = result.unwrap_err();\n\n    let source = err.source().unwrap();\n    assert_eq!(source.to_string(), \"Test call \\'undefined\\' failed\");\n    let source2 = source.source().unwrap();\n\n    assert_eq!(\n        source2.to_string(),\n        \"Tester `undefined` was called with some args but this test doesn\\'t take args\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/inheritance.rs::render_simple_inheritance", "test": "fn render_simple_inheritance() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"top\", \"{% block pre %}{% endblock pre %}{% block main %}{% endblock main %}\"),\n        (\"bottom\", \"{% extends \\\"top\\\" %}{% block main %}MAIN{% endblock %}\"),\n    ])\n    .unwrap();\n    let result = tera.render(\"bottom\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"MAIN\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/inheritance.rs::render_simple_inheritance_super", "test": "fn render_simple_inheritance_super() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"top\", \"{% block main %}TOP{% endblock main %}\"),\n        (\"bottom\", \"{% extends \\\"top\\\" %}{% block main %}{{ super() }}MAIN{% endblock %}\"),\n    ])\n    .unwrap();\n    let result = tera.render(\"bottom\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"TOPMAIN\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/inheritance.rs::render_multiple_inheritance", "test": "fn render_multiple_inheritance() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"top\", \"{% block pre %}{% endblock pre %}{% block main %}{% endblock main %}\"),\n        (\"mid\", \"{% extends \\\"top\\\" %}{% block pre %}PRE{% endblock pre %}\"),\n        (\"bottom\", \"{% extends \\\"mid\\\" %}{% block main %}MAIN{% endblock main %}\"),\n    ])\n    .unwrap();\n    let result = tera.render(\"bottom\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"PREMAIN\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/inheritance.rs::render_multiple_inheritance_with_super", "test": "fn render_multiple_inheritance_with_super() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\n            \"grandparent\",\n            \"{% block hey %}hello{% endblock hey %} {% block ending %}sincerely{% endblock ending %}\",\n        ),\n        (\n            \"parent\",\n            \"{% extends \\\"grandparent\\\" %}{% block hey %}hi and grandma says {{ super() }}{% endblock hey %}\",\n        ),\n        (\n            \"child\",\n            \"{% extends \\\"parent\\\" %}{% block hey %}dad says {{ super() }}{% endblock hey %}{% block ending %}{{ super() }} with love{% endblock ending %}\",\n        ),\n    ]).unwrap();\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(\n        result.unwrap(),\n        \"dad says hi and grandma says hello sincerely with love\".to_string()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/inheritance.rs::render_filter_section_inheritance_no_override", "test": "fn render_filter_section_inheritance_no_override() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"top\", \"{% filter upper %}hello {% block main %}top{% endblock main %}{% endfilter %}\"),\n        (\"bottom\", \"{% extends 'top' %}\"),\n    ])\n    .unwrap();\n    let result = tera.render(\"bottom\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"HELLO TOP\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/inheritance.rs::render_filter_section_inheritance", "test": "fn render_filter_section_inheritance() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"top\", \"{% filter upper %}hello {% block main %}top{% endblock main %}{% endfilter %}\"),\n        (\"bottom\", \"{% extends 'top' %}{% block main %}bottom{% endblock %}\"),\n    ])\n    .unwrap();\n    let result = tera.render(\"bottom\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"HELLO BOTTOM\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/inheritance.rs::render_super_multiple_inheritance_nested_block", "test": "fn render_super_multiple_inheritance_nested_block() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\n            \"grandparent\",\n            \"{% block hey %}hello{% endblock hey %}\",\n        ),\n        (\n            \"parent\",\n            \"{% extends \\\"grandparent\\\" %}{% block hey %}hi and grandma says {{ super() }} {% block ending %}sincerely{% endblock ending %}{% endblock hey %}\",\n        ),\n        (\n            \"child\", \"{% extends \\\"parent\\\" %}{% block hey %}dad says {{ super() }}{% endblock hey %}{% block ending %}{{ super() }} with love{% endblock ending %}\",\n        ),\n    ]).unwrap();\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(\n        result.unwrap(),\n        \"dad says hi and grandma says hello sincerely with love\".to_string()\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/inheritance.rs::render_nested_block_multiple_inheritance_no_super", "test": "fn render_nested_block_multiple_inheritance_no_super() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"index\", \"{% block content%}INDEX{% endblock content %}\"),\n        (\n            \"docs\",\n            \"{% extends \\\"index\\\" %}{% block content%}DOCS{% block more %}MORE{% endblock more %}{% endblock content %}\",\n        ),\n        (\"page\", \"{% extends \\\"docs\\\" %}{% block more %}PAGE{% endblock more %}\"),\n    ]).unwrap();\n\n    let result = tera.render(\"page\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"DOCSPAGE\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/inheritance.rs::render_super_in_top_block_errors", "test": "fn render_super_in_top_block_errors() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![(\"index\", \"{% block content%}{{super()}}{% endblock content %}\")])\n        .unwrap();\n\n    let result = tera.render(\"index\", &Context::new());\n    assert!(result.is_err());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/inheritance.rs::render_super_in_grandchild_without_redefining_works", "test": "fn render_super_in_grandchild_without_redefining_works() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"grandparent\", \"{% block title %}Title{% endblock %}\"),\n        (\n            \"parent\",\n            \"{% extends \\\"grandparent\\\" %}{% block title %}{{ super() }} - More{% endblock %}\",\n        ),\n        (\"child\", \"{% extends \\\"parent\\\" %}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n    assert_eq!(result.unwrap(), \"Title - More\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/inheritance.rs::render_super_in_grandchild_without_redefining_in_parent_works", "test": "fn render_super_in_grandchild_without_redefining_in_parent_works() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"grandparent\", \"{% block title %}Title{% endblock %}\"),\n        (\"parent\", \"{% extends \\\"grandparent\\\" %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block title %}{{ super() }} - More{% endblock %}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n    assert_eq!(result.unwrap(), \"Title - More\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::render_macros", "test": "fn render_macros() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}Hello{% endmacro hello %}\"),\n        (\n            \"tpl\",\n            \"{% import \\\"macros\\\" as macros %}{% block hey %}{{macros::hello()}}{% endblock hey %}\",\n        ),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"tpl\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"Hello\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::render_macros_expression_arg", "test": "fn render_macros_expression_arg() {\n    let mut context = Context::new();\n    context.insert(\"pages\", &vec![1, 2, 3, 4, 5]);\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello(val)%}{{val}}{% endmacro hello %}\"),\n        (\"tpl\", \"{% import \\\"macros\\\" as macros %}{{macros::hello(val=pages|last)}}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"tpl\", &context);\n\n    assert_eq!(result.unwrap(), \"5\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::render_macros_in_child_templates_same_namespace", "test": "fn render_macros_in_child_templates_same_namespace() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"grandparent\", \"{% block hey %}hello{% endblock hey %}\"),\n        (\"macros\", \"{% macro hello()%}Hello{% endmacro hello %}\"),\n        (\"macros2\", \"{% macro hi()%}Hi{% endmacro hi %}\"),\n        (\"parent\", \"{% extends \\\"grandparent\\\" %}{% import \\\"macros\\\" as macros %}{% block hey %}{{macros::hello()}}{% endblock hey %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% import \\\"macros2\\\" as macros %}{% block hey %}{{super()}}/{{macros::hi()}}{% endblock hey %}\"),\n    ]).unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"Hello/Hi\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::render_macros_in_child_templates_different_namespace", "test": "fn render_macros_in_child_templates_different_namespace() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"grandparent\", \"{% block hey %}hello{% endblock hey %}\"),\n        (\"macros\", \"{% macro hello()%}Hello{% endmacro hello %}\"),\n        (\"macros2\", \"{% macro hi()%}Hi{% endmacro hi %}\"),\n        (\"parent\", \"{% extends \\\"grandparent\\\" %}{% import \\\"macros\\\" as macros %}{% block hey %}{{macros::hello()}}{% endblock hey %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% import \\\"macros2\\\" as macros2 %}{% block hey %}{{super()}}/{{macros2::hi()}}{% endblock hey %}\"),\n    ]).unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"Hello/Hi\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::render_macros_in_parent_template_with_inheritance", "test": "fn render_macros_in_parent_template_with_inheritance() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}Hello{% endmacro hello %}\"),\n        (\"grandparent\", \"{% import \\\"macros\\\" as macros %}{% block hey %}{{macros::hello()}}{% endblock hey %}\"),\n        (\"child\", \"{% extends \\\"grandparent\\\" %}{% import \\\"macros\\\" as macros %}{% block hey %}{{super()}}/{{macros::hello()}}{% endblock hey %}\"),\n    ]).unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"Hello/Hello\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::macro_param_arent_escaped", "test": "fn macro_param_arent_escaped() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros.html\", r#\"{% macro print(val) %}{{val|safe}}{% endmacro print %}\"#),\n        (\"hello.html\", r#\"{% import \"macros.html\" as macros %}{{ macros::print(val=my_var)}}\"#),\n    ])\n    .unwrap();\n    let mut context = Context::new();\n    context.insert(\"my_var\", &\"&\");\n    let result = tera.render(\"hello.html\", &context);\n\n    assert_eq!(result.unwrap(), \"&\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::render_set_tag_macro", "test": "fn render_set_tag_macro() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}Hello{% endmacro hello %}\"),\n        (\n            \"hello.html\",\n            \"{% import \\\"macros\\\" as macros %}{% set my_var = macros::hello() %}{{my_var}}\",\n        ),\n    ])\n    .unwrap();\n    let result = tera.render(\"hello.html\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"Hello\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::render_macros_with_default_args", "test": "fn render_macros_with_default_args() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello(val=1) %}{{val}}{% endmacro hello %}\"),\n        (\"hello.html\", \"{% import \\\"macros\\\" as macros %}{{macros::hello()}}\"),\n    ])\n    .unwrap();\n    let result = tera.render(\"hello.html\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"1\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::render_macros_override_default_args", "test": "fn render_macros_override_default_args() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello(val=1) %}{{val}}{% endmacro hello %}\"),\n        (\"hello.html\", \"{% import \\\"macros\\\" as macros %}{{macros::hello(val=2)}}\"),\n    ])\n    .unwrap();\n    let result = tera.render(\"hello.html\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"2\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::render_recursive_macro", "test": "fn render_recursive_macro() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\n            \"macros\",\n            \"{% macro factorial(n) %}{% if n > 1 %}{{ n }} - {{ self::factorial(n=n-1) }}{% else %}1{% endif %}{{ n }}{% endmacro factorial %}\",\n        ),\n        (\"hello.html\", \"{% import \\\"macros\\\" as macros %}{{macros::factorial(n=7)}}\"),\n    ]).unwrap();\n    let result = tera.render(\"hello.html\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"7 - 6 - 5 - 4 - 3 - 2 - 11234567\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::recursive_macro_with_loops", "test": "fn recursive_macro_with_loops() {\n    let parent = NestedObject { label: \"Parent\".to_string(), parent: None, numbers: vec![1, 2, 3] };\n    let child = NestedObject {\n        label: \"Child\".to_string(),\n        parent: Some(Box::new(parent)),\n        numbers: vec![1, 2, 3],\n    };\n    let mut context = Context::new();\n    context.insert(\"objects\", &vec![child]);\n    let mut tera = Tera::default();\n\n    tera.add_raw_templates(vec![\n        (\n            \"macros.html\",\n            r#\"\n{% macro label_for(obj, sep) -%}\n  {%- if obj.parent -%}\n    {{ self::label_for(obj=obj.parent, sep=sep) }}{{sep}}\n  {%- endif -%}\n  {{obj.label}}\n  {%- for i in obj.numbers -%}{{ i }}{%- endfor -%}\n{%- endmacro label_for %}\n            \"#,\n        ),\n        (\n            \"recursive\",\n            r#\"\n{%- import \"macros.html\" as macros -%}\n{%- for obj in objects -%}\n    {{ macros::label_for(obj=obj, sep=\"|\") }}\n{%- endfor -%}\n\"#,\n        ),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"recursive\", &context);\n\n    assert_eq!(result.unwrap(), \"Parent123|Child123\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::render_macros_in_included", "test": "fn render_macros_in_included() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro my_macro() %}my macro{% endmacro %}\"),\n        (\"includeme\", r#\"{% import \"macros\" as macros %}{{ macros::my_macro() }}\"#),\n        (\"example\", r#\"{% include \"includeme\" %}\"#),\n    ])\n    .unwrap();\n    let result = tera.render(\"example\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"my macro\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::import_macros_into_other_macro_files", "test": "fn import_macros_into_other_macro_files() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"submacros\", \"{% macro test() %}Success!{% endmacro %}\"),\n        (\n            \"macros\",\n            r#\"{% import \"submacros\" as sub %}{% macro test() %}{{ sub::test() }}{% endmacro %}\"#,\n        ),\n        (\"index\", r#\"{% import \"macros\" as macros %}{{ macros::test() }}\"#),\n    ])\n    .unwrap();\n    let result = tera.render(\"index\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"Success!\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::can_load_parent_macro_in_child", "test": "fn can_load_parent_macro_in_child() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}{{ 1 }}{% endmacro hello %}\"),\n        (\"parent\", \"{% import \\\"macros\\\" as macros %}{{ macros::hello() }}{% block bob %}{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block bob %}{{ super() }}Hey{% endblock bob %}\"),\n    ]).unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"1Hey\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::can_load_macro_in_child", "test": "fn can_load_macro_in_child() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}{{ 1 }}{% endmacro hello %}\"),\n        (\"parent\", \"{% block bob %}{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% import \\\"macros\\\" as macros %}{% block bob %}{{ macros::hello() }}{% endblock bob %}\"),\n    ]).unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"1\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::can_inherit_macro_import_from_parent", "test": "fn can_inherit_macro_import_from_parent() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}HELLO{% endmacro hello %}\"),\n        (\"parent\", \"{% import \\\"macros\\\" as macros %}{% block bob %}parent{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block bob %}{{macros::hello()}}{% endblock bob %}\"),\n    ])\n    .unwrap();\n\n    let result = tera.render(\"child\", &Context::default());\n    assert_eq!(result.unwrap(), \"HELLO\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::can_inherit_macro_import_from_grandparent", "test": "fn can_inherit_macro_import_from_grandparent() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}HELLO{% endmacro hello %}\"),\n        (\"grandparent\", \"{% import \\\"macros\\\" as macros %}{% block bob %}grandparent{% endblock bob %}\"),\n        (\"parent\", \"{% extends \\\"grandparent\\\" %}{% import \\\"macros\\\" as macros2 %}{% block bob %}parent{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block bob %}{{macros::hello()}}-{{macros2::hello()}}{% endblock bob %}\"),\n    ]).unwrap();\n\n    let result = tera.render(\"child\", &Context::default());\n    assert_eq!(result.unwrap(), \"HELLO-HELLO\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::can_load_macro_in_parent_with_grandparent", "test": "fn can_load_macro_in_parent_with_grandparent() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"macros\", \"{% macro hello()%}{{ 1 }}{% endmacro hello %}\"),\n        (\"grandparent\", \"{% block bob %}{% endblock bob %}\"),\n        (\"parent\", \"{% extends \\\"grandparent\\\" %}{% import \\\"macros\\\" as macros %}{% block bob %}{{ macros::hello() }} - Hey{% endblock bob %}\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% block bob %}{{ super() }}{% endblock bob %}\"),\n    ]).unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n\n    assert_eq!(result.unwrap(), \"1 - Hey\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::macro_can_load_macro_from_macro_files", "test": "fn macro_can_load_macro_from_macro_files() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"submacros\", \"{% macro emma() %}Emma{% endmacro emma %}\"),\n        (\"macros\", \"{% import \\\"submacros\\\" as submacros %}{% macro hommage() %}{{ submacros::emma() }} was an amazing person!{% endmacro hommage %}\"),\n        (\"parent\", \"{% block main %}Someone was a terrible person!{% endblock main %} Don't you think?\"),\n        (\"child\", \"{% extends \\\"parent\\\" %}{% import \\\"macros\\\" as macros %}{% block main %}{{ macros::hommage() }}{% endblock main %}\")\n    ]).unwrap();\n\n    let result = tera.render(\"child\", &Context::new());\n    //println!(\"{:#?}\", result);\n    assert_eq!(result.unwrap(), \"Emma was an amazing person! Don't you think?\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::macro_can_access_global_context", "test": "fn macro_can_access_global_context() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"parent\", r#\"{% import \"macros\" as macros %}{{ macros::test_global() }}\"#),\n        (\"macros\", r#\"{% macro test_global() %}{% set_global value1 = \"42\" %}{% for i in range(end=1) %}{% set_global value2 = \" is the truth.\" %}{% endfor %}{{ value1 }}{% endmacro test_global %}\"#)\n    ]).unwrap();\n\n    let result = tera.render(\"parent\", &Context::new());\n    assert_eq!(result.unwrap(), \"42\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::template_cant_access_macros_context", "test": "fn template_cant_access_macros_context() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"parent\", r#\"{% import \"macros\" as macros %}{{ macros::empty() }}{{ quote | default(value=\"I'd rather have roses on my table than diamonds on my neck.\") }}\"#),\n        (\"macros\", r#\"{% macro empty() %}{% set_global quote = \"This should not reachable from the calling template!\" %}{% endmacro empty %}\"#)\n    ]).unwrap();\n\n    let result = tera.render(\"parent\", &Context::new());\n    assert_eq!(result.unwrap(), \"I'd rather have roses on my table than diamonds on my neck.\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/macros.rs::parent_macro_cant_access_child_macro_context", "test": "fn parent_macro_cant_access_child_macro_context() {\n    let mut tera = Tera::default();\n    tera.add_raw_templates(vec![\n        (\"parent\", \"{% import \\\"macros\\\" as macros %}{{ macros::test_global() }}\"),\n        (\"macros\", r#\"{% import \"moremacros\" as moremacros %}{% macro test_global() %}{% set_global value1 = \"ACAB\" %}{{ moremacros::another_one() }}{{ value1 }}-{{ value2 | default(value=\"ACAB\") }}{% endmacro test_global %}\"#),\n        (\"moremacros\", r#\"{% macro another_one() %}{% set_global value2 = \"1312\" %}{% endmacro another_one %}\"#)\n    ]).unwrap();\n\n    let result = tera.render(\"parent\", &Context::new());\n    assert_eq!(result.unwrap(), \"ACAB-ACAB\".to_string());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/square_brackets.rs::var_access_by_square_brackets_errors", "test": "fn var_access_by_square_brackets_errors() {\n    let mut context = Context::new();\n    context.insert(\"var\", &Test { a: \"hi\".into(), b: \"there\".into(), c: vec![] });\n    let t = Tera::one_off(\"{{var[csd]}}\", &context, true);\n    assert!(t.is_err(), \"Access of csd should be impossible\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/square_brackets.rs::var_access_by_loop_index", "test": "fn var_access_by_loop_index() {\n    let context = Context::new();\n    let res = Tera::one_off(\n        r#\"\n{% set ics = [\"fa-rocket\",\"fa-paper-plane\",\"fa-diamond\",\"fa-signal\"] %}\n{% for a in ics %}\n{{ ics[loop.index0] }}\n{% endfor %}\n    \"#,\n        &context,\n        true,\n    );\n    assert!(res.is_ok());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/square_brackets.rs::var_access_by_loop_index_with_set", "test": "fn var_access_by_loop_index_with_set() {\n    let context = Context::new();\n    let res = Tera::one_off(\n        r#\"\n{% set ics = [\"fa-rocket\",\"fa-paper-plane\",\"fa-diamond\",\"fa-signal\"] %}\n{% for a in ics %}\n    {% set i = loop.index - 1 %}\n    {{ ics[i] }}\n{% endfor %}\n    \"#,\n        &context,\n        true,\n    );\n    assert!(res.is_ok());\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/src/renderer/tests/square_brackets.rs::can_get_value_if_key_contains_period", "test": "fn can_get_value_if_key_contains_period() {\n    let mut context = Context::new();\n    context.insert(\"name\", \"Mt. Robson Provincial Park\");\n    let mut map = HashMap::new();\n    map.insert(\"Mt. Robson Provincial Park\".to_string(), \"hello\".to_string());\n    context.insert(\"tag_info\", &map);\n\n    let res = Tera::one_off(r#\"{{ tag_info[name] }}\"#, &context, true);\n    assert!(res.is_ok());\n    let res = res.unwrap();\n    assert_eq!(res, \"hello\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/tests/render_fails.rs::test_error_render_field_unknown", "test": "fn test_error_render_field_unknown() {\n    let result = render_tpl(\"field_unknown.html\");\n\n    assert!(result.is_err());\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Variable `hey` not found in context while rendering \\'field_unknown.html\\'\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/tests/render_fails.rs::test_error_render_field_unknown_in_forloop", "test": "fn test_error_render_field_unknown_in_forloop() {\n    let result = render_tpl(\"field_unknown_forloop.html\");\n\n    assert!(result.is_err());\n    let err = result.unwrap_err();\n    assert_eq!(\n        err.source().unwrap().to_string(),\n        \"Variable `r.random` not found in context while rendering \\'field_unknown_forloop.html\\'\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/tests/render_fails.rs::test_error_render_non_math", "test": "fn test_error_render_non_math() {\n    let result = render_tpl(\"non_math_operation.html\");\n\n    assert!(result.is_err());\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Variable `username` was used in a math operation but is not a number\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/tests/render_fails.rs::test_error_render_filter_section_invalid", "test": "fn test_error_render_filter_section_invalid() {\n    let result = render_tpl(\"filter_section_invalid.html\");\n    assert!(result.is_err());\n    let err = result.unwrap_err();\n    let source = err.source().unwrap();\n\n    assert_eq!(source.to_string(), \"Filter call \\'round\\' failed\");\n    let source2 = source.source().unwrap();\n    assert_eq!(\n        source2.to_string(),\n        \"Filter `round` was called on an incorrect value: got `\\\"hello\\\"` but expected a f64\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/tests/render_fails.rs::test_error_render_iterate_non_array", "test": "fn test_error_render_iterate_non_array() {\n    let result = render_tpl(\"iterate_on_non_array.html\");\n\n    assert!(result.is_err());\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Tried to iterate on a container (`friend_reviewed`) that has a unsupported type\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/tests/render_fails.rs::test_error_wrong_args_macros", "test": "fn test_error_wrong_args_macros() {\n    let result = render_tpl(\"macro_wrong_args.html\");\n\n    assert!(result.is_err());\n    assert!(result\n        .unwrap_err()\n        .source()\n        .unwrap()\n        .to_string()\n        .contains(\"Macro `input` is missing the argument\"));\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/tests/render_fails.rs::test_error_macros_self_inexisting", "test": "fn test_error_macros_self_inexisting() {\n    let result = render_tpl(\"macro_self_inexisting.html\");\n\n    assert!(result.is_err());\n    assert_eq!(\n        result.unwrap_err().source().unwrap().to_string(),\n        \"Macro `self::inexisting` not found in template `macros.html`\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/tests/render_fails.rs::test_error_in_child_template_location", "test": "fn test_error_in_child_template_location() {\n    let result = render_tpl(\"error-location/error_in_child.html\");\n\n    assert!(result.is_err());\n    let errs = result.unwrap_err();\n    assert_eq!(errs.to_string(), \"Failed to render 'error-location/error_in_child.html'\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/tests/render_fails.rs::test_error_in_grandchild_template_location", "test": "fn test_error_in_grandchild_template_location() {\n    let result = render_tpl(\"error-location/error_in_grand_child.html\");\n\n    assert!(result.is_err());\n    let errs = result.unwrap_err();\n    assert_eq!(errs.to_string(), \"Failed to render 'error-location/error_in_grand_child.html'\");\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/tests/render_fails.rs::test_error_in_parent_template_location", "test": "fn test_error_in_parent_template_location() {\n    let result = render_tpl(\"error-location/error_in_parent.html\");\n\n    assert!(result.is_err());\n    let errs = result.unwrap_err();\n    assert_eq!(\n        errs.to_string(),\n        \"Failed to render 'error-location/error_in_parent.html' (error happened in a parent template)\"\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Keats-tera/Keats-tera-1f95878/tests/render_fails.rs::test_error_in_macro_location", "test": "fn test_error_in_macro_location() {\n    let result = render_tpl(\"error-location/error_in_macro.html\");\n\n    assert!(result.is_err());\n    let errs = result.unwrap_err();\n    assert_eq!(\n        errs.to_string(),\n        \"Failed to render 'error-location/error_in_macro.html': error while rendering macro `macros::cause_error`\"\n    );\n}", "error": "Not Definition Found"}
