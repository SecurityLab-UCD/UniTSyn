{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/api_tests.rs::special_bytes_test", "test": "fn special_bytes_test() {\n    const FORMAT: u128 = STANDARD;\n\n    // Test serializing and deserializing special strings.\n    assert!(f32::from_lexical(b\"NaN\").unwrap().is_nan());\n    assert!(f32::from_lexical(b\"nan\").unwrap().is_nan());\n    assert!(f32::from_lexical(b\"NAN\").unwrap().is_nan());\n    assert!(f32::from_lexical(b\"inf\").unwrap().is_infinite());\n    assert!(f32::from_lexical(b\"INF\").unwrap().is_infinite());\n    assert!(f32::from_lexical(b\"Infinity\").unwrap().is_infinite());\n\n    let options =\n        Options::builder().nan_string(Some(b\"nan\")).inf_string(Some(b\"Infinity\")).build().unwrap();\n\n    // The error message depends on whether the radix feature is enabled.\n    assert!(f32::from_lexical_with_options::<FORMAT>(b\"inf\", &options).is_err());\n    assert!(f32::from_lexical_with_options::<FORMAT>(b\"Infinity\", &options).unwrap().is_infinite());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/num.rs::is_nan", "code": "fn is_nan(self) -> bool {\n        self.is_special() && (self.to_bits() & Self::MANTISSA_MASK) != Self::Unsigned::ZERO\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/bellerophon_tests.rs::compute_float_f32_test", "test": "fn compute_float_f32_test() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_float32(0, 16777216), (151, 0));\n    assert_eq!(compute_float32(0, 16777217), (111 + INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_float32(0, 16777218), (151, 1));\n    assert_eq!(compute_float32(0, 16777219), (111 + INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_float32(0, 16777220), (151, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float32(-10, 167772160000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772170000000000), (111 + INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_float32(-10, 167772180000000000), (151, 1));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(compute_float32(-10, 167772190000000000), (111 + INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_float32(-10, 167772200000000000), (151, 2));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/bellerophon.rs::compute_float32", "code": "pub fn compute_float32(q: i64, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        is_negative: false,\n        many_digits: false,\n        integer: &[],\n        fraction: None,\n    };\n    let fp = bellerophon::<f32, { STANDARD }>(&num, false);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/bellerophon_tests.rs::compute_float_f64_test", "test": "fn compute_float_f64_test() {\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_float64(0, 9007199254740992), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740993), (1065 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_float64(0, 9007199254740994), (1076, 1));\n    assert_eq!(compute_float64(0, 9007199254740995), (1065 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_float64(0, 9007199254740996), (1076, 2));\n    assert_eq!(compute_float64(0, 18014398509481984), (1077, 0));\n    assert_eq!(compute_float64(0, 18014398509481986), (1066 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_float64(0, 18014398509481988), (1077, 1));\n    assert_eq!(compute_float64(0, 18014398509481990), (1066 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_float64(0, 18014398509481992), (1077, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float64(-3, 9007199254740992000), (1076, 0));\n    assert_eq!(compute_float64(-3, 9007199254740993000), (1065 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_float64(-3, 9007199254740994000), (1076, 1));\n    assert_eq!(compute_float64(-3, 9007199254740995000), (1065 + INVALID_FP, 9223372036854778879));\n    assert_eq!(compute_float64(-3, 9007199254740996000), (1076, 2));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/bellerophon.rs::compute_float64", "code": "pub fn compute_float64(q: i64, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        is_negative: false,\n        many_digits: false,\n        integer: &[],\n        fraction: None,\n    };\n    let fp = bellerophon::<f64, { STANDARD }>(&num, false);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error32_test", "test": "fn compute_error32_test() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_error32(0, 16777216), (111 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error32(0, 16777217), (111 + INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_error32(0, 16777218), (111 + INVALID_FP, 9223373136366403584));\n    assert_eq!(compute_error32(0, 16777219), (111 + INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_error32(0, 16777220), (111 + INVALID_FP, 9223374235878031360));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_error32(-10, 167772160000000000), (111 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error32(-10, 167772170000000000), (111 + INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_error32(-10, 167772180000000000), (111 + INVALID_FP, 9223373136366403584));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(compute_error32(-10, 167772190000000000), (111 + INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_error32(-10, 167772200000000000), (111 + INVALID_FP, 9223374235878031360));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error32", "code": "fn compute_error32(q: i64, w: u64) -> (i32, u64) {\n    let fp = lemire::compute_error::<f32>(q, w);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error64_test", "test": "fn compute_error64_test() {\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_error64(0, 9007199254740992), (1065 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error64(0, 9007199254740993), (1065 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(0, 9007199254740994), (1065 + INVALID_FP, 9223372036854777856));\n    assert_eq!(compute_error64(0, 9007199254740995), (1065 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_error64(0, 9007199254740996), (1065 + INVALID_FP, 9223372036854779904));\n    assert_eq!(compute_error64(0, 18014398509481984), (1066 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error64(0, 18014398509481986), (1066 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(0, 18014398509481988), (1066 + INVALID_FP, 9223372036854777856));\n    assert_eq!(compute_error64(0, 18014398509481990), (1066 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_error64(0, 18014398509481992), (1066 + INVALID_FP, 9223372036854779904));\n\n    // Test a much closer set of examples.\n    assert_eq!(compute_error64(0, 9007199254740991), (1064 + INVALID_FP, 18446744073709549568));\n    assert_eq!(compute_error64(0, 9223372036854776831), (1075 + INVALID_FP, 9223372036854776830));\n    assert_eq!(compute_error64(0, 9223372036854776832), (1075 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(0, 9223372036854776833), (1075 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(-42, 9123456727292927), (925 + INVALID_FP, 13021432563531497894));\n    assert_eq!(compute_error64(-43, 91234567272929275), (925 + INVALID_FP, 13021432563531498606));\n    assert_eq!(compute_error64(-42, 9123456727292928), (925 + INVALID_FP, 13021432563531499320));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_error64(-3, 9007199254740992000), (1065 + INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error64(-3, 9007199254740993000), (1065 + INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(-3, 9007199254740994000), (1065 + INVALID_FP, 9223372036854777856));\n    assert_eq!(compute_error64(-3, 9007199254740995000), (1065 + INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_error64(-3, 9007199254740996000), (1065 + INVALID_FP, 9223372036854779904));\n\n    // Test from errors in atof.\n    assert_eq!(compute_error64(-18, 1000000178813934326), (1012 + INVALID_FP, 9223373686122217470));\n\n    // Check edge-cases from previous errors.\n    assert_eq!(\n        compute_error64(-342, 2470328229206232720),\n        (-64 + INVALID_FP, 18446744073709551608)\n    );\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error64", "code": "fn compute_error64(q: i64, w: u64) -> (i32, u64) {\n    let fp = lemire::compute_error::<f64>(q, w);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error_scaled32_test", "test": "fn compute_error_scaled32_test() {\n    // These are the same examples above, just using pre-computed scaled values.\n\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(\n        compute_error_scaled32(0, 4611686018427387904, 39),\n        (111 + INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611686293305294848, 39),\n        (111 + INVALID_FP, 9223372586610589696)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611686568183201792, 39),\n        (111 + INVALID_FP, 9223373136366403584)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611686843061108736, 39),\n        (111 + INVALID_FP, 9223373686122217472)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611687117939015680, 39),\n        (111 + INVALID_FP, 9223374235878031360)\n    );\n\n    assert_eq!(\n        compute_error_scaled32(-10, 9223372036854775808, 6),\n        (111 + INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223372586610589696, 6),\n        (111 + INVALID_FP, 9223372586610589696)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223373136366403584, 6),\n        (111 + INVALID_FP, 9223373136366403584)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223373686122217472, 6),\n        (111 + INVALID_FP, 9223373686122217472)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223374235878031360, 6),\n        (111 + INVALID_FP, 9223374235878031360)\n    );\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error_scaled32", "code": "fn compute_error_scaled32(q: i64, w: u64, lz: i32) -> (i32, u64) {\n    let fp = lemire::compute_error_scaled::<f32>(q, w, lz);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error_scaled64_test", "test": "fn compute_error_scaled64_test() {\n    // These are the same examples above, just using pre-computed scaled values.\n\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427387904, 10),\n        (1065 + INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 10),\n        (1065 + INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388928, 10),\n        (1065 + INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389440, 10),\n        (1065 + INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389952, 10),\n        (1065 + INVALID_FP, 9223372036854779904)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427387904, 9),\n        (1066 + INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 9),\n        (1066 + INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388928, 9),\n        (1066 + INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389440, 9),\n        (1066 + INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389952, 9),\n        (1066 + INVALID_FP, 9223372036854779904)\n    );\n\n    // Test a much closer set of examples.\n    assert_eq!(\n        compute_error_scaled64(0, 9223372036854774784, 11),\n        (1064 + INVALID_FP, 18446744073709549568)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388415, 0),\n        (1075 + INVALID_FP, 9223372036854776830)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 0),\n        (1075 + INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 0),\n        (1075 + INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(-42, 6510716281765748947, 10),\n        (925 + INVALID_FP, 13021432563531497894)\n    );\n    assert_eq!(\n        compute_error_scaled64(-43, 6510716281765749303, 7),\n        (925 + INVALID_FP, 13021432563531498606)\n    );\n    assert_eq!(\n        compute_error_scaled64(-42, 6510716281765749660, 10),\n        (925 + INVALID_FP, 13021432563531499320)\n    );\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854775808, 1),\n        (1065 + INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854776832, 1),\n        (1065 + INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854777856, 1),\n        (1065 + INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854778880, 1),\n        (1065 + INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854779904, 1),\n        (1065 + INVALID_FP, 9223372036854779904)\n    );\n\n    // Test from errors in atof.\n    assert_eq!(\n        compute_error_scaled64(-18, 9223373686122217470, 4),\n        (1012 + INVALID_FP, 9223373686122217470)\n    );\n\n    // Check edge-cases from previous errors.\n    assert_eq!(\n        compute_error_scaled64(-342, 9223372036854775804, 2),\n        (-64 + INVALID_FP, 18446744073709551608)\n    );\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_error_scaled64", "code": "fn compute_error_scaled64(q: i64, w: u64, lz: i32) -> (i32, u64) {\n    let fp = lemire::compute_error_scaled::<f64>(q, w, lz);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_float_f32_rounding", "test": "fn compute_float_f32_rounding() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_float32(0, 16777216), (151, 0));\n    assert_eq!(compute_float32(0, 16777217), (151, 0));\n    assert_eq!(compute_float32(0, 16777218), (151, 1));\n    assert_eq!(compute_float32(0, 16777219), (151, 2));\n    assert_eq!(compute_float32(0, 16777220), (151, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float32(-10, 167772160000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772170000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772180000000000), (151, 1));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(compute_float32(-10, 167772190000000000), (151, 2));\n    assert_eq!(compute_float32(-10, 167772200000000000), (151, 2));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/bellerophon.rs::compute_float32", "code": "pub fn compute_float32(q: i64, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        is_negative: false,\n        many_digits: false,\n        integer: &[],\n        fraction: None,\n    };\n    let fp = bellerophon::<f32, { STANDARD }>(&num, false);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/lemire_tests.rs::compute_float_f64_rounding", "test": "fn compute_float_f64_rounding() {\n    // Also need to check halfway cases **inside** that exponent range.\n\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_float64(0, 9007199254740992), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740993), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740994), (1076, 1));\n    assert_eq!(compute_float64(0, 9007199254740995), (1076, 2));\n    assert_eq!(compute_float64(0, 9007199254740996), (1076, 2));\n    assert_eq!(compute_float64(0, 18014398509481984), (1077, 0));\n    assert_eq!(compute_float64(0, 18014398509481986), (1077, 0));\n    assert_eq!(compute_float64(0, 18014398509481988), (1077, 1));\n    assert_eq!(compute_float64(0, 18014398509481990), (1077, 2));\n    assert_eq!(compute_float64(0, 18014398509481992), (1077, 2));\n\n    // Test a much closer set of examples.\n    assert_eq!(compute_float64(0, 9007199254740991), (1075, 4503599627370495));\n    assert_eq!(compute_float64(0, 9223372036854776831), (1086, 0));\n    assert_eq!(compute_float64(0, 9223372036854776832), (1086, 0));\n    assert_eq!(compute_float64(0, 9223372036854776833), (1086, 1));\n    assert_eq!(compute_float64(-42, 9123456727292927), (936, 1854521741541368));\n    assert_eq!(compute_float64(-43, 91234567272929275), (936, 1854521741541369));\n    assert_eq!(compute_float64(-42, 9123456727292928), (936, 1854521741541369));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float64(-3, 9007199254740992000), (1076, 0));\n    assert_eq!(compute_float64(-3, 9007199254740993000), (1076, 0));\n    assert_eq!(compute_float64(-3, 9007199254740994000), (1076, 1));\n    assert_eq!(compute_float64(-3, 9007199254740995000), (1076, 2));\n    assert_eq!(compute_float64(-3, 9007199254740996000), (1076, 2));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/bellerophon.rs::compute_float64", "code": "pub fn compute_float64(q: i64, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        is_negative: false,\n        many_digits: false,\n        integer: &[],\n        fraction: None,\n    };\n    let fp = bellerophon::<f64, { STANDARD }>(&num, false);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::fabsf_spec_test", "test": "fn fabsf_spec_test() {\n    assert!(libm::fabsf(f32::NAN).is_nan());\n    for f in [0.0, -0.0].iter().copied() {\n        assert_eq!(libm::fabsf(f), 0.0);\n    }\n    for f in [f32::INFINITY, f32::NEG_INFINITY].iter().copied() {\n        assert_eq!(libm::fabsf(f), f32::INFINITY);\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/num.rs::is_nan", "code": "fn is_nan(self) -> bool {\n        self.is_special() && (self.to_bits() & Self::MANTISSA_MASK) != Self::Unsigned::ZERO\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::sqrtf_spec_test", "test": "fn sqrtf_spec_test() {\n    // Not Asserted: FE_INVALID exception is raised if argument is negative.\n    assert!(libm::sqrtf(-1.0).is_nan());\n    assert!(libm::sqrtf(f32::NAN).is_nan());\n    for f in [0.0, -0.0, f32::INFINITY].iter().copied() {\n        assert_eq!(libm::sqrtf(f), f);\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/num.rs::is_nan", "code": "fn is_nan(self) -> bool {\n        self.is_special() && (self.to_bits() & Self::MANTISSA_MASK) != Self::Unsigned::ZERO\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::fabsd_spec_test", "test": "fn fabsd_spec_test() {\n    assert!(libm::fabsd(f64::NAN).is_nan());\n    for f in [0.0, -0.0].iter().copied() {\n        assert_eq!(libm::fabsd(f), 0.0);\n    }\n    for f in [f64::INFINITY, f64::NEG_INFINITY].iter().copied() {\n        assert_eq!(libm::fabsd(f), f64::INFINITY);\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/num.rs::is_nan", "code": "fn is_nan(self) -> bool {\n        self.is_special() && (self.to_bits() & Self::MANTISSA_MASK) != Self::Unsigned::ZERO\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/libm_tests.rs::sqrtd_spec_test", "test": "fn sqrtd_spec_test() {\n    // Not Asserted: FE_INVALID exception is raised if argument is negative.\n    assert!(libm::sqrtd(-1.0).is_nan());\n    assert!(libm::sqrtd(f64::NAN).is_nan());\n    for f in [0.0, -0.0, f64::INFINITY].iter().copied() {\n        assert_eq!(libm::sqrtd(f), f);\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/num.rs::is_nan", "code": "fn is_nan(self) -> bool {\n        self.is_special() && (self.to_bits() & Self::MANTISSA_MASK) != Self::Unsigned::ZERO\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::invalid_exponent_test", "test": "fn invalid_exponent_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.exponent(b'\\x00');\n    assert!(!builder.is_valid());\n    builder = builder.exponent(b'\\x7f');\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.exponent(b'^');\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::invalid_decimal_point_test", "test": "fn invalid_decimal_point_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.decimal_point(b'\\x00');\n    assert!(!builder.is_valid());\n    builder = builder.decimal_point(b'\\x7f');\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.decimal_point(b',');\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::invalid_nan_test", "test": "fn invalid_nan_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.nan_string(Some(b\"naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaan\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"inf\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"na00n\"));\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.nan_string(Some(b\"nan\"));\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n    builder = builder.nan_string(None);\n    assert!(builder.is_valid());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::invalid_inf_test", "test": "fn invalid_inf_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.inf_string(Some(b\"innnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnf\"));\n    assert!(!builder.is_valid());\n    builder = builder.inf_string(Some(b\"nan\"));\n    assert!(!builder.is_valid());\n    builder = builder.inf_string(Some(b\"in00f\"));\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.inf_string(Some(b\"i\"));\n    assert!(builder.is_valid());\n    builder = builder.inf_string(Some(b\"inf\"));\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n    builder = builder.inf_string(None);\n    assert!(builder.is_valid());\n    builder = builder.infinity_string(None);\n    assert!(builder.is_valid());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::invalid_infinity_test", "test": "fn invalid_infinity_test() {\n    let mut builder = OptionsBuilder::default();\n    builder =\n        builder.infinity_string(Some(b\"innnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnf\"));\n    assert!(!builder.is_valid());\n    builder = builder.infinity_string(Some(b\"nan\"));\n    assert!(!builder.is_valid());\n    builder = builder.infinity_string(Some(b\"i\"));\n    assert!(!builder.is_valid());\n    builder = builder.inf_string(Some(b\"infi000nity\"));\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.inf_string(Some(b\"i\"));\n    assert!(builder.is_valid());\n    builder = builder.infinity_string(Some(b\"infinity\"));\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n    builder = builder.infinity_string(None);\n    assert!(!builder.is_valid());\n    builder = builder.inf_string(None);\n    assert!(builder.is_valid());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::builder_test", "test": "fn builder_test() {\n    let mut builder = OptionsBuilder::default();\n\n    builder = builder.lossy(true);\n    builder = builder.exponent(b'^');\n    builder = builder.decimal_point(b',');\n    builder = builder.nan_string(Some(b\"nan\"));\n    builder = builder.inf_string(Some(b\"Infinity\"));\n    builder = builder.infinity_string(Some(b\"Infiniiiiiity\"));\n\n    assert_eq!(builder.get_lossy(), true);\n    assert_eq!(builder.get_exponent(), b'^');\n    assert_eq!(builder.get_decimal_point(), b',');\n    assert_eq!(builder.get_nan_string(), Some(\"nan\".as_bytes()));\n    assert_eq!(builder.get_inf_string(), Some(\"Infinity\".as_bytes()));\n    assert_eq!(builder.get_infinity_string(), Some(\"Infiniiiiiity\".as_bytes()));\n\n    assert!(builder.is_valid());\n    assert_eq!(builder.build(), Ok(unsafe { builder.build_unchecked() }));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/src/options.rs::get_lossy", "code": "pub const fn get_lossy(&self) -> bool {\n        self.lossy\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/options_tests.rs::options_test", "test": "fn options_test() {\n    let mut opts = Options::new();\n\n    unsafe {\n        opts.set_lossy(true);\n        opts.set_exponent(b'^');\n        opts.set_decimal_point(b',');\n        opts.set_nan_string(Some(b\"nan\"));\n        opts.set_inf_string(Some(b\"Infinity\"));\n        opts.set_infinity_string(Some(b\"Infiniiiiiity\"));\n    }\n\n    assert_eq!(opts.lossy(), true);\n    assert_eq!(opts.exponent(), b'^');\n    assert_eq!(opts.decimal_point(), b',');\n    assert_eq!(opts.nan_string(), Some(\"nan\".as_bytes()));\n    assert_eq!(opts.inf_string(), Some(\"Infinity\".as_bytes()));\n    assert_eq!(opts.infinity_string(), Some(\"Infiniiiiiity\".as_bytes()));\n    assert!(opts.is_valid());\n\n    assert_eq!(Options::builder(), OptionsBuilder::new());\n    assert_eq!(opts.rebuild().build(), Ok(opts));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/src/options.rs::lossy", "code": "pub const fn lossy(mut self, lossy: bool) -> Self {\n        self.lossy = lossy;\n        self\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/slow_tests.rs::b_test", "test": "fn b_test() {\n    assert_eq!(b(1e-45_f32), (1, -149));\n    assert_eq!(b(5e-324_f64), (1, -1074));\n    assert_eq!(b(1e-323_f64), (2, -1074));\n    assert_eq!(b(2e-323_f64), (4, -1074));\n    assert_eq!(b(3e-323_f64), (6, -1074));\n    assert_eq!(b(4e-323_f64), (8, -1074));\n    assert_eq!(b(5e-323_f64), (10, -1074));\n    assert_eq!(b(6e-323_f64), (12, -1074));\n    assert_eq!(b(7e-323_f64), (14, -1074));\n    assert_eq!(b(8e-323_f64), (16, -1074));\n    assert_eq!(b(9e-323_f64), (18, -1074));\n    assert_eq!(b(1_f32), (8388608, -23));\n    assert_eq!(b(1_f64), (4503599627370496, -52));\n    assert_eq!(b(1e38_f32), (9860761, 103));\n    assert_eq!(b(1e308_f64), (5010420900022432, 971));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/src/slow.rs::b", "code": "pub fn b<F: RawFloat>(float: F) -> ExtendedFloat80 {\n    ExtendedFloat80 {\n        mant: float.mantissa().as_u64(),\n        exp: float.exponent(),\n    }\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/slow_tests.rs::bh_test", "test": "fn bh_test() {\n    assert_eq!(bh(1e-45_f32), (3, -150));\n    assert_eq!(bh(5e-324_f64), (3, -1075));\n    assert_eq!(bh(1_f32), (16777217, -24));\n    assert_eq!(bh(1_f64), (9007199254740993, -53));\n    assert_eq!(bh(1e38_f32), (19721523, 102));\n    assert_eq!(bh(1e308_f64), (10020841800044865, 970));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/src/slow.rs::bh", "code": "pub fn bh<F: RawFloat>(float: F) -> ExtendedFloat80 {\n    let fp = b(float);\n    ExtendedFloat80 {\n        mant: (fp.mant << 1) + 1,\n        exp: fp.exp - 1,\n    }\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::simple_test", "test": "fn simple_test() {\n    // Test the simple properties of the stack vector.\n    let mut x = VecType::from_u32(1);\n    assert_eq!(x.len(), 1);\n    assert_eq!(x.is_empty(), false);\n    assert_eq!(x.capacity(), SIZE);\n    x.try_push(5).unwrap();\n    assert_eq!(x.len(), 2);\n    assert_eq!(x.pop(), Some(5));\n    assert_eq!(x.len(), 1);\n    assert_eq!(&*x, &[1]);\n    x.try_extend(&[2, 3, 4]).unwrap();\n    assert_eq!(x.len(), 4);\n    assert_eq!(&*x, &[1, 2, 3, 4]);\n    x.try_resize(6, 0).unwrap();\n    assert_eq!(x.len(), 6);\n    assert_eq!(&*x, &[1, 2, 3, 4, 0, 0]);\n    x.try_resize(0, 0).unwrap();\n    assert_eq!(x.len(), 0);\n    assert_eq!(x.is_empty(), true);\n\n    let x = VecType::try_from(&[5, 1]).unwrap();\n    assert_eq!(x.len(), 2);\n    assert_eq!(x.is_empty(), false);\n    assert_eq!(x.hi16(), (0x8000, true));\n    if LIMB_BITS == 32 {\n        assert_eq!(x.hi32(), (0x80000002, true));\n        assert_eq!(x.hi64(), (0x8000000280000000, false));\n    } else {\n        assert_eq!(x.hi32(), (0x80000000, true));\n        assert_eq!(x.hi64(), (0x8000000000000002, true));\n    }\n    let rview = x.rview();\n    assert_eq!(x[0], 5);\n    assert_eq!(x[1], 1);\n    assert_eq!(rview[0], 1);\n    assert_eq!(rview[1], 5);\n    assert_eq!(rview.get(1), Some(&5));\n    assert_eq!(rview.get(2), None);\n\n    assert_eq!(VecType::from_u16(u16::MAX).hi16(), (u16::MAX, false));\n    assert_eq!(VecType::from_u32(u32::MAX).hi32(), (u32::MAX, false));\n    assert_eq!(VecType::from_u64(u64::MAX).hi64(), (u64::MAX, false));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/noskip.rs::len", "code": "fn len(&self) -> usize {\n        self.length() - self.cursor()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/tests/stackvec_tests.rs::cmp_test", "test": "fn cmp_test() {\n    // Simple\n    let x = VecType::from_u32(1);\n    let y = VecType::from_u32(2);\n    assert_eq!(x.partial_cmp(&x), Some(cmp::Ordering::Equal));\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Less);\n\n    // Check asymmetric\n    let x = VecType::try_from(&[5, 1]).unwrap();\n    let y = VecType::from_u32(2);\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n\n    // Check when we use reverse ordering properly.\n    let x = VecType::try_from(&[5, 1, 9]).unwrap();\n    let y = VecType::try_from(&[6, 2, 8]).unwrap();\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n\n    // Complex scenario, check it properly uses reverse ordering.\n    let x = VecType::try_from(&[0, 1, 9]).unwrap();\n    let y = VecType::try_from(&[4294967295, 0, 9]).unwrap();\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/bf16.rs::partial_cmp", "code": "fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.as_f32().partial_cmp(&other.as_f32())\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/algorithm_tests.rs::test_try_parse_4digits", "test": "fn test_try_parse_4digits() {\n    let parse = |bytes: &[u8]| {\n        let mut digits = bytes.bytes::<{ STANDARD }>();\n        algorithm::try_parse_4digits::<u32, _, STANDARD>(&mut digits.integer_iter())\n    };\n    assert_eq!(parse(b\"1234\"), Some(1234));\n    assert_eq!(parse(b\"123\"), None);\n    assert_eq!(parse(b\"123\\x00\"), None);\n    assert_eq!(parse(b\"123.\"), None);\n    assert_eq!(parse(b\"123_\"), None);\n    assert_eq!(parse(b\"1234_\"), Some(1234));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical/src/lib.rs::parse", "code": "pub fn parse<N: FromLexical, Bytes: AsRef<[u8]>>(bytes: Bytes) -> Result<N> {\n    N::from_lexical(bytes.as_ref())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/algorithm_tests.rs::test_try_parse_8digits", "test": "fn test_try_parse_8digits() {\n    let parse = |bytes: &[u8]| {\n        let mut digits = bytes.bytes::<{ STANDARD }>();\n        algorithm::try_parse_8digits::<u64, _, STANDARD>(&mut digits.integer_iter())\n    };\n\n    assert_eq!(parse(b\"12345678\"), Some(12345678));\n    assert_eq!(parse(b\"1234567\"), None);\n    assert_eq!(parse(b\"1234567\\x00\"), None);\n    assert_eq!(parse(b\"1234567.\"), None);\n    assert_eq!(parse(b\"1234567_\"), None);\n    assert_eq!(parse(b\"12345678\"), Some(12345678));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical/src/lib.rs::parse", "code": "pub fn parse<N: FromLexical, Bytes: AsRef<[u8]>>(bytes: Bytes) -> Result<N> {\n    N::from_lexical(bytes.as_ref())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-integer/tests/options_tests.rs::options_tests", "test": "fn options_tests() {\n    let builder = OptionsBuilder::new();\n    assert!(builder.is_valid());\n    assert!(unsafe { builder.build_unchecked() }.is_valid());\n    assert!(OptionsBuilder::default().is_valid());\n\n    let options: Options = Options::new();\n    assert!(options.is_valid());\n    assert_eq!(options, Options::default());\n    assert!(OptionsBuilder::new().build().is_ok());\n    assert!(OptionsBuilder::default().build().is_ok());\n    assert!(OptionsBuilder::default().is_valid());\n    assert_eq!(options.rebuild(), Options::builder());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/bf16_tests.rs::as_f32_test", "test": "fn as_f32_test() {\n    assert_eq!(bf16::from_bits(1).as_f32(), 9.18355e-41f32);\n    assert_eq!(bf16::ZERO.as_f32(), 0.0f32);\n    assert_eq!(bf16::ZERO.to_bits(), 0);\n    assert_eq!(bf16::ONE.as_f32(), 1.0f32);\n    assert_eq!(bf16::ONE.to_bits(), (127 << 7));\n    assert_eq!(bf16::TWO.as_f32(), 2.0f32);\n    assert_eq!(bf16::TWO.to_bits(), (128 << 7));\n    assert_eq!(bf16::from_bits(126 << 7).as_f32(), 0.5f32);\n    assert!(bf16::NAN.as_f32().is_nan());\n    assert!(bf16::INFINITY.as_f32().is_inf());\n    assert!(bf16::NEG_INFINITY.as_f32().is_inf());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/bf16.rs::as_f32", "code": "pub fn as_f32(self) -> f32 {\n        // This is super easy, since we have the same exponent bits:\n        // just need to shift left 16.\n        f32::from_bits((self.bits as u32) << 16)\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/bf16_tests.rs::from_f32_test", "test": "fn from_f32_test() {\n    assert_eq!(bf16::from_f32(4.5917e-41f32).to_bits(), 0);\n    assert_eq!(bf16::from_f32(4.5918e-41f32).to_bits(), 0);\n    assert_eq!(bf16::from_f32(4.5919e-41f32).to_bits(), 1);\n    assert_eq!(bf16::from_f32(9.18354e-41f32).to_bits(), 1);\n    assert_eq!(bf16::from_f32(9.18355e-41f32).to_bits(), 1);\n    assert_eq!(bf16::from_f32(9.18356e-41f32).to_bits(), 1);\n    assert_eq!(bf16::from_f32(1.37752e-40f32).to_bits(), 1);\n    assert_eq!(bf16::from_f32(1.37753e-40f32).to_bits(), 2);\n    assert_eq!(bf16::from_f32(1.37754e-40f32).to_bits(), 2);\n    assert!(bf16::from_f32(f32::NAN).is_nan());\n    assert!(bf16::from_f32(f32::INFINITY).is_inf());\n    assert!(bf16::from_f32(f32::NEG_INFINITY).is_inf());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/bf16.rs::to_bits", "code": "pub const fn to_bits(self) -> u16 {\n        self.bits\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/f16_tests.rs::as_f32_test", "test": "fn as_f32_test() {\n    assert_eq!(f16::from_bits(1).as_f32(), 0.000000059604645);\n    assert_eq!(f16::ZERO.as_f32(), 0.0f32);\n    assert_eq!(f16::ZERO.to_bits(), 0);\n    assert_eq!(f16::ONE.as_f32(), 1.0f32);\n    assert_eq!(f16::ONE.to_bits(), (15 << 10));\n    assert_eq!(f16::TWO.as_f32(), 2.0f32);\n    assert_eq!(f16::TWO.to_bits(), (16 << 10));\n    assert_eq!(f16::from_bits(14 << 10).as_f32(), 0.5f32);\n    assert!(f16::NAN.as_f32().is_nan());\n    assert!(f16::INFINITY.as_f32().is_inf());\n    assert!(f16::NEG_INFINITY.as_f32().is_inf());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/f16.rs::as_f32", "code": "pub fn as_f32(self) -> f32 {\n        f16_to_f32(self)\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/f16_tests.rs::from_f32_test", "test": "fn from_f32_test() {\n    assert_eq!(f16::from_f32(2.980232e-08).to_bits(), 0);\n    assert_eq!(f16::from_f32(2.9802322e-08).to_bits(), 0);\n    assert_eq!(f16::from_f32(2.9802326e-08).to_bits(), 1);\n    assert_eq!(f16::from_f32(5.960464e-08).to_bits(), 1);\n    assert_eq!(f16::from_f32(5.9604645e-08).to_bits(), 1);\n    assert_eq!(f16::from_f32(5.960465e-08).to_bits(), 1);\n    assert!(f16::from_f32(f32::NAN).is_nan());\n    assert!(f16::from_f32(f32::INFINITY).is_inf());\n    assert!(f16::from_f32(f32::NEG_INFINITY).is_inf());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/f16.rs::to_bits", "code": "pub const fn to_bits(self) -> u16 {\n        self.bits\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/feature_format_tests.rs::ignore_test", "test": "fn ignore_test() {\n    let fmt = format::NumberFormat::<{ format::IGNORE }> {};\n    assert_eq!(fmt.flags(), format::DIGIT_SEPARATOR_FLAG_MASK);\n    assert_eq!(fmt.digit_separator(), b'_');\n    assert_eq!(fmt.required_integer_digits(), false);\n    assert_eq!(fmt.required_fraction_digits(), false);\n    assert_eq!(fmt.required_exponent_digits(), false);\n    assert_eq!(fmt.required_mantissa_digits(), false);\n    assert_eq!(fmt.required_digits(), false);\n    assert_eq!(fmt.no_positive_mantissa_sign(), false);\n    assert_eq!(fmt.required_mantissa_sign(), false);\n    assert_eq!(fmt.no_exponent_notation(), false);\n    assert_eq!(fmt.no_positive_exponent_sign(), false);\n    assert_eq!(fmt.required_exponent_sign(), false);\n    assert_eq!(fmt.no_exponent_without_fraction(), false);\n    assert_eq!(fmt.no_special(), false);\n    assert_eq!(fmt.case_sensitive_special(), false);\n    assert_eq!(fmt.no_integer_leading_zeros(), false);\n    assert_eq!(fmt.no_float_leading_zeros(), false);\n    assert_eq!(fmt.required_exponent_notation(), false);\n    assert_eq!(fmt.case_sensitive_exponent(), false);\n    #[cfg(feature = \"power-of-two\")]\n    assert_eq!(fmt.case_sensitive_base_prefix(), false);\n    #[cfg(feature = \"power-of-two\")]\n    assert_eq!(fmt.case_sensitive_base_suffix(), false);\n    assert_eq!(fmt.integer_internal_digit_separator(), true);\n    assert_eq!(fmt.fraction_internal_digit_separator(), true);\n    assert_eq!(fmt.exponent_internal_digit_separator(), true);\n    assert_eq!(fmt.internal_digit_separator(), true);\n    assert_eq!(fmt.integer_leading_digit_separator(), true);\n    assert_eq!(fmt.fraction_leading_digit_separator(), true);\n    assert_eq!(fmt.exponent_leading_digit_separator(), true);\n    assert_eq!(fmt.leading_digit_separator(), true);\n    assert_eq!(fmt.integer_trailing_digit_separator(), true);\n    assert_eq!(fmt.fraction_trailing_digit_separator(), true);\n    assert_eq!(fmt.exponent_trailing_digit_separator(), true);\n    assert_eq!(fmt.trailing_digit_separator(), true);\n    assert_eq!(fmt.integer_consecutive_digit_separator(), true);\n    assert_eq!(fmt.fraction_consecutive_digit_separator(), true);\n    assert_eq!(fmt.exponent_consecutive_digit_separator(), true);\n    assert_eq!(fmt.consecutive_digit_separator(), true);\n    assert_eq!(fmt.special_digit_separator(), true);\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::flags", "code": "pub const fn flags(&self) -> u128 {\n        FORMAT & flags::FLAG_MASK\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/format_builder_tests.rs::decimal_test", "test": "fn decimal_test() {\n    const FORMAT: u128 = NumberFormatBuilder::decimal();\n    let format = NumberFormat::<FORMAT> {};\n    assert!(format.is_valid());\n    assert_eq!(format.radix(), 10);\n    assert_eq!(format.mantissa_radix(), 10);\n    assert_eq!(format.exponent_base(), 10);\n    assert_eq!(format.exponent_radix(), 10);\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/not_feature_format_tests.rs::format_properties_test", "test": "fn format_properties_test() {\n    let format = NumberFormat::<{ STANDARD }> {};\n    assert_eq!(format.flags(), STANDARD & format::FLAG_MASK);\n    assert_eq!(format.interface_flags(), STANDARD & format::INTERFACE_FLAG_MASK);\n    assert_eq!(format.digit_separator(), b'\\x00');\n    assert_eq!(format.base_prefix(), b'\\x00');\n    assert_eq!(format.base_suffix(), b'\\x00');\n    assert_eq!(format.mantissa_radix(), 10);\n    assert_eq!(format.radix(), 10);\n    assert_eq!(format.exponent_base(), 10);\n    assert_eq!(format.exponent_radix(), 10);\n    assert_eq!(format.required_integer_digits(), false);\n    assert_eq!(format.required_fraction_digits(), false);\n    assert_eq!(format.required_exponent_digits(), true);\n    assert_eq!(format.required_mantissa_digits(), true);\n    assert_eq!(format.required_digits(), true);\n    assert_eq!(format.no_positive_mantissa_sign(), false);\n    assert_eq!(format.required_mantissa_sign(), false);\n    assert_eq!(format.no_exponent_notation(), false);\n    assert_eq!(format.no_positive_exponent_sign(), false);\n    assert_eq!(format.required_exponent_sign(), false);\n    assert_eq!(format.no_exponent_without_fraction(), false);\n    assert_eq!(format.no_special(), false);\n    assert_eq!(format.case_sensitive_special(), false);\n    assert_eq!(format.no_integer_leading_zeros(), false);\n    assert_eq!(format.no_float_leading_zeros(), false);\n    assert_eq!(format.required_exponent_notation(), false);\n    assert_eq!(format.case_sensitive_exponent(), false);\n    assert_eq!(format.case_sensitive_base_prefix(), false);\n    assert_eq!(format.case_sensitive_base_suffix(), false);\n    assert_eq!(format.integer_internal_digit_separator(), false);\n    assert_eq!(format.fraction_internal_digit_separator(), false);\n    assert_eq!(format.exponent_internal_digit_separator(), false);\n    assert_eq!(format.internal_digit_separator(), false);\n    assert_eq!(format.integer_leading_digit_separator(), false);\n    assert_eq!(format.fraction_leading_digit_separator(), false);\n    assert_eq!(format.exponent_leading_digit_separator(), false);\n    assert_eq!(format.leading_digit_separator(), false);\n    assert_eq!(format.integer_trailing_digit_separator(), false);\n    assert_eq!(format.fraction_trailing_digit_separator(), false);\n    assert_eq!(format.exponent_trailing_digit_separator(), false);\n    assert_eq!(format.trailing_digit_separator(), false);\n    assert_eq!(format.integer_consecutive_digit_separator(), false);\n    assert_eq!(format.fraction_consecutive_digit_separator(), false);\n    assert_eq!(format.exponent_consecutive_digit_separator(), false);\n    assert_eq!(format.consecutive_digit_separator(), false);\n    assert_eq!(format.special_digit_separator(), false);\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::flags", "code": "pub const fn flags(&self) -> u128 {\n        FORMAT & flags::FLAG_MASK\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/num_tests.rs::ceil_divmod_test", "test": "fn ceil_divmod_test() {\n    use lexical_util::num::Integer;\n\n    assert_eq!(5usize.ceil_divmod(7), (1, -2));\n    assert_eq!(0usize.ceil_divmod(7), (0, 0));\n    assert_eq!(35usize.ceil_divmod(7), (5, 0));\n    assert_eq!(36usize.ceil_divmod(7), (6, -6));\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/num.rs::ceil_divmod", "code": "fn ceil_divmod(self, y: Self) -> (Self, i32) {\n        let q = self / y;\n        let r = self % y;\n        match r == Self::ZERO {\n            true  => (q, i32::as_cast(r)),\n            false => (q + Self::ONE, i32::as_cast(r) - i32::as_cast(y))\n        }\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_i", "test": "fn test_skip_iter_i() {\n    // Test iterators that skip single, internal-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"__.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\"_.455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"__.45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4_5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4_5__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__4_5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__4_5__.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_l", "test": "fn test_skip_iter_l() {\n    // Test iterators that skip single, leading-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_leading_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"_45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"_.45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"_45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"_45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"_4__5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"4_5_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"_4__5__.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_t", "test": "fn test_skip_iter_t() {\n    // Test iterators that skip single, trailing-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_trailing_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"_.45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__4__5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_4_5.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__4__5_.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_il", "test": "fn test_skip_iter_il() {\n    // Test iterators that skip single, internal or leading-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_leading_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"_45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"_.45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4_5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4_5__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"_45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"_45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"_4_5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"_4_5__.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_it", "test": "fn test_skip_iter_it() {\n    // Test iterators that skip single, internal or trailing-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_trailing_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"_.45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4_5_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__4_5_.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_lt", "test": "fn test_skip_iter_lt() {\n    // Test iterators that skip single, leading or trailing-only digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_leading_digit_separator(true)\n        .integer_trailing_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"_45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"_.45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"_4__5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"4_5.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"_4__5_.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_ilt", "test": "fn test_skip_iter_ilt() {\n    // Test iterators that skip single digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_leading_digit_separator(true)\n        .integer_trailing_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"_45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"_.45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4_5_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"_4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"_4_5_.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_ic", "test": "fn test_skip_iter_ic() {\n    // Test iterators that skip multiple, internal digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\"_.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\"__.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__455\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\"_.455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\"__.455\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"45__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__45__.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_lc", "test": "fn test_skip_iter_lc() {\n    // Test iterators that skip multiple, leading digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_leading_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"4_5_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"4__5__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"4_5_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"4__5__.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_tc", "test": "fn test_skip_iter_tc() {\n    // Test iterators that skip multiple, trailing digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_trailing_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_4_5.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__4__5.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_ilc", "test": "fn test_skip_iter_ilc() {\n    // Test iterators that skip multiple, internal or leading digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_leading_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4_.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4__.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"455\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45_.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"45__.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"45__.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"45_\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"45__\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"45_.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"45__.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_itc", "test": "fn test_skip_iter_itc() {\n    // Test iterators that skip multiple, internal or trailing digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_trailing_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"_455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"__455\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"45.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"__45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"_45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"__45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"_45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"__45.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_ltc", "test": "fn test_skip_iter_ltc() {\n    // Test iterators that skip multiple, leading or trailing digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_leading_digit_separator(true)\n        .integer_trailing_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".45_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".45__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"4_5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"4__5.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"4_5\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"4__5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"4_5.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"4__5.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/tests/skip_tests.rs::test_skip_iter_iltc", "test": "fn test_skip_iter_iltc() {\n    // Test iterators that skip multiple digit separators.\n    pub const FORMAT: u128 = NumberFormatBuilder::new()\n        .digit_separator(num::NonZeroU8::new(b'_'))\n        .integer_internal_digit_separator(true)\n        .integer_leading_digit_separator(true)\n        .integer_trailing_digit_separator(true)\n        .integer_consecutive_digit_separator(true)\n        .build();\n    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());\n\n    skip_iter_eq::<{ FORMAT }>(b\"123.45\", b\"123.45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e45\", b\"1e45\");\n    skip_iter_eq::<{ FORMAT }>(b\"1e\", b\"1e\");\n    skip_iter_eq::<{ FORMAT }>(b\"1\", b\"1\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45\", b\".45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__\", b\"4\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__.\", b\"4.\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_5\", b\"455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__5\", b\"455\");\n    skip_iter_eq::<{ FORMAT }>(b\"_.45_5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"__.45__5\", b\".455\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"4_5_.5\", b\"45.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"4__5__.5\", b\"45.5\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_45_.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__45__.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__\", b\"45\");\n    skip_iter_eq::<{ FORMAT }>(b\"_4_5_.56\", b\"45.56\");\n    skip_iter_eq::<{ FORMAT }>(b\"__4__5__.56\", b\"45.56\");\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/not_feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::invalid_exponent_test", "test": "fn invalid_exponent_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.exponent(b'\\x00');\n    assert!(!builder.is_valid());\n    builder = builder.exponent(b'\\x7f');\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.exponent(b'^');\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::invalid_decimal_point_test", "test": "fn invalid_decimal_point_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.decimal_point(b'\\x00');\n    assert!(!builder.is_valid());\n    builder = builder.decimal_point(b'\\x7f');\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.decimal_point(b',');\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::invalid_nan_test", "test": "fn invalid_nan_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.nan_string(Some(b\"naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaan\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"inf\"));\n    assert!(!builder.is_valid());\n    builder = builder.nan_string(Some(b\"na00n\"));\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.nan_string(Some(b\"nan\"));\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n    builder = builder.nan_string(None);\n    assert!(builder.is_valid());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/tests/options_tests.rs::invalid_inf_test", "test": "fn invalid_inf_test() {\n    let mut builder = OptionsBuilder::default();\n    builder = builder.inf_string(Some(b\"innnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnf\"));\n    assert!(!builder.is_valid());\n    builder = builder.inf_string(Some(b\"nan\"));\n    assert!(!builder.is_valid());\n    builder = builder.inf_string(Some(b\"in00f\"));\n    assert!(!builder.is_valid());\n    assert!(builder.build().is_err());\n    builder = builder.inf_string(Some(b\"inf\"));\n    assert!(builder.is_valid());\n    assert!(builder.build().is_ok());\n    builder = builder.inf_string(None);\n    assert!(builder.is_valid());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/feature_format.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        self.error().is_success()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u8_pow2_test", "test": "fn u8_pow2_test() {\n    let values: &[u8] =\n        &[0, 1, 2, 3, 4, 5, 7, 8, 9, 15, 16, 17, 31, 32, 33, 63, 64, 65, 127, 128, 129, 255];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/etc/correctness/dragonbox/roundtrip.rs::roundtrip", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u8_pow10_test", "test": "fn u8_pow10_test() {\n    let values: &[u8] = &[0, 1, 5, 9, 10, 11, 15, 99, 100, 101, 105];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/etc/correctness/dragonbox/roundtrip.rs::roundtrip", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u16_pow2_test", "test": "fn u16_pow2_test() {\n    let values: &[u16] = &[\n        0, 1, 2, 3, 4, 5, 7, 8, 9, 15, 16, 17, 31, 32, 33, 63, 64, 65, 127, 128, 129, 255, 256,\n        257, 511, 512, 513, 1023, 1024, 1025, 2047, 2048, 2049, 4095, 4096, 4097, 8191, 8192, 8193,\n        16383, 16384, 16385, 32767, 32768, 32769, 65535,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/etc/correctness/dragonbox/roundtrip.rs::roundtrip", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u16_pow10_test", "test": "fn u16_pow10_test() {\n    let values: &[u16] = &[\n        0, 1, 5, 9, 10, 11, 15, 99, 100, 101, 105, 999, 1000, 1001, 1005, 9999, 10000, 10001, 10005,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/etc/correctness/dragonbox/roundtrip.rs::roundtrip", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u32_pow2_test", "test": "fn u32_pow2_test() {\n    let values: &[u32] = &[\n        0, 1, 2, 3, 4, 5, 7, 8, 9, 15, 16, 17, 31, 32, 33, 63, 64, 65, 127, 128, 129, 255, 256,\n        257, 511, 512, 513, 1023, 1024, 1025, 2047, 2048, 2049, 4095, 4096, 4097, 8191, 8192, 8193,\n        16383, 16384, 16385, 32767, 32768, 32769, 65535, 65536, 65537, 131071, 131072, 131073,\n        262143, 262144, 262145, 524287, 524288, 524289, 1048575, 1048576, 1048577, 2097151,\n        2097152, 2097153, 4194303, 4194304, 4194305, 8388607, 8388608, 8388609, 16777215, 16777216,\n        16777217, 33554431, 33554432, 33554433, 67108863, 67108864, 67108865, 134217727, 134217728,\n        134217729, 268435455, 268435456, 268435457, 536870911, 536870912, 536870913, 1073741823,\n        1073741824, 1073741825, 2147483647, 2147483648, 2147483649, 4294967295,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/etc/correctness/dragonbox/roundtrip.rs::roundtrip", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u32_pow10_test", "test": "fn u32_pow10_test() {\n    let values: &[u32] = &[\n        0, 1, 5, 9, 10, 11, 15, 99, 100, 101, 105, 999, 1000, 1001, 1005, 9999, 10000, 10001,\n        10005, 99999, 100000, 100001, 100005, 999999, 1000000, 1000001, 1000005, 9999999, 10000000,\n        10000001, 10000005, 99999999, 100000000, 100000001, 100000005, 999999999, 1000000000,\n        1000000001, 1000000005,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/etc/correctness/dragonbox/roundtrip.rs::roundtrip", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u64_pow2_test", "test": "fn u64_pow2_test() {\n    let values: &[u64] = &[\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        7,\n        8,\n        9,\n        15,\n        16,\n        17,\n        31,\n        32,\n        33,\n        63,\n        64,\n        65,\n        127,\n        128,\n        129,\n        255,\n        256,\n        257,\n        511,\n        512,\n        513,\n        1023,\n        1024,\n        1025,\n        2047,\n        2048,\n        2049,\n        4095,\n        4096,\n        4097,\n        8191,\n        8192,\n        8193,\n        16383,\n        16384,\n        16385,\n        32767,\n        32768,\n        32769,\n        65535,\n        65536,\n        65537,\n        131071,\n        131072,\n        131073,\n        262143,\n        262144,\n        262145,\n        524287,\n        524288,\n        524289,\n        1048575,\n        1048576,\n        1048577,\n        2097151,\n        2097152,\n        2097153,\n        4194303,\n        4194304,\n        4194305,\n        8388607,\n        8388608,\n        8388609,\n        16777215,\n        16777216,\n        16777217,\n        33554431,\n        33554432,\n        33554433,\n        67108863,\n        67108864,\n        67108865,\n        134217727,\n        134217728,\n        134217729,\n        268435455,\n        268435456,\n        268435457,\n        536870911,\n        536870912,\n        536870913,\n        1073741823,\n        1073741824,\n        1073741825,\n        2147483647,\n        2147483648,\n        2147483649,\n        4294967295,\n        4294967296,\n        4294967297,\n        8589934591,\n        8589934592,\n        8589934593,\n        17179869183,\n        17179869184,\n        17179869185,\n        34359738367,\n        34359738368,\n        34359738369,\n        68719476735,\n        68719476736,\n        68719476737,\n        137438953471,\n        137438953472,\n        137438953473,\n        274877906943,\n        274877906944,\n        274877906945,\n        549755813887,\n        549755813888,\n        549755813889,\n        1099511627775,\n        1099511627776,\n        1099511627777,\n        2199023255551,\n        2199023255552,\n        2199023255553,\n        4398046511103,\n        4398046511104,\n        4398046511105,\n        8796093022207,\n        8796093022208,\n        8796093022209,\n        17592186044415,\n        17592186044416,\n        17592186044417,\n        35184372088831,\n        35184372088832,\n        35184372088833,\n        70368744177663,\n        70368744177664,\n        70368744177665,\n        140737488355327,\n        140737488355328,\n        140737488355329,\n        281474976710655,\n        281474976710656,\n        281474976710657,\n        562949953421311,\n        562949953421312,\n        562949953421313,\n        1125899906842623,\n        1125899906842624,\n        1125899906842625,\n        2251799813685247,\n        2251799813685248,\n        2251799813685249,\n        4503599627370495,\n        4503599627370496,\n        4503599627370497,\n        9007199254740991,\n        9007199254740992,\n        9007199254740993,\n        18014398509481983,\n        18014398509481984,\n        18014398509481985,\n        36028797018963967,\n        36028797018963968,\n        36028797018963969,\n        72057594037927935,\n        72057594037927936,\n        72057594037927937,\n        144115188075855871,\n        144115188075855872,\n        144115188075855873,\n        288230376151711743,\n        288230376151711744,\n        288230376151711745,\n        576460752303423487,\n        576460752303423488,\n        576460752303423489,\n        1152921504606846975,\n        1152921504606846976,\n        1152921504606846977,\n        2305843009213693951,\n        2305843009213693952,\n        2305843009213693953,\n        4611686018427387903,\n        4611686018427387904,\n        4611686018427387905,\n        9223372036854775807,\n        9223372036854775808,\n        9223372036854775809,\n        18446744073709551615,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/etc/correctness/dragonbox/roundtrip.rs::roundtrip", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u64_pow10_test", "test": "fn u64_pow10_test() {\n    let values: &[u64] = &[\n        0,\n        1,\n        5,\n        9,\n        10,\n        11,\n        15,\n        99,\n        100,\n        101,\n        105,\n        999,\n        1000,\n        1001,\n        1005,\n        9999,\n        10000,\n        10001,\n        10005,\n        99999,\n        100000,\n        100001,\n        100005,\n        999999,\n        1000000,\n        1000001,\n        1000005,\n        9999999,\n        10000000,\n        10000001,\n        10000005,\n        99999999,\n        100000000,\n        100000001,\n        100000005,\n        999999999,\n        1000000000,\n        1000000001,\n        1000000005,\n        9999999999,\n        10000000000,\n        10000000001,\n        10000000005,\n        99999999999,\n        100000000000,\n        100000000001,\n        100000000005,\n        999999999999,\n        1000000000000,\n        1000000000001,\n        1000000000005,\n        9999999999999,\n        10000000000000,\n        10000000000001,\n        10000000000005,\n        99999999999999,\n        100000000000000,\n        100000000000001,\n        100000000000005,\n        999999999999999,\n        1000000000000000,\n        1000000000000001,\n        1000000000000005,\n        9999999999999999,\n        10000000000000000,\n        10000000000000001,\n        10000000000000005,\n        99999999999999999,\n        100000000000000000,\n        100000000000000001,\n        100000000000000005,\n        999999999999999999,\n        1000000000000000000,\n        1000000000000000001,\n        1000000000000000005,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/etc/correctness/dragonbox/roundtrip.rs::roundtrip", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u128_pow2_test", "test": "fn u128_pow2_test() {\n    let values: &[u128] = &[\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        7,\n        8,\n        9,\n        15,\n        16,\n        17,\n        31,\n        32,\n        33,\n        63,\n        64,\n        65,\n        127,\n        128,\n        129,\n        255,\n        256,\n        257,\n        511,\n        512,\n        513,\n        1023,\n        1024,\n        1025,\n        2047,\n        2048,\n        2049,\n        4095,\n        4096,\n        4097,\n        8191,\n        8192,\n        8193,\n        16383,\n        16384,\n        16385,\n        32767,\n        32768,\n        32769,\n        65535,\n        65536,\n        65537,\n        131071,\n        131072,\n        131073,\n        262143,\n        262144,\n        262145,\n        524287,\n        524288,\n        524289,\n        1048575,\n        1048576,\n        1048577,\n        2097151,\n        2097152,\n        2097153,\n        4194303,\n        4194304,\n        4194305,\n        8388607,\n        8388608,\n        8388609,\n        16777215,\n        16777216,\n        16777217,\n        33554431,\n        33554432,\n        33554433,\n        67108863,\n        67108864,\n        67108865,\n        134217727,\n        134217728,\n        134217729,\n        268435455,\n        268435456,\n        268435457,\n        536870911,\n        536870912,\n        536870913,\n        1073741823,\n        1073741824,\n        1073741825,\n        2147483647,\n        2147483648,\n        2147483649,\n        4294967295,\n        4294967296,\n        4294967297,\n        8589934591,\n        8589934592,\n        8589934593,\n        17179869183,\n        17179869184,\n        17179869185,\n        34359738367,\n        34359738368,\n        34359738369,\n        68719476735,\n        68719476736,\n        68719476737,\n        137438953471,\n        137438953472,\n        137438953473,\n        274877906943,\n        274877906944,\n        274877906945,\n        549755813887,\n        549755813888,\n        549755813889,\n        1099511627775,\n        1099511627776,\n        1099511627777,\n        2199023255551,\n        2199023255552,\n        2199023255553,\n        4398046511103,\n        4398046511104,\n        4398046511105,\n        8796093022207,\n        8796093022208,\n        8796093022209,\n        17592186044415,\n        17592186044416,\n        17592186044417,\n        35184372088831,\n        35184372088832,\n        35184372088833,\n        70368744177663,\n        70368744177664,\n        70368744177665,\n        140737488355327,\n        140737488355328,\n        140737488355329,\n        281474976710655,\n        281474976710656,\n        281474976710657,\n        562949953421311,\n        562949953421312,\n        562949953421313,\n        1125899906842623,\n        1125899906842624,\n        1125899906842625,\n        2251799813685247,\n        2251799813685248,\n        2251799813685249,\n        4503599627370495,\n        4503599627370496,\n        4503599627370497,\n        9007199254740991,\n        9007199254740992,\n        9007199254740993,\n        18014398509481983,\n        18014398509481984,\n        18014398509481985,\n        36028797018963967,\n        36028797018963968,\n        36028797018963969,\n        72057594037927935,\n        72057594037927936,\n        72057594037927937,\n        144115188075855871,\n        144115188075855872,\n        144115188075855873,\n        288230376151711743,\n        288230376151711744,\n        288230376151711745,\n        576460752303423487,\n        576460752303423488,\n        576460752303423489,\n        1152921504606846975,\n        1152921504606846976,\n        1152921504606846977,\n        2305843009213693951,\n        2305843009213693952,\n        2305843009213693953,\n        4611686018427387903,\n        4611686018427387904,\n        4611686018427387905,\n        9223372036854775807,\n        9223372036854775808,\n        9223372036854775809,\n        18446744073709551615,\n        18446744073709551616,\n        18446744073709551617,\n        36893488147419103231,\n        36893488147419103232,\n        36893488147419103233,\n        73786976294838206463,\n        73786976294838206464,\n        73786976294838206465,\n        147573952589676412927,\n        147573952589676412928,\n        147573952589676412929,\n        295147905179352825855,\n        295147905179352825856,\n        295147905179352825857,\n        590295810358705651711,\n        590295810358705651712,\n        590295810358705651713,\n        1180591620717411303423,\n        1180591620717411303424,\n        1180591620717411303425,\n        2361183241434822606847,\n        2361183241434822606848,\n        2361183241434822606849,\n        4722366482869645213695,\n        4722366482869645213696,\n        4722366482869645213697,\n        9444732965739290427391,\n        9444732965739290427392,\n        9444732965739290427393,\n        18889465931478580854783,\n        18889465931478580854784,\n        18889465931478580854785,\n        37778931862957161709567,\n        37778931862957161709568,\n        37778931862957161709569,\n        75557863725914323419135,\n        75557863725914323419136,\n        75557863725914323419137,\n        151115727451828646838271,\n        151115727451828646838272,\n        151115727451828646838273,\n        302231454903657293676543,\n        302231454903657293676544,\n        302231454903657293676545,\n        604462909807314587353087,\n        604462909807314587353088,\n        604462909807314587353089,\n        1208925819614629174706175,\n        1208925819614629174706176,\n        1208925819614629174706177,\n        2417851639229258349412351,\n        2417851639229258349412352,\n        2417851639229258349412353,\n        4835703278458516698824703,\n        4835703278458516698824704,\n        4835703278458516698824705,\n        9671406556917033397649407,\n        9671406556917033397649408,\n        9671406556917033397649409,\n        19342813113834066795298815,\n        19342813113834066795298816,\n        19342813113834066795298817,\n        38685626227668133590597631,\n        38685626227668133590597632,\n        38685626227668133590597633,\n        77371252455336267181195263,\n        77371252455336267181195264,\n        77371252455336267181195265,\n        154742504910672534362390527,\n        154742504910672534362390528,\n        154742504910672534362390529,\n        309485009821345068724781055,\n        309485009821345068724781056,\n        309485009821345068724781057,\n        618970019642690137449562111,\n        618970019642690137449562112,\n        618970019642690137449562113,\n        1237940039285380274899124223,\n        1237940039285380274899124224,\n        1237940039285380274899124225,\n        2475880078570760549798248447,\n        2475880078570760549798248448,\n        2475880078570760549798248449,\n        4951760157141521099596496895,\n        4951760157141521099596496896,\n        4951760157141521099596496897,\n        9903520314283042199192993791,\n        9903520314283042199192993792,\n        9903520314283042199192993793,\n        19807040628566084398385987583,\n        19807040628566084398385987584,\n        19807040628566084398385987585,\n        39614081257132168796771975167,\n        39614081257132168796771975168,\n        39614081257132168796771975169,\n        79228162514264337593543950335,\n        79228162514264337593543950336,\n        79228162514264337593543950337,\n        158456325028528675187087900671,\n        158456325028528675187087900672,\n        158456325028528675187087900673,\n        316912650057057350374175801343,\n        316912650057057350374175801344,\n        316912650057057350374175801345,\n        633825300114114700748351602687,\n        633825300114114700748351602688,\n        633825300114114700748351602689,\n        1267650600228229401496703205375,\n        1267650600228229401496703205376,\n        1267650600228229401496703205377,\n        2535301200456458802993406410751,\n        2535301200456458802993406410752,\n        2535301200456458802993406410753,\n        5070602400912917605986812821503,\n        5070602400912917605986812821504,\n        5070602400912917605986812821505,\n        10141204801825835211973625643007,\n        10141204801825835211973625643008,\n        10141204801825835211973625643009,\n        20282409603651670423947251286015,\n        20282409603651670423947251286016,\n        20282409603651670423947251286017,\n        40564819207303340847894502572031,\n        40564819207303340847894502572032,\n        40564819207303340847894502572033,\n        81129638414606681695789005144063,\n        81129638414606681695789005144064,\n        81129638414606681695789005144065,\n        162259276829213363391578010288127,\n        162259276829213363391578010288128,\n        162259276829213363391578010288129,\n        324518553658426726783156020576255,\n        324518553658426726783156020576256,\n        324518553658426726783156020576257,\n        649037107316853453566312041152511,\n        649037107316853453566312041152512,\n        649037107316853453566312041152513,\n        1298074214633706907132624082305023,\n        1298074214633706907132624082305024,\n        1298074214633706907132624082305025,\n        2596148429267413814265248164610047,\n        2596148429267413814265248164610048,\n        2596148429267413814265248164610049,\n        5192296858534827628530496329220095,\n        5192296858534827628530496329220096,\n        5192296858534827628530496329220097,\n        10384593717069655257060992658440191,\n        10384593717069655257060992658440192,\n        10384593717069655257060992658440193,\n        20769187434139310514121985316880383,\n        20769187434139310514121985316880384,\n        20769187434139310514121985316880385,\n        41538374868278621028243970633760767,\n        41538374868278621028243970633760768,\n        41538374868278621028243970633760769,\n        83076749736557242056487941267521535,\n        83076749736557242056487941267521536,\n        83076749736557242056487941267521537,\n        166153499473114484112975882535043071,\n        166153499473114484112975882535043072,\n        166153499473114484112975882535043073,\n        332306998946228968225951765070086143,\n        332306998946228968225951765070086144,\n        332306998946228968225951765070086145,\n        664613997892457936451903530140172287,\n        664613997892457936451903530140172288,\n        664613997892457936451903530140172289,\n        1329227995784915872903807060280344575,\n        1329227995784915872903807060280344576,\n        1329227995784915872903807060280344577,\n        2658455991569831745807614120560689151,\n        2658455991569831745807614120560689152,\n        2658455991569831745807614120560689153,\n        5316911983139663491615228241121378303,\n        5316911983139663491615228241121378304,\n        5316911983139663491615228241121378305,\n        10633823966279326983230456482242756607,\n        10633823966279326983230456482242756608,\n        10633823966279326983230456482242756609,\n        21267647932558653966460912964485513215,\n        21267647932558653966460912964485513216,\n        21267647932558653966460912964485513217,\n        42535295865117307932921825928971026431,\n        42535295865117307932921825928971026432,\n        42535295865117307932921825928971026433,\n        85070591730234615865843651857942052863,\n        85070591730234615865843651857942052864,\n        85070591730234615865843651857942052865,\n        170141183460469231731687303715884105727,\n        170141183460469231731687303715884105728,\n        170141183460469231731687303715884105729,\n        340282366920938463463374607431768211455,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/etc/correctness/dragonbox/roundtrip.rs::roundtrip", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/api_tests.rs::u128_pow10_test", "test": "fn u128_pow10_test() {\n    let values: &[u128] = &[\n        0,\n        1,\n        5,\n        9,\n        10,\n        11,\n        15,\n        99,\n        100,\n        101,\n        105,\n        999,\n        1000,\n        1001,\n        1005,\n        9999,\n        10000,\n        10001,\n        10005,\n        99999,\n        100000,\n        100001,\n        100005,\n        999999,\n        1000000,\n        1000001,\n        1000005,\n        9999999,\n        10000000,\n        10000001,\n        10000005,\n        99999999,\n        100000000,\n        100000001,\n        100000005,\n        999999999,\n        1000000000,\n        1000000001,\n        1000000005,\n        9999999999,\n        10000000000,\n        10000000001,\n        10000000005,\n        99999999999,\n        100000000000,\n        100000000001,\n        100000000005,\n        999999999999,\n        1000000000000,\n        1000000000001,\n        1000000000005,\n        9999999999999,\n        10000000000000,\n        10000000000001,\n        10000000000005,\n        99999999999999,\n        100000000000000,\n        100000000000001,\n        100000000000005,\n        999999999999999,\n        1000000000000000,\n        1000000000000001,\n        1000000000000005,\n        9999999999999999,\n        10000000000000000,\n        10000000000000001,\n        10000000000000005,\n        99999999999999999,\n        100000000000000000,\n        100000000000000001,\n        100000000000000005,\n        999999999999999999,\n        1000000000000000000,\n        1000000000000000001,\n        1000000000000000005,\n        9999999999999999999,\n        10000000000000000000,\n        10000000000000000001,\n        10000000000000000005,\n        99999999999999999999,\n        100000000000000000000,\n        100000000000000000001,\n        100000000000000000005,\n        999999999999999999999,\n        1000000000000000000000,\n        1000000000000000000001,\n        1000000000000000000005,\n        9999999999999999999999,\n        10000000000000000000000,\n        10000000000000000000001,\n        10000000000000000000005,\n        99999999999999999999999,\n        100000000000000000000000,\n        100000000000000000000001,\n        100000000000000000000005,\n        999999999999999999999999,\n        1000000000000000000000000,\n        1000000000000000000000001,\n        1000000000000000000000005,\n        9999999999999999999999999,\n        10000000000000000000000000,\n        10000000000000000000000001,\n        10000000000000000000000005,\n        99999999999999999999999999,\n        100000000000000000000000000,\n        100000000000000000000000001,\n        100000000000000000000000005,\n        999999999999999999999999999,\n        1000000000000000000000000000,\n        1000000000000000000000000001,\n        1000000000000000000000000005,\n        9999999999999999999999999999,\n        10000000000000000000000000000,\n        10000000000000000000000000001,\n        10000000000000000000000000005,\n        99999999999999999999999999999,\n        100000000000000000000000000000,\n        100000000000000000000000000001,\n        100000000000000000000000000005,\n        999999999999999999999999999999,\n        1000000000000000000000000000000,\n        1000000000000000000000000000001,\n        1000000000000000000000000000005,\n        9999999999999999999999999999999,\n        10000000000000000000000000000000,\n        10000000000000000000000000000001,\n        10000000000000000000000000000005,\n        99999999999999999999999999999999,\n        100000000000000000000000000000000,\n        100000000000000000000000000000001,\n        100000000000000000000000000000005,\n        999999999999999999999999999999999,\n        1000000000000000000000000000000000,\n        1000000000000000000000000000000001,\n        1000000000000000000000000000000005,\n        9999999999999999999999999999999999,\n        10000000000000000000000000000000000,\n        10000000000000000000000000000000001,\n        10000000000000000000000000000000005,\n        99999999999999999999999999999999999,\n        100000000000000000000000000000000000,\n        100000000000000000000000000000000001,\n        100000000000000000000000000000000005,\n        999999999999999999999999999999999999,\n        1000000000000000000000000000000000000,\n        1000000000000000000000000000000000001,\n        1000000000000000000000000000000000005,\n        9999999999999999999999999999999999999,\n        10000000000000000000000000000000000000,\n        10000000000000000000000000000000000001,\n        10000000000000000000000000000000000005,\n        99999999999999999999999999999999999999,\n        100000000000000000000000000000000000000,\n        100000000000000000000000000000000000001,\n        100000000000000000000000000000000000005,\n    ];\n    for &i in values.iter() {\n        assert_eq!(i, roundtrip(i));\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-float/etc/correctness/dragonbox/roundtrip.rs::roundtrip", "code": "pub fn roundtrip<F>(float: F, buffer: &mut [u8]) -> Result<(), String>\nwhere\n    F: RawFloat + ToLexical + std::str::FromStr + std::string::ToString,\n{\n    let bytes = float.to_lexical(buffer);\n    let string = unsafe { std::str::from_utf8_unchecked(bytes) };\n    let roundtrip = string.parse::<F>().map_err(|_| float.to_string())?;\n    let is_equal = if float.is_nan() {\n        roundtrip.is_nan()\n    } else {\n        float == roundtrip\n    };\n    if !is_equal {\n        return Err(float.to_string());\n    }\n    Ok(())\n}", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/decimal_tests.rs::u32toa_test", "test": "fn u32toa_test() {\n    let mut buffer = [b'\\x00'; 16];\n    unsafe {\n        assert_eq!(5u32.decimal(&mut buffer), 1);\n        assert_eq!(&buffer[..1], b\"5\");\n\n        assert_eq!(11u32.decimal(&mut buffer), 2);\n        assert_eq!(&buffer[..2], b\"11\");\n\n        assert_eq!(99u32.decimal(&mut buffer), 2);\n        assert_eq!(&buffer[..2], b\"99\");\n\n        assert_eq!(101u32.decimal(&mut buffer), 3);\n        assert_eq!(&buffer[..3], b\"101\");\n\n        assert_eq!(999u32.decimal(&mut buffer), 3);\n        assert_eq!(&buffer[..3], b\"999\");\n\n        assert_eq!(1001u32.decimal(&mut buffer), 4);\n        assert_eq!(&buffer[..4], b\"1001\");\n\n        assert_eq!(9999u32.decimal(&mut buffer), 4);\n        assert_eq!(&buffer[..4], b\"9999\");\n\n        assert_eq!(10001u32.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"10001\");\n\n        assert_eq!(65535u32.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"65535\");\n\n        assert_eq!(99999u32.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"99999\");\n\n        assert_eq!(100001u32.decimal(&mut buffer), 6);\n        assert_eq!(&buffer[..6], b\"100001\");\n\n        assert_eq!(999999u32.decimal(&mut buffer), 6);\n        assert_eq!(&buffer[..6], b\"999999\");\n\n        assert_eq!(1000001u32.decimal(&mut buffer), 7);\n        assert_eq!(&buffer[..7], b\"1000001\");\n\n        assert_eq!(9999999u32.decimal(&mut buffer), 7);\n        assert_eq!(&buffer[..7], b\"9999999\");\n\n        assert_eq!(10000001u32.decimal(&mut buffer), 8);\n        assert_eq!(&buffer[..8], b\"10000001\");\n\n        assert_eq!(99999999u32.decimal(&mut buffer), 8);\n        assert_eq!(&buffer[..8], b\"99999999\");\n\n        assert_eq!(100000001u32.decimal(&mut buffer), 9);\n        assert_eq!(&buffer[..9], b\"100000001\");\n\n        assert_eq!(999999999u32.decimal(&mut buffer), 9);\n        assert_eq!(&buffer[..9], b\"999999999\");\n\n        assert_eq!(1000000001u32.decimal(&mut buffer), 10);\n        assert_eq!(&buffer[..10], b\"1000000001\");\n\n        assert_eq!(4294967295u32.decimal(&mut buffer), 10);\n        assert_eq!(&buffer[..10], b\"4294967295\");\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/format_builder.rs::decimal", "code": "pub const fn decimal() -> u128 {\n        let mut builder = Self::new();\n        builder.mantissa_radix = 10;\n        builder.exponent_base = num::NonZeroU8::new(10);\n        builder.exponent_radix = num::NonZeroU8::new(10);\n        builder.build()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/decimal_tests.rs::u64toa_test", "test": "fn u64toa_test() {\n    let mut buffer = [b'\\x00'; 32];\n    unsafe {\n        assert_eq!(5u64.decimal(&mut buffer), 1);\n        assert_eq!(&buffer[..1], b\"5\");\n\n        assert_eq!(11u64.decimal(&mut buffer), 2);\n        assert_eq!(&buffer[..2], b\"11\");\n\n        assert_eq!(99u64.decimal(&mut buffer), 2);\n        assert_eq!(&buffer[..2], b\"99\");\n\n        assert_eq!(101u64.decimal(&mut buffer), 3);\n        assert_eq!(&buffer[..3], b\"101\");\n\n        assert_eq!(999u64.decimal(&mut buffer), 3);\n        assert_eq!(&buffer[..3], b\"999\");\n\n        assert_eq!(1001u64.decimal(&mut buffer), 4);\n        assert_eq!(&buffer[..4], b\"1001\");\n\n        assert_eq!(9999u64.decimal(&mut buffer), 4);\n        assert_eq!(&buffer[..4], b\"9999\");\n\n        assert_eq!(10001u64.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"10001\");\n\n        assert_eq!(65535u64.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"65535\");\n\n        assert_eq!(99999u64.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"99999\");\n\n        assert_eq!(100001u64.decimal(&mut buffer), 6);\n        assert_eq!(&buffer[..6], b\"100001\");\n\n        assert_eq!(999999u64.decimal(&mut buffer), 6);\n        assert_eq!(&buffer[..6], b\"999999\");\n\n        assert_eq!(1000001u64.decimal(&mut buffer), 7);\n        assert_eq!(&buffer[..7], b\"1000001\");\n\n        assert_eq!(9999999u64.decimal(&mut buffer), 7);\n        assert_eq!(&buffer[..7], b\"9999999\");\n\n        assert_eq!(10000001u64.decimal(&mut buffer), 8);\n        assert_eq!(&buffer[..8], b\"10000001\");\n\n        assert_eq!(99999999u64.decimal(&mut buffer), 8);\n        assert_eq!(&buffer[..8], b\"99999999\");\n\n        assert_eq!(100000001u64.decimal(&mut buffer), 9);\n        assert_eq!(&buffer[..9], b\"100000001\");\n\n        assert_eq!(999999999u64.decimal(&mut buffer), 9);\n        assert_eq!(&buffer[..9], b\"999999999\");\n\n        assert_eq!(1000000001u64.decimal(&mut buffer), 10);\n        assert_eq!(&buffer[..10], b\"1000000001\");\n\n        assert_eq!(9999999999u64.decimal(&mut buffer), 10);\n        assert_eq!(&buffer[..10], b\"9999999999\");\n\n        assert_eq!(10000000001u64.decimal(&mut buffer), 11);\n        assert_eq!(&buffer[..11], b\"10000000001\");\n\n        assert_eq!(99999999999u64.decimal(&mut buffer), 11);\n        assert_eq!(&buffer[..11], b\"99999999999\");\n\n        assert_eq!(100000000001u64.decimal(&mut buffer), 12);\n        assert_eq!(&buffer[..12], b\"100000000001\");\n\n        assert_eq!(999999999999u64.decimal(&mut buffer), 12);\n        assert_eq!(&buffer[..12], b\"999999999999\");\n\n        assert_eq!(1000000000001u64.decimal(&mut buffer), 13);\n        assert_eq!(&buffer[..13], b\"1000000000001\");\n\n        assert_eq!(9999999999999u64.decimal(&mut buffer), 13);\n        assert_eq!(&buffer[..13], b\"9999999999999\");\n\n        assert_eq!(10000000000001u64.decimal(&mut buffer), 14);\n        assert_eq!(&buffer[..14], b\"10000000000001\");\n\n        assert_eq!(99999999999999u64.decimal(&mut buffer), 14);\n        assert_eq!(&buffer[..14], b\"99999999999999\");\n\n        assert_eq!(100000000000001u64.decimal(&mut buffer), 15);\n        assert_eq!(&buffer[..15], b\"100000000000001\");\n\n        assert_eq!(999999999999999u64.decimal(&mut buffer), 15);\n        assert_eq!(&buffer[..15], b\"999999999999999\");\n\n        assert_eq!(1000000000000001u64.decimal(&mut buffer), 16);\n        assert_eq!(&buffer[..16], b\"1000000000000001\");\n\n        assert_eq!(9999999999999999u64.decimal(&mut buffer), 16);\n        assert_eq!(&buffer[..16], b\"9999999999999999\");\n\n        assert_eq!(10000000000000001u64.decimal(&mut buffer), 17);\n        assert_eq!(&buffer[..17], b\"10000000000000001\");\n\n        assert_eq!(99999999999999999u64.decimal(&mut buffer), 17);\n        assert_eq!(&buffer[..17], b\"99999999999999999\");\n\n        assert_eq!(100000000000000001u64.decimal(&mut buffer), 18);\n        assert_eq!(&buffer[..18], b\"100000000000000001\");\n\n        assert_eq!(999999999999999999u64.decimal(&mut buffer), 18);\n        assert_eq!(&buffer[..18], b\"999999999999999999\");\n\n        assert_eq!(1000000000000000001u64.decimal(&mut buffer), 19);\n        assert_eq!(&buffer[..19], b\"1000000000000000001\");\n\n        assert_eq!(9999999999999999999u64.decimal(&mut buffer), 19);\n        assert_eq!(&buffer[..19], b\"9999999999999999999\");\n\n        assert_eq!(10000000000000000001u64.decimal(&mut buffer), 20);\n        assert_eq!(&buffer[..20], b\"10000000000000000001\");\n\n        assert_eq!(18446744073709551615u64.decimal(&mut buffer), 20);\n        assert_eq!(&buffer[..20], b\"18446744073709551615\");\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/format_builder.rs::decimal", "code": "pub const fn decimal() -> u128 {\n        let mut builder = Self::new();\n        builder.mantissa_radix = 10;\n        builder.exponent_base = num::NonZeroU8::new(10);\n        builder.exponent_radix = num::NonZeroU8::new(10);\n        builder.build()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/decimal_tests.rs::u128toa_test", "test": "fn u128toa_test() {\n    let mut buffer = [b'\\x00'; 48];\n    unsafe {\n        assert_eq!(5u128.decimal(&mut buffer), 1);\n        assert_eq!(&buffer[..1], b\"5\");\n\n        assert_eq!(11u128.decimal(&mut buffer), 2);\n        assert_eq!(&buffer[..2], b\"11\");\n\n        assert_eq!(99u128.decimal(&mut buffer), 2);\n        assert_eq!(&buffer[..2], b\"99\");\n\n        assert_eq!(101u128.decimal(&mut buffer), 3);\n        assert_eq!(&buffer[..3], b\"101\");\n\n        assert_eq!(999u128.decimal(&mut buffer), 3);\n        assert_eq!(&buffer[..3], b\"999\");\n\n        assert_eq!(1001u128.decimal(&mut buffer), 4);\n        assert_eq!(&buffer[..4], b\"1001\");\n\n        assert_eq!(9999u128.decimal(&mut buffer), 4);\n        assert_eq!(&buffer[..4], b\"9999\");\n\n        assert_eq!(10001u128.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"10001\");\n\n        assert_eq!(65535u128.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"65535\");\n\n        assert_eq!(99999u128.decimal(&mut buffer), 5);\n        assert_eq!(&buffer[..5], b\"99999\");\n\n        assert_eq!(100001u128.decimal(&mut buffer), 6);\n        assert_eq!(&buffer[..6], b\"100001\");\n\n        assert_eq!(999999u128.decimal(&mut buffer), 6);\n        assert_eq!(&buffer[..6], b\"999999\");\n\n        assert_eq!(1000001u128.decimal(&mut buffer), 7);\n        assert_eq!(&buffer[..7], b\"1000001\");\n\n        assert_eq!(9999999u128.decimal(&mut buffer), 7);\n        assert_eq!(&buffer[..7], b\"9999999\");\n\n        assert_eq!(10000001u128.decimal(&mut buffer), 8);\n        assert_eq!(&buffer[..8], b\"10000001\");\n\n        assert_eq!(99999999u128.decimal(&mut buffer), 8);\n        assert_eq!(&buffer[..8], b\"99999999\");\n\n        assert_eq!(100000001u128.decimal(&mut buffer), 9);\n        assert_eq!(&buffer[..9], b\"100000001\");\n\n        assert_eq!(999999999u128.decimal(&mut buffer), 9);\n        assert_eq!(&buffer[..9], b\"999999999\");\n\n        assert_eq!(1000000001u128.decimal(&mut buffer), 10);\n        assert_eq!(&buffer[..10], b\"1000000001\");\n\n        assert_eq!(9999999999u128.decimal(&mut buffer), 10);\n        assert_eq!(&buffer[..10], b\"9999999999\");\n\n        assert_eq!(10000000001u128.decimal(&mut buffer), 11);\n        assert_eq!(&buffer[..11], b\"10000000001\");\n\n        assert_eq!(99999999999u128.decimal(&mut buffer), 11);\n        assert_eq!(&buffer[..11], b\"99999999999\");\n\n        assert_eq!(100000000001u128.decimal(&mut buffer), 12);\n        assert_eq!(&buffer[..12], b\"100000000001\");\n\n        assert_eq!(999999999999u128.decimal(&mut buffer), 12);\n        assert_eq!(&buffer[..12], b\"999999999999\");\n\n        assert_eq!(1000000000001u128.decimal(&mut buffer), 13);\n        assert_eq!(&buffer[..13], b\"1000000000001\");\n\n        assert_eq!(9999999999999u128.decimal(&mut buffer), 13);\n        assert_eq!(&buffer[..13], b\"9999999999999\");\n\n        assert_eq!(10000000000001u128.decimal(&mut buffer), 14);\n        assert_eq!(&buffer[..14], b\"10000000000001\");\n\n        assert_eq!(99999999999999u128.decimal(&mut buffer), 14);\n        assert_eq!(&buffer[..14], b\"99999999999999\");\n\n        assert_eq!(100000000000001u128.decimal(&mut buffer), 15);\n        assert_eq!(&buffer[..15], b\"100000000000001\");\n\n        assert_eq!(999999999999999u128.decimal(&mut buffer), 15);\n        assert_eq!(&buffer[..15], b\"999999999999999\");\n\n        assert_eq!(1000000000000001u128.decimal(&mut buffer), 16);\n        assert_eq!(&buffer[..16], b\"1000000000000001\");\n\n        assert_eq!(9999999999999999u128.decimal(&mut buffer), 16);\n        assert_eq!(&buffer[..16], b\"9999999999999999\");\n\n        assert_eq!(10000000000000001u128.decimal(&mut buffer), 17);\n        assert_eq!(&buffer[..17], b\"10000000000000001\");\n\n        assert_eq!(99999999999999999u128.decimal(&mut buffer), 17);\n        assert_eq!(&buffer[..17], b\"99999999999999999\");\n\n        assert_eq!(100000000000000001u128.decimal(&mut buffer), 18);\n        assert_eq!(&buffer[..18], b\"100000000000000001\");\n\n        assert_eq!(999999999999999999u128.decimal(&mut buffer), 18);\n        assert_eq!(&buffer[..18], b\"999999999999999999\");\n\n        assert_eq!(1000000000000000001u128.decimal(&mut buffer), 19);\n        assert_eq!(&buffer[..19], b\"1000000000000000001\");\n\n        assert_eq!(9999999999999999999u128.decimal(&mut buffer), 19);\n        assert_eq!(&buffer[..19], b\"9999999999999999999\");\n\n        assert_eq!(10000000000000000001u128.decimal(&mut buffer), 20);\n        assert_eq!(&buffer[..20], b\"10000000000000000001\");\n\n        assert_eq!(999999999999999999999999u128.decimal(&mut buffer), 24);\n        assert_eq!(&buffer[..24], b\"999999999999999999999999\");\n\n        assert_eq!(1000000000000000000000001u128.decimal(&mut buffer), 25);\n        assert_eq!(&buffer[..25], b\"1000000000000000000000001\");\n\n        assert_eq!(66620387370000000000000000000u128.decimal(&mut buffer), 29);\n        assert_eq!(&buffer[..29], b\"66620387370000000000000000000\");\n\n        assert_eq!(99999999999999999999999999999u128.decimal(&mut buffer), 29);\n        assert_eq!(&buffer[..29], b\"99999999999999999999999999999\");\n\n        assert_eq!(100000000000000000000000000001u128.decimal(&mut buffer), 30);\n        assert_eq!(&buffer[..30], b\"100000000000000000000000000001\");\n\n        assert_eq!(9999999999999999999999999999999999u128.decimal(&mut buffer), 34);\n        assert_eq!(&buffer[..34], b\"9999999999999999999999999999999999\");\n\n        assert_eq!(10000000000000000000000000000000001u128.decimal(&mut buffer), 35);\n        assert_eq!(&buffer[..35], b\"10000000000000000000000000000000001\");\n\n        assert_eq!(340282366920938463463374607431768211455u128.decimal(&mut buffer), 39);\n        assert_eq!(&buffer[..39], b\"340282366920938463463374607431768211455\");\n    }\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-util/src/format_builder.rs::decimal", "code": "pub const fn decimal() -> u128 {\n        let mut builder = Self::new();\n        builder.mantissa_radix = 10;\n        builder.exponent_base = num::NonZeroU8::new(10);\n        builder.exponent_radix = num::NonZeroU8::new(10);\n        builder.build()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-write-integer/tests/options_tests.rs::options_tests", "test": "fn options_tests() {\n    const X: Options = Options::new();\n    assert!(X.is_valid());\n    assert_eq!(X, Options::default());\n    assert!(OptionsBuilder::new().build().is_ok());\n    assert!(OptionsBuilder::default().build().is_ok());\n    assert!(OptionsBuilder::default().is_valid());\n    assert_eq!(X.rebuild(), Options::builder());\n}", "code_id": "Alexhuszagh-rust-lexical/Alexhuszagh-rust-lexical-933e2cc/lexical-parse-float/src/options.rs::is_valid", "code": "pub const fn is_valid(&self) -> bool {\n        if !is_valid_ascii(self.exponent) {\n            false\n        } else if !is_valid_ascii(self.decimal_point) {\n            false\n        } else if !self.nan_str_is_valid() {\n            false\n        } else if !self.inf_str_is_valid() {\n            false\n        } else if !self.infinity_string_is_valid() {\n            false\n        } else {\n            true\n        }\n    }", "docstring": null}
