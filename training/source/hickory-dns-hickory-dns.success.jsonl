{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_tests.rs::test_nodata_where_name_exists", "test": "fn test_nodata_where_name_exists() {\n    named_test_harness(\"example.toml\", |_, tcp_port, _, _, _| {\n        let io_loop = Runtime::new().unwrap();\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv4Addr::new(127, 0, 0, 1).into(),\n            tcp_port.expect(\"no tcp_port\"),\n        );\n        let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::new(addr);\n        let client = AsyncClient::new(Box::new(stream), sender, None);\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        let msg = io_loop\n            .block_on(client.query(\n                Name::from_str(\"www.example.com.\").unwrap(),\n                DNSClass::IN,\n                RecordType::SRV,\n            ))\n            .unwrap();\n        assert_eq!(msg.response_code(), ResponseCode::NoError);\n        assert!(msg.answers().is_empty());\n    })\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/message.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.header.response_code()\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/bin/tests/named_tests.rs::test_nxdomain_where_no_name_exists", "test": "fn test_nxdomain_where_no_name_exists() {\n    named_test_harness(\"example.toml\", |_, tcp_port, _, _, _| {\n        let io_loop = Runtime::new().unwrap();\n        let addr: SocketAddr = SocketAddr::new(\n            Ipv4Addr::new(127, 0, 0, 1).into(),\n            tcp_port.expect(\"no tcp_port\"),\n        );\n        let (stream, sender) = TcpClientStream::<AsyncIoTokioAsStd<TokioTcpStream>>::new(addr);\n        let client = AsyncClient::new(Box::new(stream), sender, None);\n        let (mut client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n        hickory_proto::spawn_bg(&io_loop, bg);\n\n        let msg = io_loop\n            .block_on(client.query(\n                Name::from_str(\"nxdomain.example.com.\").unwrap(),\n                DNSClass::IN,\n                RecordType::SRV,\n            ))\n            .unwrap();\n        assert_eq!(msg.response_code(), ResponseCode::NXDomain);\n        assert!(msg.answers().is_empty());\n    })\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/message.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.header.response_code()\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/config_tests.rs::test_read_config", "test": "fn test_read_config() {\n    let server_path = env::var(\"TDNS_WORKSPACE_ROOT\").unwrap_or_else(|_| \"../..\".to_owned());\n    let path: PathBuf =\n        PathBuf::from(server_path).join(\"tests/test-data/test_configs/example.toml\");\n\n    if !path.exists() {\n        panic!(\"can't locate example.toml and other configs: {:?}\", path)\n    }\n\n    println!(\"reading config\");\n    let config: Config = Config::read_config(&path).unwrap();\n\n    assert_eq!(config.get_listen_port(), 53);\n    assert_eq!(config.get_listen_addrs_ipv4(), Ok(Vec::<Ipv4Addr>::new()));\n    assert_eq!(config.get_listen_addrs_ipv6(), Ok(Vec::<Ipv6Addr>::new()));\n    assert_eq!(config.get_tcp_request_timeout(), Duration::from_secs(5));\n    assert_eq!(config.get_log_level(), tracing::Level::INFO);\n    assert_eq!(config.get_directory(), Path::new(\"/var/named\"));\n    assert_eq!(\n        config.get_zones(),\n        [\n            ZoneConfig::new(\n                \"localhost\".into(),\n                ZoneType::Primary,\n                \"default/localhost.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            ),\n            ZoneConfig::new(\n                \"0.0.127.in-addr.arpa\".into(),\n                ZoneType::Primary,\n                \"default/127.0.0.1.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            ),\n            ZoneConfig::new(\n                \"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.\\\n                 ip6.arpa\"\n                    .into(),\n                ZoneType::Primary,\n                \"default/ipv6_1.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            ),\n            ZoneConfig::new(\n                \"255.in-addr.arpa\".into(),\n                ZoneType::Primary,\n                \"default/255.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            ),\n            ZoneConfig::new(\n                \"0.in-addr.arpa\".into(),\n                ZoneType::Primary,\n                \"default/0.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            ),\n            ZoneConfig::new(\n                \"example.com\".into(),\n                ZoneType::Primary,\n                \"example.com.zone\".into(),\n                None,\n                None,\n                None,\n                vec![],\n            )\n        ]\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/config/mod.rs::get_listen_port", "code": "pub fn get_listen_port(&self) -> u16 {\n        self.listen_port.unwrap_or(DEFAULT_PORT)\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/config_tests.rs::test_parse_toml", "test": "fn test_parse_toml() {\n    let config = Config::from_toml(\"listen_port = 2053\").unwrap();\n    assert_eq!(config.get_listen_port(), 2053);\n\n    let config = Config::from_toml(\"listen_addrs_ipv4 = [\\\"0.0.0.0\\\"]\").unwrap();\n    assert_eq!(\n        config.get_listen_addrs_ipv4(),\n        Ok(vec![Ipv4Addr::new(0, 0, 0, 0)])\n    );\n\n    let config = Config::from_toml(\"listen_addrs_ipv4 = [\\\"0.0.0.0\\\", \\\"127.0.0.1\\\"]\").unwrap();\n    assert_eq!(\n        config.get_listen_addrs_ipv4(),\n        Ok(vec![Ipv4Addr::new(0, 0, 0, 0), Ipv4Addr::new(127, 0, 0, 1)])\n    );\n\n    let config = Config::from_toml(\"listen_addrs_ipv6 = [\\\"::0\\\"]\").unwrap();\n    assert_eq!(\n        config.get_listen_addrs_ipv6(),\n        Ok(vec![Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)])\n    );\n\n    let config = Config::from_toml(\"listen_addrs_ipv6 = [\\\"::0\\\", \\\"::1\\\"]\").unwrap();\n    assert_eq!(\n        config.get_listen_addrs_ipv6(),\n        Ok(vec![\n            Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0),\n            Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1),\n        ])\n    );\n\n    let config = Config::from_toml(\"tcp_request_timeout = 25\").unwrap();\n    assert_eq!(config.get_tcp_request_timeout(), Duration::from_secs(25));\n\n    let config = Config::from_toml(\"log_level = \\\"Debug\\\"\").unwrap();\n    assert_eq!(config.get_log_level(), tracing::Level::DEBUG);\n\n    let config = Config::from_toml(\"directory = \\\"/dev/null\\\"\").unwrap();\n    assert_eq!(config.get_directory(), Path::new(\"/dev/null\"));\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/config/mod.rs::get_listen_port", "code": "pub fn get_listen_port(&self) -> u16 {\n        self.listen_port.unwrap_or(DEFAULT_PORT)\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/config_tests.rs::test_parse_zone_keys", "test": "fn test_parse_zone_keys() {\n    use hickory_proto::rr::dnssec::Algorithm;\n    use hickory_proto::rr::Name;\n\n    let config = Config::from_toml(\n        \"\n[[zones]]\nzone = \\\"example.com\\\"\nzone_type = \\\"Primary\\\"\nfile = \\\"example.com.zone\\\"\n\n\\\n         [[zones.keys]]\nkey_path = \\\"/path/to/my_ed25519.pem\\\"\nalgorithm = \\\"ED25519\\\"\n\\\n         signer_name = \\\"ns.example.com.\\\"\nis_zone_signing_key = false\nis_zone_update_auth = true\n\n[[zones.keys]]\nkey_path = \\\"/path/to/my_rsa.pem\\\"\nalgorithm = \\\n         \\\"RSASHA256\\\"\nsigner_name = \\\"ns.example.com.\\\"\n\",\n    )\n    .unwrap();\n    assert_eq!(\n        config.get_zones()[0].get_keys()[0].key_path(),\n        Path::new(\"/path/to/my_ed25519.pem\")\n    );\n    assert_eq!(\n        config.get_zones()[0].get_keys()[0].algorithm().unwrap(),\n        Algorithm::ED25519\n    );\n    assert_eq!(\n        config.get_zones()[0].get_keys()[0]\n            .signer_name()\n            .unwrap()\n            .unwrap(),\n        Name::parse(\"ns.example.com.\", None).unwrap()\n    );\n    assert!(!config.get_zones()[0].get_keys()[0].is_zone_signing_key(),);\n    assert!(config.get_zones()[0].get_keys()[0].is_zone_update_auth(),);\n\n    assert_eq!(\n        config.get_zones()[0].get_keys()[1].key_path(),\n        Path::new(\"/path/to/my_rsa.pem\")\n    );\n    assert_eq!(\n        config.get_zones()[0].get_keys()[1].algorithm().unwrap(),\n        Algorithm::RSASHA256\n    );\n    assert_eq!(\n        config.get_zones()[0].get_keys()[1]\n            .signer_name()\n            .unwrap()\n            .unwrap(),\n        Name::parse(\"ns.example.com.\", None).unwrap()\n    );\n    assert!(!config.get_zones()[0].get_keys()[1].is_zone_signing_key(),);\n    assert!(!config.get_zones()[0].get_keys()[1].is_zone_update_auth(),);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/config/dnssec.rs::key_path", "code": "pub fn key_path(&self) -> &Path {\n        Path::new(&self.key_path)\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/in_memory.rs::test_cname_loop", "test": "fn test_cname_loop() {\n    let runtime = Runtime::new().expect(\"failed to create Tokio Runtime\");\n    let mut auth = InMemoryAuthority::empty(\n        Name::from_str(\"example.com.\").unwrap(),\n        ZoneType::Primary,\n        false,\n    );\n\n    auth.upsert_mut(\n        Record::from_rdata(\n            Name::from_str(\"foo.example.com.\").unwrap(),\n            300,\n            RData::CNAME(CNAME(Name::from_str(\"foo.example.com.\").unwrap())),\n        ),\n        0,\n    );\n\n    auth.upsert_mut(\n        Record::from_rdata(\n            Name::from_str(\"bar.example.com.\").unwrap(),\n            300,\n            RData::CNAME(CNAME(Name::from_str(\"foo.example.com.\").unwrap())),\n        ),\n        0,\n    );\n\n    auth.upsert_mut(\n        Record::from_rdata(\n            Name::from_str(\"baz.example.com.\").unwrap(),\n            300,\n            RData::CNAME(CNAME(Name::from_str(\"boz.example.com.\").unwrap())),\n        ),\n        0,\n    );\n\n    auth.upsert_mut(\n        Record::from_rdata(\n            Name::from_str(\"boz.example.com.\").unwrap(),\n            300,\n            RData::CNAME(CNAME(Name::from_str(\"biz.example.com.\").unwrap())),\n        ),\n        0,\n    );\n\n    auth.upsert_mut(\n        Record::from_rdata(\n            Name::from_str(\"biz.example.com.\").unwrap(),\n            300,\n            RData::CNAME(CNAME(Name::from_str(\"baz.example.com.\").unwrap())),\n        ),\n        0,\n    );\n\n    let mut lookup = runtime\n        .block_on(auth.lookup(\n            &Name::from_str(\"foo.example.com.\").unwrap().into(),\n            RecordType::A,\n            Default::default(),\n        ))\n        .unwrap();\n\n    let records: Vec<&Record> = lookup.iter().collect();\n    assert_eq!(records.len(), 1);\n    let record = records[0];\n    assert_eq!(record.name(), &Name::from_str(\"foo.example.com.\").unwrap());\n    assert_eq!(\n        record.data(),\n        Some(&RData::CNAME(CNAME(\n            Name::from_str(\"foo.example.com.\").unwrap()\n        )))\n    );\n\n    assert!(\n        lookup.take_additionals().is_none(),\n        \"Should be no additional records.\"\n    );\n\n    let mut lookup = runtime\n        .block_on(auth.lookup(\n            &Name::from_str(\"bar.example.com.\").unwrap().into(),\n            RecordType::A,\n            Default::default(),\n        ))\n        .unwrap();\n\n    let records: Vec<&Record> = lookup.iter().collect();\n    assert_eq!(records.len(), 1);\n    let record = records[0];\n    assert_eq!(record.name(), &Name::from_str(\"bar.example.com.\").unwrap());\n    assert_eq!(\n        record.data(),\n        Some(&RData::CNAME(CNAME(\n            Name::from_str(\"foo.example.com.\").unwrap()\n        )))\n    );\n\n    let additionals = lookup\n        .take_additionals()\n        .expect(\"Should be additional records\");\n    let additionals: Vec<&Record> = additionals.iter().collect();\n    assert_eq!(additionals.len(), 1);\n    let record = additionals[0];\n    assert_eq!(record.name(), &Name::from_str(\"foo.example.com.\").unwrap());\n    assert_eq!(\n        record.data(),\n        Some(&RData::CNAME(CNAME(\n            Name::from_str(\"foo.example.com.\").unwrap()\n        )))\n    );\n\n    let mut lookup = runtime\n        .block_on(auth.lookup(\n            &Name::from_str(\"baz.example.com.\").unwrap().into(),\n            RecordType::A,\n            Default::default(),\n        ))\n        .unwrap();\n\n    let records: Vec<&Record> = lookup.iter().collect();\n    assert_eq!(records.len(), 1);\n    let record = records[0];\n    assert_eq!(record.name(), &Name::from_str(\"baz.example.com.\").unwrap());\n    assert_eq!(\n        record.data(),\n        Some(&RData::CNAME(CNAME(\n            Name::from_str(\"boz.example.com.\").unwrap()\n        )))\n    );\n\n    let additionals = lookup\n        .take_additionals()\n        .expect(\"Should be additional records\");\n    let additionals: Vec<&Record> = additionals.iter().collect();\n    assert_eq!(additionals.len(), 2);\n    let record = additionals[0];\n    assert_eq!(record.name(), &Name::from_str(\"boz.example.com.\").unwrap());\n    assert_eq!(\n        record.data(),\n        Some(&RData::CNAME(CNAME(\n            Name::from_str(\"biz.example.com.\").unwrap()\n        )))\n    );\n    let record = additionals[1];\n    assert_eq!(record.name(), &Name::from_str(\"biz.example.com.\").unwrap());\n    assert_eq!(\n        record.data(),\n        Some(&RData::CNAME(CNAME(\n            Name::from_str(\"baz.example.com.\").unwrap()\n        )))\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/rr/dnssec/trust_anchor.rs::len", "code": "pub fn len(&self) -> usize {\n        self.pkeys.len()\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/sqlite_tests.rs::test_new_journal", "test": "fn test_new_journal() {\n    let conn = Connection::open_in_memory().expect(\"could not create in memory DB\");\n    assert_eq!(\n        Journal::new(conn).expect(\"new Journal\").schema_version(),\n        -1\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/store/sqlite/persistence.rs::schema_version", "code": "pub fn schema_version(&self) -> i64 {\n        self.version\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/tests/store_file_tests.rs::test_ttl_wilcard", "test": "async fn test_ttl_wilcard() {\n    let config = FileConfig {\n        zone_file_path: \"../../tests/test-data/test_configs/default/test.local.zone\".to_string(),\n    };\n\n    let zone_name = LowerName::from_str(\"test.local.\").unwrap();\n    let mut authority = FileAuthority::try_from_config(\n        Name::from(zone_name.clone()),\n        ZoneType::Primary,\n        false,\n        None,\n        &config,\n    )\n    .unwrap();\n\n    // This one pass.\n    let rrkey = RrKey {\n        record_type: RecordType::A,\n        name: LowerName::from(Name::from_ascii(\"simple.test.local.\").unwrap()),\n    };\n    assert_eq!(authority.records_get_mut().get(&rrkey).unwrap().ttl(), 120);\n    // // This one related to a wildcard don't pass arround $TTL\n    let name = LowerName::from(Name::from_ascii(\"x.wc.test.local.\").unwrap());\n    let rr = authority\n        .lookup(&name, RecordType::A, LookupOptions::default())\n        .await\n        .unwrap();\n    let data = rr\n        .into_iter()\n        .next()\n        .expect(\"A record not found in authority\");\n\n    assert_eq!(data.record_type(), RecordType::A);\n    assert_eq!(data.ttl(), 120);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/rr/resource.rs::ttl", "code": "pub fn ttl(&self) -> u32 {\n        self.ttl\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/compatibility-tests/tests/tsig_tests.rs::test_create", "test": "fn test_create() {\n    use hickory_client::rr::rdata::A;\n\n    let (_process, port) = named_process();\n    let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);\n    let conn = UdpClientConnection::new(socket).unwrap();\n\n    let client = create_tsig_ready_client(conn);\n    let origin = Name::from_str(\"example.net.\").unwrap();\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.net.\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // trying to create again should error\n    // TODO: it would be cool to make this\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n\n    // will fail if already set and not the same value.\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n\n    let result = client.create(record, origin).expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/compatibility-tests/tests/tsig_tests.rs::test_tsig_zone_transfer", "test": "fn test_tsig_zone_transfer() {\n    let (_process, port) = named_process();\n    let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);\n    let conn = TcpClientConnection::new(socket).unwrap();\n\n    let client = create_tsig_ready_client(conn);\n\n    let name = Name::from_str(\"example.net.\").unwrap();\n    let result = client.zone_transfer(&name, None).expect(\"query failed\");\n    let result = result.collect::<Result<Vec<_>, _>>().unwrap();\n    assert_ne!(result.len(), 1);\n    assert_eq!(\n        result.iter().map(|r| r.answers().len()).sum::<usize>(),\n        2000 + 3\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/resolver/src/lookup.rs::len", "code": "pub(crate) fn len(&self) -> usize {\n        self.records.len()\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_catalog_lookup", "test": "async fn test_catalog_lookup() {\n    let example = create_example();\n    let test = create_test();\n    let origin = example.origin().clone();\n    let test_origin = test.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin.clone(), Box::new(Arc::new(example)));\n    catalog.upsert(test_origin.clone(), Box::new(Arc::new(test)));\n\n    let mut question: Message = Message::new();\n\n    let mut query: Query = Query::new();\n    query.set_name(origin.into());\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert!(result.header().authoritative());\n\n    let answers: &[Record] = result.answers();\n\n    assert!(!answers.is_empty());\n    assert_eq!(answers.first().unwrap().record_type(), RecordType::A);\n    assert_eq!(\n        answers.first().unwrap().data().unwrap(),\n        &RData::A(A::new(93, 184, 216, 34))\n    );\n\n    let ns = result.name_servers();\n    assert!(ns.is_empty());\n\n    // other zone\n    let mut question: Message = Message::new();\n    let mut query: Query = Query::new();\n    query.set_name(test_origin.into());\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert!(result.header().authoritative());\n\n    let answers: &[Record] = result.answers();\n\n    assert!(!answers.is_empty());\n    assert_eq!(answers.first().unwrap().record_type(), RecordType::A);\n    assert_eq!(\n        answers.first().unwrap().data().unwrap(),\n        &RData::A(A::new(94, 184, 216, 34))\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_catalog_lookup_soa", "test": "async fn test_catalog_lookup_soa() {\n    let example = create_example();\n    let test = create_test();\n    let origin = example.origin().clone();\n    let test_origin = test.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin.clone(), Box::new(Arc::new(example)));\n    catalog.upsert(test_origin, Box::new(Arc::new(test)));\n\n    let mut question: Message = Message::new();\n\n    let mut query: Query = Query::new();\n    query.set_name(origin.into());\n    query.set_query_type(RecordType::SOA);\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert!(result.header().authoritative());\n\n    let answers: &[Record] = result.answers();\n\n    assert!(!answers.is_empty());\n    assert_eq!(answers.first().unwrap().record_type(), RecordType::SOA);\n    assert_eq!(\n        answers.first().unwrap().data().unwrap(),\n        &RData::SOA(SOA::new(\n            Name::parse(\"sns.dns.icann.org.\", None).unwrap(),\n            Name::parse(\"noc.dns.icann.org.\", None).unwrap(),\n            2015082403,\n            7200,\n            3600,\n            1209600,\n            3600,\n        ))\n    );\n\n    // assert SOA requests get NS records\n    let mut ns: Vec<Record> = result.name_servers().to_vec();\n    ns.sort();\n\n    assert_eq!(ns.len(), 2);\n    assert_eq!(ns.first().unwrap().record_type(), RecordType::NS);\n    assert_eq!(\n        ns.first().unwrap().data().unwrap(),\n        &RData::NS(NS(Name::parse(\"a.iana-servers.net.\", None).unwrap()))\n    );\n    assert_eq!(ns.last().unwrap().record_type(), RecordType::NS);\n    assert_eq!(\n        ns.last().unwrap().data().unwrap(),\n        &RData::NS(NS(Name::parse(\"b.iana-servers.net.\", None).unwrap()))\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_non_authoritive_nx_refused", "test": "async fn test_non_authoritive_nx_refused() {\n    let example = create_example();\n    let origin = example.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin, Box::new(Arc::new(example)));\n\n    let mut question: Message = Message::new();\n\n    let mut query: Query = Query::new();\n    query.set_name(Name::parse(\"com.\", None).unwrap());\n    query.set_query_type(RecordType::SOA);\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.response_code(), ResponseCode::Refused);\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert!(!result.header().authoritative());\n\n    assert_eq!(result.name_servers().len(), 0);\n    assert_eq!(result.answers().len(), 0);\n    assert_eq!(result.additionals().len(), 0);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_axfr_refused", "test": "async fn test_axfr_refused() {\n    let mut test = create_test();\n    test.set_allow_axfr(false);\n\n    let origin = test.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin.clone(), Box::new(Arc::new(test)));\n\n    let mut query: Query = Query::new();\n    query.set_name(origin.into());\n    query.set_query_type(RecordType::AXFR);\n\n    let mut question: Message = Message::new();\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.response_code(), ResponseCode::Refused);\n    assert!(result.answers().is_empty());\n    assert!(result.name_servers().is_empty());\n    assert!(result.additionals().is_empty());\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_cname_additionals", "test": "async fn test_cname_additionals() {\n    let example = create_example();\n    let origin = example.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin, Box::new(Arc::new(example)));\n\n    let mut question: Message = Message::new();\n\n    let mut query: Query = Query::new();\n    query.set_name(Name::from_str(\"alias.example.com.\").unwrap());\n    query.set_query_type(RecordType::A);\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let answers: &[Record] = result.answers();\n    assert_eq!(answers.len(), 1);\n    assert_eq!(answers.first().unwrap().record_type(), RecordType::CNAME);\n    assert_eq!(\n        answers.first().unwrap().data().unwrap(),\n        &RData::CNAME(CNAME(Name::from_str(\"www.example.com.\").unwrap()))\n    );\n\n    let additionals: &[Record] = result.additionals();\n    assert!(!additionals.is_empty());\n    assert_eq!(additionals.first().unwrap().record_type(), RecordType::A);\n    assert_eq!(\n        additionals.first().unwrap().data().unwrap(),\n        &RData::A(A::new(93, 184, 216, 34))\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::message_type", "code": "pub fn message_type(&self) -> MessageType {\n        self.message_type\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/catalog_tests.rs::test_multiple_cname_additionals", "test": "async fn test_multiple_cname_additionals() {\n    let example = create_example();\n    let origin = example.origin().clone();\n\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(origin, Box::new(Arc::new(example)));\n\n    let mut question: Message = Message::new();\n\n    let mut query: Query = Query::new();\n    query.set_name(Name::from_str(\"alias2.example.com.\").unwrap());\n    query.set_query_type(RecordType::A);\n\n    question.add_query(query);\n\n    // temp request\n    let question_bytes = question.to_bytes().unwrap();\n    let question_req = MessageRequest::from_bytes(&question_bytes).unwrap();\n    let question_req = Request::new(question_req, ([127, 0, 0, 1], 5553).into(), Protocol::Udp);\n\n    let response_handler = TestResponseHandler::new();\n    catalog\n        .lookup(&question_req, None, response_handler.clone())\n        .await;\n    let result = response_handler.into_message().await;\n\n    assert_eq!(result.message_type(), MessageType::Response);\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let answers: &[Record] = result.answers();\n    assert_eq!(answers.len(), 1);\n    assert_eq!(answers.first().unwrap().record_type(), RecordType::CNAME);\n    assert_eq!(\n        answers.first().unwrap().data().unwrap(),\n        &RData::CNAME(CNAME(Name::from_str(\"alias.example.com.\").unwrap()))\n    );\n\n    // we should have the intermediate record\n    let additionals: &[Record] = result.additionals();\n    assert!(!additionals.is_empty());\n    assert_eq!(\n        additionals.first().unwrap().record_type(),\n        RecordType::CNAME\n    );\n    assert_eq!(\n        additionals.first().unwrap().data().unwrap(),\n        &RData::CNAME(CNAME(Name::from_str(\"www.example.com.\").unwrap()))\n    );\n\n    // final record should be the actual\n    let additionals: &[Record] = result.additionals();\n    assert!(!additionals.is_empty());\n    assert_eq!(additionals.last().unwrap().record_type(), RecordType::A);\n    assert_eq!(\n        additionals.last().unwrap().data().unwrap(),\n        &RData::A(A::new(93, 184, 216, 34))\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::message_type", "code": "pub fn message_type(&self) -> MessageType {\n        self.message_type\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_query", "test": "fn test_query(client: &mut AsyncClient) -> impl Future<Output = ()> {\n    let name = Name::from_ascii(\"WWW.example.com\").unwrap();\n\n    client\n        .query(name.clone(), DNSClass::IN, RecordType::A)\n        .map_ok(move |response| {\n            println!(\"response records: {response:?}\");\n            assert!(response\n                .queries()\n                .first()\n                .expect(\"expected query\")\n                .name()\n                .eq_case(&name));\n\n            let record = &response.answers()[0];\n            assert_eq!(record.name(), &name);\n            assert_eq!(record.record_type(), RecordType::A);\n            assert_eq!(record.dns_class(), DNSClass::IN);\n\n            if let RData::A(ref address) = record.data().unwrap() {\n                assert_eq!(address, &A::new(93, 184, 216, 34))\n            } else {\n                panic!();\n            }\n        })\n        .map(|r: Result<_, _>| r.expect(\"query failed\"))\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/rr/domain/name.rs::eq_case", "code": "pub fn eq_case(&self, other: &Self) -> bool {\n        self.cmp_with_f::<CaseSensitive>(other) == Ordering::Equal\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_query_edns", "test": "fn test_query_edns(client: &mut AsyncClient) -> impl Future<Output = ()> {\n    let name = Name::from_ascii(\"WWW.example.com\").unwrap();\n    let mut edns = Edns::new();\n    // garbage subnet value, but lets check\n    edns.options_mut()\n        .insert(EdnsOption::Subnet(\"1.2.0.0/16\".parse().unwrap()));\n\n    // TODO: write builder\n    let mut msg = Message::new();\n    msg.add_query({\n        let mut query = Query::query(name.clone(), RecordType::A);\n        query.set_query_class(DNSClass::IN);\n        query\n    })\n    .set_id(rand::random::<u16>())\n    .set_message_type(MessageType::Query)\n    .set_op_code(OpCode::Query)\n    .set_recursion_desired(true)\n    .set_edns(edns)\n    .extensions_mut()\n    .as_mut()\n    .map(|edns| edns.set_max_payload(1232).set_version(0));\n\n    client\n        .send(msg)\n        .first_answer()\n        .map_ok(move |response| {\n            println!(\"response records: {response:?}\");\n            assert!(response\n                .queries()\n                .first()\n                .expect(\"expected query\")\n                .name()\n                .eq_case(&name));\n\n            let record = &response.answers()[0];\n            assert_eq!(record.name(), &name);\n            assert_eq!(record.record_type(), RecordType::A);\n            assert_eq!(record.dns_class(), DNSClass::IN);\n            assert!(response.extensions().is_some());\n            assert_eq!(\n                response\n                    .extensions()\n                    .as_ref()\n                    .unwrap()\n                    .option(EdnsCode::Subnet)\n                    .unwrap(),\n                &EdnsOption::Subnet(\"1.2.0.0/16\".parse().unwrap())\n            );\n            if let RData::A(ref address) = *record.data().unwrap() {\n                assert_eq!(address, &A::new(93, 184, 216, 34))\n            } else {\n                panic!();\n            }\n        })\n        .map(|r: Result<_, _>| r.expect(\"query failed\"))\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/rr/domain/name.rs::eq_case", "code": "pub fn eq_case(&self, other: &Self) -> bool {\n        self.cmp_with_f::<CaseSensitive>(other) == Ordering::Equal\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_create", "test": "fn test_create() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n    let record = record;\n\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // trying to create again should error\n    // TODO: it would be cool to make this\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n\n    // will fail if already set and not the same value.\n    let mut record = record;\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n\n    let result = io_loop\n        .block_on(client.create(record, origin))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_create_multi", "test": "fn test_create_multi() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n    let record = record;\n\n    let mut record2 = record.clone();\n    record2.set_data(Some(RData::A(A::new(100, 10, 100, 11))));\n    let record2 = record2;\n\n    let mut rrset = RecordSet::from(record.clone());\n    rrset.insert(record2.clone(), 0);\n    let rrset = rrset;\n\n    let result = io_loop\n        .block_on(client.create(rrset.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n\n    assert!(result.answers().iter().any(|rr| *rr == record));\n    assert!(result.answers().iter().any(|rr| *rr == record2));\n\n    // trying to create again should error\n    // TODO: it would be cool to make this\n    let result = io_loop\n        .block_on(client.create(rrset, origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n\n    // will fail if already set and not the same value.\n    let mut record = record;\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 12))));\n\n    let result = io_loop\n        .block_on(client.create(record, origin))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_append", "test": "fn test_append() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n    let record = record;\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), true))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    // next append to a non-existent RRset\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), false))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // will fail if already set and not the same value.\n    let mut record2 = record.clone();\n    record2.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let record2 = record2;\n\n    let result = io_loop\n        .block_on(client.append(record2.clone(), origin.clone(), true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n\n    assert!(result.answers().iter().any(|rr| *rr == record));\n    assert!(result.answers().iter().any(|rr| *rr == record2));\n\n    // show that appending the same thing again is ok, but doesn't add any records\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin, true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_append_multi", "test": "fn test_append_multi() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), true))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    // next append to a non-existent RRset\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), false))\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // will fail if already set and not the same value.\n    let mut record2 = record.clone();\n    record2.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let mut record3 = record.clone();\n    record3.set_data(Some(RData::A(A::new(101, 11, 101, 12))));\n\n    // build the append set\n    let mut rrset = RecordSet::from(record2.clone());\n    rrset.insert(record3.clone(), 0);\n\n    let result = io_loop\n        .block_on(client.append(rrset, origin.clone(), true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 3);\n\n    assert!(result.answers().iter().any(|rr| *rr == record));\n    assert!(result.answers().iter().any(|rr| *rr == record2));\n    assert!(result.answers().iter().any(|rr| *rr == record3));\n\n    // show that appending the same thing again is ok, but doesn't add any records\n    // TODO: technically this is a test for the Server, not client...\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin, true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 3);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_compare_and_swap", "test": "fn test_compare_and_swap() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n    let record = record;\n\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let current = record;\n    let mut new = current.clone();\n    new.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let new = new;\n\n    let result = io_loop\n        .block_on(client.compare_and_swap(current.clone(), new.clone(), origin.clone()))\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(new.name().clone(), new.dns_class(), new.record_type()))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result.answers().iter().any(|rr| *rr == new));\n    assert!(!result.answers().iter().any(|rr| *rr == current));\n\n    // check the it fails if tried again.\n    let mut not = new.clone();\n    not.set_data(Some(RData::A(A::new(102, 12, 102, 12))));\n    let not = not;\n\n    let result = io_loop\n        .block_on(client.compare_and_swap(current, not.clone(), origin))\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    let result = io_loop\n        .block_on(client.query(new.name().clone(), new.dns_class(), new.record_type()))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result.answers().iter().any(|rr| *rr == new));\n    assert!(!result.answers().iter().any(|rr| *rr == not));\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_compare_and_swap_multi", "test": "fn test_compare_and_swap_multi() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // create a record\n    let mut current = RecordSet::with_ttl(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n\n    let current1 = current\n        .new_record(&RData::A(A::new(100, 10, 100, 10)))\n        .clone();\n    let current2 = current\n        .new_record(&RData::A(A::new(100, 10, 100, 11)))\n        .clone();\n    let current = current;\n\n    let result = io_loop\n        .block_on(client.create(current.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let mut new = RecordSet::with_ttl(current.name().clone(), current.record_type(), current.ttl());\n    let new1 = new.new_record(&RData::A(A::new(100, 10, 101, 10))).clone();\n    let new2 = new.new_record(&RData::A(A::new(100, 10, 101, 11))).clone();\n    let new = new;\n\n    let result = io_loop\n        .block_on(client.compare_and_swap(current.clone(), new.clone(), origin.clone()))\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(new.name().clone(), new.dns_class(), new.record_type()))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n    assert!(result.answers().iter().any(|rr| *rr == new1));\n    assert!(result.answers().iter().any(|rr| *rr == new2));\n    assert!(!result.answers().iter().any(|rr| *rr == current1));\n    assert!(!result.answers().iter().any(|rr| *rr == current2));\n\n    // check the it fails if tried again.\n    let mut not = new1.clone();\n    not.set_data(Some(RData::A(A::new(102, 12, 102, 12))));\n    let not = not;\n\n    let result = io_loop\n        .block_on(client.compare_and_swap(current, not.clone(), origin))\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    let result = io_loop\n        .block_on(client.query(new.name().clone(), new.dns_class(), new.record_type()))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n    assert!(result.answers().iter().any(|rr| *rr == new1));\n    assert!(!result.answers().iter().any(|rr| *rr == not));\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_delete_by_rdata", "test": "fn test_delete_by_rdata() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record1 = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record1.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.delete_by_rdata(record1.clone(), origin.clone()))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = io_loop\n        .block_on(client.create(record1.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let mut record2 = record1.clone();\n    record2.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let result = io_loop\n        .block_on(client.append(record2.clone(), origin.clone(), true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.delete_by_rdata(record2, origin))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record1.name().clone(),\n            record1.dns_class(),\n            record1.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result.answers().iter().any(|rr| *rr == record1));\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_delete_by_rdata_multi", "test": "fn test_delete_by_rdata_multi() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut rrset = RecordSet::with_ttl(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n\n    let record1 = rrset\n        .new_record(&RData::A(A::new(100, 10, 100, 10)))\n        .clone();\n    let record2 = rrset\n        .new_record(&RData::A(A::new(100, 10, 100, 11)))\n        .clone();\n    let record3 = rrset\n        .new_record(&RData::A(A::new(100, 10, 100, 12)))\n        .clone();\n    let record4 = rrset\n        .new_record(&RData::A(A::new(100, 10, 100, 13)))\n        .clone();\n    let rrset = rrset;\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.delete_by_rdata(rrset.clone(), origin.clone()))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = io_loop\n        .block_on(client.create(rrset, origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // append a record\n    let mut rrset = RecordSet::with_ttl(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n\n    let record1 = rrset.new_record(record1.data().unwrap()).clone();\n    let record3 = rrset.new_record(record3.data().unwrap()).clone();\n    let rrset = rrset;\n\n    let result = io_loop\n        .block_on(client.append(rrset.clone(), origin.clone(), true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.delete_by_rdata(rrset, origin))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record1.name().clone(),\n            record1.dns_class(),\n            record1.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n    assert!(!result.answers().iter().any(|rr| *rr == record1));\n    assert!(result.answers().iter().any(|rr| *rr == record2));\n    assert!(!result.answers().iter().any(|rr| *rr == record3));\n    assert!(result.answers().iter().any(|rr| *rr == record4));\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_delete_rrset", "test": "fn test_delete_rrset() {\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.delete_rrset(record.clone(), origin.clone()))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let result = io_loop\n        .block_on(client.append(record.clone(), origin.clone(), true))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.delete_rrset(record.clone(), origin))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(\n            record.name().clone(),\n            record.dns_class(),\n            record.record_type(),\n        ))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_future_tests.rs::test_delete_all", "test": "fn test_delete_all() {\n    use hickory_proto::rr::rdata::AAAA;\n\n    let io_loop = Runtime::new().unwrap();\n    let ((mut client, bg), origin) = io_loop.block_on(create_sig0_ready_client());\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = io_loop\n        .block_on(client.delete_all(record.name().clone(), origin.clone(), DNSClass::IN))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    record.set_rr_type(RecordType::AAAA);\n    record.set_data(Some(RData::AAAA(AAAA::new(1, 2, 3, 4, 5, 6, 7, 8))));\n    let result = io_loop\n        .block_on(client.create(record.clone(), origin.clone()))\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = io_loop\n        .block_on(client.delete_all(record.name().clone(), origin, DNSClass::IN))\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = io_loop\n        .block_on(client.query(record.name().clone(), record.dns_class(), RecordType::A))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n\n    let result = io_loop\n        .block_on(client.query(record.name().clone(), record.dns_class(), RecordType::AAAA))\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_create", "test": "fn test_create() {\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // trying to create again should error\n    // TODO: it would be cool to make this\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n\n    // will fail if already set and not the same value.\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n\n    let result = client.create(record, origin).expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::YXRRSet);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_append", "test": "fn test_append() {\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = client\n        .append(record.clone(), origin.clone(), true)\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    // next append to a non-existent RRset\n    let result = client\n        .append(record.clone(), origin.clone(), false)\n        .expect(\"append failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert_eq!(result.answers()[0], record);\n\n    // will fail if already set and not the same value.\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n\n    let result = client\n        .append(record.clone(), origin.clone(), true)\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n\n    assert!(result\n        .answers()\n        .iter()\n        .any(|rr| if let RData::A(ip) = *rr.data().unwrap() {\n            ip == A::new(100, 10, 100, 10)\n        } else {\n            false\n        }));\n    assert!(result\n        .answers()\n        .iter()\n        .any(|rr| if let RData::A(ip) = rr.data().unwrap() {\n            *ip == A::new(101, 11, 101, 11)\n        } else {\n            false\n        }));\n\n    // show that appending the same thing again is ok, but doesn't add any records\n    let result = client\n        .append(record.clone(), origin, true)\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 2);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_compare_and_swap", "test": "fn test_compare_and_swap() {\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // create a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let current = record;\n    let mut new = current.clone();\n    new.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n\n    let result = client\n        .compare_and_swap(current.clone(), new.clone(), origin.clone())\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n        .query(new.name(), new.dns_class(), new.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result\n        .answers()\n        .iter()\n        .any(|rr| if let RData::A(ip) = rr.data().unwrap() {\n            *ip == A::new(101, 11, 101, 11)\n        } else {\n            false\n        }));\n\n    // check the it fails if tried again.\n    new.set_data(Some(RData::A(A::new(102, 12, 102, 12))));\n\n    let result = client\n        .compare_and_swap(current, new.clone(), origin)\n        .expect(\"compare_and_swap failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXRRSet);\n\n    let result = client\n        .query(new.name(), new.dns_class(), new.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result\n        .answers()\n        .iter()\n        .any(|rr| if let RData::A(ip) = rr.data().unwrap() {\n            *ip == A::new(101, 11, 101, 11)\n        } else {\n            false\n        }));\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_delete_by_rdata", "test": "fn test_delete_by_rdata() {\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = client\n        .delete_by_rdata(record.clone(), origin.clone())\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let result = client\n        .append(record.clone(), origin.clone(), true)\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = client\n        .delete_by_rdata(record.clone(), origin)\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n    assert_eq!(result.answers().len(), 1);\n    assert!(result\n        .answers()\n        .iter()\n        .any(|rr| if let RData::A(ip) = rr.data().unwrap() {\n            *ip == A::new(100, 10, 100, 10)\n        } else {\n            false\n        }));\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_delete_rrset", "test": "fn test_delete_rrset() {\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = client\n        .delete_rrset(record.clone(), origin.clone())\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    record.set_data(Some(RData::A(A::new(101, 11, 101, 11))));\n    let result = client\n        .append(record.clone(), origin.clone(), true)\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = client\n        .delete_rrset(record.clone(), origin)\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n        .query(record.name(), record.dns_class(), record.record_type())\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/client_tests.rs::test_delete_all", "test": "fn test_delete_all() {\n    use hickory_proto::rr::rdata::AAAA;\n\n    let catalog = Catalog::new();\n    let (client, origin) = create_sig0_ready_client(catalog);\n\n    // append a record\n    let mut record = Record::with(\n        Name::from_str(\"new.example.com\").unwrap(),\n        RecordType::A,\n        Duration::minutes(5).whole_seconds() as u32,\n    );\n    record.set_data(Some(RData::A(A::new(100, 10, 100, 10))));\n\n    // first check the must_exist option\n    let result = client\n        .delete_all(record.name().clone(), origin.clone(), DNSClass::IN)\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // next create to a non-existent RRset\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    record.set_rr_type(RecordType::AAAA);\n    record.set_data(Some(RData::AAAA(AAAA::new(1, 2, 3, 4, 5, 6, 7, 8))));\n    let result = client\n        .create(record.clone(), origin.clone())\n        .expect(\"create failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    // verify record contents\n    let result = client\n        .delete_all(record.name().clone(), origin, DNSClass::IN)\n        .expect(\"delete failed\");\n    assert_eq!(result.response_code(), ResponseCode::NoError);\n\n    let result = client\n        .query(record.name(), record.dns_class(), RecordType::A)\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n\n    let result = client\n        .query(record.name(), record.dns_class(), RecordType::AAAA)\n        .expect(\"query failed\");\n    assert_eq!(result.response_code(), ResponseCode::NXDomain);\n    assert_eq!(result.answers().len(), 0);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.response_code\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_lookup", "test": "fn test_lookup() {\n    let authority = create_example();\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let io_loop = Runtime::new().unwrap();\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let dns_conn = DnsMultiplexer::new(stream, sender, NoopMessageFinalizer::new());\n    let client = DnsExchange::connect::<_, _, TokioTime>(dns_conn);\n\n    let (client, bg) = io_loop.block_on(client).expect(\"client failed to connect\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, false),\n    );\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        *lookup.iter().next().unwrap(),\n        RData::A(A::new(93, 184, 216, 34))\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/resolver/src/lookup.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_lookup_hosts", "test": "fn test_lookup_hosts() {\n    let authority = create_example();\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let io_loop = Runtime::new().unwrap();\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let dns_conn = DnsMultiplexer::new(stream, sender, NoopMessageFinalizer::new());\n\n    let client = DnsExchange::connect::<_, _, TokioTime>(dns_conn);\n    let (client, bg) = io_loop.block_on(client).expect(\"client connect failed\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    let mut hosts = Hosts::default();\n    let record = Record::from_rdata(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        86400,\n        RData::A(A::new(10, 0, 1, 104)),\n    );\n    hosts.insert(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        RecordType::A,\n        Lookup::new_with_max_ttl(\n            Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A),\n            Arc::from([record]),\n        ),\n    );\n\n    let lookup = LookupIpFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        LookupIpStrategy::default(),\n        CachingClient::new(0, client, false),\n        Default::default(),\n        Some(Arc::new(hosts)),\n        None,\n    );\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(lookup.iter().next().unwrap(), Ipv4Addr::new(10, 0, 1, 104));\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/resolver/src/lookup.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_lookup_ipv4_like", "test": "fn test_lookup_ipv4_like() {\n    let authority = create_ip_like_example();\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let io_loop = Runtime::new().unwrap();\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let dns_conn = DnsMultiplexer::new(stream, sender, NoopMessageFinalizer::new());\n\n    let client = DnsExchange::connect::<_, _, TokioTime>(dns_conn);\n    let (client, bg) = io_loop.block_on(client).expect(\"client connect failed\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    let lookup = LookupIpFuture::lookup(\n        vec![Name::from_str(\"1.2.3.4.example.com.\").unwrap()],\n        LookupIpStrategy::default(),\n        CachingClient::new(0, client, false),\n        Default::default(),\n        Some(Arc::new(Hosts::default())),\n        Some(RData::A(A::new(1, 2, 3, 4))),\n    );\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        lookup.iter().next().unwrap(),\n        Ipv4Addr::new(198, 51, 100, 35)\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/resolver/src/lookup.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_lookup_ipv4_like_fall_through", "test": "fn test_lookup_ipv4_like_fall_through() {\n    let authority = create_ip_like_example();\n    let mut catalog = Catalog::new();\n    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));\n\n    let io_loop = Runtime::new().unwrap();\n    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));\n    let dns_conn = DnsMultiplexer::new(stream, sender, NoopMessageFinalizer::new());\n\n    let client = DnsExchange::connect::<_, _, TokioTime>(dns_conn);\n    let (client, bg) = io_loop.block_on(client).expect(\"client connect failed\");\n    hickory_proto::spawn_bg(&io_loop, bg);\n\n    let lookup = LookupIpFuture::lookup(\n        vec![Name::from_str(\"198.51.100.35.example.com.\").unwrap()],\n        LookupIpStrategy::default(),\n        CachingClient::new(0, client, false),\n        Default::default(),\n        Some(Arc::new(Hosts::default())),\n        Some(RData::A(A::new(198, 51, 100, 35))),\n    );\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        lookup.iter().next().unwrap(),\n        Ipv4Addr::new(198, 51, 100, 35)\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/resolver/src/lookup.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_mock_lookup", "test": "fn test_mock_lookup() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let v4_record = v4_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n    let message = message(resp_query, vec![v4_record], vec![], vec![]);\n    let client: MockClientHandle<_, ResolveError> =\n        MockClientHandle::mock(vec![Ok(DnsResponse::from_message(message).unwrap())]);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, false),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        *lookup.iter().next().unwrap(),\n        RData::A(A::new(93, 184, 216, 34))\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/resolver/src/lookup.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_cname_lookup", "test": "fn test_cname_lookup() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let cname_record = cname_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Name::from_str(\"v4.example.com.\").unwrap(),\n    );\n    let v4_record = v4_record(\n        Name::from_str(\"v4.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n    let message = message(resp_query, vec![cname_record, v4_record], vec![], vec![]);\n    let client: MockClientHandle<_, ResolveError> =\n        MockClientHandle::mock(vec![Ok(DnsResponse::from_message(message).unwrap())]);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, false),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        *lookup.iter().next().unwrap(),\n        RData::A(A::new(93, 184, 216, 34))\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/resolver/src/lookup.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_cname_lookup_preserve", "test": "fn test_cname_lookup_preserve() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let cname_record = cname_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Name::from_str(\"v4.example.com.\").unwrap(),\n    );\n    let v4_record = v4_record(\n        Name::from_str(\"v4.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n    let message = message(\n        resp_query,\n        vec![cname_record.clone(), v4_record],\n        vec![],\n        vec![],\n    );\n    let client: MockClientHandle<_, ResolveError> =\n        MockClientHandle::mock(vec![Ok(DnsResponse::from_message(message).unwrap())]);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, true),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    let mut iter = lookup.iter();\n    assert_eq!(iter.next().unwrap(), cname_record.data().unwrap());\n    assert_eq!(*iter.next().unwrap(), RData::A(A::new(93, 184, 216, 34)));\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/rr/rr_set.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_chained_cname_lookup", "test": "fn test_chained_cname_lookup() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let cname_record = cname_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Name::from_str(\"v4.example.com.\").unwrap(),\n    );\n    let v4_record = v4_record(\n        Name::from_str(\"v4.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n\n    // The first response should be a cname, the second will be the actual record\n    let message1 = message(resp_query.clone(), vec![cname_record], vec![], vec![]);\n    let message2 = message(resp_query, vec![v4_record], vec![], vec![]);\n\n    // the mock pops messages...\n    let client: MockClientHandle<_, ResolveError> = MockClientHandle::mock(vec![\n        Ok(DnsResponse::from_message(message2).unwrap()),\n        Ok(DnsResponse::from_message(message1).unwrap()),\n    ]);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, false),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    assert_eq!(\n        *lookup.iter().next().unwrap(),\n        RData::A(A::new(93, 184, 216, 34))\n    );\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/resolver/src/lookup.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().and_then(Record::data)\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/lookup_tests.rs::test_chained_cname_lookup_preserve", "test": "fn test_chained_cname_lookup_preserve() {\n    let resp_query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let cname_record = cname_record(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        Name::from_str(\"v4.example.com.\").unwrap(),\n    );\n    let v4_record = v4_record(\n        Name::from_str(\"v4.example.com.\").unwrap(),\n        Ipv4Addr::new(93, 184, 216, 34),\n    );\n\n    // The first response should be a cname, the second will be the actual record\n    let message1 = message(\n        resp_query.clone(),\n        vec![cname_record.clone()],\n        vec![],\n        vec![],\n    );\n    let message2 = message(resp_query, vec![v4_record], vec![], vec![]);\n\n    // the mock pops messages...\n    let client: MockClientHandle<_, ResolveError> = MockClientHandle::mock(vec![\n        Ok(DnsResponse::from_message(message2).unwrap()),\n        Ok(DnsResponse::from_message(message1).unwrap()),\n    ]);\n\n    let lookup = LookupFuture::lookup(\n        vec![Name::from_str(\"www.example.com.\").unwrap()],\n        RecordType::A,\n        Default::default(),\n        CachingClient::new(0, client, true),\n    );\n\n    let io_loop = Runtime::new().unwrap();\n    let lookup = io_loop.block_on(lookup).unwrap();\n\n    let mut iter = lookup.iter();\n    assert_eq!(iter.next().unwrap(), cname_record.data().unwrap());\n    assert_eq!(*iter.next().unwrap(), RData::A(A::new(93, 184, 216, 34)));\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/rr/rr_set.rs::next", "code": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.next()\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_datagram", "test": "fn test_datagram() {\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let udp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n    let tcp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 2));\n\n    let udp_message = message(query.clone(), vec![udp_record.clone()], vec![], vec![]);\n    let tcp_message = message(query.clone(), vec![tcp_record], vec![], vec![]);\n    let udp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        Default::default(),\n    );\n    let tcp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(tcp_message).unwrap())],\n        Default::default(),\n    );\n\n    let pool = mock_nameserver_pool(\n        vec![udp_nameserver],\n        vec![tcp_nameserver],\n        None,\n        Default::default(),\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], udp_record);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/authority/auth_lookup.rs::answers", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_datagram_stream_upgrades_on_truncation", "test": "fn test_datagram_stream_upgrades_on_truncation() {\n    // Lookup to UDP should return a truncated message, then we expect lookup on TCP.\n    // This should occur even though `try_tcp_on_error` is set to false.\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let tcp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 2));\n\n    let mut udp_message = message(query.clone(), vec![], vec![], vec![]);\n    udp_message.set_truncated(true);\n\n    let tcp_message = message(query.clone(), vec![tcp_record.clone()], vec![], vec![]);\n\n    let udp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        Default::default(),\n    );\n    let tcp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(tcp_message).unwrap())],\n        Default::default(),\n    );\n\n    let pool = mock_nameserver_pool(\n        vec![udp_nameserver],\n        vec![tcp_nameserver],\n        None,\n        Default::default(),\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], tcp_record);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/authority/auth_lookup.rs::answers", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_datagram_stream_upgrade_on_truncation_despite_udp", "test": "fn test_datagram_stream_upgrade_on_truncation_despite_udp() {\n    // Lookup to UDP should return a truncated message, then we expect lookup on TCP.\n    // This should occur even though `try_tcp_on_error` is set to false.\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let udp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n    let tcp_record1 = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 2));\n    let tcp_record2 = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 3));\n\n    let mut udp_message = message(query.clone(), vec![udp_record], vec![], vec![]);\n    udp_message.set_truncated(true);\n\n    let tcp_message = message(\n        query.clone(),\n        vec![tcp_record1.clone(), tcp_record2.clone()],\n        vec![],\n        vec![],\n    );\n\n    let udp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        Default::default(),\n    );\n    let tcp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(tcp_message).unwrap())],\n        Default::default(),\n    );\n\n    let pool = mock_nameserver_pool(\n        vec![udp_nameserver],\n        vec![tcp_nameserver],\n        None,\n        Default::default(),\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers(), &[tcp_record1, tcp_record2]);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/authority/auth_lookup.rs::answers", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_datagram_fails_to_stream", "test": "fn test_datagram_fails_to_stream() {\n    // Lookup to UDP should fail, and then the query should be retried on TCP because\n    // `try_tcp_on_error` is set to true.\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let tcp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 2));\n    let udp_message: Result<DnsResponse, _> = Err(ResolveError::from(\"Forced Testing Error\"));\n\n    let tcp_message = message(query.clone(), vec![tcp_record.clone()], vec![], vec![]);\n\n    let udp_nameserver = mock_nameserver(vec![udp_message], Default::default());\n    let tcp_nameserver = mock_nameserver(\n        vec![Ok(DnsResponse::from_message(tcp_message).unwrap())],\n        Default::default(),\n    );\n\n    let mut options = ResolverOpts::default();\n    options.try_tcp_on_error = true;\n    let pool = mock_nameserver_pool(vec![udp_nameserver], vec![tcp_nameserver], None, options);\n\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], tcp_record);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/authority/auth_lookup.rs::answers", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_user_provided_server_order", "test": "fn test_user_provided_server_order() {\n    use hickory_proto::rr::Record;\n\n    let mut options = ResolverOpts::default();\n\n    options.num_concurrent_reqs = 1;\n    options.server_ordering_strategy = ServerOrderingStrategy::UserProvidedOrder;\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let preferred_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n    let secondary_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 2));\n\n    let preferred_server_records = vec![preferred_record; 10];\n    let secondary_server_records = vec![secondary_record; 10];\n\n    let to_dns_response = |records: Vec<Record>| -> Vec<Result<DnsResponse, ResolveError>> {\n        records\n            .iter()\n            .map(|record| {\n                Ok(DnsResponse::from_message(message(\n                    query.clone(),\n                    vec![record.clone()],\n                    vec![],\n                    vec![],\n                ))\n                .unwrap())\n            })\n            .collect()\n    };\n\n    // Specify different IP addresses for each name server to ensure that they\n    // are considered separately.\n    let preferred_nameserver = mock_nameserver_with_addr(\n        to_dns_response(preferred_server_records.clone()),\n        Ipv4Addr::new(128, 0, 0, 1).into(),\n        Default::default(),\n    );\n    let secondary_nameserver = mock_nameserver_with_addr(\n        to_dns_response(secondary_server_records.clone()),\n        Ipv4Addr::new(129, 0, 0, 1).into(),\n        Default::default(),\n    );\n\n    let pool = mock_nameserver_pool(\n        vec![preferred_nameserver, secondary_nameserver],\n        vec![],\n        None,\n        options,\n    );\n\n    // The returned records should consistently be from the preferred name\n    // server until the configured records are exhausted. Subsequently, the\n    // secondary server should be used.\n    preferred_server_records\n        .into_iter()\n        .chain(secondary_server_records)\n        .for_each(|expected_record| {\n            let request = message(query.clone(), vec![], vec![], vec![]);\n            let future = pool.send(request).first_answer();\n\n            let response = block_on(future).unwrap();\n            assert_eq!(response.answers()[0], expected_record);\n        });\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/authority/auth_lookup.rs::answers", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_concurrent_requests_2_conns", "test": "fn test_concurrent_requests_2_conns() {\n    let mut options = ResolverOpts::default();\n\n    // there are only 2 conns, so this matches that count\n    options.num_concurrent_reqs = 2;\n\n    // we want to make sure that both udp connections are called\n    //   this will count down to 0 only if both are called.\n    let on_send = OnSendBarrier::new(2);\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let udp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n\n    let udp_message = message(query.clone(), vec![udp_record.clone()], vec![], vec![]);\n\n    let udp1_nameserver = mock_nameserver_on_send(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        options.clone(),\n        on_send.clone(),\n    );\n    let udp2_nameserver = mock_nameserver_on_send(vec![], options.clone(), on_send);\n\n    let pool = mock_nameserver_pool_on_send(\n        vec![udp2_nameserver, udp1_nameserver],\n        vec![],\n        None,\n        options,\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    // there's no actual network traffic happening, 1 sec should be plenty\n    //   TODO: for some reason this timeout doesn't work, not clear why...\n    // let future = Timeout::new(future, Duration::from_secs(1));\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], udp_record);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/authority/auth_lookup.rs::answers", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_concurrent_requests_more_than_conns", "test": "fn test_concurrent_requests_more_than_conns() {\n    let mut options = ResolverOpts::default();\n\n    // there are only two conns, but this requests 3 concurrent requests, only 2 called\n    options.num_concurrent_reqs = 3;\n\n    // we want to make sure that both udp connections are called\n    //   this will count down to 0 only if both are called.\n    let on_send = OnSendBarrier::new(2);\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let udp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n\n    let udp_message = message(query.clone(), vec![udp_record.clone()], vec![], vec![]);\n\n    let udp1_nameserver = mock_nameserver_on_send(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        options.clone(),\n        on_send.clone(),\n    );\n    let udp2_nameserver = mock_nameserver_on_send(vec![], options.clone(), on_send);\n\n    let pool = mock_nameserver_pool_on_send(\n        vec![udp2_nameserver, udp1_nameserver],\n        vec![],\n        None,\n        options,\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    // there's no actual network traffic happening, 1 sec should be plenty\n    //   TODO: for some reason this timeout doesn't work, not clear why...\n    // let future = Timeout::new(future, Duration::from_secs(1));\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], udp_record);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/authority/auth_lookup.rs::answers", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_concurrent_requests_1_conn", "test": "fn test_concurrent_requests_1_conn() {\n    let mut options = ResolverOpts::default();\n\n    // there are two connections, but no concurrency requested\n    options.num_concurrent_reqs = 1;\n\n    // we want to make sure that both udp connections are called\n    //   this will count down to 0 only if both are called.\n    let on_send = OnSendBarrier::new(1);\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let udp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n\n    let udp_message = message(query.clone(), vec![udp_record.clone()], vec![], vec![]);\n\n    let udp1_nameserver = mock_nameserver_on_send(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        options.clone(),\n        on_send,\n    );\n    let udp2_nameserver = udp1_nameserver.clone();\n\n    let pool = mock_nameserver_pool_on_send(\n        vec![udp2_nameserver, udp1_nameserver],\n        vec![],\n        None,\n        options,\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    // there's no actual network traffic happening, 1 sec should be plenty\n    //   TODO: for some reason this timeout doesn't work, not clear why...\n    // let future = Timeout::new(future, Duration::from_secs(1));\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], udp_record);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/authority/auth_lookup.rs::answers", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/name_server_pool_tests.rs::test_concurrent_requests_0_conn", "test": "fn test_concurrent_requests_0_conn() {\n    let mut options = ResolverOpts::default();\n\n    // there are two connections, but no concurrency requested, 0==1\n    options.num_concurrent_reqs = 0;\n\n    // we want to make sure that both udp connections are called\n    //   this will count down to 0 only if both are called.\n    let on_send = OnSendBarrier::new(1);\n\n    let query = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n\n    let udp_record = v4_record(query.name().clone(), Ipv4Addr::new(127, 0, 0, 1));\n\n    let udp_message = message(query.clone(), vec![udp_record.clone()], vec![], vec![]);\n\n    let udp1_nameserver = mock_nameserver_on_send(\n        vec![Ok(DnsResponse::from_message(udp_message).unwrap())],\n        options.clone(),\n        on_send,\n    );\n    let udp2_nameserver = udp1_nameserver.clone();\n\n    let pool = mock_nameserver_pool_on_send(\n        vec![udp2_nameserver, udp1_nameserver],\n        vec![],\n        None,\n        options,\n    );\n\n    // lookup on UDP succeeds, any other would fail\n    let request = message(query, vec![], vec![], vec![]);\n    let future = pool.send(request).first_answer();\n\n    // there's no actual network traffic happening, 1 sec should be plenty\n    //   TODO: for some reason this timeout doesn't work, not clear why...\n    // let future = Timeout::new(future, Duration::from_secs(1));\n\n    let response = block_on(future).unwrap();\n    assert_eq!(response.answers()[0], udp_record);\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/authority/auth_lookup.rs::answers", "code": "pub fn answers(answers: LookupRecords, additionals: Option<LookupRecords>) -> Self {\n        Self::Records {\n            answers,\n            additionals,\n        }\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/retry_dns_handle_tests.rs::retry_on_retryable_error", "test": "fn retry_on_retryable_error() {\n    let handle = RetryDnsHandle::new(\n        TestClient {\n            retries: 1,\n            error_response: ResolveError::from(std::io::Error::from(std::io::ErrorKind::TimedOut)),\n            attempts: Arc::new(AtomicU16::new(0)),\n        },\n        2,\n    );\n    let test1 = Message::new();\n    let result = block_on(handle.send(test1).first_answer()).expect(\"should have succeeded\");\n    assert_eq!(result.id(), 1); // this is checking the number of iterations the TestClient ran\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/op/header.rs::id", "code": "pub fn id(&self) -> u16 {\n        self.id\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/server_future_tests.rs::test_server_unknown_type", "test": "fn test_server_unknown_type() {\n    let runtime = Runtime::new().expect(\"failed to create Tokio Runtime\");\n    let addr = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 0));\n    let udp_socket = runtime.block_on(UdpSocket::bind(&addr)).unwrap();\n\n    let ipaddr = udp_socket.local_addr().unwrap();\n    println!(\"udp_socket on port: {ipaddr}\");\n    let server_continue = Arc::new(AtomicBool::new(true));\n    let server_continue2 = server_continue.clone();\n\n    let server_thread = thread::Builder::new()\n        .name(\"test_server:udp:server\".to_string())\n        .spawn(move || server_thread_udp(runtime, udp_socket, server_continue2))\n        .unwrap();\n\n    let conn = UdpClientConnection::new(ipaddr).unwrap();\n    let client = SyncClient::new(conn);\n    let client_result = client\n        .query(\n            &Name::from_str(\"www.example.com.\").unwrap(),\n            DNSClass::IN,\n            RecordType::Unknown(65535),\n        )\n        .expect(\"query failed for unknown\");\n\n    assert_eq!(client_result.response_code(), ResponseCode::NoError);\n    assert_eq!(\n        client_result.queries().first().unwrap().query_type(),\n        RecordType::Unknown(65535)\n    );\n    assert!(client_result.answers().is_empty());\n    assert!(!client_result.name_servers().is_empty());\n    // SOA should be the first record in the response\n    assert_eq!(\n        client_result\n            .name_servers()\n            .first()\n            .expect(\"no SOA present\")\n            .record_type(),\n        RecordType::SOA\n    );\n\n    server_continue.store(false, Ordering::Relaxed);\n    server_thread.join().unwrap();\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/server/src/authority/message_request.rs::response_code", "code": "pub fn response_code(&self) -> ResponseCode {\n        self.header.response_code()\n    }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/server_future_tests.rs::test_server_form_error_on_multiple_queries", "test": "fn test_server_form_error_on_multiple_queries() {\n    let runtime = Runtime::new().expect(\"failed to create Tokio Runtime\");\n    let addr = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 0));\n    let udp_socket = runtime.block_on(UdpSocket::bind(&addr)).unwrap();\n\n    let ipaddr = udp_socket.local_addr().unwrap();\n    println!(\"udp_socket on port: {ipaddr}\");\n    let server_continue = Arc::new(AtomicBool::new(true));\n    let server_continue2 = server_continue.clone();\n\n    let server_thread = thread::Builder::new()\n        .name(\"test_server:udp:server\".to_string())\n        .spawn(move || server_thread_udp(runtime, udp_socket, server_continue2))\n        .unwrap();\n\n    let conn = UdpClientConnection::new(ipaddr).unwrap();\n    let client = SyncClient::new(conn);\n\n    // build the message\n    let query_a = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let query_aaaa = Query::query(\n        Name::from_str(\"www.example.com.\").unwrap(),\n        RecordType::AAAA,\n    );\n    let mut message: Message = Message::new();\n    message\n        .add_query(query_a)\n        .add_query(query_aaaa)\n        .set_message_type(MessageType::Query)\n        .set_op_code(OpCode::Query)\n        .set_recursion_desired(true);\n\n    let mut client_result = client.send(message);\n\n    assert_eq!(client_result.len(), 1);\n    let client_result = client_result\n        .pop()\n        .expect(\"there should be one response\")\n        .expect(\"should have been a successful network request\");\n\n    assert_eq!(client_result.response_code(), ResponseCode::FormErr);\n\n    server_continue.store(false, Ordering::Relaxed);\n    server_thread.join().unwrap();\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/serialize/binary/encoder.rs::len", "code": "pub(super) fn len(&self) -> usize {\n            self.buffer.len()\n        }", "docstring": null}
{"test_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/tests/integration-tests/tests/server_future_tests.rs::test_server_no_response_on_response", "test": "fn test_server_no_response_on_response() {\n    let runtime = Runtime::new().expect(\"failed to create Tokio Runtime\");\n    let addr = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 0));\n    let udp_socket = runtime.block_on(UdpSocket::bind(&addr)).unwrap();\n\n    let ipaddr = udp_socket.local_addr().unwrap();\n    println!(\"udp_socket on port: {}\", ipaddr);\n    let server_continue = Arc::new(AtomicBool::new(true));\n    let server_continue2 = server_continue.clone();\n\n    let server_thread = thread::Builder::new()\n        .name(\"test_server:udp:server\".to_string())\n        .spawn(move || server_thread_udp(runtime, udp_socket, server_continue2))\n        .unwrap();\n\n    let conn = UdpClientConnection::new(ipaddr).unwrap();\n    let client = SyncClient::new(conn);\n\n    // build the message\n    let query_a = Query::query(Name::from_str(\"www.example.com.\").unwrap(), RecordType::A);\n    let mut message = Message::new();\n    message\n        .set_message_type(MessageType::Response)\n        .set_op_code(OpCode::Query)\n        .add_query(query_a);\n\n    let client_result = client.send(message);\n    assert_eq!(client_result.len(), 0);\n\n    server_continue.store(false, Ordering::Relaxed);\n    server_thread.join().unwrap();\n}", "code_id": "hickory-dns-hickory-dns/hickory-dns-hickory-dns-408d0ba/crates/proto/src/serialize/binary/encoder.rs::len", "code": "pub(super) fn len(&self) -> usize {\n            self.buffer.len()\n        }", "docstring": null}
