{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_identifier.rs::test_new", "test": "fn test_new() {\n    fn test(identifier: Prerelease, expected: &str) {\n        assert_eq!(identifier.is_empty(), expected.is_empty());\n        assert_eq!(identifier.len(), expected.len());\n        assert_eq!(identifier.as_str(), expected);\n        assert_eq!(identifier, identifier);\n        assert_eq!(identifier, identifier.clone());\n    }\n\n    let ref mut string = String::new();\n    let limit = if cfg!(miri) { 40 } else { 280 }; // miri is slow\n    for _ in 0..limit {\n        test(prerelease(string), string);\n        string.push('1');\n    }\n\n    if !cfg!(miri) {\n        let ref string = string.repeat(20000);\n        test(prerelease(string), string);\n    }\n}", "code_id": "dtolnay-semver/dtolnay-semver-750f0ac/src/identifier.rs::is_empty", "code": "pub(crate) fn is_empty(&self) -> bool {\n        // `cmp rdi, -1` -- basically: `repr as i64 == -1`\n        let empty = Self::empty();\n        let is_empty = self.head == empty.head && self.tail == empty.tail;\n        // The empty representation does nothing on Drop. We can't let this one\n        // drop normally because `impl Drop for Identifier` calls is_empty; that\n        // would be an infinite recursion.\n        mem::forget(empty);\n        is_empty\n    }", "docstring": null}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_identifier.rs::test_eq", "test": "fn test_eq() {\n    assert_eq!(prerelease(\"-\"), prerelease(\"-\"));\n    assert_ne!(prerelease(\"a\"), prerelease(\"aa\"));\n    assert_ne!(prerelease(\"aa\"), prerelease(\"a\"));\n    assert_ne!(prerelease(\"aaaaaaaaa\"), prerelease(\"a\"));\n    assert_ne!(prerelease(\"a\"), prerelease(\"aaaaaaaaa\"));\n    assert_ne!(prerelease(\"aaaaaaaaa\"), prerelease(\"bbbbbbbbb\"));\n    assert_ne!(build_metadata(\"1\"), build_metadata(\"001\"));\n}", "code_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/util/mod.rs::prerelease", "code": "pub(super) fn prerelease(text: &str) -> Prerelease {\n    Prerelease::new(text).unwrap()\n}", "docstring": null}
{"test_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/test_version_req.rs::test_wildcard", "test": "pub fn test_wildcard() {\n    let err = req_err(\"\");\n    assert_to_string(\n        err,\n        \"unexpected end of input while parsing major version number\",\n    );\n\n    let ref r = req(\"*\");\n    assert_match_all(r, &[\"0.9.1\", \"2.9.0\", \"0.0.9\", \"1.0.1\", \"1.1.1\"]);\n    assert_match_none(r, &[\"1.0.0-pre\"]);\n\n    for s in &[\"x\", \"X\"] {\n        assert_eq!(*r, req(s));\n    }\n\n    let ref r = req(\"1.*\");\n    assert_match_all(r, &[\"1.2.0\", \"1.2.1\", \"1.1.1\", \"1.3.0\"]);\n    assert_match_none(r, &[\"0.0.9\", \"1.2.0-pre\"]);\n\n    for s in &[\"1.x\", \"1.X\", \"1.*.*\"] {\n        assert_eq!(*r, req(s));\n    }\n\n    let ref r = req(\"1.2.*\");\n    assert_match_all(r, &[\"1.2.0\", \"1.2.2\", \"1.2.4\"]);\n    assert_match_none(r, &[\"1.9.0\", \"1.0.9\", \"2.0.1\", \"0.1.3\", \"1.2.2-pre\"]);\n\n    for s in &[\"1.2.x\", \"1.2.X\"] {\n        assert_eq!(*r, req(s));\n    }\n}", "code_id": "dtolnay-semver/dtolnay-semver-750f0ac/tests/node/mod.rs::req", "code": "pub(super) fn req(text: &str) -> VersionReq {\n    VersionReq(crate::util::req(text))\n}", "docstring": null}
