{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/integration_tests.rs::f32_test", "test": "fn f32_test() {\n    assert_eq!(\n        (184467440000000000000.0, b!(\"\\x00\\x00006\")),\n        parse_float::<f32>(b\"000184467440737095516150\\x00\\x00006\")\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/integration_tests.rs::f64_test", "test": "fn f64_test() {\n    assert_eq!(\n        (184467440737095500000.0, b!(\"\\x00\\x00006\")),\n        parse_float::<f64>(b\"000184467440737095516150\\x00\\x00006\")\n    );\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/libm_tests.rs::fabsf_sanity_test", "test": "fn fabsf_sanity_test() {\n    assert_eq!(libm::fabsf(-1.0), 1.0);\n    assert_eq!(libm::fabsf(2.8), 2.8);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/libm_tests.rs::fabsf_spec_test", "test": "fn fabsf_spec_test() {\n    assert!(libm::fabsf(f32::NAN).is_nan());\n    for f in [0.0, -0.0].iter().copied() {\n        assert_eq!(libm::fabsf(f), 0.0);\n    }\n    for f in [f32::INFINITY, f32::NEG_INFINITY].iter().copied() {\n        assert_eq!(libm::fabsf(f), f32::INFINITY);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/libm_tests.rs::sqrtf_sanity_test", "test": "fn sqrtf_sanity_test() {\n    assert_eq!(libm::sqrtf(100.0), 10.0);\n    assert_eq!(libm::sqrtf(4.0), 2.0);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/libm_tests.rs::sqrtf_spec_test", "test": "fn sqrtf_spec_test() {\n    // Not Asserted: FE_INVALID exception is raised if argument is negative.\n    assert!(libm::sqrtf(-1.0).is_nan());\n    assert!(libm::sqrtf(f32::NAN).is_nan());\n    for f in [0.0, -0.0, f32::INFINITY].iter().copied() {\n        assert_eq!(libm::sqrtf(f), f);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/libm_tests.rs::normal_cases", "test": "fn normal_cases() {\n    assert_eq!(libm::powd(2.0, 20.0), (1 << 20) as f64);\n    assert_eq!(libm::powd(-1.0, 9.0), -1.0);\n    assert!(libm::powd(-1.0, 2.2).is_nan());\n    assert!(libm::powd(-1.0, -1.14).is_nan());\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/libm_tests.rs::fabsd_sanity_test", "test": "fn fabsd_sanity_test() {\n    assert_eq!(libm::fabsd(-1.0), 1.0);\n    assert_eq!(libm::fabsd(2.8), 2.8);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/libm_tests.rs::fabsd_spec_test", "test": "fn fabsd_spec_test() {\n    assert!(libm::fabsd(f64::NAN).is_nan());\n    for f in [0.0, -0.0].iter().copied() {\n        assert_eq!(libm::fabsd(f), 0.0);\n    }\n    for f in [f64::INFINITY, f64::NEG_INFINITY].iter().copied() {\n        assert_eq!(libm::fabsd(f), f64::INFINITY);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/libm_tests.rs::sqrtd_sanity_test", "test": "fn sqrtd_sanity_test() {\n    assert_eq!(libm::sqrtd(100.0), 10.0);\n    assert_eq!(libm::sqrtd(4.0), 2.0);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/libm_tests.rs::sqrtd_spec_test", "test": "fn sqrtd_spec_test() {\n    // Not Asserted: FE_INVALID exception is raised if argument is negative.\n    assert!(libm::sqrtd(-1.0).is_nan());\n    assert!(libm::sqrtd(f64::NAN).is_nan());\n    for f in [0.0, -0.0, f64::INFINITY].iter().copied() {\n        assert_eq!(libm::sqrtd(f), f);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/mask_tests.rs::lower_n_mask_test", "test": "fn lower_n_mask_test() {\n    assert_eq!(mask::lower_n_mask(2), 0b11);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/mask_tests.rs::lower_n_halfway_test", "test": "fn lower_n_halfway_test() {\n    assert_eq!(mask::lower_n_halfway(2), 0b10);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/mask_tests.rs::nth_bit_test", "test": "fn nth_bit_test() {\n    assert_eq!(mask::nth_bit(2), 0b100);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/number_tests.rs::is_fast_path_test", "test": "fn is_fast_path_test() {\n    let mut number = Number {\n        exponent: -4,\n        mantissa: 12345,\n        many_digits: false,\n    };\n    assert_eq!(number.is_fast_path::<f32>(), true);\n    assert_eq!(number.is_fast_path::<f64>(), true);\n\n    number.exponent = -15;\n    assert_eq!(number.is_fast_path::<f32>(), false);\n    assert_eq!(number.is_fast_path::<f64>(), true);\n\n    number.exponent = -25;\n    assert_eq!(number.is_fast_path::<f32>(), false);\n    assert_eq!(number.is_fast_path::<f64>(), false);\n\n    number.exponent = 25;\n    assert_eq!(number.is_fast_path::<f32>(), false);\n    assert_eq!(number.is_fast_path::<f64>(), true);\n\n    number.exponent = 36;\n    assert_eq!(number.is_fast_path::<f32>(), false);\n    assert_eq!(number.is_fast_path::<f64>(), true);\n\n    number.exponent = 38;\n    assert_eq!(number.is_fast_path::<f32>(), false);\n    assert_eq!(number.is_fast_path::<f64>(), false);\n\n    number.mantissa = 1 << 25;\n    number.exponent = 0;\n    assert_eq!(number.is_fast_path::<f32>(), false);\n    assert_eq!(number.is_fast_path::<f64>(), true);\n\n    number.mantissa = 1 << 54;\n    assert_eq!(number.is_fast_path::<f32>(), false);\n    assert_eq!(number.is_fast_path::<f64>(), false);\n\n    number.mantissa = 1 << 52;\n    assert_eq!(number.is_fast_path::<f32>(), false);\n    assert_eq!(number.is_fast_path::<f64>(), true);\n\n    number.many_digits = true;\n    assert_eq!(number.is_fast_path::<f32>(), false);\n    assert_eq!(number.is_fast_path::<f64>(), false);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/number_tests.rs::try_fast_path_test", "test": "fn try_fast_path_test() {\n    let mut number = Number {\n        exponent: -4,\n        mantissa: 12345,\n        many_digits: false,\n    };\n    assert_eq!(number.try_fast_path::<f32>(), Some(1.2345));\n    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345));\n\n    number.exponent = -10;\n    assert_eq!(number.try_fast_path::<f32>(), Some(1.2345e-6));\n    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345e-6));\n\n    number.exponent = -20;\n    assert_eq!(number.try_fast_path::<f32>(), None);\n    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345e-16));\n\n    number.exponent = -25;\n    assert_eq!(number.try_fast_path::<f32>(), None);\n    assert_eq!(number.try_fast_path::<f64>(), None);\n\n    number.exponent = 12;\n    assert_eq!(number.try_fast_path::<f32>(), Some(1.2345e16));\n    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345e16));\n\n    number.exponent = 25;\n    assert_eq!(number.try_fast_path::<f32>(), None);\n    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345e29));\n\n    number.exponent = 32;\n    assert_eq!(number.try_fast_path::<f32>(), None);\n    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345e36));\n\n    number.exponent = 36;\n    assert_eq!(number.try_fast_path::<f32>(), None);\n    assert_eq!(number.try_fast_path::<f64>(), None);\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::scalar_add_test", "test": "fn scalar_add_test() {\n    assert_eq!(bigint::scalar_add(5, 5), (10, false));\n    assert_eq!(bigint::scalar_add(LIMB_MAX, 1), (0, true));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::scalar_mul_test", "test": "fn scalar_mul_test() {\n    assert_eq!(bigint::scalar_mul(5, 5, 0), (25, 0));\n    assert_eq!(bigint::scalar_mul(5, 5, 1), (26, 0));\n    assert_eq!(bigint::scalar_mul(LIMB_MAX, 2, 0), (LIMB_MAX - 1, 1));\n}", "error": "Not Definition Found"}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::bit_length_test", "test": "fn bit_length_test() {\n    let x: VecType = vec_from_u32(&[0, 0, 0, 1]);\n    assert_eq!(bigint::bit_length(&x), 97);\n\n    let x: VecType = vec_from_u32(&[0, 0, 0, 3]);\n    assert_eq!(bigint::bit_length(&x), 98);\n\n    let x = VecType::from_u64(1 << 31);\n    assert_eq!(bigint::bit_length(&x), 32);\n}", "error": "Not Definition Found"}
