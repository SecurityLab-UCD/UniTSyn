{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::version_negotiate_server", "test": "fn version_negotiate_server() {\n    let _guard = subscribe();\n    let client_addr = \"[::2]:7890\".parse().unwrap();\n    let mut server = Endpoint::new(Default::default(), Some(Arc::new(server_config())), true);\n    let now = Instant::now();\n    let event = server.handle(\n        now,\n        client_addr,\n        None,\n        None,\n        // Long-header packet with reserved version number\n        hex!(\"80 0a1a2a3a 04 00000000 04 00000000 00\")[..].into(),\n    );\n    assert!(event.is_none());\n\n    let io = server.poll_transmit();\n    assert!(io.is_some());\n    if let Some(Transmit { contents, .. }) = io {\n        assert_ne!(contents[0] & 0x80, 0);\n        assert_eq!(&contents[1..15], hex!(\"00000000 04 00000000 04 00000000\"));\n        assert!(contents[15..].chunks(4).any(|x| {\n            DEFAULT_SUPPORTED_VERSIONS.contains(&u32::from_be_bytes(x.try_into().unwrap()))\n        }));\n    }\n    assert_matches!(server.poll_transmit(), None);\n}", "error": "Not Definition Found"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::congestion", "test": "fn congestion() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, _) = pair.connect();\n\n    const TARGET: u64 = 2048;\n    assert!(pair.client_conn_mut(client_ch).congestion_window() > TARGET);\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    // Send data without receiving ACKs until the congestion state falls below target\n    while pair.client_conn_mut(client_ch).congestion_window() > TARGET {\n        let n = pair.client_send(client_ch, s).write(&[42; 1024]).unwrap();\n        assert_eq!(n, 1024);\n        pair.drive_client();\n    }\n    // Ensure that the congestion state recovers after receiving the ACKs\n    pair.drive();\n    assert!(pair.client_conn_mut(client_ch).congestion_window() >= TARGET);\n    pair.client_send(client_ch, s).write(&[42; 1024]).unwrap();\n}", "error": "Not Definition Found"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::high_latency_handshake", "test": "fn high_latency_handshake() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    pair.latency = Duration::from_micros(200 * 1000);\n    let (client_ch, server_ch) = pair.connect();\n    assert_eq!(pair.client_conn_mut(client_ch).bytes_in_flight(), 0);\n    assert_eq!(pair.server_conn_mut(server_ch).bytes_in_flight(), 0);\n    assert!(pair.client_conn_mut(client_ch).using_ecn());\n    assert!(pair.server_conn_mut(server_ch).using_ecn());\n}", "error": "Not Definition Found"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::idle_timeout", "test": "fn idle_timeout() {\n    let _guard = subscribe();\n    const IDLE_TIMEOUT: u64 = 100;\n    let server = ServerConfig {\n        transport: Arc::new(TransportConfig {\n            max_idle_timeout: Some(VarInt(IDLE_TIMEOUT)),\n            ..TransportConfig::default()\n        }),\n        ..server_config()\n    };\n    let mut pair = Pair::new(Default::default(), server);\n    let (client_ch, server_ch) = pair.connect();\n    pair.client_conn_mut(client_ch).ping();\n    let start = pair.time;\n\n    while !pair.client_conn_mut(client_ch).is_closed()\n        || !pair.server_conn_mut(server_ch).is_closed()\n    {\n        if !pair.step() {\n            if let Some(t) = min_opt(pair.client.next_wakeup(), pair.server.next_wakeup()) {\n                pair.time = t;\n            }\n        }\n        pair.client.inbound.clear(); // Simulate total S->C packet loss\n    }\n\n    assert!(pair.time - start < Duration::from_millis(2 * IDLE_TIMEOUT));\n    assert_matches!(\n        pair.client_conn_mut(client_ch).poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::TimedOut,\n        })\n    );\n    assert_matches!(\n        pair.server_conn_mut(server_ch).poll(),\n        Some(Event::ConnectionLost {\n            reason: ConnectionError::TimedOut,\n        })\n    );\n}", "error": "Not Definition Found"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::migration", "test": "fn migration() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, server_ch) = pair.connect();\n    pair.client.addr = SocketAddr::new(\n        Ipv4Addr::new(127, 0, 0, 1).into(),\n        CLIENT_PORTS.lock().unwrap().next().unwrap(),\n    );\n    pair.client_conn_mut(client_ch).ping();\n\n    // Assert that just receiving the ping message is accounted into the servers\n    // anti-amplification budget\n    pair.drive_client();\n    pair.drive_server();\n    assert_ne!(pair.server_conn_mut(server_ch).total_recvd(), 0);\n\n    pair.drive();\n    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n    assert_eq!(\n        pair.server_conn_mut(server_ch).remote_address(),\n        pair.client.addr\n    );\n}", "error": "Not Definition Found"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::cid_rotation", "test": "fn cid_rotation() {\n    let _guard = subscribe();\n    const CID_TIMEOUT: Duration = Duration::from_secs(2);\n\n    let cid_generator_factory: fn() -> Box<dyn ConnectionIdGenerator> =\n        || Box::new(*RandomConnectionIdGenerator::new(8).set_lifetime(CID_TIMEOUT));\n\n    // Only test cid rotation on server side to have a clear output trace\n    let server = Endpoint::new(\n        Arc::new(EndpointConfig {\n            connection_id_generator_factory: Arc::new(cid_generator_factory),\n            ..EndpointConfig::default()\n        }),\n        Some(Arc::new(server_config())),\n        true,\n    );\n    let client = Endpoint::new(Arc::new(EndpointConfig::default()), None, true);\n\n    let mut pair = Pair::new_from_endpoint(client, server);\n    let (_, server_ch) = pair.connect();\n\n    let mut round: u64 = 1;\n    let mut stop = pair.time;\n    let end = pair.time + 5 * CID_TIMEOUT;\n\n    use crate::cid_queue::CidQueue;\n    use crate::LOC_CID_COUNT;\n    let mut active_cid_num = CidQueue::LEN as u64 + 1;\n    active_cid_num = active_cid_num.min(LOC_CID_COUNT);\n    let mut left_bound = 0;\n    let mut right_bound = active_cid_num - 1;\n\n    while pair.time < end {\n        stop += CID_TIMEOUT;\n        // Run a while until PushNewCID timer fires\n        while pair.time < stop {\n            if !pair.step() {\n                if let Some(time) = min_opt(pair.client.next_wakeup(), pair.server.next_wakeup()) {\n                    pair.time = time;\n                }\n            }\n        }\n        info!(\n            \"Checking active cid sequence range before {:?} seconds\",\n            round * CID_TIMEOUT.as_secs()\n        );\n        let _bound = (left_bound, right_bound);\n        assert_matches!(\n            pair.server_conn_mut(server_ch).active_local_cid_seq(),\n            _bound\n        );\n        round += 1;\n        left_bound += active_cid_num;\n        right_bound += active_cid_num;\n        pair.drive_server();\n    }\n}", "error": "Not Definition Found"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::handshake_1rtt_handling", "test": "fn handshake_1rtt_handling() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let client_ch = pair.begin_connect(client_config());\n    pair.drive_client();\n    pair.drive_server();\n    let server_ch = pair.server.assert_accept();\n    // Server now has 1-RTT keys, but remains in Handshake state until the TLS CFIN has\n    // authenticated the client. Delay the final client handshake flight so that doesn't happen yet.\n    pair.client.drive(pair.time, pair.server.addr);\n    pair.client.delay_outbound();\n\n    // Send some 1-RTT data which will be received first.\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    const MSG: &[u8] = b\"hello\";\n    pair.client_send(client_ch, s).write(MSG).unwrap();\n    pair.client_send(client_ch, s).finish().unwrap();\n    pair.client.drive(pair.time, pair.server.addr);\n\n    // Add the handshake flight back on.\n    pair.client.finish_delay();\n\n    pair.drive();\n\n    assert!(pair.client_conn_mut(client_ch).lost_packets() != 0);\n    let mut recv = pair.server_recv(server_ch, s);\n    let mut chunks = recv.read(false).unwrap();\n    assert_matches!(\n        chunks.next(usize::MAX),\n        Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == MSG\n    );\n    let _ = chunks.finalize();\n}", "error": "Not Definition Found"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::congested_tail_loss", "test": "fn congested_tail_loss() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    let (client_ch, _) = pair.connect();\n\n    const TARGET: u64 = 2048;\n    assert!(pair.client_conn_mut(client_ch).congestion_window() > TARGET);\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    // Send data without receiving ACKs until the congestion state falls below target\n    while pair.client_conn_mut(client_ch).congestion_window() > TARGET {\n        let n = pair.client_send(client_ch, s).write(&[42; 1024]).unwrap();\n        assert_eq!(n, 1024);\n        pair.drive_client();\n    }\n    assert!(!pair.server.inbound.is_empty());\n    pair.server.inbound.clear();\n    // Ensure that the congestion state recovers after retransmits occur and are ACKed\n    info!(\"recovering\");\n    pair.drive();\n    assert!(pair.client_conn_mut(client_ch).congestion_window() > TARGET);\n    pair.client_send(client_ch, s).write(&[42; 1024]).unwrap();\n}", "error": "Not Definition Found"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::connect_detects_mtu", "test": "fn connect_detects_mtu() {\n    let _guard = subscribe();\n    let max_udp_payload_and_expected_mtu = &[(1200, 1200), (1400, 1389), (1500, 1452)];\n\n    for &(pair_max_udp, expected_mtu) in max_udp_payload_and_expected_mtu {\n        println!(\"Trying {pair_max_udp}\");\n        let mut pair = Pair::default();\n        pair.mtu = pair_max_udp;\n        let (client_ch, server_ch) = pair.connect();\n        pair.drive();\n\n        assert_eq!(pair.client_conn_mut(client_ch).path_mtu(), expected_mtu);\n        assert_eq!(pair.server_conn_mut(server_ch).path_mtu(), expected_mtu);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::migrate_detects_new_mtu_and_respects_original_peer_max_udp_payload_size", "test": "fn migrate_detects_new_mtu_and_respects_original_peer_max_udp_payload_size() {\n    let _guard = subscribe();\n\n    let client_max_udp_payload_size: u16 = 1400;\n\n    // Set up a client with a max payload size of 1400 (and use the defaults for the server)\n    let server_endpoint_config = EndpointConfig::default();\n    let server = Endpoint::new(\n        Arc::new(server_endpoint_config),\n        Some(Arc::new(server_config())),\n        true,\n    );\n    let client_endpoint_config = EndpointConfig {\n        max_udp_payload_size: VarInt::from(client_max_udp_payload_size),\n        ..EndpointConfig::default()\n    };\n    let client = Endpoint::new(Arc::new(client_endpoint_config), None, true);\n    let mut pair = Pair::new_from_endpoint(client, server);\n    pair.mtu = 1300;\n\n    // Connect\n    let (client_ch, server_ch) = pair.connect();\n    pair.drive();\n\n    // Sanity check: MTUD ran to completion (the numbers differ because binary search stops when\n    // changes are smaller than 20, otherwise both endpoints would converge at the same MTU of 1300)\n    assert_eq!(pair.client_conn_mut(client_ch).path_mtu(), 1293);\n    assert_eq!(pair.server_conn_mut(server_ch).path_mtu(), 1300);\n\n    // Migrate client to a different port (and simulate a higher path MTU)\n    pair.mtu = 1500;\n    pair.client.addr = SocketAddr::new(\n        Ipv4Addr::new(127, 0, 0, 1).into(),\n        CLIENT_PORTS.lock().unwrap().next().unwrap(),\n    );\n    pair.client_conn_mut(client_ch).ping();\n    pair.drive();\n\n    // Sanity check: the server saw that the client address was updated\n    assert_eq!(\n        pair.server_conn_mut(server_ch).remote_address(),\n        pair.client.addr\n    );\n\n    // MTU detection has successfully run after migrating\n    assert_eq!(\n        pair.server_conn_mut(server_ch).path_mtu(),\n        client_max_udp_payload_size\n    );\n\n    // Sanity check: the client keeps the old MTU, because migration is triggered by incoming\n    // packets from a different address\n    assert_eq!(pair.client_conn_mut(client_ch).path_mtu(), 1293);\n}", "error": "Not Definition Found"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::connect_runs_mtud_again_after_600_seconds", "test": "fn connect_runs_mtud_again_after_600_seconds() {\n    let _guard = subscribe();\n    let mut server_config = server_config();\n    let mut client_config = client_config();\n\n    // Note: we use an infinite idle timeout to ensure we can wait 600 seconds without the\n    // connection closing\n    Arc::get_mut(&mut server_config.transport)\n        .unwrap()\n        .max_idle_timeout(None);\n    Arc::get_mut(&mut client_config.transport)\n        .unwrap()\n        .max_idle_timeout(None);\n\n    let mut pair = Pair::new(Default::default(), server_config);\n    pair.mtu = 1400;\n    let (client_ch, server_ch) = pair.connect_with(client_config);\n    pair.drive();\n\n    // Sanity check: the mtu has been discovered\n    let client_conn = pair.client_conn_mut(client_ch);\n    assert_eq!(client_conn.path_mtu(), 1389);\n    assert_eq!(client_conn.stats().path.sent_plpmtud_probes, 5);\n    assert_eq!(client_conn.stats().path.lost_plpmtud_probes, 3);\n    let server_conn = pair.server_conn_mut(server_ch);\n    assert_eq!(server_conn.path_mtu(), 1389);\n    assert_eq!(server_conn.stats().path.sent_plpmtud_probes, 5);\n    assert_eq!(server_conn.stats().path.lost_plpmtud_probes, 3);\n\n    // Sanity check: the mtu does not change after the fact, even though the link now supports a\n    // higher udp payload size\n    pair.mtu = 1500;\n    pair.drive();\n    assert_eq!(pair.client_conn_mut(client_ch).path_mtu(), 1389);\n    assert_eq!(pair.server_conn_mut(server_ch).path_mtu(), 1389);\n\n    // The MTU changes after 600 seconds, because now MTUD runs for the second time\n    pair.time += Duration::from_secs(600);\n    pair.drive();\n    assert!(!pair.client_conn_mut(client_ch).is_closed());\n    assert!(!pair.server_conn_mut(client_ch).is_closed());\n    assert_eq!(pair.client_conn_mut(client_ch).path_mtu(), 1452);\n    assert_eq!(pair.server_conn_mut(server_ch).path_mtu(), 1452);\n}", "error": "Not Definition Found"}
{"test_id": "quinn-rs-quinn/quinn-rs-quinn-83e4f46/quinn-proto/src/tests/mod.rs::blackhole_after_mtu_change_repairs_itself", "test": "fn blackhole_after_mtu_change_repairs_itself() {\n    let _guard = subscribe();\n    let mut pair = Pair::default();\n    pair.mtu = 1500;\n    let (client_ch, server_ch) = pair.connect();\n    pair.drive();\n\n    // Sanity check\n    assert_eq!(pair.client_conn_mut(client_ch).path_mtu(), 1452);\n    assert_eq!(pair.server_conn_mut(server_ch).path_mtu(), 1452);\n\n    // Back to the base MTU\n    pair.mtu = 1200;\n\n    // The payload will be sent in a single packet, because the detected MTU was 1444, but it will\n    // be dropped because the link no longer supports that packet size!\n    let payload = vec![42; 1300];\n    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();\n    pair.client_send(client_ch, s).write(&payload).unwrap();\n    let out_of_bounds = pair.drive_bounded();\n\n    if out_of_bounds {\n        panic!(\"Connections never reached an idle state\");\n    }\n\n    let recv = pair.server_recv(server_ch, s);\n    let buf = stream_chunks(recv);\n\n    // The whole packet arrived in the end\n    assert_eq!(buf.len(), 1300);\n\n    // Sanity checks (black hole detected after 3 lost packets)\n    let client_stats = pair.client_conn_mut(client_ch).stats();\n    assert!(client_stats.path.lost_packets >= 3);\n    assert!(client_stats.path.congestion_events >= 3);\n    assert_eq!(client_stats.path.black_holes_detected, 1);\n}", "error": "Not Definition Found"}
