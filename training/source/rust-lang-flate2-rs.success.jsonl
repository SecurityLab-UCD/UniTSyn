{"test_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/tests/empty-read.rs::deflate_decoder_empty_read", "test": "fn deflate_decoder_empty_read() {\n    let original: &[u8] = b\"Lorem ipsum dolor sit amet.\";\n    let mut encoder =\n        flate2::write::DeflateEncoder::new(Vec::new(), flate2::Compression::default());\n    encoder.write_all(original).unwrap();\n    let encoded: Vec<u8> = encoder.finish().unwrap();\n    let mut decoder = flate2::read::DeflateDecoder::new(encoded.as_slice());\n    assert_eq!(decoder.read(&mut []).unwrap(), 0);\n    let mut decoded = Vec::new();\n    decoder.read_to_end(&mut decoded).unwrap();\n    assert_eq!(decoded.as_slice(), original);\n}", "code_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/src/bufreader.rs::read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }", "docstring": null}
{"test_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/tests/empty-read.rs::deflate_encoder_empty_read", "test": "fn deflate_encoder_empty_read() {\n    let original: &[u8] = b\"Lorem ipsum dolor sit amet.\";\n    let mut encoder = flate2::read::DeflateEncoder::new(original, flate2::Compression::default());\n    assert_eq!(encoder.read(&mut []).unwrap(), 0);\n    let mut encoded = Vec::new();\n    encoder.read_to_end(&mut encoded).unwrap();\n    let mut decoder = flate2::read::DeflateDecoder::new(encoded.as_slice());\n    let mut decoded = Vec::new();\n    decoder.read_to_end(&mut decoded).unwrap();\n    assert_eq!(decoded.as_slice(), original);\n}", "code_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/src/bufreader.rs::read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }", "docstring": null}
{"test_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/tests/empty-read.rs::gzip_decoder_empty_read", "test": "fn gzip_decoder_empty_read() {\n    let original: &[u8] = b\"Lorem ipsum dolor sit amet.\";\n    let mut encoder = flate2::write::GzEncoder::new(Vec::new(), flate2::Compression::default());\n    encoder.write_all(original).unwrap();\n    let encoded: Vec<u8> = encoder.finish().unwrap();\n    let mut decoder = flate2::read::GzDecoder::new(encoded.as_slice());\n    assert_eq!(decoder.read(&mut []).unwrap(), 0);\n    let mut decoded = Vec::new();\n    decoder.read_to_end(&mut decoded).unwrap();\n    assert_eq!(decoded.as_slice(), original);\n}", "code_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/src/bufreader.rs::read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }", "docstring": null}
{"test_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/tests/empty-read.rs::gzip_encoder_empty_read", "test": "fn gzip_encoder_empty_read() {\n    let original: &[u8] = b\"Lorem ipsum dolor sit amet.\";\n    let mut encoder = flate2::read::GzEncoder::new(original, flate2::Compression::default());\n    assert_eq!(encoder.read(&mut []).unwrap(), 0);\n    let mut encoded = Vec::new();\n    encoder.read_to_end(&mut encoded).unwrap();\n    let mut decoder = flate2::read::GzDecoder::new(encoded.as_slice());\n    let mut decoded = Vec::new();\n    decoder.read_to_end(&mut decoded).unwrap();\n    assert_eq!(decoded.as_slice(), original);\n}", "code_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/src/bufreader.rs::read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }", "docstring": null}
{"test_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/tests/empty-read.rs::zlib_decoder_empty_read", "test": "fn zlib_decoder_empty_read() {\n    let original: &[u8] = b\"Lorem ipsum dolor sit amet.\";\n    let mut encoder = flate2::write::ZlibEncoder::new(Vec::new(), flate2::Compression::default());\n    encoder.write_all(original).unwrap();\n    let encoded: Vec<u8> = encoder.finish().unwrap();\n    let mut decoder = flate2::read::ZlibDecoder::new(encoded.as_slice());\n    assert_eq!(decoder.read(&mut []).unwrap(), 0);\n    let mut decoded = Vec::new();\n    decoder.read_to_end(&mut decoded).unwrap();\n    assert_eq!(decoded.as_slice(), original);\n}", "code_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/src/bufreader.rs::read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }", "docstring": null}
{"test_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/tests/empty-read.rs::zlib_encoder_empty_read", "test": "fn zlib_encoder_empty_read() {\n    let original: &[u8] = b\"Lorem ipsum dolor sit amet.\";\n    let mut encoder = flate2::read::ZlibEncoder::new(original, flate2::Compression::default());\n    assert_eq!(encoder.read(&mut []).unwrap(), 0);\n    let mut encoded = Vec::new();\n    encoder.read_to_end(&mut encoded).unwrap();\n    let mut decoder = flate2::read::ZlibDecoder::new(encoded.as_slice());\n    let mut decoded = Vec::new();\n    decoder.read_to_end(&mut decoded).unwrap();\n    assert_eq!(decoded.as_slice(), original);\n}", "code_id": "rust-lang-flate2-rs/rust-lang-flate2-rs-649aaae/src/bufreader.rs::read", "code": "fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }", "docstring": null}
