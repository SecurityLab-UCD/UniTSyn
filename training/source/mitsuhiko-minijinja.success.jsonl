{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_compiler.rs::test_referenced_names_empty_bug", "test": "fn test_referenced_names_empty_bug() {\n    let c = CodeGenerator::new(\"<unknown>\", \"\");\n    let instructions = c.finish().0;\n    let rv = instructions.get_referenced_names(0);\n    assert!(rv.is_empty());\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/compiler/instructions.rs::is_empty", "code": "pub fn is_empty(&self) -> bool {\n        self.instructions.is_empty()\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_expression", "test": "fn test_expression() {\n    let env = Environment::new();\n    let expr = env.compile_expression(\"foo + bar\").unwrap();\n    let mut ctx = BTreeMap::new();\n    ctx.insert(\"foo\", 42);\n    ctx.insert(\"bar\", 23);\n    assert_eq!(expr.eval(&ctx).unwrap(), Value::from(65));\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/expression.rs::eval", "code": "pub fn eval<S: Serialize>(&self, ctx: S) -> Result<Value, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _eval.\n        self._eval(Value::from_serializable(&ctx))\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_clone", "test": "fn test_clone() {\n    let mut env = Environment::new();\n    env.add_template(\"test\", \"a\").unwrap();\n    let mut env2 = env.clone();\n    assert_eq!(env2.get_template(\"test\").unwrap().render(()).unwrap(), \"a\");\n    env2.add_template(\"test\", \"b\").unwrap();\n    assert_eq!(env2.get_template(\"test\").unwrap().render(()).unwrap(), \"b\");\n    assert_eq!(env.get_template(\"test\").unwrap().render(()).unwrap(), \"a\");\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-cli/src/repl.rs::render", "code": "fn render(env: &Environment, template: &str, ctx: &Value, locals: &BTreeMap<String, Value>) {\n    match env.render_str(\n        template,\n        context!(\n            ..Value::from_iter(locals.iter().map(|x| (x.0.clone(), x.1.clone()))),\n            ..ctx.clone()\n        ),\n    ) {\n        Ok(rv) => {\n            println!(\"{}\", rv);\n        }\n        Err(err) => print_error(&Error::from(err)),\n    }\n}", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_globals", "test": "fn test_globals() {\n    let mut env = Environment::new();\n    env.add_global(\"a\", Value::from(42));\n    env.add_template(\"test\", \"{{ a }}\").unwrap();\n    let tmpl = env.get_template(\"test\").unwrap();\n    assert_eq!(tmpl.render(()).unwrap(), \"42\");\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/template.rs::render", "code": "pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_environment.rs::test_keep_trailing_newlines", "test": "fn test_keep_trailing_newlines() {\n    let mut env = Environment::new();\n    env.add_template(\"foo.txt\", \"blub\\r\\n\").unwrap();\n    assert_eq!(env.render_str(\"blub\\r\\n\", ()).unwrap(), \"blub\");\n\n    env.set_keep_trailing_newline(true);\n    env.add_template(\"foo_keep.txt\", \"blub\\r\\n\").unwrap();\n    assert_eq!(\n        env.get_template(\"foo.txt\").unwrap().render(()).unwrap(),\n        \"blub\"\n    );\n    assert_eq!(\n        env.get_template(\"foo_keep.txt\")\n            .unwrap()\n            .render(())\n            .unwrap(),\n        \"blub\\r\\n\"\n    );\n    assert_eq!(env.render_str(\"blub\\r\\n\", ()).unwrap(), \"blub\\r\\n\");\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-py/src/environment.rs::render_str", "code": "pub fn render_str(\n        slf: PyRef<'_, Self>,\n        source: &str,\n        name: Option<&str>,\n        ctx: Option<&PyDict>,\n    ) -> PyResult<String> {\n        bind_environment(slf.as_ptr(), || {\n            let ctx = ctx\n                .map(|ctx| Value::from_struct_object(DictLikeObject { inner: ctx.into() }))\n                .unwrap_or_else(|| context!());\n            slf.inner\n                .lock()\n                .unwrap()\n                .env\n                .render_named_str(name.unwrap_or(\"<string>\"), source, ctx)\n                .map_err(to_py_error)\n        })\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_fuel.rs::test_basic", "test": "fn test_basic() {\n    let mut env = Environment::new();\n    assert_eq!(env.fuel(), None);\n    env.set_fuel(Some(100));\n    assert_eq!(env.fuel(), Some(100));\n    env.add_template(\"test\", \"{% for x in seq %}{{ x }}\\n{% endfor %}\")\n        .unwrap();\n    let t = env.get_template(\"test\").unwrap();\n\n    // this will still manage to run with 100 fuel\n    let rv = t\n        .render(context!(seq => (0..15).collect::<Vec<_>>()))\n        .unwrap();\n    assert_eq!(rv.lines().count(), 15);\n\n    // this is above the limit\n    let rv = t\n        .render(context!(seq => (0..20).collect::<Vec<_>>()))\n        .unwrap_err();\n    assert_eq!(rv.kind(), ErrorKind::OutOfFuel);\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/environment.rs::fuel", "code": "pub fn fuel(&self) -> Option<u64> {\n        self.fuel\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_fuel.rs::test_macro_fuel", "test": "fn test_macro_fuel() {\n    let mut env = Environment::new();\n    assert_eq!(env.fuel(), None);\n    env.set_fuel(Some(100));\n    assert_eq!(env.fuel(), Some(100));\n    env.add_template(\n        \"test\",\n        \"\n        {% macro x() %}{% for item in range(5) %}...{% endfor %}{% endmacro %}\n        {% for count in range(macros) %}{{ x() }}{% endfor %}\n    \",\n    )\n    .unwrap();\n    let t = env.get_template(\"test\").unwrap();\n\n    // this should succeed\n    t.render(context!(macros => 3)).unwrap();\n\n    // but running more macros should not\n    let err = t.render(context!(macros => 5)).unwrap_err();\n    assert_eq!(err.kind(), ErrorKind::OutOfFuel);\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/environment.rs::fuel", "code": "pub fn fuel(&self) -> Option<u64> {\n        self.fuel\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_loader.rs::test_basic", "test": "fn test_basic() {\n    let env = create_env();\n    let t = env.get_template(\"hello\").unwrap();\n    assert_eq!(t.render(()).unwrap(), \"Hello World!\");\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/template.rs::render", "code": "pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_loader.rs::test_dynamic", "test": "fn test_dynamic() {\n    let mut env = Environment::new();\n    let template = String::from(\"Hello World 2!\");\n    env.add_template_owned(\"hello2\", template).unwrap();\n    env.set_loader(|name| match name {\n        \"hello\" => Ok(Some(\"Hello World!\".into())),\n        _ => Ok(None),\n    });\n    let t = env.get_template(\"hello\").unwrap();\n    assert_eq!(t.render(()).unwrap(), \"Hello World!\");\n    let t = env.get_template(\"hello2\").unwrap();\n    assert_eq!(t.render(()).unwrap(), \"Hello World 2!\");\n    let err = env.get_template(\"missing\").unwrap_err();\n    assert_eq!(\n        err.to_string(),\n        \"template not found: template \\\"missing\\\" does not exist\"\n    );\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/template.rs::render", "code": "pub fn render<S: Serialize>(&self, ctx: S) -> Result<String, Error> {\n        // reduce total amount of code faling under mono morphization into\n        // this function, and share the rest in _render.\n        self._render(Value::from_serializable(&ctx)).map(|x| x.0)\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_context", "test": "fn test_context() {\n    let var1 = 23;\n    let ctx = context!(var1, var2 => 42);\n    assert_eq!(ctx.get_attr(\"var1\").unwrap(), Value::from(23));\n    assert_eq!(ctx.get_attr(\"var2\").unwrap(), Value::from(42));\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/value/mod.rs::get_attr", "code": "pub fn get_attr(&self, key: &str) -> Result<Value, Error> {\n        Ok(match self.0 {\n            ValueRepr::Undefined => return Err(Error::from(ErrorKind::UndefinedError)),\n            ValueRepr::Map(ref items, _) => items.get(&KeyRef::Str(key)).cloned(),\n            ValueRepr::Dynamic(ref dy) => match dy.kind() {\n                ObjectKind::Struct(s) => s.get_field(key),\n                ObjectKind::Plain | ObjectKind::Seq(_) => None,\n            },\n            _ => None,\n        }\n        .unwrap_or(Value::UNDEFINED))\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_context_merge", "test": "fn test_context_merge() {\n    let one = context!(a => 1);\n    let two = context!(b => 2, a => 42);\n    let ctx = context![..one, ..two];\n    assert_eq!(ctx.get_attr(\"a\").unwrap(), Value::from(1));\n    assert_eq!(ctx.get_attr(\"b\").unwrap(), Value::from(2));\n\n    let two = context!(b => 2, a => 42);\n    let ctx = context!(a => 1, ..two);\n    assert_eq!(ctx.get_attr(\"a\").unwrap(), Value::from(1));\n    assert_eq!(ctx.get_attr(\"b\").unwrap(), Value::from(2));\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/value/mod.rs::get_attr", "code": "pub fn get_attr(&self, key: &str) -> Result<Value, Error> {\n        Ok(match self.0 {\n            ValueRepr::Undefined => return Err(Error::from(ErrorKind::UndefinedError)),\n            ValueRepr::Map(ref items, _) => items.get(&KeyRef::Str(key)).cloned(),\n            ValueRepr::Dynamic(ref dy) => match dy.kind() {\n                ObjectKind::Struct(s) => s.get_field(key),\n                ObjectKind::Plain | ObjectKind::Seq(_) => None,\n            },\n            _ => None,\n        }\n        .unwrap_or(Value::UNDEFINED))\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_context_merge_custom", "test": "fn test_context_merge_custom() {\n    struct X;\n    impl StructObject for X {\n        fn get_field(&self, name: &str) -> Option<Value> {\n            match name {\n                \"a\" => Some(Value::from(1)),\n                \"b\" => Some(Value::from(2)),\n                _ => None,\n            }\n        }\n    }\n\n    let x = Value::from_struct_object(X);\n    let ctx = context! { a => 42, ..x };\n\n    assert_eq!(ctx.get_attr(\"a\").unwrap(), Value::from(42));\n    assert_eq!(ctx.get_attr(\"b\").unwrap(), Value::from(2));\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/value/mod.rs::get_attr", "code": "pub fn get_attr(&self, key: &str) -> Result<Value, Error> {\n        Ok(match self.0 {\n            ValueRepr::Undefined => return Err(Error::from(ErrorKind::UndefinedError)),\n            ValueRepr::Map(ref items, _) => items.get(&KeyRef::Str(key)).cloned(),\n            ValueRepr::Dynamic(ref dy) => match dy.kind() {\n                ObjectKind::Struct(s) => s.get_field(key),\n                ObjectKind::Plain | ObjectKind::Seq(_) => None,\n            },\n            _ => None,\n        }\n        .unwrap_or(Value::UNDEFINED))\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_args", "test": "fn test_args() {\n    fn type_name_of_val<T: ?Sized>(_val: &T) -> &str {\n        std::any::type_name::<T>()\n    }\n\n    let args = args!();\n    assert_eq!(args.len(), 0);\n    assert_eq!(type_name_of_val(args), \"[minijinja::value::Value]\");\n\n    let args = args!(1, 2);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n    assert_eq!(type_name_of_val(args), \"[minijinja::value::Value]\");\n\n    let args = args!(1, 2,);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n\n    let args = args!(1, 2, foo => 42, bar => 23);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n    let kwargs = Kwargs::try_from(args[2].clone()).unwrap();\n    assert_eq!(kwargs.get::<i32>(\"foo\").unwrap(), 42);\n    assert_eq!(kwargs.get::<i32>(\"bar\").unwrap(), 23);\n\n    let args = args!(1, 2, foo => 42, bar => 23,);\n    assert_eq!(args[0], Value::from(1));\n    assert_eq!(args[1], Value::from(2));\n    let kwargs = Kwargs::try_from(args[2].clone()).unwrap();\n    assert_eq!(kwargs.get::<i32>(\"foo\").unwrap(), 42);\n    assert_eq!(kwargs.get::<i32>(\"bar\").unwrap(), 23);\n    assert_eq!(type_name_of_val(args), \"[minijinja::value::Value]\");\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/value/mod.rs::len", "code": "pub fn len(&self) -> Option<usize> {\n        match self.0 {\n            ValueRepr::String(ref s, _) => Some(s.chars().count()),\n            ValueRepr::Map(ref items, _) => Some(items.len()),\n            ValueRepr::Seq(ref items) => Some(items.len()),\n            ValueRepr::Dynamic(ref dy) => match dy.kind() {\n                ObjectKind::Plain => None,\n                ObjectKind::Seq(s) => Some(s.item_count()),\n                ObjectKind::Struct(s) => Some(s.field_count()),\n            },\n            _ => None,\n        }\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_macro_passing", "test": "fn test_macro_passing() {\n    let env = Environment::new();\n    let tmpl = env\n        .template_from_str(\"{% macro m(a) %}{{ a }}{% endmacro %}\")\n        .unwrap();\n    let (_, state) = tmpl.render_and_return_state(()).unwrap();\n    let m = state.lookup(\"m\").unwrap();\n    assert_eq!(m.get_attr(\"name\").unwrap().as_str(), Some(\"m\"));\n    let rv = m.call(&state, args!(42)).unwrap();\n    assert_eq!(rv.as_str(), Some(\"42\"));\n\n    // if we call the macro on an empty state it errors\n    let empty_state = env.empty_state();\n    let err = m.call(&empty_state, args!(42)).unwrap_err();\n    assert_eq!(err.kind(), ErrorKind::InvalidOperation);\n    assert_eq!(\n        err.detail(),\n        Some(\"cannot call this macro. template state went away.\")\n    );\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/value/keyref.rs::as_str", "code": "pub fn as_str(&self) -> Option<&str> {\n        match self {\n            KeyRef::Value(v) => v.as_str(),\n            KeyRef::Str(s) => Some(s),\n        }\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_macros.rs::test_no_leak", "test": "fn test_no_leak() {\n    let dropped = Arc::new(AtomicBool::new(false));\n\n    struct X(Arc<AtomicBool>);\n\n    impl StructObject for X {\n        fn get_field(&self, _name: &str) -> Option<Value> {\n            None\n        }\n    }\n\n    impl Drop for X {\n        fn drop(&mut self) {\n            self.0.store(true, std::sync::atomic::Ordering::Relaxed);\n        }\n    }\n\n    let ctx = context! {\n        x => Value::from_struct_object(X(dropped.clone())),\n    };\n    let mut env = Environment::new();\n    env.add_template(\"x\", \"{% macro meh() %}{{ x }}{{ meh }}{% endmacro %}\")\n        .unwrap();\n    let rv = env\n        .render_str(\n            r#\"\n        {%- from 'x' import meh %}\n        {{- meh() }}\n        {%- set closure = x %}\n        {%- macro foo() %}{{ foo }}{{ closure }}{% endmacro %}\n        {{- foo() -}}\n\n        {%- for y in range(3) %}\n            {%- set closure = x %}\n            {%- macro foo() %}{{ foo }}{{ closure }}{% endmacro %}\n            {{- foo() -}}\n        {%- endfor -%}\n    \"#,\n            ctx,\n        )\n        .unwrap();\n\n    assert!(dropped.load(std::sync::atomic::Ordering::Relaxed));\n    assert_eq!(\n        rv,\n        \"{}<macro meh><macro foo>{}<macro foo>{}<macro foo>{}<macro foo>{}\"\n    );\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/vm/context.rs::load", "code": "pub fn load(&self, env: &Environment, key: &str) -> Option<Value> {\n        for frame in self.stack.iter().rev() {\n            // look at locals first\n            if let Some(value) = frame.locals.get(key) {\n                return Some(value.clone());\n            }\n\n            // if we are a loop, check if we are looking up the special loop var.\n            if let Some(ref l) = frame.current_loop {\n                if l.with_loop_var && key == \"loop\" {\n                    return Some(Value::from(l.object.clone()));\n                }\n            }\n\n            // perform a fast lookup.  This one will not produce errors if the\n            // context is undefined or of the wrong type.\n            if let Some(rv) = frame.ctx.get_attr_fast(key) {\n                return Some(rv);\n            }\n        }\n\n        env.get_global(key)\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_undefined.rs::test_lenient_undefined", "test": "fn test_lenient_undefined() {\n    let mut env = Environment::new();\n    env.add_filter(\"test\", |state: &State, value: String| -> String {\n        assert_eq!(state.undefined_behavior(), UndefinedBehavior::Lenient);\n        assert_eq!(value, \"\");\n        value\n    });\n\n    assert_eq!(env.undefined_behavior(), UndefinedBehavior::Lenient);\n    assert_eq!(render!(in env, \"<{{ true.missing_attribute }}>\"), \"<>\");\n    assert_eq!(\n        env.render_str(\"{{ undefined.missing_attribute }}\", ())\n            .unwrap_err()\n            .kind(),\n        ErrorKind::UndefinedError\n    );\n    assert_eq!(\n        render!(in env, \"<{% for x in undefined %}...{% endfor %}>\"),\n        \"<>\"\n    );\n    assert_eq!(render!(in env, \"<{{ undefined }}>\"), \"<>\");\n    assert_eq!(render!(in env, \"{{ undefined is undefined }}\"), \"true\");\n    assert_eq!(render!(in env, \"{{ undefined|list }}\"), \"[]\");\n    assert_eq!(render!(in env, \"<{{ undefined|test }}>\"), \"<>\");\n    assert_eq!(render!(in env, \"{{ 42 in undefined }}\"), \"false\");\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/vm/state.rs::undefined_behavior", "code": "pub fn undefined_behavior(&self) -> UndefinedBehavior {\n        self.env.undefined_behavior()\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_undefined.rs::test_strict_undefined", "test": "fn test_strict_undefined() {\n    let mut env = Environment::new();\n    env.set_undefined_behavior(UndefinedBehavior::Strict);\n    env.add_filter(\"test\", |_state: &State, _value: String| -> String {\n        panic!(\"filter must not be called\");\n    });\n\n    assert_eq!(\n        env.render_str(\"{{ true.missing_attribute }}\", ())\n            .unwrap_err()\n            .kind(),\n        ErrorKind::UndefinedError\n    );\n    assert_eq!(\n        env.render_str(\"{{ undefined.missing_attribute }}\", ())\n            .unwrap_err()\n            .kind(),\n        ErrorKind::UndefinedError\n    );\n    assert_eq!(\n        env.render_str(\"<{% for x in undefined %}...{% endfor %}>\", ())\n            .unwrap_err()\n            .kind(),\n        ErrorKind::UndefinedError\n    );\n    assert_eq!(\n        env.render_str(\"<{{ undefined }}>\", ()).unwrap_err().kind(),\n        ErrorKind::UndefinedError\n    );\n    assert_eq!(render!(in env, \"{{ undefined is undefined }}\"), \"true\");\n    assert_eq!(\n        env.render_str(\"{{ undefined|list }}\", ())\n            .unwrap_err()\n            .kind(),\n        ErrorKind::InvalidOperation\n    );\n    assert_eq!(\n        env.render_str(\"{{ undefined|test }}\", ())\n            .unwrap_err()\n            .kind(),\n        ErrorKind::UndefinedError\n    );\n    assert_eq!(\n        env.render_str(\"{{ 42 in undefined }}\", ())\n            .unwrap_err()\n            .kind(),\n        ErrorKind::UndefinedError\n    );\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja-py/src/typeconv.rs::kind", "code": "fn kind(&self) -> ObjectKind<'_> {\n        Python::with_gil(|py| {\n            let inner = self.inner.as_ref(py);\n            if inner.downcast::<PySequence>().is_ok() || self.sequencified.is_some() {\n                ObjectKind::Seq(self)\n            } else {\n                ObjectKind::Struct(self)\n            }\n        })\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_undefined.rs::test_chainable_undefined", "test": "fn test_chainable_undefined() {\n    let mut env = Environment::new();\n    env.set_undefined_behavior(UndefinedBehavior::Chainable);\n    env.add_filter(\"test\", |state: &State, value: String| -> String {\n        assert_eq!(state.undefined_behavior(), UndefinedBehavior::Chainable);\n        assert_eq!(value, \"\");\n        value\n    });\n\n    assert_eq!(render!(in env, \"<{{ true.missing_attribute }}>\"), \"<>\");\n    assert_eq!(render!(in env, \"<{{ undefined.missing_attribute }}>\"), \"<>\");\n    assert_eq!(\n        render!(in env, \"<{% for x in undefined %}...{% endfor %}>\"),\n        \"<>\"\n    );\n    assert_eq!(render!(in env, \"<{{ undefined }}>\"), \"<>\");\n    assert_eq!(render!(in env, \"{{ undefined is undefined }}\"), \"true\");\n    assert_eq!(render!(in env, \"{{ undefined|list }}\"), \"[]\");\n    assert_eq!(render!(in env, \"<{{ undefined|test }}>\"), \"<>\");\n    assert_eq!(render!(in env, \"{{ 42 in undefined }}\"), \"false\");\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/vm/state.rs::undefined_behavior", "code": "pub fn undefined_behavior(&self) -> UndefinedBehavior {\n        self.env.undefined_behavior()\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_safe_string_roundtrip", "test": "fn test_safe_string_roundtrip() {\n    let v = Value::from_safe_string(\"<b>HTML</b>\".into());\n    let v2 = Value::from_serializable(&v);\n    assert!(v.is_safe());\n    assert!(v2.is_safe());\n    assert_eq!(v.to_string(), v2.to_string());\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/value/mod.rs::is_safe", "code": "pub fn is_safe(&self) -> bool {\n        matches!(&self.0, ValueRepr::String(_, StringType::Safe))\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_undefined_roundtrip", "test": "fn test_undefined_roundtrip() {\n    let v = Value::UNDEFINED;\n    let v2 = Value::from_serializable(&v);\n    assert!(v.is_undefined());\n    assert!(v2.is_undefined());\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/value/mod.rs::is_undefined", "code": "pub fn is_undefined(&self) -> bool {\n        matches!(&self.0, ValueRepr::Undefined)\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_value_as_bytes", "test": "fn test_value_as_bytes() {\n    assert_eq!(Value::from(\"foo\").as_bytes(), Some(&b\"foo\"[..]));\n    assert_eq!(Value::from(&b\"foo\"[..]).as_bytes(), Some(&b\"foo\"[..]));\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/value/mod.rs::as_bytes", "code": "pub fn as_bytes(&self) -> Option<&[u8]> {\n        match &self.0 {\n            ValueRepr::String(ref s, _) => Some(s.as_bytes()),\n            ValueRepr::Bytes(ref b) => Some(&b[..]),\n            _ => None,\n        }\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_value_by_index", "test": "fn test_value_by_index() {\n    let val = Value::from(vec![1u32, 2, 3]);\n    assert_eq!(val.get_item_by_index(0).unwrap(), Value::from(1));\n    assert!(val.get_item_by_index(4).unwrap().is_undefined());\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/value/mod.rs::get_item_by_index", "code": "pub fn get_item_by_index(&self, idx: usize) -> Result<Value, Error> {\n        self.get_item(&Value(ValueRepr::U64(idx as _)))\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_value_object_interface", "test": "fn test_value_object_interface() {\n    let val = Value::from_seq_object(vec![1u32, 2, 3, 4]);\n    let seq = val.as_seq().unwrap();\n    assert_eq!(seq.item_count(), 4);\n\n    let obj = val.as_object().unwrap();\n    let seq2 = match obj.kind() {\n        ObjectKind::Seq(s) => s,\n        _ => panic!(\"did not expect this\"),\n    };\n    assert_eq!(seq2.item_count(), 4);\n    assert_eq!(obj.to_string(), \"[1, 2, 3, 4]\");\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/examples/dynamic-objects/src/main.rs::item_count", "code": "fn item_count(&self) -> usize {\n        4\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_kwargs_error", "test": "fn test_kwargs_error() {\n    let kwargs = Kwargs::from_iter([(\"foo\", Value::from(42))]);\n    let bar = kwargs.get::<Value>(\"bar\").unwrap_err();\n    assert_eq!(bar.detail(), Some(\"missing keyword argument 'bar'\"));\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/error.rs::detail", "code": "pub fn detail(&self) -> Option<&str> {\n        self.repr.detail.as_deref()\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_return_none", "test": "fn test_return_none() {\n    let env = Environment::empty();\n    let val = Value::from_function(|| -> Result<(), Error> { Ok(()) });\n    let rv = val.call(&env.empty_state(), &[][..]).unwrap();\n    assert!(rv.is_none());\n    let val = Value::from_function(|| ());\n    let rv = val.call(&env.empty_state(), &[][..]).unwrap();\n    assert!(rv.is_none());\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/tests.rs::is_none", "code": "pub fn is_none(v: Value) -> bool {\n    v.is_none()\n}", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_filter_basics", "test": "fn test_filter_basics() {\n    fn test(a: u32, b: u32) -> Result<u32, Error> {\n        Ok(a + b)\n    }\n\n    let mut env = Environment::new();\n    env.add_filter(\"test\", test);\n    assert_eq!(\n        env.empty_state()\n            .apply_filter(\"test\", args!(23, 42))\n            .unwrap(),\n        Value::from(65)\n    );\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/vm/state.rs::apply_filter", "code": "pub fn apply_filter(&self, filter: &str, args: &[Value]) -> Result<Value, Error> {\n        match self.env.get_filter(filter) {\n            Some(filter) => filter.apply_to(self, args),\n            None => Err(Error::from(ErrorKind::UnknownFilter)),\n        }\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_rest_args", "test": "fn test_rest_args() {\n    fn sum(val: u32, rest: Rest<u32>) -> u32 {\n        rest.iter().fold(val, |a, b| a + b)\n    }\n\n    let mut env = Environment::new();\n    env.add_filter(\"sum\", sum);\n    assert_eq!(\n        env.empty_state()\n            .apply_filter(\"sum\", args!(1, 2, 3, 4))\n            .unwrap(),\n        Value::from(1 + 2 + 3 + 4)\n    );\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/vm/state.rs::apply_filter", "code": "pub fn apply_filter(&self, filter: &str, args: &[Value]) -> Result<Value, Error> {\n        match self.env.get_filter(filter) {\n            Some(filter) => filter.apply_to(self, args),\n            None => Err(Error::from(ErrorKind::UnknownFilter)),\n        }\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_values_in_vec", "test": "fn test_values_in_vec() {\n    fn upper(value: &str) -> String {\n        value.to_uppercase()\n    }\n\n    fn sum(value: Vec<i64>) -> i64 {\n        value.into_iter().sum::<i64>()\n    }\n\n    let mut env = Environment::new();\n    env.add_filter(\"upper\", upper);\n    env.add_filter(\"sum\", sum);\n    let state = env.empty_state();\n\n    assert_eq!(\n        state.apply_filter(\"upper\", args!(\"Hello World!\")).unwrap(),\n        Value::from(\"HELLO WORLD!\")\n    );\n\n    assert_eq!(\n        state.apply_filter(\"sum\", args!(vec![1, 2])).unwrap(),\n        Value::from(3)\n    );\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/vm/state.rs::apply_filter", "code": "pub fn apply_filter(&self, filter: &str, args: &[Value]) -> Result<Value, Error> {\n        match self.env.get_filter(filter) {\n            Some(filter) => filter.apply_to(self, args),\n            None => Err(Error::from(ErrorKind::UnknownFilter)),\n        }\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_value.rs::test_seq_object_borrow", "test": "fn test_seq_object_borrow() {\n    fn connect(values: &dyn SeqObject) -> String {\n        let mut rv = String::new();\n        for item in values.iter() {\n            rv.push_str(&item.to_string())\n        }\n        rv\n    }\n\n    let mut env = Environment::new();\n    env.add_filter(\"connect\", connect);\n    let state = env.empty_state();\n    assert_eq!(\n        state\n            .apply_filter(\n                \"connect\",\n                args!(vec![Value::from(\"HELLO\"), Value::from(42)])\n            )\n            .unwrap(),\n        Value::from(\"HELLO42\")\n    );\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/vm/state.rs::apply_filter", "code": "pub fn apply_filter(&self, filter: &str, args: &[Value]) -> Result<Value, Error> {\n        match self.env.get_filter(filter) {\n            Some(filter) => filter.apply_to(self, args),\n            None => Err(Error::from(ErrorKind::UnknownFilter)),\n        }\n    }", "docstring": null}
{"test_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/tests/test_vm.rs::test_error_info", "test": "fn test_error_info() {\n    let mut c = CodeGenerator::new(\"hello.html\", \"\");\n    c.set_line(1);\n    c.add(Instruction::EmitRaw(\"<h1>Hello</h1>\\n\"));\n    c.set_line(2);\n    c.add(Instruction::Lookup(\"a_string\"));\n    c.add(Instruction::Lookup(\"an_int\"));\n    c.add(Instruction::Add);\n\n    let mut ctx = std::collections::BTreeMap::new();\n    ctx.insert(\"a_string\", Value::from(\"foo\"));\n    ctx.insert(\"an_int\", Value::from(42));\n\n    let err = simple_eval(&c.finish().0, ctx).unwrap_err();\n    assert_eq!(err.name(), Some(\"hello.html\"));\n    assert_eq!(err.line(), Some(2));\n}", "code_id": "mitsuhiko-minijinja/mitsuhiko-minijinja-5f2c1e8/minijinja/src/error.rs::name", "code": "pub fn name(&self) -> Option<&str> {\n        self.repr.name.as_deref()\n    }", "docstring": null}
