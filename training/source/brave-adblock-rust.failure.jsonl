{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/matching.rs::check_filter_matching", "test": "fn check_filter_matching() {\n    let requests = load_requests();\n\n    let mut requests_checked = 0;\n\n    assert!(requests.len() > 0, \"List of parsed request info is empty\");\n\n    let opts = ParseOptions::default();\n\n    for req in requests {\n        for filter in req.filters {\n            let network_filter_res = NetworkFilter::parse(&filter, true, opts);\n            assert!(\n                network_filter_res.is_ok(),\n                \"Could not parse filter {}\",\n                filter\n            );\n            let network_filter = network_filter_res.unwrap();\n\n            let request_res = Request::new(&req.url, &req.sourceUrl, &req.r#type);\n            // The dataset has cases where URL is set to just \"http://\" or \"https://\", which we do not support\n            if request_res.is_ok() {\n                let request = request_res.unwrap();\n                assert!(\n                    network_filter.matches(&request, &mut RegexManager::default()),\n                    \"Expected {} to match {} at {}, typed {}\",\n                    filter,\n                    req.url,\n                    req.sourceUrl,\n                    req.r#type\n                );\n                requests_checked += 1;\n            }\n        }\n    }\n\n    assert_eq!(requests_checked, 9354); // A catch for regressions\n}", "error": "Not Definition Found"}
{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/matching.rs::check_engine_matching", "test": "fn check_engine_matching() {\n    let requests = load_requests();\n\n    assert!(requests.len() > 0, \"List of parsed request info is empty\");\n\n    for req in requests {\n        if req.url == \"http://\" || req.url == \"https://\" {\n            continue;\n        }\n        for filter in req.filters {\n            let opts = ParseOptions::default();\n            let mut engine = Engine::from_rules_debug(&[filter.clone()], opts);\n            let resources = build_resources_from_filters(&[filter.clone()]);\n            engine.use_resources(resources);\n\n            let network_filter_res = NetworkFilter::parse(&filter, true, opts);\n            assert!(\n                network_filter_res.is_ok(),\n                \"Could not parse filter {}\",\n                filter\n            );\n            let network_filter = network_filter_res.unwrap();\n\n            let request = Request::new(&req.url, &req.sourceUrl, &req.r#type).unwrap();\n            let result = engine.check_network_request(&request);\n\n            if network_filter.is_exception() {\n                assert!(\n                    !result.matched,\n                    \"Expected {} to NOT match {} at {}, typed {}\",\n                    filter, req.url, req.sourceUrl, req.r#type\n                );\n                // assert!(result.exception.is_some(), \"Expected exception {} to match {} at {}, typed {}\", filter, req.url, req.sourceUrl, req.r#type);\n            } else {\n                assert!(\n                    result.matched,\n                    \"Expected {} to match {} at {}, typed {}\",\n                    filter, req.url, req.sourceUrl, req.r#type\n                );\n            }\n\n            if network_filter.is_redirect() {\n                assert!(\n                    result.redirect.is_some(),\n                    \"Expected {} to trigger redirect rule {}\",\n                    req.url,\n                    filter\n                );\n                let resource = result.redirect.unwrap();\n                // each redirect resource is base64 encoded\n                assert!(resource.contains(\"base64\"));\n            }\n        }\n    }\n}", "error": "Not Definition Found"}
{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/ublock-coverage.rs::check_matching_equivalent", "test": "fn check_matching_equivalent() {\n    let requests = load_requests();\n\n    assert!(requests.len() > 0, \"List of parsed request info is empty\");\n\n    let engine = get_blocker_engine();\n\n    let requests_len = requests.len() as u32;\n\n    let mut mismatch_expected_match = 0;\n    let mut mismatch_expected_exception = 0;\n    let mut mismatch_expected_pass = 0;\n    let mut false_negative_rules: HashMap<String, (String, String, String)> = HashMap::new();\n    let mut false_positive_rules: HashMap<String, (String, String, String)> = HashMap::new();\n    let mut false_negative_exceptions: HashMap<String, (String, String, String)> = HashMap::new();\n    for req in requests {\n        let request = Request::new(&req.url, &req.sourceUrl, &req.r#type).unwrap();\n        let checked = engine.check_network_request(&request);\n        if req.blocked == 1 && checked.matched != true {\n            mismatch_expected_match += 1;\n            req.filter.as_ref().map(|f| {\n                false_negative_rules.insert(\n                    f.clone(),\n                    (req.url.clone(), req.sourceUrl.clone(), req.r#type.clone()),\n                )\n            });\n            println!(\n                \"Expected match, uBo matched {} at {}, type {} ON {:?}\",\n                req.url, req.sourceUrl, req.r#type, req.filter\n            );\n        } else if req.blocked == 2 && checked.exception.is_none() {\n            mismatch_expected_exception += 1;\n            checked.filter.as_ref().map(|f| {\n                false_negative_exceptions.insert(\n                    f.clone(),\n                    (req.url.clone(), req.sourceUrl.clone(), req.r#type.clone()),\n                )\n            });\n            println!(\n                \"Expected exception to match for {} at {}, type {}, got rule match {:?}\",\n                req.url, req.sourceUrl, req.r#type, checked.filter\n            );\n        } else if req.blocked == 0 && checked.matched != false {\n            mismatch_expected_pass += 1;\n            checked.filter.as_ref().map(|f| {\n                false_positive_rules.insert(\n                    f.clone(),\n                    (req.url.clone(), req.sourceUrl.clone(), req.r#type.clone()),\n                )\n            });\n            println!(\n                \"Expected pass, matched {} at {}, type {} ON {:?}\",\n                req.url, req.sourceUrl, req.r#type, checked.filter\n            );\n        }\n    }\n\n    let mismatches = mismatch_expected_match + mismatch_expected_exception + mismatch_expected_pass;\n    let ratio = mismatches as f32 / requests_len as f32;\n    assert!(ratio < 0.01);\n    assert!(\n        false_positive_rules.len() < 3,\n        \"False positive rules higher than expected: {:?}\",\n        false_positive_rules\n    );\n    assert!(\n        false_negative_rules.len() < 3,\n        \"False negative rules higher than expected: {:?}\",\n        false_negative_rules\n    );\n    assert!(\n        false_negative_exceptions.len() < 3,\n        \"False negative exceptions higher than expected: {:?}\",\n        false_negative_exceptions\n    );\n}", "error": "Not Definition Found"}
{"test_id": "brave-adblock-rust/brave-adblock-rust-662d80c/tests/ublock-coverage.rs::check_matching_hostnames", "test": "fn check_matching_hostnames() {\n    // Makes sure that reuqests are handled with the same result whether parsed form full url or from pre-parsed hostname\n    let requests = load_requests();\n\n    assert!(requests.len() > 0, \"List of parsed request info is empty\");\n\n    let engine = get_blocker_engine();\n\n    for req in requests {\n        let url_host = adblock::url_parser::parse_url(&req.url).unwrap();\n        let source_host = adblock::url_parser::parse_url(&req.sourceUrl).unwrap();\n        let domain = url_host.domain();\n        let source_domain = source_host.domain();\n        let third_party = source_domain != domain;\n\n        let request = Request::new(&req.url, &req.sourceUrl, &req.r#type).unwrap();\n        let preparsed_request = Request::preparsed(&req.url, url_host.hostname(), source_host.hostname(), &req.r#type, third_party);\n\n        let checked = engine.check_network_request(&request);\n        let checked_hostnames = engine.check_network_request(&preparsed_request);\n\n        assert_eq!(checked.matched, checked_hostnames.matched);\n        assert_eq!(checked.filter, checked_hostnames.filter);\n        assert_eq!(checked.exception, checked_hostnames.exception);\n        assert_eq!(checked.redirect, checked_hostnames.redirect);\n    }\n}", "error": "Not Definition Found"}
