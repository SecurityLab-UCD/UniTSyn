{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_encode_nonfinite_float_yields_null", "test": "fn test_encode_nonfinite_float_yields_null() {\n    let v = to_value(::std::f64::NAN.copysign(1.0)).unwrap();\n    assert!(v.is_null());\n\n    let v = to_value(::std::f64::NAN.copysign(-1.0)).unwrap();\n    assert!(v.is_null());\n\n    let v = to_value(::std::f64::INFINITY).unwrap();\n    assert!(v.is_null());\n\n    let v = to_value(-::std::f64::INFINITY).unwrap();\n    assert!(v.is_null());\n\n    let v = to_value(::std::f32::NAN.copysign(1.0)).unwrap();\n    assert!(v.is_null());\n\n    let v = to_value(::std::f32::NAN.copysign(-1.0)).unwrap();\n    assert!(v.is_null());\n\n    let v = to_value(::std::f32::INFINITY).unwrap();\n    assert!(v.is_null());\n\n    let v = to_value(-::std::f32::INFINITY).unwrap();\n    assert!(v.is_null());\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_deserialize_number_to_untagged_enum", "test": "fn test_deserialize_number_to_untagged_enum() {\n    #[derive(Eq, PartialEq, Deserialize, Debug)]\n    #[serde(untagged)]\n    enum E {\n        N(i64),\n    }\n\n    assert_eq!(E::N(0), E::deserialize(Number::from(0)).unwrap());\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_parse_negative_zero", "test": "fn test_parse_negative_zero() {\n    for negative_zero in &[\n        \"-0\",\n        \"-0.0\",\n        \"-0e2\",\n        \"-0.0e2\",\n        \"-1e-400\",\n        \"-1e-4000000000000000000000000000000000000000000000000\",\n    ] {\n        assert!(\n            from_str::<f32>(negative_zero).unwrap().is_sign_negative(),\n            \"should have been negative: {:?}\",\n            negative_zero,\n        );\n        assert!(\n            from_str::<f64>(negative_zero).unwrap().is_sign_negative(),\n            \"should have been negative: {:?}\",\n            negative_zero,\n        );\n    }\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_value_as_f64", "test": "fn test_value_as_f64() {\n    let v = serde_json::from_str::<Value>(\"1e1000\");\n\n    #[cfg(not(feature = \"arbitrary_precision\"))]\n    assert!(v.is_err());\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    assert_eq!(v.unwrap().as_f64(), None);\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_raw_de_lone_surrogate", "test": "fn test_raw_de_lone_surrogate() {\n    use serde_json::value::RawValue;\n\n    assert!(from_str::<Box<RawValue>>(r#\"\"\\ud83c\"\"#).is_ok());\n    assert!(from_str::<Box<RawValue>>(r#\"\"\\ud83c\\n\"\"#).is_ok());\n    assert!(from_str::<Box<RawValue>>(r#\"\"\\ud83c \"\"#).is_ok());\n    assert!(from_str::<Box<RawValue>>(r#\"\"\\udc01 \"\"#).is_ok());\n    assert!(from_str::<Box<RawValue>>(r#\"\"\\udc01\\!\"\"#).is_err());\n    assert!(from_str::<Box<RawValue>>(r#\"\"\\udc01\\u\"\"#).is_err());\n    assert!(from_str::<Box<RawValue>>(r#\"\"\\ud83c\\ud83c\"\"#).is_ok());\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_json_pointer", "test": "fn test_json_pointer() {\n    // Test case taken from https://tools.ietf.org/html/rfc6901#page-5\n    let data: Value = from_str(\n        r#\"{\n        \"foo\": [\"bar\", \"baz\"],\n        \"\": 0,\n        \"a/b\": 1,\n        \"c%d\": 2,\n        \"e^f\": 3,\n        \"g|h\": 4,\n        \"i\\\\j\": 5,\n        \"k\\\"l\": 6,\n        \" \": 7,\n        \"m~n\": 8\n    }\"#,\n    )\n    .unwrap();\n    assert_eq!(data.pointer(\"\").unwrap(), &data);\n    assert_eq!(data.pointer(\"/foo\").unwrap(), &json!([\"bar\", \"baz\"]));\n    assert_eq!(data.pointer(\"/foo/0\").unwrap(), &json!(\"bar\"));\n    assert_eq!(data.pointer(\"/\").unwrap(), &json!(0));\n    assert_eq!(data.pointer(\"/a~1b\").unwrap(), &json!(1));\n    assert_eq!(data.pointer(\"/c%d\").unwrap(), &json!(2));\n    assert_eq!(data.pointer(\"/e^f\").unwrap(), &json!(3));\n    assert_eq!(data.pointer(\"/g|h\").unwrap(), &json!(4));\n    assert_eq!(data.pointer(\"/i\\\\j\").unwrap(), &json!(5));\n    assert_eq!(data.pointer(\"/k\\\"l\").unwrap(), &json!(6));\n    assert_eq!(data.pointer(\"/ \").unwrap(), &json!(7));\n    assert_eq!(data.pointer(\"/m~0n\").unwrap(), &json!(8));\n    // Invalid pointers\n    assert!(data.pointer(\"/unknown\").is_none());\n    assert!(data.pointer(\"/e^f/ertz\").is_none());\n    assert!(data.pointer(\"/foo/00\").is_none());\n    assert!(data.pointer(\"/foo/01\").is_none());\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_json_pointer_mut", "test": "fn test_json_pointer_mut() {\n    // Test case taken from https://tools.ietf.org/html/rfc6901#page-5\n    let mut data: Value = from_str(\n        r#\"{\n        \"foo\": [\"bar\", \"baz\"],\n        \"\": 0,\n        \"a/b\": 1,\n        \"c%d\": 2,\n        \"e^f\": 3,\n        \"g|h\": 4,\n        \"i\\\\j\": 5,\n        \"k\\\"l\": 6,\n        \" \": 7,\n        \"m~n\": 8\n    }\"#,\n    )\n    .unwrap();\n\n    // Basic pointer checks\n    assert_eq!(data.pointer_mut(\"/foo\").unwrap(), &json!([\"bar\", \"baz\"]));\n    assert_eq!(data.pointer_mut(\"/foo/0\").unwrap(), &json!(\"bar\"));\n    assert_eq!(data.pointer_mut(\"/\").unwrap(), 0);\n    assert_eq!(data.pointer_mut(\"/a~1b\").unwrap(), 1);\n    assert_eq!(data.pointer_mut(\"/c%d\").unwrap(), 2);\n    assert_eq!(data.pointer_mut(\"/e^f\").unwrap(), 3);\n    assert_eq!(data.pointer_mut(\"/g|h\").unwrap(), 4);\n    assert_eq!(data.pointer_mut(\"/i\\\\j\").unwrap(), 5);\n    assert_eq!(data.pointer_mut(\"/k\\\"l\").unwrap(), 6);\n    assert_eq!(data.pointer_mut(\"/ \").unwrap(), 7);\n    assert_eq!(data.pointer_mut(\"/m~0n\").unwrap(), 8);\n\n    // Invalid pointers\n    assert!(data.pointer_mut(\"/unknown\").is_none());\n    assert!(data.pointer_mut(\"/e^f/ertz\").is_none());\n    assert!(data.pointer_mut(\"/foo/00\").is_none());\n    assert!(data.pointer_mut(\"/foo/01\").is_none());\n\n    // Mutable pointer checks\n    *data.pointer_mut(\"/\").unwrap() = 100.into();\n    assert_eq!(data.pointer(\"/\").unwrap(), 100);\n    *data.pointer_mut(\"/foo/0\").unwrap() = json!(\"buzz\");\n    assert_eq!(data.pointer(\"/foo/0\").unwrap(), &json!(\"buzz\"));\n\n    // Example of ownership stealing\n    assert_eq!(\n        data.pointer_mut(\"/a~1b\")\n            .map(|m| mem::replace(m, json!(null)))\n            .unwrap(),\n        1\n    );\n    assert_eq!(data.pointer(\"/a~1b\").unwrap(), &json!(null));\n\n    // Need to compare against a clone so we don't anger the borrow checker\n    // by taking out two references to a mutable value\n    let mut d2 = data.clone();\n    assert_eq!(data.pointer_mut(\"\").unwrap(), &mut d2);\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_deny_non_finite_f32_key", "test": "fn test_deny_non_finite_f32_key() {\n    // We store float bits so that we can derive Ord, and other traits. In a\n    // real context the code might involve a crate like ordered-float.\n\n    #[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone)]\n    struct F32Bits(u32);\n    impl Serialize for F32Bits {\n        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n        where\n            S: Serializer,\n        {\n            serializer.serialize_f32(f32::from_bits(self.0))\n        }\n    }\n\n    let map = treemap!(F32Bits(f32::INFINITY.to_bits()) => \"x\".to_owned());\n    assert!(serde_json::to_string(&map).is_err());\n    assert!(serde_json::to_value(map).is_err());\n\n    let map = treemap!(F32Bits(f32::NEG_INFINITY.to_bits()) => \"x\".to_owned());\n    assert!(serde_json::to_string(&map).is_err());\n    assert!(serde_json::to_value(map).is_err());\n\n    let map = treemap!(F32Bits(f32::NAN.to_bits()) => \"x\".to_owned());\n    assert!(serde_json::to_string(&map).is_err());\n    assert!(serde_json::to_value(map).is_err());\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::test_deny_non_finite_f64_key", "test": "fn test_deny_non_finite_f64_key() {\n    // We store float bits so that we can derive Ord, and other traits. In a\n    // real context the code might involve a crate like ordered-float.\n\n    #[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone)]\n    struct F64Bits(u64);\n    impl Serialize for F64Bits {\n        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n        where\n            S: Serializer,\n        {\n            serializer.serialize_f64(f64::from_bits(self.0))\n        }\n    }\n\n    let map = treemap!(F64Bits(f64::INFINITY.to_bits()) => \"x\".to_owned());\n    assert!(serde_json::to_string(&map).is_err());\n    assert!(serde_json::to_value(map).is_err());\n\n    let map = treemap!(F64Bits(f64::NEG_INFINITY.to_bits()) => \"x\".to_owned());\n    assert!(serde_json::to_string(&map).is_err());\n    assert!(serde_json::to_value(map).is_err());\n\n    let map = treemap!(F64Bits(f64::NAN.to_bits()) => \"x\".to_owned());\n    assert!(serde_json::to_string(&map).is_err());\n    assert!(serde_json::to_value(map).is_err());\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::issue_220", "test": "fn issue_220() {\n    #[derive(Debug, PartialEq, Eq, Deserialize)]\n    enum E {\n        V(u8),\n    }\n\n    assert!(from_str::<E>(r#\" \"V\"0 \"#).is_err());\n\n    assert_eq!(from_str::<E>(r#\"{\"V\": 0}\"#).unwrap(), E::V(0));\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/test.rs::null_invalid_type", "test": "fn null_invalid_type() {\n    let err = serde_json::from_str::<String>(\"null\").unwrap_err();\n    assert_eq!(\n        format!(\"{}\", err),\n        String::from(\"invalid type: null, expected a string at line 1 column 4\")\n    );\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/algorithm.rs::float_fast_path_test", "test": "fn float_fast_path_test() {\n    // valid\n    let mantissa = (1 << f32::MANTISSA_SIZE) - 1;\n    let (min_exp, max_exp) = f32::exponent_limit();\n    for exp in min_exp..=max_exp {\n        let f = fast_path::<f32>(mantissa, exp);\n        assert!(f.is_some(), \"should be valid {:?}.\", (mantissa, exp));\n    }\n\n    // Check slightly above valid exponents\n    let f = fast_path::<f32>(123, 15);\n    assert_eq!(f, Some(1.23e+17));\n\n    // Exponent is 1 too high, pushes over the mantissa.\n    let f = fast_path::<f32>(123, 16);\n    assert!(f.is_none());\n\n    // Mantissa is too large, checked_mul should overflow.\n    let f = fast_path::<f32>(mantissa, 11);\n    assert!(f.is_none());\n\n    // invalid exponents\n    let (min_exp, max_exp) = f32::exponent_limit();\n    let f = fast_path::<f32>(mantissa, min_exp - 1);\n    assert!(f.is_none(), \"exponent under min_exp\");\n\n    let f = fast_path::<f32>(mantissa, max_exp + 1);\n    assert!(f.is_none(), \"exponent above max_exp\");\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/algorithm.rs::double_fast_path_test", "test": "fn double_fast_path_test() {\n    // valid\n    let mantissa = (1 << f64::MANTISSA_SIZE) - 1;\n    let (min_exp, max_exp) = f64::exponent_limit();\n    for exp in min_exp..=max_exp {\n        let f = fast_path::<f64>(mantissa, exp);\n        assert!(f.is_some(), \"should be valid {:?}.\", (mantissa, exp));\n    }\n\n    // invalid exponents\n    let (min_exp, max_exp) = f64::exponent_limit();\n    let f = fast_path::<f64>(mantissa, min_exp - 1);\n    assert!(f.is_none(), \"exponent under min_exp\");\n\n    let f = fast_path::<f64>(mantissa, max_exp + 1);\n    assert!(f.is_none(), \"exponent above max_exp\");\n\n    assert_eq!(\n        Some(0.04628372940652459),\n        fast_path::<f64>(4628372940652459, -17)\n    );\n    assert_eq!(None, fast_path::<f64>(26383446160308229, -272));\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/float.rs::to_f32_test", "test": "fn to_f32_test() {\n    // underflow\n    let x = ExtendedFloat {\n        mant: 9223372036854775808,\n        exp: -213,\n    };\n    assert_eq!(x.into_float::<f32>(), 0.0);\n\n    // min value\n    let x = ExtendedFloat {\n        mant: 9223372036854775808,\n        exp: -212,\n    };\n    assert_eq!(x.into_float::<f32>(), 1e-45);\n\n    // 1.0e-40\n    let x = ExtendedFloat {\n        mant: 10043308644012916736,\n        exp: -196,\n    };\n    assert_eq!(x.into_float::<f32>(), 1e-40);\n\n    // 1.0e-20\n    let x = ExtendedFloat {\n        mant: 13611294244890214400,\n        exp: -130,\n    };\n    assert_eq!(x.into_float::<f32>(), 1e-20);\n\n    // 1.0\n    let x = ExtendedFloat {\n        mant: 9223372036854775808,\n        exp: -63,\n    };\n    assert_eq!(x.into_float::<f32>(), 1.0);\n\n    // 1e20\n    let x = ExtendedFloat {\n        mant: 12500000250510966784,\n        exp: 3,\n    };\n    assert_eq!(x.into_float::<f32>(), 1e20);\n\n    // max value\n    let x = ExtendedFloat {\n        mant: 18446740775174668288,\n        exp: 64,\n    };\n    assert_eq!(x.into_float::<f32>(), 3.402823e38);\n\n    // almost max, high exp\n    let x = ExtendedFloat {\n        mant: 1048575,\n        exp: 108,\n    };\n    assert_eq!(x.into_float::<f32>(), 3.4028204e38);\n\n    // max value + 1\n    let x = ExtendedFloat {\n        mant: 16777216,\n        exp: 104,\n    };\n    assert_eq!(x.into_float::<f32>(), f32::INFINITY);\n\n    // max value + 1\n    let x = ExtendedFloat {\n        mant: 1048576,\n        exp: 108,\n    };\n    assert_eq!(x.into_float::<f32>(), f32::INFINITY);\n\n    // 1e40\n    let x = ExtendedFloat {\n        mant: 16940658945086007296,\n        exp: 69,\n    };\n    assert_eq!(x.into_float::<f32>(), f32::INFINITY);\n\n    // Integers.\n    for int in &INTEGERS {\n        let fp = ExtendedFloat { mant: *int, exp: 0 };\n        assert_eq!(fp.into_float::<f32>(), *int as f32, \"{:?} as f32\", *int);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/float.rs::to_f64_test", "test": "fn to_f64_test() {\n    // underflow\n    let x = ExtendedFloat {\n        mant: 9223372036854775808,\n        exp: -1138,\n    };\n    assert_eq!(x.into_float::<f64>(), 0.0);\n\n    // min value\n    let x = ExtendedFloat {\n        mant: 9223372036854775808,\n        exp: -1137,\n    };\n    assert_eq!(x.into_float::<f64>(), 5e-324);\n\n    // 1.0e-250\n    let x = ExtendedFloat {\n        mant: 13207363278391631872,\n        exp: -894,\n    };\n    assert_eq!(x.into_float::<f64>(), 1e-250);\n\n    // 1.0e-150\n    let x = ExtendedFloat {\n        mant: 15095849699286165504,\n        exp: -562,\n    };\n    assert_eq!(x.into_float::<f64>(), 1e-150);\n\n    // 1.0e-45\n    let x = ExtendedFloat {\n        mant: 13164036458569648128,\n        exp: -213,\n    };\n    assert_eq!(x.into_float::<f64>(), 1e-45);\n\n    // 1.0e-40\n    let x = ExtendedFloat {\n        mant: 10043362776618688512,\n        exp: -196,\n    };\n    assert_eq!(x.into_float::<f64>(), 1e-40);\n\n    // 1.0e-20\n    let x = ExtendedFloat {\n        mant: 13611294676837537792,\n        exp: -130,\n    };\n    assert_eq!(x.into_float::<f64>(), 1e-20);\n\n    // 1.0\n    let x = ExtendedFloat {\n        mant: 9223372036854775808,\n        exp: -63,\n    };\n    assert_eq!(x.into_float::<f64>(), 1.0);\n\n    // 1e20\n    let x = ExtendedFloat {\n        mant: 12500000000000000000,\n        exp: 3,\n    };\n    assert_eq!(x.into_float::<f64>(), 1e20);\n\n    // 1e40\n    let x = ExtendedFloat {\n        mant: 16940658945086007296,\n        exp: 69,\n    };\n    assert_eq!(x.into_float::<f64>(), 1e40);\n\n    // 1e150\n    let x = ExtendedFloat {\n        mant: 11270725851789228032,\n        exp: 435,\n    };\n    assert_eq!(x.into_float::<f64>(), 1e150);\n\n    // 1e250\n    let x = ExtendedFloat {\n        mant: 12882297539194265600,\n        exp: 767,\n    };\n    assert_eq!(x.into_float::<f64>(), 1e250);\n\n    // max value\n    let x = ExtendedFloat {\n        mant: 9007199254740991,\n        exp: 971,\n    };\n    assert_eq!(x.into_float::<f64>(), 1.7976931348623157e308);\n\n    // max value\n    let x = ExtendedFloat {\n        mant: 18446744073709549568,\n        exp: 960,\n    };\n    assert_eq!(x.into_float::<f64>(), 1.7976931348623157e308);\n\n    // overflow\n    let x = ExtendedFloat {\n        mant: 9007199254740992,\n        exp: 971,\n    };\n    assert_eq!(x.into_float::<f64>(), f64::INFINITY);\n\n    // overflow\n    let x = ExtendedFloat {\n        mant: 18446744073709549568,\n        exp: 961,\n    };\n    assert_eq!(x.into_float::<f64>(), f64::INFINITY);\n\n    // Underflow\n    // Adapted from failures in strtod.\n    let x = ExtendedFloat {\n        exp: -1139,\n        mant: 18446744073709550712,\n    };\n    assert_eq!(x.into_float::<f64>(), 0.0);\n\n    let x = ExtendedFloat {\n        exp: -1139,\n        mant: 18446744073709551460,\n    };\n    assert_eq!(x.into_float::<f64>(), 0.0);\n\n    let x = ExtendedFloat {\n        exp: -1138,\n        mant: 9223372036854776103,\n    };\n    assert_eq!(x.into_float::<f64>(), 5e-324);\n\n    // Integers.\n    for int in &INTEGERS {\n        let fp = ExtendedFloat { mant: *int, exp: 0 };\n        assert_eq!(fp.into_float::<f64>(), *int as f64, \"{:?} as f64\", *int);\n    }\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/float.rs::mul_test", "test": "fn mul_test() {\n    // Normalized (64-bit mantissa)\n    let a = ExtendedFloat {\n        mant: 13164036458569648128,\n        exp: -213,\n    };\n    let b = ExtendedFloat {\n        mant: 9223372036854775808,\n        exp: -62,\n    };\n    let c = ExtendedFloat {\n        mant: 6582018229284824064,\n        exp: -211,\n    };\n    check_mul(a, b, c);\n\n    // Check with integers\n    // 64-bit mantissa\n    let mut a = ExtendedFloat { mant: 10, exp: 0 };\n    let mut b = ExtendedFloat { mant: 10, exp: 0 };\n    a.normalize();\n    b.normalize();\n    assert_eq!(a.mul(&b).into_float::<f64>(), 100.0);\n\n    // Check both values need high bits set.\n    let a = ExtendedFloat {\n        mant: 1 << 32,\n        exp: -31,\n    };\n    let b = ExtendedFloat {\n        mant: 1 << 32,\n        exp: -31,\n    };\n    assert_eq!(a.mul(&b).into_float::<f64>(), 4.0);\n\n    // Check both values need high bits set.\n    let a = ExtendedFloat {\n        mant: 10 << 31,\n        exp: -31,\n    };\n    let b = ExtendedFloat {\n        mant: 10 << 31,\n        exp: -31,\n    };\n    assert_eq!(a.mul(&b).into_float::<f64>(), 100.0);\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/lexical/float.rs::imul_test", "test": "fn imul_test() {\n    // Normalized (64-bit mantissa)\n    let a = ExtendedFloat {\n        mant: 13164036458569648128,\n        exp: -213,\n    };\n    let b = ExtendedFloat {\n        mant: 9223372036854775808,\n        exp: -62,\n    };\n    let c = ExtendedFloat {\n        mant: 6582018229284824064,\n        exp: -211,\n    };\n    check_imul(a, b, c);\n\n    // Check with integers\n    // 64-bit mantissa\n    let mut a = ExtendedFloat { mant: 10, exp: 0 };\n    let mut b = ExtendedFloat { mant: 10, exp: 0 };\n    a.normalize();\n    b.normalize();\n    a.imul(&b);\n    assert_eq!(a.into_float::<f64>(), 100.0);\n\n    // Check both values need high bits set.\n    let mut a = ExtendedFloat {\n        mant: 1 << 32,\n        exp: -31,\n    };\n    let b = ExtendedFloat {\n        mant: 1 << 32,\n        exp: -31,\n    };\n    a.imul(&b);\n    assert_eq!(a.into_float::<f64>(), 4.0);\n\n    // Check both values need high bits set.\n    let mut a = ExtendedFloat {\n        mant: 10 << 31,\n        exp: -31,\n    };\n    let b = ExtendedFloat {\n        mant: 10 << 31,\n        exp: -31,\n    };\n    a.imul(&b);\n    assert_eq!(a.into_float::<f64>(), 100.0);\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/regression/issue795.rs::test", "test": "fn test() {\n    let s = r#\" {\"Variant\":{\"x\":0,\"y\":0}} \"#;\n    assert!(serde_json::from_str::<Enum>(s).is_err());\n\n    let j = json!({\"Variant\":{\"x\":0,\"y\":0}});\n    assert!(serde_json::from_value::<Enum>(j).is_err());\n}", "error": "Not Definition Found"}
{"test_id": "serde-rs-json/serde-rs-json-66f862f/tests/regression/issue953.rs::test", "test": "fn test() {\n    let x1 = serde_json::from_str::<Value>(\"18446744073709551615.\");\n    assert!(x1.is_err());\n    let x2 = serde_json::from_str::<Value>(\"18446744073709551616.\");\n    assert!(x2.is_err());\n}", "error": "Not Definition Found"}
