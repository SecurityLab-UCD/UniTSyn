{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/filetests/src/match_directive.rs::test_match_directive", "test": "fn test_match_directive() {\n    assert_eq!(match_directive(\"; foo: bar  \", \"foo:\"), Some(\"bar\"));\n    assert_eq!(match_directive(\" foo:bar\", \"foo:\"), Some(\"bar\"));\n    assert_eq!(match_directive(\"foo:bar\", \"foo:\"), Some(\"bar\"));\n    assert_eq!(match_directive(\";x foo: bar\", \"foo:\"), None);\n    assert_eq!(match_directive(\";;; foo: bar\", \"foo:\"), Some(\"bar\"));\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/filetests/src/match_directive.rs::match_directive", "code": "pub fn match_directive<'a>(comment: &'a str, directive: &str) -> Option<&'a str> {\n    assert!(\n        directive.ends_with(':'),\n        \"Directive must include trailing colon\"\n    );\n    let text = comment.trim_start_matches(';').trim_start();\n    if text.starts_with(directive) {\n        Some(text[directive.len()..].trim())\n    } else {\n        None\n    }\n}", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wiggle/tests/wasmtime_sync.rs::test_async_host_func_pending", "test": "fn test_async_host_func_pending() {\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    atoms::add_to_linker(&mut linker, |cx| cx).unwrap();\n    let mut store = store(&engine);\n\n    let shim_mod = shim_module(&engine);\n    let shim_inst = linker.instantiate(&mut store, &shim_mod).unwrap();\n\n    let result_location: i32 = 0;\n\n    // This input triggers the host func pending forever\n    let input: i32 = TRIGGER_PENDING as i32;\n    let trap = shim_inst\n        .get_func(&mut store, \"double_int_return_float_shim\")\n        .unwrap()\n        .call(\n            &mut store,\n            &[input.into(), result_location.into()],\n            &mut [Val::I32(0)],\n        )\n        .unwrap_err();\n    assert!(\n        format!(\"{:?}\", trap).contains(\"Cannot wait on pending future\"),\n        \"expected get a pending future Trap from dummy executor, got: {}\",\n        trap\n    );\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::call_wrapped_async_func", "test": "async fn call_wrapped_async_func() -> Result<(), Error> {\n    let mut config = Config::new();\n    config.async_support(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook(State::call_hook);\n    let f = Func::wrap4_async(\n        &mut store,\n        |caller: Caller<State>, a: i32, b: i64, c: f32, d: f64| {\n            Box::new(async move {\n                // Calling this func will switch context into wasm, then back to host:\n                assert_eq!(caller.data().context, vec![Context::Wasm, Context::Host]);\n\n                assert_eq!(\n                    caller.data().calls_into_host,\n                    caller.data().returns_from_host + 1\n                );\n                assert_eq!(\n                    caller.data().calls_into_wasm,\n                    caller.data().returns_from_wasm + 1\n                );\n\n                assert_eq!(a, 1);\n                assert_eq!(b, 2);\n                assert_eq!(c, 3.0);\n                assert_eq!(d, 4.0);\n            })\n        },\n    );\n\n    f.call_async(\n        &mut store,\n        &[Val::I32(1), Val::I64(2), 3.0f32.into(), 4.0f64.into()],\n        &mut [],\n    )\n    .await?;\n\n    // One switch from vm to host to call f, another in return from f.\n    assert_eq!(store.data().calls_into_host, 1);\n    assert_eq!(store.data().returns_from_host, 1);\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().returns_from_wasm, 1);\n\n    f.typed::<(i32, i64, f32, f64), ()>(&store)?\n        .call_async(&mut store, (1, 2, 3.0, 4.0))\n        .await?;\n\n    assert_eq!(store.data().calls_into_host, 2);\n    assert_eq!(store.data().returns_from_host, 2);\n    assert_eq!(store.data().calls_into_wasm, 2);\n    assert_eq!(store.data().returns_from_wasm, 2);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::data", "code": "pub fn data(&self) -> &[u8] {\n        // N.B.: we emit every section into the .text section as far as\n        // the `CodeSink` is concerned; we do not bother to segregate\n        // the contents into the actual program text, the jumptable and the\n        // rodata (constant pool). This allows us to generate code assuming\n        // that these will not be relocated relative to each other, and avoids\n        // having to designate each section as belonging in one of the three\n        // fixed categories defined by `CodeSink`. If this becomes a problem\n        // later (e.g. because of memory permissions or similar), we can\n        // add this designation and segregate the output; take care, however,\n        // to add the appropriate relocations in this case.\n\n        &self.data[..]\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::call_linked_func", "test": "fn call_linked_func() -> Result<(), Error> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook(State::call_hook);\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\n        \"host\",\n        \"f\",\n        |caller: Caller<State>, a: i32, b: i64, c: f32, d: f64| {\n            // Calling this func will switch context into wasm, then back to host:\n            assert_eq!(caller.data().context, vec![Context::Wasm, Context::Host]);\n\n            assert_eq!(\n                caller.data().calls_into_host,\n                caller.data().returns_from_host + 1\n            );\n            assert_eq!(\n                caller.data().calls_into_wasm,\n                caller.data().returns_from_wasm + 1\n            );\n\n            assert_eq!(a, 1);\n            assert_eq!(b, 2);\n            assert_eq!(c, 3.0);\n            assert_eq!(d, 4.0);\n        },\n    )?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32) (param i64) (param f32) (param f64)))\n            (func (export \"export\")\n                (call $f (i32.const 1) (i64.const 2) (f32.const 3.0) (f64.const 4.0)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let inst = linker.instantiate(&mut store, &module)?;\n    let export = inst\n        .get_export(&mut store, \"export\")\n        .expect(\"get export\")\n        .into_func()\n        .expect(\"export is func\");\n\n    export.call(&mut store, &[], &mut [])?;\n\n    // One switch from vm to host to call f, another in return from f.\n    assert_eq!(store.data().calls_into_host, 1);\n    assert_eq!(store.data().returns_from_host, 1);\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().returns_from_wasm, 1);\n\n    export.typed::<(), ()>(&store)?.call(&mut store, ())?;\n\n    assert_eq!(store.data().calls_into_host, 2);\n    assert_eq!(store.data().returns_from_host, 2);\n    assert_eq!(store.data().calls_into_wasm, 2);\n    assert_eq!(store.data().returns_from_wasm, 2);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::data", "code": "pub fn data(&self) -> &[u8] {\n        // N.B.: we emit every section into the .text section as far as\n        // the `CodeSink` is concerned; we do not bother to segregate\n        // the contents into the actual program text, the jumptable and the\n        // rodata (constant pool). This allows us to generate code assuming\n        // that these will not be relocated relative to each other, and avoids\n        // having to designate each section as belonging in one of the three\n        // fixed categories defined by `CodeSink`. If this becomes a problem\n        // later (e.g. because of memory permissions or similar), we can\n        // add this designation and segregate the output; take care, however,\n        // to add the appropriate relocations in this case.\n\n        &self.data[..]\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::call_linked_func_async", "test": "async fn call_linked_func_async() -> Result<(), Error> {\n    let mut config = Config::new();\n    config.async_support(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook(State::call_hook);\n\n    let f = Func::wrap4_async(\n        &mut store,\n        |caller: Caller<State>, a: i32, b: i64, c: f32, d: f64| {\n            Box::new(async move {\n                // Calling this func will switch context into wasm, then back to host:\n                assert_eq!(caller.data().context, vec![Context::Wasm, Context::Host]);\n\n                assert_eq!(\n                    caller.data().calls_into_host,\n                    caller.data().returns_from_host + 1\n                );\n                assert_eq!(\n                    caller.data().calls_into_wasm,\n                    caller.data().returns_from_wasm + 1\n                );\n                assert_eq!(a, 1);\n                assert_eq!(b, 2);\n                assert_eq!(c, 3.0);\n                assert_eq!(d, 4.0);\n            })\n        },\n    );\n\n    let mut linker = Linker::new(&engine);\n\n    linker.define(&mut store, \"host\", \"f\", f)?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32) (param i64) (param f32) (param f64)))\n            (func (export \"export\")\n                (call $f (i32.const 1) (i64.const 2) (f32.const 3.0) (f64.const 4.0)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let inst = linker.instantiate_async(&mut store, &module).await?;\n    let export = inst\n        .get_export(&mut store, \"export\")\n        .expect(\"get export\")\n        .into_func()\n        .expect(\"export is func\");\n\n    export.call_async(&mut store, &[], &mut []).await?;\n\n    // One switch from vm to host to call f, another in return from f.\n    assert_eq!(store.data().calls_into_host, 1);\n    assert_eq!(store.data().returns_from_host, 1);\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().returns_from_wasm, 1);\n\n    export\n        .typed::<(), ()>(&store)?\n        .call_async(&mut store, ())\n        .await?;\n\n    assert_eq!(store.data().calls_into_host, 2);\n    assert_eq!(store.data().returns_from_host, 2);\n    assert_eq!(store.data().calls_into_wasm, 2);\n    assert_eq!(store.data().returns_from_wasm, 2);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::data", "code": "pub fn data(&self) -> &[u8] {\n        // N.B.: we emit every section into the .text section as far as\n        // the `CodeSink` is concerned; we do not bother to segregate\n        // the contents into the actual program text, the jumptable and the\n        // rodata (constant pool). This allows us to generate code assuming\n        // that these will not be relocated relative to each other, and avoids\n        // having to designate each section as belonging in one of the three\n        // fixed categories defined by `CodeSink`. If this becomes a problem\n        // later (e.g. because of memory permissions or similar), we can\n        // add this designation and segregate the output; take care, however,\n        // to add the appropriate relocations in this case.\n\n        &self.data[..]\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::instantiate", "test": "fn instantiate() -> Result<(), Error> {\n    let mut store = Store::<State>::default();\n    store.call_hook(State::call_hook);\n\n    let m = Module::new(store.engine(), \"(module)\")?;\n    Instance::new(&mut store, &m, &[])?;\n    assert_eq!(store.data().calls_into_wasm, 0);\n    assert_eq!(store.data().calls_into_host, 0);\n\n    let m = Module::new(store.engine(), \"(module (func) (start 0))\")?;\n    Instance::new(&mut store, &m, &[])?;\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().calls_into_host, 0);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::data", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::instantiate_async", "test": "async fn instantiate_async() -> Result<(), Error> {\n    let mut config = Config::new();\n    config.async_support(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook(State::call_hook);\n\n    let m = Module::new(store.engine(), \"(module)\")?;\n    Instance::new_async(&mut store, &m, &[]).await?;\n    assert_eq!(store.data().calls_into_wasm, 0);\n    assert_eq!(store.data().calls_into_host, 0);\n\n    let m = Module::new(store.engine(), \"(module (func) (start 0))\")?;\n    Instance::new_async(&mut store, &m, &[]).await?;\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().calls_into_host, 0);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::data", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::recursion", "test": "fn recursion() -> Result<(), Error> {\n    // Make sure call hook behaves reasonably when called recursively\n\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook(State::call_hook);\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\"host\", \"f\", |mut caller: Caller<State>, n: i32| {\n        assert_eq!(caller.data().context.last(), Some(&Context::Host));\n\n        assert_eq!(caller.data().calls_into_host, caller.data().calls_into_wasm);\n\n        // Recurse\n        if n > 0 {\n            caller\n                .get_export(\"export\")\n                .expect(\"caller exports \\\"export\\\"\")\n                .into_func()\n                .expect(\"export is a func\")\n                .typed::<i32, ()>(&caller)\n                .expect(\"export typing\")\n                .call(&mut caller, n - 1)\n                .unwrap()\n        }\n    })?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32)))\n            (func (export \"export\") (param i32)\n                (call $f (local.get 0)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let inst = linker.instantiate(&mut store, &module)?;\n    let export = inst\n        .get_export(&mut store, \"export\")\n        .expect(\"get export\")\n        .into_func()\n        .expect(\"export is func\");\n\n    // Recursion depth:\n    let n: usize = 10;\n\n    export.call(&mut store, &[Val::I32(n as i32)], &mut [])?;\n\n    // Recurse down to 0: n+1 calls\n    assert_eq!(store.data().calls_into_host, n + 1);\n    assert_eq!(store.data().returns_from_host, n + 1);\n    assert_eq!(store.data().calls_into_wasm, n + 1);\n    assert_eq!(store.data().returns_from_wasm, n + 1);\n\n    export\n        .typed::<i32, ()>(&store)?\n        .call(&mut store, n as i32)?;\n\n    assert_eq!(store.data().calls_into_host, 2 * (n + 1));\n    assert_eq!(store.data().returns_from_host, 2 * (n + 1));\n    assert_eq!(store.data().calls_into_wasm, 2 * (n + 1));\n    assert_eq!(store.data().returns_from_wasm, 2 * (n + 1));\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/boxed_slice.rs::last", "code": "pub fn last(&self) -> Option<&V> {\n        self.elems.last()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::trapping", "test": "fn trapping() -> Result<(), Error> {\n    const TRAP_IN_F: i32 = 0;\n    const TRAP_NEXT_CALL_HOST: i32 = 1;\n    const TRAP_NEXT_RETURN_HOST: i32 = 2;\n    const TRAP_NEXT_CALL_WASM: i32 = 3;\n    const TRAP_NEXT_RETURN_WASM: i32 = 4;\n\n    let engine = Engine::default();\n\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\n        \"host\",\n        \"f\",\n        |mut caller: Caller<State>, action: i32, recur: i32| -> Result<()> {\n            assert_eq!(caller.data().context.last(), Some(&Context::Host));\n            assert_eq!(caller.data().calls_into_host, caller.data().calls_into_wasm);\n\n            match action {\n                TRAP_IN_F => bail!(\"trapping in f\"),\n                TRAP_NEXT_CALL_HOST => caller.data_mut().trap_next_call_host = true,\n                TRAP_NEXT_RETURN_HOST => caller.data_mut().trap_next_return_host = true,\n                TRAP_NEXT_CALL_WASM => caller.data_mut().trap_next_call_wasm = true,\n                TRAP_NEXT_RETURN_WASM => caller.data_mut().trap_next_return_wasm = true,\n                _ => {} // Do nothing\n            }\n\n            // recur so that we can trigger a next call.\n            // propogate its trap, if it traps!\n            if recur > 0 {\n                let _ = caller\n                    .get_export(\"export\")\n                    .expect(\"caller exports \\\"export\\\"\")\n                    .into_func()\n                    .expect(\"export is a func\")\n                    .typed::<(i32, i32), ()>(&caller)\n                    .expect(\"export typing\")\n                    .call(&mut caller, (action, 0))?;\n            }\n\n            Ok(())\n        },\n    )?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32) (param i32)))\n            (func (export \"export\") (param i32) (param i32)\n                (call $f (local.get 0) (local.get 1)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let run = |action: i32, recur: bool| -> (State, Option<Error>) {\n        let mut store = Store::new(&engine, State::default());\n        store.call_hook(State::call_hook);\n        let inst = linker\n            .instantiate(&mut store, &module)\n            .expect(\"instantiate\");\n        let export = inst\n            .get_export(&mut store, \"export\")\n            .expect(\"get export\")\n            .into_func()\n            .expect(\"export is func\");\n\n        let r = export.call(\n            &mut store,\n            &[Val::I32(action), Val::I32(if recur { 1 } else { 0 })],\n            &mut [],\n        );\n        (store.into_data(), r.err())\n    };\n\n    let (s, e) = run(TRAP_IN_F, false);\n    assert!(format!(\"{:?}\", e.unwrap()).contains(\"trapping in f\"));\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 1);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    // trap in next call to host. No calls after the bit is set, so this trap shouldn't happen\n    let (s, e) = run(TRAP_NEXT_CALL_HOST, false);\n    assert!(e.is_none());\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 1);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    // trap in next call to host. recur, so the second call into host traps:\n    let (s, e) = run(TRAP_NEXT_CALL_HOST, true);\n    assert!(format!(\"{:?}\", e.unwrap()).contains(\"call_hook: trapping on CallingHost\"));\n    assert_eq!(s.calls_into_host, 2);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 2);\n    assert_eq!(s.returns_from_wasm, 2);\n\n    // trap in the return from host. should trap right away, without recursion\n    let (s, e) = run(TRAP_NEXT_RETURN_HOST, false);\n    assert!(format!(\"{:?}\", e.unwrap()).contains(\"call_hook: trapping on ReturningFromHost\"));\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 1);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    // trap in next call to wasm. No calls after the bit is set, so this trap shouldnt happen:\n    let (s, e) = run(TRAP_NEXT_CALL_WASM, false);\n    assert!(e.is_none());\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 1);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    // trap in next call to wasm. recur, so the second call into wasm traps:\n    let (s, e) = run(TRAP_NEXT_CALL_WASM, true);\n    assert!(format!(\"{:?}\", e.unwrap()).contains(\"call_hook: trapping on CallingWasm\"));\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 2);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    // trap in the return from wasm. should trap right away, without recursion\n    let (s, e) = run(TRAP_NEXT_RETURN_WASM, false);\n    assert!(format!(\"{:?}\", e.unwrap()).contains(\"call_hook: trapping on ReturningFromWasm\"));\n    assert_eq!(s.calls_into_host, 1);\n    assert_eq!(s.returns_from_host, 1);\n    assert_eq!(s.calls_into_wasm, 1);\n    assert_eq!(s.returns_from_wasm, 1);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/boxed_slice.rs::last", "code": "pub fn last(&self) -> Option<&V> {\n        self.elems.last()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::basic_async_hook", "test": "async fn basic_async_hook() -> Result<(), Error> {\n    struct HandlerR;\n\n    #[async_trait::async_trait]\n    impl CallHookHandler<State> for HandlerR {\n        async fn handle_call_event(&self, obj: &mut State, ch: CallHook) -> Result<()> {\n            State::call_hook(obj, ch)\n        }\n    }\n    let mut config = Config::new();\n    config.async_support(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook_async(HandlerR {});\n\n    assert_eq!(store.data().calls_into_host, 0);\n    assert_eq!(store.data().returns_from_host, 0);\n    assert_eq!(store.data().calls_into_wasm, 0);\n    assert_eq!(store.data().returns_from_wasm, 0);\n\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\n        \"host\",\n        \"f\",\n        |caller: Caller<State>, a: i32, b: i64, c: f32, d: f64| {\n            // Calling this func will switch context into wasm, then back to host:\n            assert_eq!(caller.data().context, vec![Context::Wasm, Context::Host]);\n\n            assert_eq!(\n                caller.data().calls_into_host,\n                caller.data().returns_from_host + 1\n            );\n            assert_eq!(\n                caller.data().calls_into_wasm,\n                caller.data().returns_from_wasm + 1\n            );\n\n            assert_eq!(a, 1);\n            assert_eq!(b, 2);\n            assert_eq!(c, 3.0);\n            assert_eq!(d, 4.0);\n        },\n    )?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32) (param i64) (param f32) (param f64)))\n            (func (export \"export\")\n                (call $f (i32.const 1) (i64.const 2) (f32.const 3.0) (f64.const 4.0)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let inst = linker.instantiate_async(&mut store, &module).await?;\n    let export = inst\n        .get_export(&mut store, \"export\")\n        .expect(\"get export\")\n        .into_func()\n        .expect(\"export is func\");\n\n    export.call_async(&mut store, &[], &mut []).await?;\n\n    // One switch from vm to host to call f, another in return from f.\n    assert_eq!(store.data().calls_into_host, 1);\n    assert_eq!(store.data().returns_from_host, 1);\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().returns_from_wasm, 1);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::data", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/call_hook.rs::timeout_async_hook", "test": "async fn timeout_async_hook() -> Result<(), Error> {\n    struct HandlerR;\n\n    #[async_trait::async_trait]\n    impl CallHookHandler<State> for HandlerR {\n        async fn handle_call_event(&self, obj: &mut State, ch: CallHook) -> Result<()> {\n            if obj.calls_into_host > 200 {\n                bail!(\"timeout\");\n            }\n\n            match ch {\n                CallHook::CallingHost => obj.calls_into_host += 1,\n                CallHook::CallingWasm => obj.calls_into_wasm += 1,\n                CallHook::ReturningFromHost => obj.returns_from_host += 1,\n                CallHook::ReturningFromWasm => obj.returns_from_wasm += 1,\n            }\n\n            Ok(())\n        }\n    }\n\n    let mut config = Config::new();\n    config.async_support(true);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, State::default());\n    store.call_hook_async(HandlerR {});\n\n    assert_eq!(store.data().calls_into_host, 0);\n    assert_eq!(store.data().returns_from_host, 0);\n    assert_eq!(store.data().calls_into_wasm, 0);\n    assert_eq!(store.data().returns_from_wasm, 0);\n\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\n        \"host\",\n        \"f\",\n        |_caller: Caller<State>, a: i32, b: i64, c: f32, d: f64| {\n            assert_eq!(a, 1);\n            assert_eq!(b, 2);\n            assert_eq!(c, 3.0);\n            assert_eq!(d, 4.0);\n        },\n    )?;\n\n    let wat = r#\"\n        (module\n            (import \"host\" \"f\"\n                (func $f (param i32) (param i64) (param f32) (param f64)))\n            (func (export \"export\")\n                (loop $start\n                    (call $f (i32.const 1) (i64.const 2) (f32.const 3.0) (f64.const 4.0))\n                    (br $start)))\n        )\n    \"#;\n    let module = Module::new(&engine, wat)?;\n\n    let inst = linker.instantiate_async(&mut store, &module).await?;\n    let export = inst\n        .get_typed_func::<(), ()>(&mut store, \"export\")\n        .expect(\"export is func\");\n\n    store.set_epoch_deadline(1);\n    store.epoch_deadline_async_yield_and_update(1);\n    assert!(export.call_async(&mut store, ()).await.is_err());\n\n    // One switch from vm to host to call f, another in return from f.\n    assert!(store.data().calls_into_host > 1);\n    assert!(store.data().returns_from_host > 1);\n    assert_eq!(store.data().calls_into_wasm, 1);\n    assert_eq!(store.data().returns_from_wasm, 0);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::data", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::run_coredump_smoketest", "test": "fn run_coredump_smoketest() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/coredump_smoketest.wat\")?;\n    let coredump_file = NamedTempFile::new()?;\n    let coredump_arg = format!(\"-Dcoredump={}\", coredump_file.path().display());\n    let err = run_wasmtime(&[\n        \"run\",\n        \"--invoke\",\n        \"a\",\n        \"-Ccache=n\",\n        &coredump_arg,\n        wasm.path().to_str().unwrap(),\n    ])\n    .unwrap_err();\n    assert!(err.to_string().contains(&format!(\n        \"core dumped at {}\",\n        coredump_file.path().display()\n    )));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::display", "code": "pub fn display<'a>(&'a self, params: Option<&'a FunctionParameters>) -> String {\n        match self {\n            FinalizedRelocTarget::ExternalName(name) => format!(\"{}\", name.display(params)),\n            FinalizedRelocTarget::Func(offset) => format!(\"func+{offset}\"),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::run_wasmtime_simple_wat", "test": "fn run_wasmtime_simple_wat() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/simple.wat\")?;\n    run_wasmtime(&[\n        \"run\",\n        \"--invoke\",\n        \"simple\",\n        \"-Ccache=n\",\n        wasm.path().to_str().unwrap(),\n        \"4\",\n    ])?;\n    assert_eq!(\n        run_wasmtime(&[\n            \"run\",\n            \"--invoke\",\n            \"get_f32\",\n            \"-Ccache=n\",\n            wasm.path().to_str().unwrap(),\n        ])?,\n        \"100\\n\"\n    );\n    assert_eq!(\n        run_wasmtime(&[\n            \"run\",\n            \"--invoke\",\n            \"get_f64\",\n            \"-Ccache=n\",\n            wasm.path().to_str().unwrap(),\n        ])?,\n        \"100\\n\"\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/component/func/typed.rs::to_str", "code": "pub fn to_str<'a, T: 'a>(&self, store: impl Into<StoreContext<'a, T>>) -> Result<Cow<'a, str>> {\n        let store = store.into().0;\n        let memory = self.options.memory(store);\n        self.to_str_from_memory(memory)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::timeout_in_start", "test": "fn timeout_in_start() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/iloop-start.wat\")?;\n    let output = run_wasmtime_for_output(\n        &[\n            \"run\",\n            \"-Wtimeout=1ms\",\n            \"-Ccache=n\",\n            wasm.path().to_str().unwrap(),\n        ],\n        None,\n    )?;\n    assert!(!output.status.success());\n    assert_eq!(output.stdout, b\"\");\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"wasm trap: interrupt\"),\n        \"bad stderr: {}\",\n        stderr\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-common/src/snapshots/preview_0.rs::success", "code": "fn success() -> Self {\n        Self::Success\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::timeout_in_invoke", "test": "fn timeout_in_invoke() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/iloop-invoke.wat\")?;\n    let output = run_wasmtime_for_output(\n        &[\n            \"run\",\n            \"-Wtimeout=1ms\",\n            \"-Ccache=n\",\n            wasm.path().to_str().unwrap(),\n        ],\n        None,\n    )?;\n    assert!(!output.status.success());\n    assert_eq!(output.stdout, b\"\");\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"wasm trap: interrupt\"),\n        \"bad stderr: {}\",\n        stderr\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-common/src/snapshots/preview_0.rs::success", "code": "fn success() -> Self {\n        Self::Success\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit2_wasi_snapshot0", "test": "fn exit2_wasi_snapshot0() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit2_wasi_snapshot0.wat\")?;\n    let output = run_wasmtime_for_output(&[\"-Ccache=n\", wasm.path().to_str().unwrap()], None)?;\n    assert_eq!(output.status.code().unwrap(), 2);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/module/registry.rs::code", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit2_wasi_snapshot1", "test": "fn exit2_wasi_snapshot1() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit2_wasi_snapshot1.wat\")?;\n    let output = run_wasmtime_for_output(&[\"-Ccache=n\", wasm.path().to_str().unwrap()], None)?;\n    assert_eq!(output.status.code().unwrap(), 2);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/module/registry.rs::code", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit125_wasi_snapshot0", "test": "fn exit125_wasi_snapshot0() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit125_wasi_snapshot0.wat\")?;\n    let output = run_wasmtime_for_output(&[\"-Ccache=n\", wasm.path().to_str().unwrap()], None)?;\n    if cfg!(windows) {\n        assert_eq!(output.status.code().unwrap(), 1);\n    } else {\n        assert_eq!(output.status.code().unwrap(), 125);\n    }\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/module/registry.rs::code", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit125_wasi_snapshot1", "test": "fn exit125_wasi_snapshot1() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit125_wasi_snapshot1.wat\")?;\n    let output = run_wasmtime_for_output(&[\"-Ccache=n\", wasm.path().to_str().unwrap()], None)?;\n    if cfg!(windows) {\n        assert_eq!(output.status.code().unwrap(), 1);\n    } else {\n        assert_eq!(output.status.code().unwrap(), 125);\n    }\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/module/registry.rs::code", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit126_wasi_snapshot0", "test": "fn exit126_wasi_snapshot0() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit126_wasi_snapshot0.wat\")?;\n    let output = run_wasmtime_for_output(&[\"-Ccache=n\", wasm.path().to_str().unwrap()], None)?;\n    assert_eq!(output.status.code().unwrap(), 1);\n    assert!(output.stdout.is_empty());\n    assert!(String::from_utf8_lossy(&output.stderr).contains(\"invalid exit status\"));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/module/registry.rs::code", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit126_wasi_snapshot1", "test": "fn exit126_wasi_snapshot1() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit126_wasi_snapshot1.wat\")?;\n    let output = run_wasmtime_for_output(&[wasm.path().to_str().unwrap(), \"-Ccache=n\"], None)?;\n    assert_eq!(output.status.code().unwrap(), 1);\n    assert!(output.stdout.is_empty());\n    assert!(String::from_utf8_lossy(&output.stderr).contains(\"invalid exit status\"));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/module/registry.rs::code", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::exit_with_saved_fprs", "test": "fn exit_with_saved_fprs() -> Result<()> {\n    let wasm = build_wasm(\"tests/all/cli_tests/exit_with_saved_fprs.wat\")?;\n    let output = run_wasmtime_for_output(&[\"-Ccache=n\", wasm.path().to_str().unwrap()], None)?;\n    assert_eq!(output.status.code().unwrap(), 0);\n    assert!(output.stdout.is_empty());\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/module/registry.rs::code", "code": "fn code(&self, pc: usize) -> Option<(&LoadedCode, usize)> {\n        let (end, (start, code)) = self.loaded_code.range(pc..).next()?;\n        if pc < *start || *end < pc {\n            return None;\n        }\n        Some((code, pc - *start))\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::specify_env", "test": "fn specify_env() -> Result<()> {\n    // By default no env is inherited\n    let output = get_wasmtime_command()?\n        .args(&[\"run\", \"tests/all/cli_tests/print_env.wat\"])\n        .env(\"THIS_WILL_NOT\", \"show up in the output\")\n        .output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n\n    // Specify a single env var\n    let output = get_wasmtime_command()?\n        .args(&[\n            \"run\",\n            \"--env\",\n            \"FOO=bar\",\n            \"tests/all/cli_tests/print_env.wat\",\n        ])\n        .output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"FOO=bar\\n\");\n\n    // Inherit a single env var\n    let output = get_wasmtime_command()?\n        .args(&[\"run\", \"--env\", \"FOO\", \"tests/all/cli_tests/print_env.wat\"])\n        .env(\"FOO\", \"bar\")\n        .output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"FOO=bar\\n\");\n\n    // Inherit a nonexistent env var\n    let output = get_wasmtime_command()?\n        .args(&[\n            \"run\",\n            \"--env\",\n            \"SURELY_THIS_ENV_VAR_DOES_NOT_EXIST_ANYWHERE_RIGHT\",\n            \"tests/all/cli_tests/print_env.wat\",\n        ])\n        .output()?;\n    assert!(!output.status.success());\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-common/src/snapshots/preview_0.rs::success", "code": "fn success() -> Self {\n        Self::Success\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::name_same_as_builtin_command", "test": "fn name_same_as_builtin_command() -> Result<()> {\n    // a bare subcommand shouldn't run successfully\n    let output = get_wasmtime_command()?\n        .current_dir(\"tests/all/cli_tests\")\n        .arg(\"run\")\n        .output()?;\n    assert!(!output.status.success());\n\n    // a `--` prefix should let everything else get interpreted as a wasm\n    // module and arguments, even if the module has a name like `run`\n    let output = get_wasmtime_command()?\n        .current_dir(\"tests/all/cli_tests\")\n        .arg(\"--\")\n        .arg(\"run\")\n        .output()?;\n    assert!(output.status.success(), \"expected success got {output:#?}\");\n\n    // Passing options before the subcommand should work and doesn't require\n    // `--` to disambiguate\n    let output = get_wasmtime_command()?\n        .current_dir(\"tests/all/cli_tests\")\n        .arg(\"-Ccache=n\")\n        .arg(\"run\")\n        .output()?;\n    assert!(output.status.success(), \"expected success got {output:#?}\");\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-common/src/snapshots/preview_0.rs::success", "code": "fn success() -> Self {\n        Self::Success\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::wasm_flags_without_subcommand", "test": "fn wasm_flags_without_subcommand() -> Result<()> {\n    let output = get_wasmtime_command()?\n        .current_dir(\"tests/all/cli_tests/\")\n        .arg(\"print-arguments.wat\")\n        .arg(\"-foo\")\n        .arg(\"bar\")\n        .output()?;\n    assert!(output.status.success());\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        \"\\\n            print-arguments.wat\\n\\\n            -foo\\n\\\n            bar\\n\\\n        \"\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-common/src/snapshots/preview_0.rs::success", "code": "fn success() -> Self {\n        Self::Success\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::wasi_misaligned_pointer", "test": "fn wasi_misaligned_pointer() -> Result<()> {\n    let output = get_wasmtime_command()?\n        .arg(\"./tests/all/cli_tests/wasi_misaligned_pointer.wat\")\n        .output()?;\n    assert!(!output.status.success());\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"Pointer not aligned\"),\n        \"bad stderr: {stderr}\",\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-common/src/snapshots/preview_0.rs::success", "code": "fn success() -> Self {\n        Self::Success\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::bad_text_syntax", "test": "fn bad_text_syntax() -> Result<()> {\n    let output = get_wasmtime_command()?\n        .arg(\"-Ccache=n\")\n        .arg(\"tests/all/cli_tests/bad-syntax.wat\")\n        .output()?;\n    assert!(!output.status.success());\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"--> tests/all/cli_tests/bad-syntax.wat\"),\n        \"bad stderr: {stderr}\"\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-common/src/snapshots/preview_0.rs::success", "code": "fn success() -> Self {\n        Self::Success\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::memory_growth_failure", "test": "fn memory_growth_failure() -> Result<()> {\n    let output = get_wasmtime_command()?\n        .args(&[\n            \"run\",\n            \"-Wmemory64\",\n            \"-Wtrap-on-grow-failure\",\n            \"tests/all/cli_tests/memory-grow-failure.wat\",\n        ])\n        .output()?;\n    assert!(!output.status.success());\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"forcing a memory growth failure to be a trap\"),\n        \"bad stderr: {stderr}\"\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-common/src/snapshots/preview_0.rs::success", "code": "fn success() -> Self {\n        Self::Success\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::table_growth_failure", "test": "fn table_growth_failure() -> Result<()> {\n    let output = get_wasmtime_command()?\n        .args(&[\n            \"run\",\n            \"-Wtrap-on-grow-failure\",\n            \"tests/all/cli_tests/table-grow-failure.wat\",\n        ])\n        .output()?;\n    assert!(!output.status.success());\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"forcing trap when growing table\"),\n        \"bad stderr: {stderr}\"\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-common/src/snapshots/preview_0.rs::success", "code": "fn success() -> Self {\n        Self::Success\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::table_growth_failure2", "test": "fn table_growth_failure2() -> Result<()> {\n    let output = get_wasmtime_command()?\n        .args(&[\n            \"run\",\n            \"-Wtrap-on-grow-failure\",\n            \"tests/all/cli_tests/table-grow-failure2.wat\",\n        ])\n        .output()?;\n    assert!(!output.status.success());\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    assert!(\n        stderr.contains(\"forcing a table growth failure to be a trap\"),\n        \"bad stderr: {stderr}\"\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-common/src/snapshots/preview_0.rs::success", "code": "fn success() -> Self {\n        Self::Success\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/cli_tests.rs::preview2_stdin", "test": "fn preview2_stdin() -> Result<()> {\n    let test = \"tests/all/cli_tests/count-stdin.wat\";\n    let cmd = || -> Result<_> {\n        let mut cmd = get_wasmtime_command()?;\n        cmd.arg(\"--invoke=count\").arg(\"-Spreview2\").arg(test);\n        Ok(cmd)\n    };\n\n    // read empty pipe is ok\n    let output = cmd()?.output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"0\\n\");\n\n    // read itself is ok\n    let file = File::open(test)?;\n    let size = file.metadata()?.len();\n    let output = cmd()?.stdin(File::open(test)?).output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), format!(\"{size}\\n\"));\n\n    // read piped input ok is ok\n    let mut child = cmd()?\n        .stdin(Stdio::piped())\n        .stdout(Stdio::piped())\n        .stderr(Stdio::piped())\n        .spawn()?;\n    let mut stdin = child.stdin.take().unwrap();\n    std::thread::spawn(move || {\n        stdin.write_all(b\"hello\").unwrap();\n    });\n    let output = child.wait_with_output()?;\n    assert!(output.status.success());\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"5\\n\");\n\n    let count_up_to = |n: usize| -> Result<_> {\n        let mut child = get_wasmtime_command()?\n            .arg(\"--invoke=count-up-to\")\n            .arg(\"-Spreview2\")\n            .arg(test)\n            .arg(n.to_string())\n            .stdin(Stdio::piped())\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped())\n            .spawn()?;\n        let mut stdin = child.stdin.take().unwrap();\n        let t = std::thread::spawn(move || {\n            let mut written = 0;\n            let bytes = [0; 64 * 1024];\n            loop {\n                written += match stdin.write(&bytes) {\n                    Ok(n) => n,\n                    Err(_) => break written,\n                };\n            }\n        });\n        let output = child.wait_with_output()?;\n        assert!(output.status.success());\n        let written = t.join().unwrap();\n        let read = String::from_utf8_lossy(&output.stdout)\n            .trim()\n            .parse::<usize>()\n            .unwrap();\n        // The test reads in 1000 byte chunks so make sure that it doesn't read\n        // more than 1000 bytes than requested.\n        assert!(read < n + 1000, \"test read too much {read}\");\n        Ok(written)\n    };\n\n    // wasmtime shouldn't eat information that the guest never actually tried to\n    // read.\n    //\n    // NB: this may be a bit flaky. Exactly how much we wrote in the above\n    // helper thread depends on how much the OS buffers for us. For now give\n    // some some slop and assume that OSes are unlikely to buffer more than\n    // that.\n    let slop = 256 * 1024;\n    for amt in [0, 100, 100_000] {\n        let written = count_up_to(amt)?;\n        assert!(written < slop + amt, \"wrote too much {written}\");\n    }\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-common/src/snapshots/preview_0.rs::success", "code": "fn success() -> Self {\n        Self::Success\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::get_set_externref_globals_via_api", "test": "fn get_set_externref_globals_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    // Initialize with a null externref.\n\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::ExternRef, Mutability::Var),\n        Val::ExternRef(None),\n    )?;\n    assert!(global.get(&mut store).unwrap_externref().is_none());\n\n    global.set(\n        &mut store,\n        Val::ExternRef(Some(ExternRef::new(\"hello\".to_string()))),\n    )?;\n    let r = global.get(&mut store).unwrap_externref().unwrap();\n    assert!(r.data().is::<String>());\n    assert_eq!(r.data().downcast_ref::<String>().unwrap(), \"hello\");\n\n    // Initialize with a non-null externref.\n\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::ExternRef, Mutability::Const),\n        Val::ExternRef(Some(ExternRef::new(42_i32))),\n    )?;\n    let r = global.get(&mut store).unwrap_externref().unwrap();\n    assert!(r.data().is::<i32>());\n    assert_eq!(r.data().downcast_ref::<i32>().copied().unwrap(), 42);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/packed_option.rs::is_none", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::get_set_funcref_globals_via_api", "test": "fn get_set_funcref_globals_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let f = Func::wrap(&mut store, || {});\n\n    // Initialize with a null funcref.\n\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::FuncRef, Mutability::Var),\n        Val::FuncRef(None),\n    )?;\n    assert!(global.get(&mut store).unwrap_funcref().is_none());\n\n    global.set(&mut store, Val::FuncRef(Some(f.clone())))?;\n    let f2 = global.get(&mut store).unwrap_funcref().cloned().unwrap();\n    assert_eq!(f.ty(&store), f2.ty(&store));\n\n    // Initialize with a non-null funcref.\n\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::FuncRef, Mutability::Var),\n        Val::FuncRef(Some(f.clone())),\n    )?;\n    let f2 = global.get(&mut store).unwrap_funcref().cloned().unwrap();\n    assert_eq!(f.ty(&store), f2.ty(&store));\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/packed_option.rs::is_none", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::create_get_set_funcref_tables_via_api", "test": "fn create_get_set_funcref_tables_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let table_ty = TableType::new(ValType::FuncRef, 10, None);\n    let init = Val::FuncRef(Some(Func::wrap(&mut store, || {})));\n    let table = Table::new(&mut store, table_ty, init)?;\n\n    assert!(table.get(&mut store, 5).unwrap().unwrap_funcref().is_some());\n    table.set(&mut store, 5, Val::FuncRef(None))?;\n    assert!(table.get(&mut store, 5).unwrap().unwrap_funcref().is_none());\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/packed_option.rs::is_some", "code": "pub fn is_some(&self) -> bool {\n        !self.0.is_reserved_value()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::fill_funcref_tables_via_api", "test": "fn fill_funcref_tables_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let table_ty = TableType::new(ValType::FuncRef, 10, None);\n    let table = Table::new(&mut store, table_ty, Val::FuncRef(None))?;\n\n    for i in 0..10 {\n        assert!(table.get(&mut store, i).unwrap().unwrap_funcref().is_none());\n    }\n\n    let fill = Val::FuncRef(Some(Func::wrap(&mut store, || {})));\n    table.fill(&mut store, 2, fill, 4)?;\n\n    for i in (0..2).chain(7..10) {\n        assert!(table.get(&mut store, i).unwrap().unwrap_funcref().is_none());\n    }\n    for i in 2..6 {\n        assert!(table.get(&mut store, i).unwrap().unwrap_funcref().is_some());\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/packed_option.rs::is_none", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::grow_funcref_tables_via_api", "test": "fn grow_funcref_tables_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let table_ty = TableType::new(ValType::FuncRef, 10, None);\n    let table = Table::new(&mut store, table_ty, Val::FuncRef(None))?;\n\n    assert_eq!(table.size(&store), 10);\n    table.grow(&mut store, 3, Val::FuncRef(None))?;\n    assert_eq!(table.size(&store), 13);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/table.rs::size", "code": "pub fn size(&self) -> u32 {\n        match self {\n            Table::Static { size, .. } => *size,\n            Table::Dynamic { elements, .. } => elements.len().try_into().unwrap(),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::fill_externref_tables_via_api", "test": "fn fill_externref_tables_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let table_ty = TableType::new(ValType::ExternRef, 10, None);\n    let table = Table::new(&mut store, table_ty, Val::ExternRef(None))?;\n\n    for i in 0..10 {\n        assert!(table\n            .get(&mut store, i)\n            .unwrap()\n            .unwrap_externref()\n            .is_none());\n    }\n\n    table.fill(\n        &mut store,\n        2,\n        Val::ExternRef(Some(ExternRef::new(42_usize))),\n        4,\n    )?;\n\n    for i in (0..2).chain(7..10) {\n        assert!(table\n            .get(&mut store, i)\n            .unwrap()\n            .unwrap_externref()\n            .is_none());\n    }\n    for i in 2..6 {\n        assert_eq!(\n            *table\n                .get(&mut store, i)\n                .unwrap()\n                .unwrap_externref()\n                .unwrap()\n                .data()\n                .downcast_ref::<usize>()\n                .unwrap(),\n            42\n        );\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/packed_option.rs::is_none", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/externals.rs::grow_externref_tables_via_api", "test": "fn grow_externref_tables_via_api() -> anyhow::Result<()> {\n    let mut cfg = Config::new();\n    cfg.wasm_reference_types(true);\n    let engine = Engine::new(&cfg)?;\n    let mut store = Store::new(&engine, ());\n\n    let table_ty = TableType::new(ValType::ExternRef, 10, None);\n    let table = Table::new(&mut store, table_ty, Val::ExternRef(None))?;\n\n    assert_eq!(table.size(&store), 10);\n    table.grow(&mut store, 3, Val::ExternRef(None))?;\n    assert_eq!(table.size(&store), 13);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/table.rs::size", "code": "pub fn size(&self) -> u32 {\n        match self {\n            Table::Static { size, .. } => *size,\n            Table::Dynamic { elements, .. } => elements.len().try_into().unwrap(),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/fuel.rs::manual_fuel", "test": "fn manual_fuel() {\n    let mut config = Config::new();\n    config.consume_fuel(true);\n    let engine = Engine::new(&config).unwrap();\n    let mut store = Store::new(&engine, ());\n    store.add_fuel(10_000).unwrap();\n    assert_eq!(store.fuel_consumed(), Some(0));\n    assert_eq!(store.fuel_remaining(), Some(10_000));\n    assert_eq!(store.consume_fuel(1).unwrap(), 9_999);\n    assert_eq!(store.fuel_consumed(), Some(1));\n    assert_eq!(store.fuel_remaining(), Some(9_999));\n    assert!(store.consume_fuel(10_000).is_err());\n    assert_eq!(store.consume_fuel(999).unwrap(), 9_000);\n    assert!(store.consume_fuel(10_000).is_err());\n    assert_eq!(store.consume_fuel(8998).unwrap(), 2);\n    assert!(store.consume_fuel(3).is_err());\n    assert_eq!(store.consume_fuel(1).unwrap(), 1);\n    assert_eq!(store.consume_fuel(1).unwrap(), 0);\n    assert_eq!(store.consume_fuel(0).unwrap(), 0);\n    assert_eq!(store.fuel_remaining(), Some(0));\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::fuel_consumed", "code": "pub fn fuel_consumed(&self) -> Option<u64> {\n        self.inner.fuel_consumed()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/fuel.rs::manual_edge_cases", "test": "fn manual_edge_cases() {\n    let mut config = Config::new();\n    config.consume_fuel(true);\n    let engine = Engine::new(&config).unwrap();\n    let mut store = Store::new(&engine, ());\n    store.add_fuel(u64::MAX).unwrap();\n    assert_eq!(store.fuel_consumed(), Some(0));\n    assert!(store.consume_fuel(u64::MAX).is_err());\n    assert!(store.consume_fuel(i64::MAX as u64 + 1).is_err());\n    assert_eq!(store.consume_fuel(i64::MAX as u64).unwrap(), 0);\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::fuel_consumed", "code": "pub fn fuel_consumed(&self) -> Option<u64> {\n        self.inner.fuel_consumed()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/func.rs::call_array_to_native", "test": "fn call_array_to_native() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let func = Func::wrap(&mut store, |a: i32, b: i32, c: i32| -> (i32, i32, i32) {\n        (a * 10, b * 10, c * 10)\n    });\n    let mut results = [Val::I32(0), Val::I32(0), Val::I32(0)];\n    func.call(\n        &mut store,\n        &[Val::I32(10), Val::I32(20), Val::I32(30)],\n        &mut results,\n    )?;\n    assert_eq!(results[0].i32(), Some(100));\n    assert_eq!(results[1].i32(), Some(200));\n    assert_eq!(results[2].i32(), Some(300));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/vmcontext.rs::i32", "code": "pub fn i32(i: i32) -> ValRaw {\n        // Note that this is intentionally not setting the `i32` field, instead\n        // setting the `i64` field with a zero-extended version of `i`. For more\n        // information on this see the comments on `Lower for Result` in the\n        // `wasmtime` crate. Otherwise though all `ValRaw` constructors are\n        // otherwise constrained to guarantee that the initial 64-bits are\n        // always initialized.\n        ValRaw::u64((i as u32).into())\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/func.rs::dtor_runs", "test": "fn dtor_runs() {\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n\n    struct A;\n\n    impl Drop for A {\n        fn drop(&mut self) {\n            HITS.fetch_add(1, SeqCst);\n        }\n    }\n\n    let mut store = Store::<()>::default();\n    let a = A;\n    assert_eq!(HITS.load(SeqCst), 0);\n    Func::wrap(&mut store, move || {\n        let _ = &a;\n    });\n    drop(store);\n    assert_eq!(HITS.load(SeqCst), 1);\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/vmcontext.rs::load", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/func.rs::dtor_delayed", "test": "fn dtor_delayed() -> Result<()> {\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n\n    struct A;\n\n    impl Drop for A {\n        fn drop(&mut self) {\n            HITS.fetch_add(1, SeqCst);\n        }\n    }\n\n    let mut store = Store::<()>::default();\n    let a = A;\n    let func = Func::wrap(&mut store, move || {\n        let _ = &a;\n    });\n\n    assert_eq!(HITS.load(SeqCst), 0);\n    let wasm = wat::parse_str(r#\"(import \"\" \"\" (func))\"#)?;\n    let module = Module::new(store.engine(), &wasm)?;\n    let _instance = Instance::new(&mut store, &module, &[func.into()])?;\n    assert_eq!(HITS.load(SeqCst), 0);\n    drop(store);\n    assert_eq!(HITS.load(SeqCst), 1);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/vmcontext.rs::load", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/func.rs::trap_smoke", "test": "fn trap_smoke() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let f = Func::wrap(&mut store, || -> Result<()> { bail!(\"test\") });\n    let err = f.call(&mut store, &[], &mut []).unwrap_err();\n    assert!(err.to_string().contains(\"test\"));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/gc.rs::global_init_no_leak", "test": "fn global_init_no_leak() -> anyhow::Result<()> {\n    let (mut store, module) = ref_types_module(\n        false,\n        r#\"\n            (module\n                (import \"\" \"\" (global externref))\n                (global externref (global.get 0))\n            )\n        \"#,\n    )?;\n\n    let externref = ExternRef::new(());\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::ExternRef, Mutability::Const),\n        externref.clone().into(),\n    )?;\n    Instance::new(&mut store, &module, &[global.into()])?;\n    drop(store);\n    assert_eq!(externref.strong_count(), 1);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/externref.rs::strong_count", "code": "pub fn strong_count(&self) -> usize {\n        self.extern_data().ref_count.load(Ordering::SeqCst)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/globals.rs::smoke", "test": "fn smoke() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::I32, Mutability::Const),\n        0.into(),\n    )?;\n    assert_eq!(g.get(&mut store).i32(), Some(0));\n    assert!(g.set(&mut store, 0.into()).is_err());\n\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::I32, Mutability::Const),\n        1i32.into(),\n    )?;\n    assert_eq!(g.get(&mut store).i32(), Some(1));\n\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::I64, Mutability::Const),\n        2i64.into(),\n    )?;\n    assert_eq!(g.get(&mut store).i64(), Some(2));\n\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::F32, Mutability::Const),\n        3.0f32.into(),\n    )?;\n    assert_eq!(g.get(&mut store).f32(), Some(3.0));\n\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::F64, Mutability::Const),\n        4.0f64.into(),\n    )?;\n    assert_eq!(g.get(&mut store).f64(), Some(4.0));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/winch/codegen/src/masm.rs::i32", "code": "pub fn i32(val: i32) -> Self {\n        Self::I32(val as u32)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/globals.rs::mutability", "test": "fn mutability() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::I32, Mutability::Var),\n        0.into(),\n    )?;\n    assert_eq!(g.get(&mut store).i32(), Some(0));\n    g.set(&mut store, 1.into())?;\n    assert_eq!(g.get(&mut store).i32(), Some(1));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/winch/codegen/src/masm.rs::i32", "code": "pub fn i32(val: i32) -> Self {\n        Self::I32(val as u32)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/globals.rs::use_after_drop", "test": "fn use_after_drop() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (module\n                (global (export \"foo\") (mut i32) (i32.const 100)))\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let g = instance.get_global(&mut store, \"foo\").unwrap();\n    assert_eq!(g.get(&mut store).i32(), Some(100));\n    g.set(&mut store, 101.into())?;\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n    Instance::new(&mut store, &module, &[])?;\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n    drop(module);\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n\n    // spray some heap values\n    let mut x = Vec::new();\n    for _ in 0..100 {\n        x.push(\"xy\".to_string());\n    }\n    drop(x);\n    assert_eq!(g.get(&mut store).i32(), Some(101));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/winch/codegen/src/masm.rs::i32", "code": "pub fn i32(val: i32) -> Self {\n        Self::I32(val as u32)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/globals.rs::v128", "test": "fn v128() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::V128, Mutability::Var),\n        0u128.into(),\n    )?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(0)));\n    g.set(&mut store, 1u128.into())?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(1)));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/globals.rs::v128", "code": "fn v128() -> anyhow::Result<()> {\n    let mut store = Store::<()>::default();\n    let g = Global::new(\n        &mut store,\n        GlobalType::new(ValType::V128, Mutability::Var),\n        0u128.into(),\n    )?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(0)));\n    g.set(&mut store, 1u128.into())?;\n    assert_eq!(g.get(&mut store).v128(), Some(V128::from(1)));\n    Ok(())\n}", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/host_funcs.rs::drop_func", "test": "fn drop_func() -> Result<()> {\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n    struct A;\n\n    impl Drop for A {\n        fn drop(&mut self) {\n            HITS.fetch_add(1, SeqCst);\n        }\n    }\n\n    let engine = Engine::default();\n    let mut linker = Linker::<()>::new(&engine);\n    linker.allow_shadowing(true);\n\n    let a = A;\n    linker.func_wrap(\"\", \"\", move || {\n        let _ = &a;\n    })?;\n\n    assert_eq!(HITS.load(SeqCst), 0);\n\n    // Define the function again to ensure redefined functions are dropped\n\n    let a = A;\n    linker.func_wrap(\"\", \"\", move || {\n        let _ = &a;\n    })?;\n\n    assert_eq!(HITS.load(SeqCst), 1);\n\n    drop(linker);\n\n    assert_eq!(HITS.load(SeqCst), 2);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/vmcontext.rs::load", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/host_funcs.rs::drop_delayed", "test": "fn drop_delayed() -> Result<()> {\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n\n    struct A;\n\n    impl Drop for A {\n        fn drop(&mut self) {\n            HITS.fetch_add(1, SeqCst);\n        }\n    }\n\n    let engine = Engine::default();\n    let mut linker = Linker::<()>::new(&engine);\n\n    let a = A;\n    linker.func_wrap(\"\", \"\", move || {\n        let _ = &a;\n    })?;\n\n    assert_eq!(HITS.load(SeqCst), 0);\n\n    let module = Module::new(&engine, &wat::parse_str(r#\"(import \"\" \"\" (func))\"#)?)?;\n\n    let mut store = Store::new(&engine, ());\n    let func = linker.get(&mut store, \"\", \"\").unwrap();\n    Instance::new(&mut store, &module, &[func])?;\n\n    drop(store);\n\n    assert_eq!(HITS.load(SeqCst), 0);\n\n    let mut store = Store::new(&engine, ());\n    let func = linker.get(&mut store, \"\", \"\").unwrap();\n    Instance::new(&mut store, &module, &[func])?;\n\n    drop(store);\n\n    assert_eq!(HITS.load(SeqCst), 0);\n\n    drop(linker);\n\n    assert_eq!(HITS.load(SeqCst), 1);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/vmcontext.rs::load", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/host_funcs.rs::trap_smoke", "test": "fn trap_smoke() -> Result<()> {\n    let engine = Engine::default();\n    let mut linker = Linker::<()>::new(&engine);\n    linker.func_wrap(\"\", \"\", || -> Result<()> { bail!(\"test\") })?;\n\n    let mut store = Store::new(&engine, ());\n\n    let f = linker.get(&mut store, \"\", \"\").unwrap().into_func().unwrap();\n\n    let err = f.call(&mut store, &[], &mut []).unwrap_err();\n\n    assert!(err.to_string().contains(\"test\"));\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/host_funcs.rs::store_with_context", "test": "fn store_with_context() -> Result<()> {\n    struct Ctx {\n        called: bool,\n    }\n\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n\n    linker.func_wrap(\"\", \"\", |mut caller: Caller<'_, Ctx>| {\n        caller.data_mut().called = true;\n    })?;\n\n    let mut store = Store::new(&engine, Ctx { called: false });\n\n    let f = linker.get(&mut store, \"\", \"\").unwrap().into_func().unwrap();\n    f.call(&mut store, &[], &mut [])?;\n\n    assert!(store.data().called);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::data", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/iloop.rs::loop_interrupt_from_afar", "test": "fn loop_interrupt_from_afar() -> anyhow::Result<()> {\n    // Create an instance which calls an imported function on each iteration of\n    // the loop so we can count the number of loop iterations we've executed so\n    // far.\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n    static STOP: AtomicBool = AtomicBool::new(false);\n    let mut store = interruptable_store();\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (import \"\" \"\" (func))\n\n            (func (export \"loop\")\n                (loop\n                    call 0\n                    br 0)\n            )\n        \"#,\n    )?;\n    let func = Func::wrap(&mut store, || {\n        HITS.fetch_add(1, SeqCst);\n    });\n    let instance = Instance::new(&mut store, &module, &[func.into()])?;\n\n    // Use the engine to wait for it to enter the loop long enough and then we\n    // signal an interrupt happens.\n    let engine = store.engine().clone();\n    let thread = std::thread::spawn(move || {\n        while HITS.load(SeqCst) <= NUM_HITS && !STOP.load(SeqCst) {\n            // continue ...\n        }\n        println!(\"interrupting\");\n        engine.increment_epoch();\n    });\n\n    // Enter the infinitely looping function and assert that our interrupt\n    // handle does indeed actually interrupt the function.\n    let iloop = instance.get_typed_func::<(), ()>(&mut store, \"loop\")?;\n    let trap = iloop.call(&mut store, ()).unwrap_err().downcast::<Trap>()?;\n    STOP.store(true, SeqCst);\n    thread.join().unwrap();\n    assert!(HITS.load(SeqCst) > NUM_HITS);\n    assert_eq!(trap, Trap::Interrupt);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/vmcontext.rs::load", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/iloop.rs::function_interrupt_from_afar", "test": "fn function_interrupt_from_afar() -> anyhow::Result<()> {\n    // Create an instance which calls an imported function on each iteration of\n    // the loop so we can count the number of loop iterations we've executed so\n    // far.\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n    static STOP: AtomicBool = AtomicBool::new(false);\n\n    let mut store = interruptable_store();\n    let module = hugely_recursive_module(store.engine())?;\n    let func = Func::wrap(&mut store, || {\n        HITS.fetch_add(1, SeqCst);\n    });\n    let instance = Instance::new(&mut store, &module, &[func.into()])?;\n\n    // Use the instance's interrupt handle to wait for it to enter the loop long\n    // enough and then we signal an interrupt happens.\n    let engine = store.engine().clone();\n    let thread = std::thread::spawn(move || {\n        while HITS.load(SeqCst) <= NUM_HITS && !STOP.load(SeqCst) {\n            // continue ...\n        }\n        engine.increment_epoch();\n    });\n\n    // Enter the infinitely looping function and assert that our interrupt\n    // handle does indeed actually interrupt the function.\n    let iloop = instance.get_typed_func::<(), ()>(&mut store, \"loop\")?;\n    let trap = iloop.call(&mut store, ()).unwrap_err().downcast::<Trap>()?;\n    STOP.store(true, SeqCst);\n    thread.join().unwrap();\n    assert!(HITS.load(SeqCst) > NUM_HITS);\n    assert_eq!(trap, Trap::Interrupt);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/vmcontext.rs::load", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/import_calling_export.rs::test_returns_incorrect_type", "test": "fn test_returns_incorrect_type() -> Result<()> {\n    const WAT: &str = r#\"\n    (module\n        (import \"env\" \"evil\" (func $evil (result i32)))\n        (func (export \"run\") (result i32)\n            (call $evil)\n        )\n    )\n    \"#;\n\n    let mut store = Store::<()>::default();\n    let module = Module::new(store.engine(), WAT)?;\n\n    let callback_func = Func::new(\n        &mut store,\n        FuncType::new(None, Some(ValType::I32)),\n        |_, _, results| {\n            // Evil! Returns I64 here instead of promised in the signature I32.\n            results[0] = Val::I64(228);\n            Ok(())\n        },\n    );\n\n    let imports = vec![callback_func.into()];\n    let instance = Instance::new(&mut store, &module, imports.as_slice())?;\n\n    let run_func = instance\n        .get_func(&mut store, \"run\")\n        .expect(\"expected a run func in the module\");\n\n    let mut result = [Val::I32(0)];\n    let trap = run_func\n        .call(&mut store, &[], &mut result)\n        .expect_err(\"the execution should fail\");\n    assert!(format!(\"{:?}\", trap).contains(\"function attempted to return an incompatible value\"));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/import_indexes.rs::same_import_names_still_distinct", "test": "fn same_import_names_still_distinct() -> anyhow::Result<()> {\n    const WAT: &str = r#\"\n(module\n  (import \"\" \"\" (func $a (result i32)))\n  (import \"\" \"\" (func $b (result f32)))\n  (func (export \"foo\") (result i32)\n    call $a\n    call $b\n    i32.trunc_f32_u\n    i32.add)\n)\n    \"#;\n\n    let mut store = Store::<()>::default();\n    let module = Module::new(store.engine(), WAT)?;\n\n    let imports = [\n        Func::new(\n            &mut store,\n            FuncType::new(None, Some(ValType::I32)),\n            |_, params, results| {\n                assert!(params.is_empty());\n                assert_eq!(results.len(), 1);\n                results[0] = 1i32.into();\n                Ok(())\n            },\n        )\n        .into(),\n        Func::new(\n            &mut store,\n            FuncType::new(None, Some(ValType::F32)),\n            |_, params, results| {\n                assert!(params.is_empty());\n                assert_eq!(results.len(), 1);\n                results[0] = 2.0f32.into();\n                Ok(())\n            },\n        )\n        .into(),\n    ];\n    let instance = Instance::new(&mut store, &module, &imports)?;\n\n    let func = instance.get_typed_func::<(), i32>(&mut store, \"foo\")?;\n    let result = func.call(&mut store, ())?;\n    assert_eq!(result, 3);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/sparse.rs::is_empty", "code": "pub fn is_empty(&self) -> bool {\n        self.dense.is_empty()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_limits_memory_only", "test": "fn test_limits_memory_only() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 0) (table (export \"t\") 0 anyfunc))\"#,\n    )?;\n\n    let mut store = Store::new(\n        &engine,\n        StoreLimitsBuilder::new()\n            .memory_size(10 * WASM_PAGE_SIZE)\n            .build(),\n    );\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    let instance = Instance::new(&mut store, &module, &[])?;\n\n    // Test instance exports and host objects hitting the limit\n    for memory in IntoIterator::into_iter([\n        instance.get_memory(&mut store, \"m\").unwrap(),\n        Memory::new(&mut store, MemoryType::new(0, None))?,\n    ]) {\n        memory.grow(&mut store, 3)?;\n        memory.grow(&mut store, 5)?;\n        memory.grow(&mut store, 2)?;\n\n        assert_eq!(\n            memory\n                .grow(&mut store, 1)\n                .map_err(|e| e.to_string())\n                .unwrap_err(),\n            \"failed to grow memory by `1`\"\n        );\n    }\n\n    // Test instance exports and host objects *not* hitting the limit\n    for table in IntoIterator::into_iter([\n        instance.get_table(&mut store, \"t\").unwrap(),\n        Table::new(\n            &mut store,\n            TableType::new(ValType::FuncRef, 0, None),\n            Val::FuncRef(None),\n        )?,\n    ]) {\n        table.grow(&mut store, 2, Val::FuncRef(None))?;\n        table.grow(&mut store, 1, Val::FuncRef(None))?;\n        table.grow(&mut store, 2, Val::FuncRef(None))?;\n        table.grow(&mut store, 1, Val::FuncRef(None))?;\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_initial_memory_limits_exceeded", "test": "fn test_initial_memory_limits_exceeded() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(&engine, r#\"(module (memory (export \"m\") 11))\"#)?;\n\n    let mut store = Store::new(\n        &engine,\n        StoreLimitsBuilder::new()\n            .memory_size(10 * WASM_PAGE_SIZE)\n            .build(),\n    );\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    match Instance::new(&mut store, &module, &[]) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"memory minimum size of 11 pages exceeds memory limits\"\n        ),\n    }\n\n    match Memory::new(&mut store, MemoryType::new(25, None)) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"memory minimum size of 25 pages exceeds memory limits\"\n        ),\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_limits_table_only", "test": "fn test_limits_table_only() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 0) (table (export \"t\") 0 anyfunc))\"#,\n    )?;\n\n    let mut store = Store::new(&engine, StoreLimitsBuilder::new().table_elements(5).build());\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    let instance = Instance::new(&mut store, &module, &[])?;\n\n    // Test instance exports and host objects *not* hitting the limit\n    for memory in IntoIterator::into_iter([\n        instance.get_memory(&mut store, \"m\").unwrap(),\n        Memory::new(&mut store, MemoryType::new(0, None))?,\n    ]) {\n        memory.grow(&mut store, 3)?;\n        memory.grow(&mut store, 5)?;\n        memory.grow(&mut store, 2)?;\n        memory.grow(&mut store, 1)?;\n    }\n\n    // Test instance exports and host objects hitting the limit\n    for table in IntoIterator::into_iter([\n        instance.get_table(&mut store, \"t\").unwrap(),\n        Table::new(\n            &mut store,\n            TableType::new(ValType::FuncRef, 0, None),\n            Val::FuncRef(None),\n        )?,\n    ]) {\n        table.grow(&mut store, 2, Val::FuncRef(None))?;\n        table.grow(&mut store, 1, Val::FuncRef(None))?;\n        table.grow(&mut store, 2, Val::FuncRef(None))?;\n\n        assert_eq!(\n            table\n                .grow(&mut store, 1, Val::FuncRef(None))\n                .map_err(|e| e.to_string())\n                .unwrap_err(),\n            \"failed to grow table by `1`\"\n        );\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_initial_table_limits_exceeded", "test": "fn test_initial_table_limits_exceeded() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(&engine, r#\"(module (table (export \"t\") 23 anyfunc))\"#)?;\n\n    let mut store = Store::new(&engine, StoreLimitsBuilder::new().table_elements(4).build());\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    match Instance::new(&mut store, &module, &[]) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"table minimum size of 23 elements exceeds table limits\"\n        ),\n    }\n\n    match Table::new(\n        &mut store,\n        TableType::new(ValType::FuncRef, 99, None),\n        Val::FuncRef(None),\n    ) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"table minimum size of 99 elements exceeds table limits\"\n        ),\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_pooling_allocator_initial_limits_exceeded", "test": "fn test_pooling_allocator_initial_limits_exceeded() -> Result<()> {\n    let mut pool = crate::small_pool_config();\n    pool.total_memories(2)\n        .max_memories_per_module(2)\n        .memory_pages(5);\n    let mut config = Config::new();\n    config.wasm_multi_memory(true);\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n\n    let engine = Engine::new(&config)?;\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m1\") 2) (memory (export \"m2\") 5))\"#,\n    )?;\n\n    let mut store = Store::new(\n        &engine,\n        StoreLimitsBuilder::new()\n            .memory_size(3 * WASM_PAGE_SIZE)\n            .build(),\n    );\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n\n    match Instance::new(&mut store, &module, &[]) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"memory minimum size of 5 pages exceeds memory limits\"\n        ),\n    }\n\n    // An instance should still be able to be created after the failure above\n    let module = Module::new(&engine, r#\"(module (memory (export \"m\") 2))\"#)?;\n\n    Instance::new(&mut store, &module, &[])?;\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::test_custom_table_limiter", "test": "fn test_custom_table_limiter() -> Result<()> {\n    let engine = Engine::default();\n    let linker = Linker::new(&engine);\n\n    let module = Module::new(&engine, r#\"(module (table (export \"t\") 0 anyfunc))\"#)?;\n\n    let context = TableContext {\n        elements_used: 0,\n        element_limit: 10,\n        limit_exceeded: false,\n    };\n\n    let mut store = Store::new(&engine, context);\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n    let instance = linker.instantiate(&mut store, &module)?;\n    let table = instance.get_table(&mut store, \"t\").unwrap();\n\n    // Grow the table by 10 elements\n    table.grow(&mut store, 3, Val::FuncRef(None))?;\n    table.grow(&mut store, 5, Val::FuncRef(None))?;\n    table.grow(&mut store, 2, Val::FuncRef(None))?;\n\n    assert!(!store.data().limit_exceeded);\n\n    // Table is at the maximum, but the limit hasn't been exceeded\n    assert!(!store.data().limit_exceeded);\n\n    // Try to grow the memory again\n    assert_eq!(\n        table\n            .grow(&mut store, 1, Val::FuncRef(None))\n            .map_err(|e| e.to_string())\n            .unwrap_err(),\n        \"failed to grow table by `1`\"\n    );\n\n    assert!(store.data().limit_exceeded);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::data", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/limits.rs::custom_limiter_detect_grow_failure", "test": "fn custom_limiter_detect_grow_failure() -> Result<()> {\n    if std::env::var(\"WASMTIME_TEST_NO_HOG_MEMORY\").is_ok() {\n        return Ok(());\n    }\n    let mut pool = crate::small_pool_config();\n    pool.memory_pages(10).table_elements(10);\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n    let engine = Engine::new(&config).unwrap();\n    let linker = Linker::new(&engine);\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 0) (table (export \"t\") 0 anyfunc))\"#,\n    )?;\n\n    let context = FailureDetector::default();\n\n    let mut store = Store::new(&engine, context);\n    store.limiter(|s| s as &mut dyn ResourceLimiter);\n    let instance = linker.instantiate(&mut store, &module)?;\n    let memory = instance.get_memory(&mut store, \"m\").unwrap();\n\n    // Grow the memory by 640 KiB (10 pages)\n    memory.grow(&mut store, 10)?;\n\n    assert!(store.data().memory_error.is_none());\n    assert_eq!(store.data().memory_current, 0);\n    assert_eq!(store.data().memory_desired, 10 * 64 * 1024);\n\n    // Grow past the static limit set by ModuleLimits.\n    // The ResourceLimiter will permit this, but the grow will fail.\n    assert_eq!(\n        memory.grow(&mut store, 1).unwrap_err().to_string(),\n        \"failed to grow memory by `1`\"\n    );\n\n    assert_eq!(store.data().memory_current, 10 * 64 * 1024);\n    assert_eq!(store.data().memory_desired, 11 * 64 * 1024);\n    assert_eq!(\n        store.data().memory_error.as_ref().unwrap(),\n        \"Memory maximum size exceeded\"\n    );\n\n    let table = instance.get_table(&mut store, \"t\").unwrap();\n    // Grow the table 10 elements\n    table.grow(&mut store, 10, Val::FuncRef(None))?;\n\n    assert!(store.data().table_error.is_none());\n    assert_eq!(store.data().table_current, 0);\n    assert_eq!(store.data().table_desired, 10);\n\n    // Grow past the static limit set by ModuleLimits.\n    // The ResourceLimiter will permit this, but the grow will fail.\n    assert_eq!(\n        table\n            .grow(&mut store, 1, Val::FuncRef(None))\n            .unwrap_err()\n            .to_string(),\n        \"failed to grow table by `1`\"\n    );\n\n    assert_eq!(store.data().table_current, 10);\n    assert_eq!(store.data().table_desired, 11);\n    assert_eq!(\n        store.data().table_error.as_ref().unwrap(),\n        \"Table maximum size exceeded\"\n    );\n\n    drop(store);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/packed_option.rs::is_none", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/linker.rs::test_unknown_import_error", "test": "fn test_unknown_import_error() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let linker = Linker::new(store.engine());\n    let module = Module::new(\n        store.engine(),\n        r#\"(module (import \"unknown-module\" \"unknown-name\" (func)))\"#,\n    )?;\n    let err = linker\n        .instantiate(&mut store, &module)\n        .expect_err(\"should fail\");\n    let unknown_import: UnknownImportError = err.downcast()?;\n    assert_eq!(unknown_import.module(), \"unknown-module\");\n    assert_eq!(unknown_import.name(), \"unknown-name\");\n    unknown_import.ty().unwrap_func();\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/instance.rs::module", "code": "pub(crate) fn module(&self) -> &Arc<Module> {\n        self.runtime_info.module()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/linker.rs::get_host_function", "test": "fn get_host_function() -> Result<()> {\n    let engine = Engine::default();\n    let module = Module::new(&engine, r#\"(module (import \"mod\" \"f1\" (func)))\"#)?;\n\n    let mut linker = Linker::new(&engine);\n    linker.func_wrap(\"mod\", \"f1\", || {})?;\n    let mut store = Store::new(&engine, ());\n    assert!(linker\n        .get_by_import(&mut store, &module.imports().nth(0).unwrap())\n        .is_some());\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/packed_option.rs::is_some", "code": "pub fn is_some(&self) -> bool {\n        !self.0.is_reserved_value()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/linker.rs::funcs_live_on_to_fight_another_day", "test": "fn funcs_live_on_to_fight_another_day() -> Result<()> {\n    struct DropMe(Arc<AtomicUsize>);\n\n    impl Drop for DropMe {\n        fn drop(&mut self) {\n            self.0.fetch_add(1, SeqCst);\n        }\n    }\n\n    let flag = Arc::new(AtomicUsize::new(0));\n    let engine = Engine::default();\n    let mut linker = Linker::new(&engine);\n    let drop_me = DropMe(flag.clone());\n    linker.func_wrap(\"\", \"\", move || {\n        let _ = &drop_me;\n    })?;\n    assert_eq!(flag.load(SeqCst), 0);\n\n    let get_and_call = || -> Result<()> {\n        assert_eq!(flag.load(SeqCst), 0);\n        let mut store = Store::new(&engine, ());\n        let func = linker.get(&mut store, \"\", \"\").unwrap();\n        func.into_func().unwrap().call(&mut store, &[], &mut [])?;\n        assert_eq!(flag.load(SeqCst), 0);\n        Ok(())\n    };\n\n    get_and_call()?;\n    get_and_call()?;\n    drop(linker);\n    assert_eq!(flag.load(SeqCst), 1);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/vmcontext.rs::load", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/memory.rs::dynamic_extra_growth_unchanged_pointer", "test": "fn dynamic_extra_growth_unchanged_pointer() -> Result<()> {\n    const EXTRA_PAGES: u64 = 5;\n    let mut config = Config::new();\n    config.static_memory_maximum_size(0);\n    // 5 wasm pages extra\n    config.dynamic_memory_reserved_for_growth(EXTRA_PAGES * (1 << 16));\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, ());\n\n    fn assert_behaves_well(store: &mut Store<()>, mem: &Memory) -> Result<()> {\n        let ptr = mem.data_ptr(&store);\n\n        // Each growth here should retain the same linear pointer in memory and the\n        // memory shouldn't get moved.\n        for _ in 0..EXTRA_PAGES {\n            mem.grow(&mut *store, 1)?;\n            assert_eq!(ptr, mem.data_ptr(&store));\n        }\n\n        // Growth afterwards though will be forced to move the pointer\n        mem.grow(&mut *store, 1)?;\n        let new_ptr = mem.data_ptr(&store);\n        assert_ne!(ptr, new_ptr);\n\n        for _ in 0..EXTRA_PAGES - 1 {\n            mem.grow(&mut *store, 1)?;\n            assert_eq!(new_ptr, mem.data_ptr(&store));\n        }\n        Ok(())\n    }\n\n    let mem = Memory::new(&mut store, MemoryType::new(10, None))?;\n    assert_behaves_well(&mut store, &mem)?;\n\n    let module = Module::new(&engine, r#\"(module (memory (export \"mem\") 10))\"#)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let mem = instance.get_memory(&mut store, \"mem\").unwrap();\n    assert_behaves_well(&mut store, &mem)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"mem\") 10)\n                (data (i32.const 0) \"\"))\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let mem = instance.get_memory(&mut store, \"mem\").unwrap();\n    assert_behaves_well(&mut store, &mem)?;\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/memory.rs::data_ptr", "code": "pub fn data_ptr(&self, store: impl AsContext) -> *mut u8 {\n        unsafe { (*store.as_context()[self.0].definition).base }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/module.rs::checks_incompatible_target", "test": "fn checks_incompatible_target() -> Result<()> {\n    let mut target = target_lexicon::Triple::host();\n    target.operating_system = target_lexicon::OperatingSystem::Unknown;\n    match Module::new(\n        &Engine::new(Config::new().target(&target.to_string())?)?,\n        \"(module)\",\n    ) {\n        Ok(_) => unreachable!(),\n        Err(e) => assert!(\n            format!(\"{:?}\", e).contains(\"configuration does not match the host\"),\n            \"bad error: {:?}\",\n            e\n        ),\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/module.rs::serialize_not_overly_massive", "test": "fn serialize_not_overly_massive() -> Result<()> {\n    let mut config = Config::new();\n    config.memory_guaranteed_dense_image_size(1 << 20);\n    let engine = Engine::new(&config)?;\n\n    let assert_smaller_than_1mb = |module: &str| -> Result<()> {\n        println!(\"{}\", module);\n        let bytes = Module::new(&engine, module)?.serialize()?;\n        assert!(bytes.len() < (1 << 20));\n        Ok(())\n    };\n\n    // Tons of space between data segments should use sparse initialization,\n    // along with various permutations of empty and nonempty segments.\n    assert_smaller_than_1mb(\n        r#\"(module\n            (memory 20000)\n            (data (i32.const 0) \"a\")\n            (data (i32.const 0x200000) \"b\")\n        )\"#,\n    )?;\n    assert_smaller_than_1mb(\n        r#\"(module\n            (memory 20000)\n            (data (i32.const 0) \"a\")\n            (data (i32.const 0x200000) \"\")\n        )\"#,\n    )?;\n    assert_smaller_than_1mb(\n        r#\"(module\n            (memory 20000)\n            (data (i32.const 0) \"\")\n            (data (i32.const 0x200000) \"b\")\n        )\"#,\n    )?;\n    assert_smaller_than_1mb(\n        r#\"(module\n            (memory 20000)\n            (data (i32.const 0) \"\")\n            (data (i32.const 0x200000) \"\")\n        )\"#,\n    )?;\n\n    // lone data segment\n    assert_smaller_than_1mb(\n        r#\"(module\n            (memory 20000)\n            (data (i32.const 0x200000) \"b\")\n        )\"#,\n    )?;\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/cranelift-shared/src/obj.rs::len", "code": "fn len(&self) -> usize {\n                self.0.len()\n            }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/name.rs::test_module_no_name", "test": "fn test_module_no_name() -> anyhow::Result<()> {\n    let engine = Engine::default();\n    let wat = r#\"\n        (module\n        (func (export \"run\") (nop))\n        )\n    \"#;\n\n    let module = Module::new(&engine, wat)?;\n    assert_eq!(module.name(), None);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/module.rs::name", "code": "pub fn name(&self) -> Option<&str> {\n        self.compiled_module().module().name.as_deref()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/name.rs::test_module_name", "test": "fn test_module_name() -> anyhow::Result<()> {\n    let engine = Engine::default();\n    let wat = r#\"\n        (module $from_name_section\n        (func (export \"run\") (nop))\n        )\n    \"#;\n\n    let module = Module::new(&engine, wat)?;\n    assert_eq!(module.name(), Some(\"from_name_section\"));\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/module.rs::name", "code": "pub fn name(&self) -> Option<&str> {\n        self.compiled_module().module().name.as_deref()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::memory_init", "test": "fn memory_init() -> Result<()> {\n    let mut pool = crate::small_pool_config();\n    pool.memory_pages(2).table_elements(0);\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"m\") 2)\n                (data (i32.const 65530) \"this data spans multiple pages\")\n                (data (i32.const 10) \"hello world\")\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let memory = instance.get_memory(&mut store, \"m\").unwrap();\n\n    assert_eq!(\n        &memory.data(&store)[65530..65560],\n        b\"this data spans multiple pages\"\n    );\n    assert_eq!(&memory.data(&store)[10..21], b\"hello world\");\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/memory.rs::data", "code": "pub fn data<'a, T: 'a>(&self, store: impl Into<StoreContext<'a, T>>) -> &'a [u8] {\n        unsafe {\n            let store = store.into();\n            let definition = &*store[self.0].definition;\n            debug_assert!(!self.ty(store).is_shared());\n            slice::from_raw_parts(definition.base, definition.current_length())\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::memory_zeroed", "test": "fn memory_zeroed() -> Result<()> {\n    if skip_pooling_allocator_tests() {\n        return Ok(());\n    }\n\n    let mut pool = crate::small_pool_config();\n    pool.memory_pages(1).table_elements(0);\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(&engine, r#\"(module (memory (export \"m\") 1))\"#)?;\n\n    // Instantiate the module repeatedly after writing data to the entire memory\n    for _ in 0..10 {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let memory = instance.get_memory(&mut store, \"m\").unwrap();\n\n        assert_eq!(memory.size(&store,), 1);\n        assert_eq!(memory.data_size(&store), 65536);\n\n        let ptr = memory.data_mut(&mut store).as_mut_ptr();\n\n        unsafe {\n            for i in 0..8192 {\n                assert_eq!(*ptr.cast::<u64>().offset(i), 0);\n            }\n            std::ptr::write_bytes(ptr, 0xFE, memory.data_size(&store));\n        }\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/memory.rs::size", "code": "pub fn size(&self, store: impl AsContext) -> u64 {\n        self.internal_size(store.as_context().0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::table_zeroed", "test": "fn table_zeroed() -> Result<()> {\n    if skip_pooling_allocator_tests() {\n        return Ok(());\n    }\n\n    let pool = crate::small_pool_config();\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(&engine, r#\"(module (table (export \"t\") 10 funcref))\"#)?;\n\n    // Instantiate the module repeatedly after filling table elements\n    for _ in 0..10 {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let table = instance.get_table(&mut store, \"t\").unwrap();\n        let f = Func::wrap(&mut store, || {});\n\n        assert_eq!(table.size(&store), 10);\n\n        for i in 0..10 {\n            match table.get(&mut store, i).unwrap() {\n                Val::FuncRef(r) => assert!(r.is_none()),\n                _ => panic!(\"expected a funcref\"),\n            }\n            table\n                .set(&mut store, i, Val::FuncRef(Some(f.clone())))\n                .unwrap();\n        }\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/table.rs::size", "code": "pub fn size(&self) -> u32 {\n        match self {\n            Table::Static { size, .. } => *size,\n            Table::Dynamic { elements, .. } => elements.len().try_into().unwrap(),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::total_core_instances_limit", "test": "fn total_core_instances_limit() -> Result<()> {\n    const INSTANCE_LIMIT: u32 = 10;\n    let mut pool = crate::small_pool_config();\n    pool.total_core_instances(INSTANCE_LIMIT);\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, r#\"(module)\"#)?;\n\n    // Instantiate to the limit\n    {\n        let mut store = Store::new(&engine, ());\n\n        for _ in 0..INSTANCE_LIMIT {\n            Instance::new(&mut store, &module, &[])?;\n        }\n\n        match Instance::new(&mut store, &module, &[]) {\n            Ok(_) => panic!(\"instantiation should fail\"),\n            Err(e) => assert_eq!(\n                e.to_string(),\n                format!(\n                    \"maximum concurrent core instance limit of {} reached\",\n                    INSTANCE_LIMIT\n                )\n            ),\n        }\n    }\n\n    // With the above store dropped, ensure instantiations can be made\n\n    let mut store = Store::new(&engine, ());\n\n    for _ in 0..INSTANCE_LIMIT {\n        Instance::new(&mut store, &module, &[])?;\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/pooling_allocator.rs::multi_memory_with_imported_memories", "test": "fn multi_memory_with_imported_memories() -> Result<()> {\n    // This test checks that the base address for the defined memory is correct for the instance\n    // despite the presence of an imported memory.\n\n    let mut pool = crate::small_pool_config();\n    pool.total_memories(2).max_memories_per_module(2);\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));\n    config.wasm_multi_memory(true);\n\n    let engine = Engine::new(&config)?;\n    let module = Module::new(\n        &engine,\n        r#\"(module (import \"\" \"m1\" (memory 0)) (memory (export \"m2\") 1))\"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n\n    let m1 = Memory::new(&mut store, MemoryType::new(0, None))?;\n    let instance = Instance::new(&mut store, &module, &[m1.into()])?;\n\n    let m2 = instance.get_memory(&mut store, \"m2\").unwrap();\n\n    m2.data_mut(&mut store)[0] = 0x42;\n    assert_eq!(m2.data(&store)[0], 0x42);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::data", "code": "pub fn data(&self) -> &[u8] {\n        // N.B.: we emit every section into the .text section as far as\n        // the `CodeSink` is concerned; we do not bother to segregate\n        // the contents into the actual program text, the jumptable and the\n        // rodata (constant pool). This allows us to generate code assuming\n        // that these will not be relocated relative to each other, and avoids\n        // having to designate each section as belonging in one of the three\n        // fixed categories defined by `CodeSink`. If this becomes a problem\n        // later (e.g. because of memory permissions or similar), we can\n        // add this designation and segregate the output; take care, however,\n        // to add the appropriate relocations in this case.\n\n        &self.data[..]\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/relocs.rs::forward_call_works", "test": "fn forward_call_works() -> Result<()> {\n    let mut store = store_with_padding(128 * MB)?;\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (module\n                (func (export \"foo\") (result i32)\n                    call 1)\n                (func (result i32)\n                    i32.const 4)\n            )\n        \"#,\n    )?;\n\n    let i = Instance::new(&mut store, &module, &[])?;\n    let foo = i.get_typed_func::<(), i32>(&mut store, \"foo\")?;\n    assert_eq!(foo.call(&mut store, ())?, 4);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/src/commands/serve.rs::call", "code": "fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n            .await?;\n\n            proxy\n                .wasi_http_incoming_handler()\n                .call_handle(store, req, out)\n                .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/relocs.rs::backwards_call_works", "test": "fn backwards_call_works() -> Result<()> {\n    let mut store = store_with_padding(128 * MB)?;\n    let module = Module::new(\n        store.engine(),\n        r#\"\n            (module\n                (func (result i32)\n                    i32.const 4)\n                (func (export \"foo\") (result i32)\n                    call 0)\n            )\n        \"#,\n    )?;\n\n    let i = Instance::new(&mut store, &module, &[])?;\n    let foo = i.get_typed_func::<(), i32>(&mut store, \"foo\")?;\n    assert_eq!(foo.call(&mut store, ())?, 4);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/src/commands/serve.rs::call", "code": "fn call(&mut self, req: Request) -> Self::Future {\n        use http_body_util::BodyExt;\n\n        let handler = self.clone();\n\n        let (sender, receiver) = tokio::sync::oneshot::channel();\n\n        // TODO: need to track the join handle, but don't want to block the response on it\n        tokio::task::spawn(async move {\n            let mut store = handler.0.cmd.new_store(&handler.0.engine)?;\n\n            let req = store.data_mut().new_incoming_request(\n                req.map(|body| body.map_err(|e| anyhow::anyhow!(e)).boxed()),\n            )?;\n\n            let out = store.data_mut().new_response_outparam(sender)?;\n\n            let (proxy, _inst) = wasmtime_wasi_http::proxy::Proxy::instantiate_pre(\n                &mut store,\n                &handler.0.instance_pre,\n            )\n            .await?;\n\n            proxy\n                .wasi_http_incoming_handler()\n                .call_handle(store, req, out)\n                .await?;\n\n            Ok::<_, anyhow::Error>(())\n        });\n\n        Box::pin(async move {\n            let resp = receiver.await.unwrap()?;\n            Ok(resp)\n        })\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/stack_overflow.rs::big_stack_works_ok", "test": "fn big_stack_works_ok() -> Result<()> {\n    const N: usize = 10000;\n\n    // Build a module with a function that uses a very large amount of stack space,\n    // modeled here by calling an i64-returning-function many times followed by\n    // adding them all into one i64.\n    //\n    // This should exercise the ability to consume multi-page stacks and\n    // only touch a few internals of it at a time.\n    let mut s = String::new();\n    s.push_str(\"(module\\n\");\n    s.push_str(\"(func (export \\\"\\\") (result i64)\\n\");\n    s.push_str(\"i64.const 0\\n\");\n    for _ in 0..N {\n        s.push_str(\"call $get\\n\");\n    }\n    for _ in 0..N {\n        s.push_str(\"i64.add\\n\");\n    }\n    s.push_str(\")\\n\");\n    s.push_str(\"(func $get (result i64) i64.const 0)\\n\");\n    s.push_str(\")\\n\");\n\n    let mut store = Store::<()>::default();\n    let module = Module::new(store.engine(), &s)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let func = instance.get_typed_func::<(), i64>(&mut store, \"\")?;\n    assert_eq!(func.call(&mut store, ())?, 0);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/func.rs::call", "code": "pub fn call(\n        &self,\n        mut store: impl AsContextMut,\n        params: &[Val],\n        results: &mut [Val],\n    ) -> Result<()> {\n        assert!(\n            !store.as_context().async_support(),\n            \"must use `call_async` when async support is enabled on the config\",\n        );\n        self.call_impl(&mut store.as_context_mut(), params, results)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/store.rs::into_inner", "test": "fn into_inner() {\n    static HITS: AtomicUsize = AtomicUsize::new(0);\n\n    struct A;\n\n    impl Drop for A {\n        fn drop(&mut self) {\n            HITS.fetch_add(1, SeqCst);\n        }\n    }\n\n    let engine = Engine::default();\n    assert_eq!(HITS.load(SeqCst), 0);\n    drop(Store::new(&engine, A));\n    assert_eq!(HITS.load(SeqCst), 1);\n    Store::new(&engine, A).into_data();\n    assert_eq!(HITS.load(SeqCst), 2);\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/runtime/src/vmcontext.rs::load", "code": "pub unsafe fn load(ptr: *mut Self) -> Self {\n        let other = &*ptr;\n        VMMemoryDefinition {\n            base: other.base,\n            current_length: other.current_length().into(),\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/table.rs::get_none", "test": "fn get_none() {\n    let mut store = Store::<()>::default();\n    let ty = TableType::new(ValType::FuncRef, 1, None);\n    let table = Table::new(&mut store, ty, Val::FuncRef(None)).unwrap();\n    match table.get(&mut store, 0) {\n        Some(Val::FuncRef(None)) => {}\n        _ => panic!(),\n    }\n    assert!(table.get(&mut store, 1).is_none());\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/packed_option.rs::is_none", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/table.rs::fill_wrong", "test": "fn fill_wrong() {\n    let mut store = Store::<()>::default();\n    let ty = TableType::new(ValType::FuncRef, 1, None);\n    let table = Table::new(&mut store, ty, Val::FuncRef(None)).unwrap();\n    assert_eq!(\n        table\n            .fill(&mut store, 0, Val::ExternRef(None), 1)\n            .map_err(|e| e.to_string())\n            .unwrap_err(),\n        \"value does not match table element type\"\n    );\n\n    let ty = TableType::new(ValType::ExternRef, 1, None);\n    let table = Table::new(&mut store, ty, Val::ExternRef(None)).unwrap();\n    assert_eq!(\n        table\n            .fill(&mut store, 0, Val::FuncRef(None), 1)\n            .map_err(|e| e.to_string())\n            .unwrap_err(),\n        \"value does not match table element type\"\n    );\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/table.rs::copy_wrong", "test": "fn copy_wrong() {\n    let mut store = Store::<()>::default();\n    let ty = TableType::new(ValType::FuncRef, 1, None);\n    let table1 = Table::new(&mut store, ty, Val::FuncRef(None)).unwrap();\n    let ty = TableType::new(ValType::ExternRef, 1, None);\n    let table2 = Table::new(&mut store, ty, Val::ExternRef(None)).unwrap();\n    assert_eq!(\n        Table::copy(&mut store, &table1, 0, &table2, 0, 1)\n            .map_err(|e| e.to_string())\n            .unwrap_err(),\n        \"tables do not have the same element type\"\n    );\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-preview1-component-adapter/byte-array-literals/src/lib.rs::to_string", "code": "fn to_string(lit: Literal) -> String {\n    let formatted = lit.to_string();\n\n    let mut it = formatted.chars();\n    assert_eq!(it.next(), Some('\"'));\n\n    let mut rv = String::new();\n    loop {\n        match it.next() {\n            Some('\"') => match it.next() {\n                Some(_) => panic!(),\n                None => break,\n            },\n            Some('\\\\') => match it.next() {\n                Some('x') => {\n                    let hi = it.next().unwrap().to_digit(16).unwrap();\n                    let lo = it.next().unwrap().to_digit(16).unwrap();\n                    let v = (hi << 16) | lo;\n                    rv.push(v as u8 as char);\n                }\n                Some('u') => {\n                    assert_eq!(it.next(), Some('{'));\n                    let mut c = it.next().unwrap();\n                    let mut ch = 0;\n                    while let Some(v) = c.to_digit(16) {\n                        ch *= 16;\n                        ch |= v;\n                        c = it.next().unwrap();\n                    }\n                    assert_eq!(c, '}');\n                    rv.push(::std::char::from_u32(ch).unwrap());\n                }\n                Some('0') => rv.push('\\0'),\n                Some('\\\\') => rv.push('\\\\'),\n                Some('\\\"') => rv.push('\\\"'),\n                Some('r') => rv.push('\\r'),\n                Some('n') => rv.push('\\n'),\n                Some('t') => rv.push('\\t'),\n                Some(_) => panic!(),\n                None => panic!(),\n            },\n            Some(c) => rv.push(c),\n            None => panic!(),\n        }\n    }\n\n    rv\n}", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/threads.rs::test_export_shared_memory", "test": "fn test_export_shared_memory() -> Result<()> {\n    let wat = r#\"(module (memory (export \"memory\") 1 5 shared))\"#;\n    let mut config = Config::new();\n    config.wasm_threads(true);\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, wat)?;\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let shared_memory = instance.get_shared_memory(&mut store, \"memory\").unwrap();\n\n    assert_eq!(shared_memory.size(), 1);\n    assert!(shared_memory.ty().is_shared());\n    assert_eq!(shared_memory.ty().maximum(), Some(5));\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/memory.rs::size", "code": "pub fn size(&self, store: impl AsContext) -> u64 {\n        self.internal_size(store.as_context().0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/threads.rs::test_multi_memory", "test": "fn test_multi_memory() -> Result<()> {\n    let wat = r#\"(module\n        (import \"env\" \"imported\" (memory $imported 5 10 shared))\n        (memory (export \"owned\") 10 20)\n        (memory (export \"shared\") 1 2 shared)\n        (export \"imported\" (memory $imported))\n    )\"#;\n    let mut config = Config::new();\n    config.wasm_threads(true);\n    config.wasm_multi_memory(true);\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, wat)?;\n    let mut store = Store::new(&engine, ());\n    let incoming_shared_memory = SharedMemory::new(&engine, MemoryType::shared(5, 10))?;\n    let instance = Instance::new(&mut store, &module, &[incoming_shared_memory.into()])?;\n    let owned_memory = instance.get_memory(&mut store, \"owned\").unwrap();\n    let shared_memory = instance.get_shared_memory(&mut store, \"shared\").unwrap();\n    let imported_memory = instance.get_shared_memory(&mut store, \"imported\").unwrap();\n\n    assert_eq!(owned_memory.size(&store), 10);\n    assert_eq!(owned_memory.ty(&store).minimum(), 10);\n    assert_eq!(owned_memory.ty(&store).maximum(), Some(20));\n    assert_eq!(owned_memory.ty(&store).is_shared(), false);\n    assert_eq!(shared_memory.size(), 1);\n    assert_eq!(shared_memory.ty().minimum(), 1);\n    assert_eq!(shared_memory.ty().maximum(), Some(2));\n    assert_eq!(shared_memory.ty().is_shared(), true);\n    assert_eq!(imported_memory.size(), 5);\n    assert_eq!(imported_memory.ty().minimum(), 5);\n    assert_eq!(imported_memory.ty().maximum(), Some(10));\n    assert_eq!(imported_memory.ty().is_shared(), true);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/memory.rs::size", "code": "pub fn size(&self, store: impl AsContext) -> u64 {\n        self.internal_size(store.as_context().0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_return", "test": "fn test_trap_return() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module\n        (func $hello (import \"\" \"hello\"))\n        (func (export \"run\") (call $hello))\n        )\n    \"#;\n\n    let module = Module::new(store.engine(), wat)?;\n    let hello_type = FuncType::new(None, None);\n    let hello_func = Func::new(&mut store, hello_type, |_, _, _| bail!(\"test 123\"));\n\n    let instance = Instance::new(&mut store, &module, &[hello_func.into()])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func.call(&mut store, ()).unwrap_err();\n    assert!(format!(\"{e:?}\").contains(\"test 123\"));\n\n    assert!(\n        e.downcast_ref::<WasmBacktrace>().is_some(),\n        \"error should contain a WasmBacktrace\"\n    );\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_anyhow_error_return", "test": "fn test_anyhow_error_return() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module\n        (func $hello (import \"\" \"hello\"))\n        (func (export \"run\") (call $hello))\n        )\n    \"#;\n\n    let module = Module::new(store.engine(), wat)?;\n    let hello_type = FuncType::new(None, None);\n    let hello_func = Func::new(&mut store, hello_type, |_, _, _| {\n        Err(anyhow::Error::msg(\"test 1234\"))\n    });\n\n    let instance = Instance::new(&mut store, &module, &[hello_func.into()])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func.call(&mut store, ()).unwrap_err();\n    assert!(!e.to_string().contains(\"test 1234\"));\n    assert!(format!(\"{:?}\", e).contains(\"Caused by:\\n    test 1234\"));\n\n    assert!(e.downcast_ref::<Trap>().is_none());\n    assert!(e.downcast_ref::<WasmBacktrace>().is_some());\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_return_downcast", "test": "fn test_trap_return_downcast() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module\n        (func $hello (import \"\" \"hello\"))\n        (func (export \"run\") (call $hello))\n        )\n    \"#;\n\n    #[derive(Debug)]\n    struct MyTrap;\n    impl std::fmt::Display for MyTrap {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            write!(f, \"my trap\")\n        }\n    }\n    impl std::error::Error for MyTrap {}\n\n    let module = Module::new(store.engine(), wat)?;\n    let hello_type = FuncType::new(None, None);\n    let hello_func = Func::new(&mut store, hello_type, |_, _, _| {\n        Err(anyhow::Error::from(MyTrap))\n    });\n\n    let instance = Instance::new(&mut store, &module, &[hello_func.into()])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func\n        .call(&mut store, ())\n        .err()\n        .expect(\"error calling function\");\n    let dbg = format!(\"{:?}\", e);\n    println!(\"{}\", dbg);\n\n    assert!(!e.to_string().contains(\"my trap\"));\n    assert!(dbg.contains(\"Caused by:\\n    my trap\"));\n\n    e.downcast_ref::<MyTrap>()\n        .expect(\"error downcasts to MyTrap\");\n    let bt = e\n        .downcast_ref::<WasmBacktrace>()\n        .expect(\"error downcasts to WasmBacktrace\");\n    assert_eq!(bt.frames().len(), 1);\n    println!(\"{:?}\", bt);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_trace", "test": "fn test_trap_trace() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module $hello_mod\n            (func (export \"run\") (call $hello))\n            (func $hello (unreachable))\n        )\n    \"#;\n\n    let module = Module::new(store.engine(), wat)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func.call(&mut store, ()).unwrap_err();\n\n    let trace = e.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert_eq!(trace.len(), 2);\n    assert_eq!(trace[0].module().name().unwrap(), \"hello_mod\");\n    assert_eq!(trace[0].func_index(), 1);\n    assert_eq!(trace[0].func_name(), Some(\"hello\"));\n    assert_eq!(trace[0].func_offset(), Some(1));\n    assert_eq!(trace[0].module_offset(), Some(0x26));\n    assert_eq!(trace[1].module().name().unwrap(), \"hello_mod\");\n    assert_eq!(trace[1].func_index(), 0);\n    assert_eq!(trace[1].func_name(), None);\n    assert_eq!(trace[1].func_offset(), Some(1));\n    assert_eq!(trace[1].module_offset(), Some(0x21));\n    assert_eq!(e.downcast::<Trap>()?, Trap::UnreachableCodeReached);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/settings.rs::len", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_through_host", "test": "fn test_trap_through_host() -> Result<()> {\n    let wat = r#\"\n        (module $hello_mod\n            (import \"\" \"\" (func $host_func_a))\n            (import \"\" \"\" (func $host_func_b))\n            (func $a (export \"a\")\n                call $host_func_a\n            )\n            (func $b (export \"b\")\n                call $host_func_b\n            )\n            (func $c (export \"c\")\n                unreachable\n            )\n        )\n    \"#;\n\n    let engine = Engine::default();\n    let module = Module::new(&engine, wat)?;\n    let mut store = Store::<()>::new(&engine, ());\n\n    let host_func_a = Func::new(\n        &mut store,\n        FuncType::new(vec![], vec![]),\n        |mut caller, _args, _results| {\n            caller\n                .get_export(\"b\")\n                .unwrap()\n                .into_func()\n                .unwrap()\n                .call(caller, &[], &mut [])?;\n            Ok(())\n        },\n    );\n    let host_func_b = Func::new(\n        &mut store,\n        FuncType::new(vec![], vec![]),\n        |mut caller, _args, _results| {\n            caller\n                .get_export(\"c\")\n                .unwrap()\n                .into_func()\n                .unwrap()\n                .call(caller, &[], &mut [])?;\n            Ok(())\n        },\n    );\n\n    let instance = Instance::new(\n        &mut store,\n        &module,\n        &[host_func_a.into(), host_func_b.into()],\n    )?;\n    let a = instance.get_typed_func::<(), ()>(&mut store, \"a\")?;\n    let err = a.call(&mut store, ()).unwrap_err();\n    let trace = err.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert_eq!(trace.len(), 3);\n    assert_eq!(trace[0].func_name(), Some(\"c\"));\n    assert_eq!(trace[1].func_name(), Some(\"b\"));\n    assert_eq!(trace[2].func_name(), Some(\"a\"));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/settings.rs::len", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_trace_cb", "test": "fn test_trap_trace_cb() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module $hello_mod\n            (import \"\" \"throw\" (func $throw))\n            (func (export \"run\") (call $hello))\n            (func $hello (call $throw))\n        )\n    \"#;\n\n    let fn_type = FuncType::new(None, None);\n    let fn_func = Func::new(&mut store, fn_type, |_, _, _| bail!(\"cb throw\"));\n\n    let module = Module::new(store.engine(), wat)?;\n    let instance = Instance::new(&mut store, &module, &[fn_func.into()])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func.call(&mut store, ()).unwrap_err();\n\n    let trace = e.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert_eq!(trace.len(), 2);\n    assert_eq!(trace[0].module().name().unwrap(), \"hello_mod\");\n    assert_eq!(trace[0].func_index(), 2);\n    assert_eq!(trace[1].module().name().unwrap(), \"hello_mod\");\n    assert_eq!(trace[1].func_index(), 1);\n    assert!(format!(\"{e:?}\").contains(\"cb throw\"));\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/settings.rs::len", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::test_trap_stack_overflow", "test": "fn test_trap_stack_overflow() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let wat = r#\"\n        (module $rec_mod\n            (func $run (export \"run\") (call $run))\n        )\n    \"#;\n\n    let module = Module::new(store.engine(), wat)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func.call(&mut store, ()).unwrap_err();\n\n    let trace = e.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert!(trace.len() >= 32);\n    for i in 0..trace.len() {\n        assert_eq!(trace[i].module().name().unwrap(), \"rec_mod\");\n        assert_eq!(trace[i].func_index(), 0);\n        assert_eq!(trace[i].func_name(), Some(\"run\"));\n    }\n    assert_eq!(e.downcast::<Trap>()?, Trap::StackOverflow);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/settings.rs::len", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::trap_start_function_import", "test": "fn trap_start_function_import() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (import \"\" \"\" (func $foo))\n                (start $foo)\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let sig = FuncType::new(None, None);\n    let func = Func::new(&mut store, sig, |_, _, _| bail!(\"user trap\"));\n    let err = Instance::new(&mut store, &module, &[func.into()]).unwrap_err();\n    assert!(format!(\"{err:?}\").contains(\"user trap\"));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::rust_catch_panic_import", "test": "fn rust_catch_panic_import() -> Result<()> {\n    let mut store = Store::<()>::default();\n\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (import \"\" \"panic\" (func $panic))\n                (import \"\" \"catch panic\" (func $catch_panic))\n                (func (export \"panic\") call $panic)\n                (func (export \"run\")\n                  call $catch_panic\n                  call $catch_panic\n                  unreachable\n                )\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let num_panics = std::sync::Arc::new(std::sync::atomic::AtomicU32::new(0));\n    let sig = FuncType::new(None, None);\n    let panic = Func::new(&mut store, sig, {\n        let num_panics = num_panics.clone();\n        move |_, _, _| {\n            num_panics.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n            panic!(\"this is a panic\");\n        }\n    });\n    let catch_panic = Func::wrap(&mut store, |mut caller: Caller<'_, _>| {\n        panic::catch_unwind(AssertUnwindSafe(|| {\n            drop(\n                caller\n                    .get_export(\"panic\")\n                    .unwrap()\n                    .into_func()\n                    .unwrap()\n                    .call(&mut caller, &[], &mut []),\n            );\n        }))\n        .unwrap_err();\n    });\n\n    let instance = Instance::new(&mut store, &module, &[panic.into(), catch_panic.into()])?;\n    let run = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n    let trap = run.call(&mut store, ()).unwrap_err();\n    let trace = trap.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert_eq!(trace.len(), 1);\n    assert_eq!(trace[0].func_index(), 3);\n    assert_eq!(num_panics.load(std::sync::atomic::Ordering::SeqCst), 2);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/settings.rs::len", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::mismatched_arguments", "test": "fn mismatched_arguments() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (func (export \"foo\") (param i32))\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let func = instance.get_func(&mut store, \"foo\").unwrap();\n    assert_eq!(\n        func.call(&mut store, &[], &mut []).unwrap_err().to_string(),\n        \"expected 1 arguments, got 0\"\n    );\n    assert_eq!(\n        func.call(&mut store, &[Val::F32(0)], &mut [])\n            .unwrap_err()\n            .to_string(),\n        \"argument type mismatch: found f32 but expected i32\",\n    );\n    assert_eq!(\n        func.call(&mut store, &[Val::I32(0), Val::I32(1)], &mut [])\n            .unwrap_err()\n            .to_string(),\n        \"expected 1 arguments, got 2\"\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::call_signature_mismatch", "test": "fn call_signature_mismatch() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let binary = wat::parse_str(\n        r#\"\n            (module $a\n                (func $foo\n                    i32.const 0\n                    call_indirect)\n                (func $bar (param i32))\n                (start $foo)\n\n                (table 1 anyfunc)\n                (elem (i32.const 0) 1)\n            )\n        \"#,\n    )?;\n\n    let module = Module::new(store.engine(), &binary)?;\n    let err = Instance::new(&mut store, &module, &[])\n        .err()\n        .unwrap()\n        .downcast::<Trap>()\n        .unwrap();\n    assert!(err\n        .to_string()\n        .contains(\"wasm trap: indirect call type mismatch\"));\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::present_after_module_drop", "test": "fn present_after_module_drop() -> Result<()> {\n    let mut store = Store::<()>::default();\n    let module = Module::new(store.engine(), r#\"(func (export \"foo\") unreachable)\"#)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let func = instance.get_typed_func::<(), ()>(&mut store, \"foo\")?;\n\n    println!(\"asserting before we drop modules\");\n    assert_trap(func.call(&mut store, ()).unwrap_err());\n    drop((instance, module));\n\n    println!(\"asserting after drop\");\n    assert_trap(func.call(&mut store, ()).unwrap_err());\n    return Ok(());\n\n    fn assert_trap(t: Error) {\n        println!(\"{:?}\", t);\n        let trace = t.downcast_ref::<WasmBacktrace>().unwrap().frames();\n        assert_eq!(trace.len(), 1);\n        assert_eq!(trace[0].func_index(), 0);\n    }\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/settings.rs::len", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::parse_dwarf_info", "test": "fn parse_dwarf_info() -> Result<()> {\n    let wasm = rustc(\n        \"\n            fn main() {\n                panic!();\n            }\n        \",\n    );\n    let mut config = Config::new();\n    config.wasm_backtrace_details(WasmBacktraceDetails::Enable);\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, &wasm)?;\n    let mut linker = Linker::new(&engine);\n    wasmtime_wasi::add_to_linker(&mut linker, |s| s)?;\n    let mut store = Store::new(\n        &engine,\n        wasmtime_wasi::sync::WasiCtxBuilder::new()\n            .inherit_stdio()\n            .build(),\n    );\n    linker.module(&mut store, \"\", &module)?;\n    let run = linker.get_default(&mut store, \"\")?;\n    let trap = run.call(&mut store, &[], &mut []).unwrap_err();\n\n    let mut found = false;\n    let frames = trap.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    for frame in frames {\n        for symbol in frame.symbols() {\n            if let Some(file) = symbol.file() {\n                if file.ends_with(\"input.rs\") {\n                    found = true;\n                    assert!(symbol.name().unwrap().contains(\"main\"));\n                    assert_eq!(symbol.line(), Some(3));\n                }\n            }\n        }\n    }\n    assert!(found);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::traps_without_address_map", "test": "fn traps_without_address_map() -> Result<()> {\n    let mut config = Config::new();\n    config.generate_address_map(false);\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, ());\n    let wat = r#\"\n        (module $hello_mod\n            (func (export \"run\") (call $hello))\n            (func $hello (unreachable))\n        )\n    \"#;\n\n    let module = Module::new(store.engine(), wat)?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let run_func = instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n\n    let e = run_func.call(&mut store, ()).unwrap_err();\n\n    let trace = e.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert_eq!(trace.len(), 2);\n    assert_eq!(trace[0].func_name(), Some(\"hello\"));\n    assert_eq!(trace[0].func_index(), 1);\n    assert_eq!(trace[0].module_offset(), None);\n    assert_eq!(trace[1].func_name(), None);\n    assert_eq!(trace[1].func_index(), 0);\n    assert_eq!(trace[1].module_offset(), None);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/settings.rs::len", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::catch_trap_calling_across_stores", "test": "fn catch_trap_calling_across_stores() -> Result<()> {\n    let _ = env_logger::try_init();\n\n    let engine = Engine::default();\n\n    let mut child_store = Store::new(&engine, ());\n    let child_module = Module::new(\n        child_store.engine(),\n        r#\"\n            (module $child\n              (func $trap (export \"trap\")\n                unreachable\n              )\n            )\n        \"#,\n    )?;\n    let child_instance = Instance::new(&mut child_store, &child_module, &[])?;\n\n    struct ParentCtx {\n        child_store: Store<()>,\n        child_instance: Instance,\n    }\n\n    let mut linker = Linker::new(&engine);\n    linker.func_wrap(\n        \"host\",\n        \"catch_child_trap\",\n        move |mut caller: Caller<'_, ParentCtx>| {\n            let mut ctx = caller.as_context_mut();\n            let data = ctx.data_mut();\n            let func = data\n                .child_instance\n                .get_typed_func::<(), ()>(&mut data.child_store, \"trap\")\n                .expect(\"trap function should be exported\");\n\n            let trap = func.call(&mut data.child_store, ()).unwrap_err();\n            assert!(\n                format!(\"{trap:?}\").contains(\"unreachable\"),\n                \"trap should contain 'unreachable', got: {trap:?}\"\n            );\n\n            let trace = trap.downcast_ref::<WasmBacktrace>().unwrap().frames();\n\n            assert_eq!(trace.len(), 1);\n            assert_eq!(trace[0].func_name(), Some(\"trap\"));\n            // For now, we only get stack frames for Wasm in this store, not\n            // across all stores.\n            //\n            // assert_eq!(trace[1].func_name(), Some(\"run\"));\n\n            Ok(())\n        },\n    )?;\n\n    let mut store = Store::new(\n        &engine,\n        ParentCtx {\n            child_store,\n            child_instance,\n        },\n    );\n\n    let parent_module = Module::new(\n        store.engine(),\n        r#\"\n            (module $parent\n              (func $host.catch_child_trap (import \"host\" \"catch_child_trap\"))\n              (func $run (export \"run\")\n                call $host.catch_child_trap\n              )\n            )\n        \"#,\n    )?;\n\n    let parent_instance = linker.instantiate(&mut store, &parent_module)?;\n\n    let func = parent_instance.get_typed_func::<(), ()>(&mut store, \"run\")?;\n    func.call(store, ())?;\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::async_then_sync_trap", "test": "async fn async_then_sync_trap() -> Result<()> {\n    // Test the trapping and capturing the stack with the following sequence of\n    // calls:\n    //\n    // a[async] ---> b[host] ---> c[sync]\n\n    drop(env_logger::try_init());\n\n    let wat = r#\"\n        (module\n            (import \"\" \"b\" (func $b))\n            (func $a (export \"a\")\n                call $b\n            )\n            (func $c (export \"c\")\n                unreachable\n            )\n        )\n    \"#;\n\n    let mut sync_store = Store::new(&Engine::default(), ());\n\n    let sync_module = Module::new(sync_store.engine(), wat)?;\n\n    let mut sync_linker = Linker::new(sync_store.engine());\n    sync_linker.func_wrap(\"\", \"b\", |_caller: Caller<_>| unreachable!())?;\n\n    let sync_instance = sync_linker.instantiate(&mut sync_store, &sync_module)?;\n\n    struct AsyncCtx {\n        sync_instance: Instance,\n        sync_store: Store<()>,\n    }\n\n    let mut async_store = Store::new(\n        &Engine::new(Config::new().async_support(true)).unwrap(),\n        AsyncCtx {\n            sync_instance,\n            sync_store,\n        },\n    );\n\n    let async_module = Module::new(async_store.engine(), wat)?;\n\n    let mut async_linker = Linker::new(async_store.engine());\n    async_linker.func_wrap(\"\", \"b\", move |mut caller: Caller<AsyncCtx>| {\n        log::info!(\"Called `b`...\");\n        let sync_instance = caller.data().sync_instance;\n        let sync_store = &mut caller.data_mut().sync_store;\n\n        log::info!(\"Calling `c`...\");\n        let c = sync_instance\n            .get_typed_func::<(), ()>(&mut *sync_store, \"c\")\n            .unwrap();\n        c.call(sync_store, ())?;\n        Ok(())\n    })?;\n\n    let async_instance = async_linker\n        .instantiate_async(&mut async_store, &async_module)\n        .await?;\n\n    log::info!(\"Calling `a`...\");\n    let a = async_instance\n        .get_typed_func::<(), ()>(&mut async_store, \"a\")\n        .unwrap();\n    let trap = a.call_async(&mut async_store, ()).await.unwrap_err();\n\n    let trace = trap.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    // We don't support cross-store or cross-engine symbolication currently, so\n    // the other frames are ignored.\n    assert_eq!(trace.len(), 1);\n    assert_eq!(trace[0].func_name(), Some(\"c\"));\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/settings.rs::len", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::sync_then_async_trap", "test": "async fn sync_then_async_trap() -> Result<()> {\n    // Test the trapping and capturing the stack with the following sequence of\n    // calls:\n    //\n    // a[sync] ---> b[host] ---> c[async]\n\n    drop(env_logger::try_init());\n\n    let wat = r#\"\n        (module\n            (import \"\" \"b\" (func $b))\n            (func $a (export \"a\")\n                call $b\n            )\n            (func $c (export \"c\")\n                unreachable\n            )\n        )\n    \"#;\n\n    let mut async_store = Store::new(&Engine::new(Config::new().async_support(true)).unwrap(), ());\n\n    let async_module = Module::new(async_store.engine(), wat)?;\n\n    let mut async_linker = Linker::new(async_store.engine());\n    async_linker.func_wrap(\"\", \"b\", |_caller: Caller<_>| unreachable!())?;\n\n    let async_instance = async_linker\n        .instantiate_async(&mut async_store, &async_module)\n        .await?;\n\n    struct SyncCtx {\n        async_instance: Instance,\n        async_store: Store<()>,\n    }\n\n    let mut sync_store = Store::new(\n        &Engine::default(),\n        SyncCtx {\n            async_instance,\n            async_store,\n        },\n    );\n\n    let sync_module = Module::new(sync_store.engine(), wat)?;\n\n    let mut sync_linker = Linker::new(sync_store.engine());\n    sync_linker.func_wrap(\"\", \"b\", move |mut caller: Caller<SyncCtx>| -> Result<()> {\n        log::info!(\"Called `b`...\");\n        let async_instance = caller.data().async_instance;\n        let async_store = &mut caller.data_mut().async_store;\n\n        log::info!(\"Calling `c`...\");\n        let c = async_instance\n            .get_typed_func::<(), ()>(&mut *async_store, \"c\")\n            .unwrap();\n        tokio::task::block_in_place(|| {\n            tokio::runtime::Handle::current()\n                .block_on(async move { c.call_async(async_store, ()).await })\n        })?;\n        Ok(())\n    })?;\n\n    let sync_instance = sync_linker.instantiate(&mut sync_store, &sync_module)?;\n\n    log::info!(\"Calling `a`...\");\n    let a = sync_instance\n        .get_typed_func::<(), ()>(&mut sync_store, \"a\")\n        .unwrap();\n    let trap = a.call(&mut sync_store, ()).unwrap_err();\n\n    let trace = trap.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    // We don't support cross-store or cross-engine symbolication currently, so\n    // the other frames are ignored.\n    assert_eq!(trace.len(), 1);\n    assert_eq!(trace[0].func_name(), Some(\"c\"));\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/settings.rs::len", "code": "fn len(&self) -> usize {\n            self.hash_table.len()\n        }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::standalone_backtrace", "test": "fn standalone_backtrace() -> Result<()> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, ());\n    let trace = WasmBacktrace::capture(&store);\n    assert!(trace.frames().is_empty());\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (import \"\" \"\" (func $host))\n                (func $foo (export \"f\") call $bar)\n                (func $bar call $host)\n            )\n        \"#,\n    )?;\n    let func = Func::wrap(&mut store, |cx: Caller<'_, ()>| {\n        let trace = WasmBacktrace::capture(&cx);\n        assert_eq!(trace.frames().len(), 2);\n        let frame1 = &trace.frames()[0];\n        let frame2 = &trace.frames()[1];\n        assert_eq!(frame1.func_index(), 2);\n        assert_eq!(frame1.func_name(), Some(\"bar\"));\n        assert_eq!(frame2.func_index(), 1);\n        assert_eq!(frame2.func_name(), Some(\"foo\"));\n    });\n    let instance = Instance::new(&mut store, &module, &[func.into()])?;\n    let f = instance.get_typed_func::<(), ()>(&mut store, \"f\")?;\n    f.call(&mut store, ())?;\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::is_empty", "code": "pub fn is_empty(&self) -> bool {\n        self.root.is_none()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::div_plus_load_reported_right", "test": "fn div_plus_load_reported_right() -> Result<()> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, ());\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"memory\") 1)\n                (func (export \"i32.div_s\") (param i32 i32) (result i32)\n                    (i32.div_s (local.get 0) (i32.load (local.get 1))))\n                (func (export \"i32.div_u\") (param i32 i32) (result i32)\n                    (i32.div_u (local.get 0) (i32.load (local.get 1))))\n                (func (export \"i32.rem_s\") (param i32 i32) (result i32)\n                    (i32.rem_s (local.get 0) (i32.load (local.get 1))))\n                (func (export \"i32.rem_u\") (param i32 i32) (result i32)\n                    (i32.rem_u (local.get 0) (i32.load (local.get 1))))\n            )\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let memory = instance.get_memory(&mut store, \"memory\").unwrap();\n    let i32_div_s = instance.get_typed_func::<(i32, i32), i32>(&mut store, \"i32.div_s\")?;\n    let i32_div_u = instance.get_typed_func::<(u32, u32), u32>(&mut store, \"i32.div_u\")?;\n    let i32_rem_s = instance.get_typed_func::<(i32, i32), i32>(&mut store, \"i32.rem_s\")?;\n    let i32_rem_u = instance.get_typed_func::<(u32, u32), u32>(&mut store, \"i32.rem_u\")?;\n\n    memory.write(&mut store, 0, &1i32.to_le_bytes()).unwrap();\n    memory.write(&mut store, 4, &0i32.to_le_bytes()).unwrap();\n    memory.write(&mut store, 8, &(-1i32).to_le_bytes()).unwrap();\n\n    assert_eq!(i32_div_s.call(&mut store, (100, 0))?, 100);\n    assert_eq!(i32_div_u.call(&mut store, (101, 0))?, 101);\n    assert_eq!(i32_rem_s.call(&mut store, (102, 0))?, 0);\n    assert_eq!(i32_rem_u.call(&mut store, (103, 0))?, 0);\n\n    assert_trap(\n        i32_div_s.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n    assert_trap(\n        i32_div_u.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n    assert_trap(\n        i32_rem_s.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n    assert_trap(\n        i32_rem_u.call(&mut store, (100, 4)),\n        Trap::IntegerDivisionByZero,\n    );\n\n    assert_trap(\n        i32_div_s.call(&mut store, (i32::MIN, 8)),\n        Trap::IntegerOverflow,\n    );\n    assert_eq!(i32_rem_s.call(&mut store, (i32::MIN, 8))?, 0);\n\n    assert_trap(\n        i32_div_s.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n    assert_trap(\n        i32_div_u.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n    assert_trap(\n        i32_rem_s.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n    assert_trap(\n        i32_rem_u.call(&mut store, (100, 100_000)),\n        Trap::MemoryOutOfBounds,\n    );\n\n    return Ok(());\n\n    #[track_caller]\n    fn assert_trap<T>(result: Result<T>, expected: Trap) {\n        match result {\n            Ok(_) => panic!(\"expected failure\"),\n            Err(e) => {\n                if let Some(code) = e.downcast_ref::<Trap>() {\n                    if *code == expected {\n                        return;\n                    }\n                }\n                panic!(\"unexpected error {e:?}\");\n            }\n        }\n    }\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/meta/src/cdsl/instructions.rs::call", "code": "pub fn call(mut self) -> Self {\n        self.is_call = true;\n        self\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::wasm_fault_address_reported_by_default", "test": "fn wasm_fault_address_reported_by_default() -> Result<()> {\n    let engine = Engine::default();\n    let mut store = Store::new(&engine, ());\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory 1)\n                (func $start\n                    i32.const 0xdeadbeef\n                    i32.load\n                    drop)\n                (start $start)\n            )\n        \"#,\n    )?;\n    let err = Instance::new(&mut store, &module, &[]).unwrap_err();\n\n    // NB: at this time there's no programmatic access to the fault address\n    // because it's not always available for load/store traps. Only static\n    // memories on 32-bit have this information, but bounds-checked memories\n    // use manual trapping instructions and otherwise don't have a means of\n    // communicating the faulting address at this time.\n    //\n    // It looks like the exact reported fault address may not be deterministic,\n    // so assert that we have the right error message, but not the exact address.\n    let err = format!(\"{err:?}\");\n    assert!(\n        err.contains(\"memory fault at wasm address \")\n            && err.contains(\" in linear memory of size 0x10000\"),\n        \"bad error: {err}\"\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::dont_see_stale_stack_walking_registers", "test": "fn dont_see_stale_stack_walking_registers() -> Result<()> {\n    let engine = Engine::default();\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (import \"\" \"host_start\" (func $host_start))\n                (import \"\" \"host_get_trap\" (func $host_get_trap))\n                (export \"get_trap\" (func $host_get_trap))\n\n                ;; We enter and exit Wasm, which saves registers in the\n                ;; `VMRuntimeLimits`. Later, when we call a re-exported host\n                ;; function, we should not accidentally reuse those saved\n                ;; registers.\n                (start $start)\n                (func $start\n                    (call $host_start)\n                )\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n\n    let host_start = Func::new(\n        &mut store,\n        FuncType::new([], []),\n        |_caller, _args, _results| Ok(()),\n    );\n    linker.define(&store, \"\", \"host_start\", host_start)?;\n\n    let host_get_trap = Func::new(\n        &mut store,\n        FuncType::new([], []),\n        |_caller, _args, _results| Err(anyhow::anyhow!(\"trap!!!\")),\n    );\n    linker.define(&store, \"\", \"host_get_trap\", host_get_trap)?;\n\n    let instance = linker.instantiate(&mut store, &module)?;\n    let get_trap = instance.get_func(&mut store, \"get_trap\").unwrap();\n\n    let err = get_trap.call(&mut store, &[], &mut []).unwrap_err();\n    assert!(err.to_string().contains(\"trap!!!\"));\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/traps.rs::same_module_multiple_stores", "test": "fn same_module_multiple_stores() -> Result<()> {\n    let _ = env_logger::try_init();\n\n    let engine = Engine::default();\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (import \"\" \"f\" (func $f))\n                (import \"\" \"call_ref\" (func $call_ref (param funcref)))\n                (global $g (mut i32) (i32.const 0))\n                (func $a (export \"a\")\n                    call $b\n                )\n                (func $b\n                    call $c\n                )\n                (func $c\n                    global.get $g\n                    if\n                        call $f\n                    else\n                        i32.const 1\n                        global.set $g\n                        ref.func $a\n                        call $call_ref\n                    end\n                )\n            )\n        \"#,\n    )?;\n\n    let stacks = Arc::new(Mutex::new(vec![]));\n\n    let mut store3 = Store::new(&engine, ());\n    let f3 = Func::new(&mut store3, FuncType::new([], []), {\n        let stacks = stacks.clone();\n        move |caller, _params, _results| {\n            stacks\n                .lock()\n                .unwrap()\n                .push(WasmBacktrace::force_capture(caller));\n            Ok(())\n        }\n    });\n    let call_ref3 = Func::wrap(&mut store3, |caller: Caller<'_, _>, f: Option<Func>| {\n        f.unwrap().call(caller, &[], &mut [])\n    });\n    let instance3 = Instance::new(&mut store3, &module, &[f3.into(), call_ref3.into()])?;\n\n    let mut store2 = Store::new(&engine, store3);\n    let f2 = Func::new(&mut store2, FuncType::new([], []), {\n        let stacks = stacks.clone();\n        move |mut caller, _params, _results| {\n            stacks\n                .lock()\n                .unwrap()\n                .push(WasmBacktrace::force_capture(&mut caller));\n            instance3\n                .get_typed_func::<(), ()>(caller.data_mut(), \"a\")\n                .unwrap()\n                .call(caller.data_mut(), ())\n                .unwrap();\n            Ok(())\n        }\n    });\n    let call_ref2 = Func::wrap(&mut store2, |caller: Caller<'_, _>, f: Option<Func>| {\n        f.unwrap().call(caller, &[], &mut [])\n    });\n    let instance2 = Instance::new(&mut store2, &module, &[f2.into(), call_ref2.into()])?;\n\n    let mut store1 = Store::new(&engine, store2);\n    let f1 = Func::new(&mut store1, FuncType::new([], []), {\n        let stacks = stacks.clone();\n        move |mut caller, _params, _results| {\n            stacks\n                .lock()\n                .unwrap()\n                .push(WasmBacktrace::force_capture(&mut caller));\n            instance2\n                .get_typed_func::<(), ()>(caller.data_mut(), \"a\")\n                .unwrap()\n                .call(caller.data_mut(), ())\n                .unwrap();\n            Ok(())\n        }\n    });\n    let call_ref1 = Func::wrap(&mut store1, |caller: Caller<'_, _>, f: Option<Func>| {\n        f.unwrap().call(caller, &[], &mut [])\n    });\n    let instance1 = Instance::new(&mut store1, &module, &[f1.into(), call_ref1.into()])?;\n\n    instance1\n        .get_typed_func(&mut store1, \"a\")?\n        .call(&mut store1, ())?;\n\n    let expected_stacks = vec![\n        // [f1, c1, b1, a1, call_ref1, c1, b1, a1]\n        vec![\"c\", \"b\", \"a\", \"c\", \"b\", \"a\"],\n        // [f2, c2, b2, a2, call_ref2, c2, b2, a2, f1, c1, b1, a1, call_ref1, c1, b1, a1]\n        vec![\"c\", \"b\", \"a\", \"c\", \"b\", \"a\"],\n        // [f3, c3, b3, a3, call_ref3, c3, b3, a3, f2, c2, b2, a2, call_ref2, c2, b2, a2, f1, c1, b1, a1, call_ref1, c1, b1, a1]\n        vec![\"c\", \"b\", \"a\", \"c\", \"b\", \"a\"],\n    ];\n    eprintln!(\"expected = {expected_stacks:#?}\");\n    let actual_stacks = stacks.lock().unwrap();\n    eprintln!(\"actaul = {actual_stacks:#?}\");\n\n    assert_eq!(actual_stacks.len(), expected_stacks.len());\n    for (expected_stack, actual_stack) in expected_stacks.into_iter().zip(actual_stacks.iter()) {\n        assert_eq!(expected_stack.len(), actual_stack.frames().len());\n        for (expected_frame, actual_frame) in expected_stack.into_iter().zip(actual_stack.frames())\n        {\n            assert_eq!(actual_frame.func_name(), Some(expected_frame));\n        }\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/winch/codegen/src/stack.rs::len", "code": "pub fn len(&self) -> usize {\n        self.inner.len()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/aot.rs::bare_bones", "test": "fn bare_bones() -> Result<()> {\n    let engine = super::engine();\n    let component = Component::new(&engine, \"(component)\")?.serialize()?;\n    assert_eq!(component, engine.precompile_component(b\"(component)\")?);\n\n    let component = unsafe { Component::deserialize(&engine, &component)? };\n    let mut store = Store::new(&engine, ());\n    Linker::new(&engine).instantiate(&mut store, &component)?;\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/engine.rs::precompile_component", "code": "pub fn precompile_component(&self, bytes: &[u8]) -> Result<Vec<u8>> {\n        #[cfg(feature = \"wat\")]\n        let bytes = wat::parse_bytes(&bytes)?;\n        let (mmap, _) = crate::component::Component::build_artifacts(self, &bytes)?;\n        Ok(mmap.to_vec())\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/func.rs::integers", "test": "fn integers() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"take-i32-100\") (param i32)\n                    local.get 0\n                    i32.const 100\n                    i32.eq\n                    br_if 0\n                    unreachable\n                )\n                (func (export \"take-i64-100\") (param i64)\n                    local.get 0\n                    i64.const 100\n                    i64.eq\n                    br_if 0\n                    unreachable\n                )\n                (func (export \"ret-i32-0\") (result i32) i32.const 0)\n                (func (export \"ret-i64-0\") (result i64) i64.const 0)\n                (func (export \"ret-i32-minus-1\") (result i32) i32.const -1)\n                (func (export \"ret-i64-minus-1\") (result i64) i64.const -1)\n                (func (export \"ret-i32-100000\") (result i32) i32.const 100000)\n            )\n            (core instance $i (instantiate (module $m)))\n            (func (export \"take-u8\") (param \"a\" u8) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-s8\") (param \"a\" s8) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-u16\") (param \"a\" u16) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-s16\") (param \"a\" s16) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-u32\") (param \"a\" u32) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-s32\") (param \"a\" s32) (canon lift (core func $i \"take-i32-100\")))\n            (func (export \"take-u64\") (param \"a\" u64) (canon lift (core func $i \"take-i64-100\")))\n            (func (export \"take-s64\") (param \"a\" s64) (canon lift (core func $i \"take-i64-100\")))\n\n            (func (export \"ret-u8\") (result u8) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-s8\") (result s8) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-u16\") (result u16) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-s16\") (result s16) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-u32\") (result u32) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-s32\") (result s32) (canon lift (core func $i \"ret-i32-0\")))\n            (func (export \"ret-u64\") (result u64) (canon lift (core func $i \"ret-i64-0\")))\n            (func (export \"ret-s64\") (result s64) (canon lift (core func $i \"ret-i64-0\")))\n\n            (func (export \"retm1-u8\") (result u8) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-s8\") (result s8) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-u16\") (result u16) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-s16\") (result s16) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-u32\") (result u32) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-s32\") (result s32) (canon lift (core func $i \"ret-i32-minus-1\")))\n            (func (export \"retm1-u64\") (result u64) (canon lift (core func $i \"ret-i64-minus-1\")))\n            (func (export \"retm1-s64\") (result s64) (canon lift (core func $i \"ret-i64-minus-1\")))\n\n            (func (export \"retbig-u8\") (result u8) (canon lift (core func $i \"ret-i32-100000\")))\n            (func (export \"retbig-s8\") (result s8) (canon lift (core func $i \"ret-i32-100000\")))\n            (func (export \"retbig-u16\") (result u16) (canon lift (core func $i \"ret-i32-100000\")))\n            (func (export \"retbig-s16\") (result s16) (canon lift (core func $i \"ret-i32-100000\")))\n            (func (export \"retbig-u32\") (result u32) (canon lift (core func $i \"ret-i32-100000\")))\n            (func (export \"retbig-s32\") (result s32) (canon lift (core func $i \"ret-i32-100000\")))\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n    let new_instance = |store: &mut Store<()>| Linker::new(&engine).instantiate(store, &component);\n    let instance = new_instance(&mut store)?;\n\n    // Passing in 100 is valid for all primitives\n    instance\n        .get_typed_func::<(u8,), ()>(&mut store, \"take-u8\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(i8,), ()>(&mut store, \"take-s8\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(u16,), ()>(&mut store, \"take-u16\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(i16,), ()>(&mut store, \"take-s16\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(u32,), ()>(&mut store, \"take-u32\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(i32,), ()>(&mut store, \"take-s32\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(u64,), ()>(&mut store, \"take-u64\")?\n        .call_and_post_return(&mut store, (100,))?;\n    instance\n        .get_typed_func::<(i64,), ()>(&mut store, \"take-s64\")?\n        .call_and_post_return(&mut store, (100,))?;\n\n    // This specific wasm instance traps if any value other than 100 is passed\n    new_instance(&mut store)?\n        .get_typed_func::<(u8,), ()>(&mut store, \"take-u8\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(i8,), ()>(&mut store, \"take-s8\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(u16,), ()>(&mut store, \"take-u16\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(i16,), ()>(&mut store, \"take-s16\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(u32,), ()>(&mut store, \"take-u32\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(i32,), ()>(&mut store, \"take-s32\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(u64,), ()>(&mut store, \"take-u64\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n    new_instance(&mut store)?\n        .get_typed_func::<(i64,), ()>(&mut store, \"take-s64\")?\n        .call(&mut store, (101,))\n        .unwrap_err()\n        .downcast::<Trap>()?;\n\n    // Zero can be returned as any integer\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u8,)>(&mut store, \"ret-u8\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i8,)>(&mut store, \"ret-s8\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u16,)>(&mut store, \"ret-u16\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i16,)>(&mut store, \"ret-s16\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u32,)>(&mut store, \"ret-u32\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i32,)>(&mut store, \"ret-s32\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u64,)>(&mut store, \"ret-u64\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i64,)>(&mut store, \"ret-s64\")?\n            .call_and_post_return(&mut store, ())?,\n        (0,)\n    );\n\n    // Returning -1 should reinterpret the bytes as defined by each type.\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u8,)>(&mut store, \"retm1-u8\")?\n            .call_and_post_return(&mut store, ())?,\n        (0xff,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i8,)>(&mut store, \"retm1-s8\")?\n            .call_and_post_return(&mut store, ())?,\n        (-1,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u16,)>(&mut store, \"retm1-u16\")?\n            .call_and_post_return(&mut store, ())?,\n        (0xffff,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i16,)>(&mut store, \"retm1-s16\")?\n            .call_and_post_return(&mut store, ())?,\n        (-1,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u32,)>(&mut store, \"retm1-u32\")?\n            .call_and_post_return(&mut store, ())?,\n        (0xffffffff,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i32,)>(&mut store, \"retm1-s32\")?\n            .call_and_post_return(&mut store, ())?,\n        (-1,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u64,)>(&mut store, \"retm1-u64\")?\n            .call_and_post_return(&mut store, ())?,\n        (0xffffffff_ffffffff,)\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i64,)>(&mut store, \"retm1-s64\")?\n            .call_and_post_return(&mut store, ())?,\n        (-1,)\n    );\n\n    // Returning 100000 should chop off bytes as necessary\n    let ret: u32 = 100000;\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u8,)>(&mut store, \"retbig-u8\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret as u8,),\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i8,)>(&mut store, \"retbig-s8\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret as i8,),\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u16,)>(&mut store, \"retbig-u16\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret as u16,),\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i16,)>(&mut store, \"retbig-s16\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret as i16,),\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (u32,)>(&mut store, \"retbig-u32\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret,),\n    );\n    assert_eq!(\n        instance\n            .get_typed_func::<(), (i32,)>(&mut store, \"retbig-s32\")?\n            .call_and_post_return(&mut store, ())?,\n        (ret as i32,),\n    );\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/misc/component-test-util/src/lib.rs::call_and_post_return", "code": "fn call_and_post_return(&self, mut store: impl AsContextMut, params: P) -> Result<R> {\n        let result = self.call(&mut store, params)?;\n        self.post_return(&mut store)?;\n        Ok(result)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/func.rs::bools", "test": "fn bools() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"pass\") (param i32) (result i32) local.get 0)\n            )\n            (core instance $i (instantiate $m))\n\n            (func (export \"u32-to-bool\") (param \"a\" u32) (result bool)\n                (canon lift (core func $i \"pass\"))\n            )\n            (func (export \"bool-to-u32\") (param \"a\" bool) (result u32)\n                (canon lift (core func $i \"pass\"))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let u32_to_bool = instance.get_typed_func::<(u32,), (bool,)>(&mut store, \"u32-to-bool\")?;\n    let bool_to_u32 = instance.get_typed_func::<(bool,), (u32,)>(&mut store, \"bool-to-u32\")?;\n\n    assert_eq!(bool_to_u32.call(&mut store, (false,))?, (0,));\n    bool_to_u32.post_return(&mut store)?;\n    assert_eq!(bool_to_u32.call(&mut store, (true,))?, (1,));\n    bool_to_u32.post_return(&mut store)?;\n    assert_eq!(u32_to_bool.call(&mut store, (0,))?, (false,));\n    u32_to_bool.post_return(&mut store)?;\n    assert_eq!(u32_to_bool.call(&mut store, (1,))?, (true,));\n    u32_to_bool.post_return(&mut store)?;\n    assert_eq!(u32_to_bool.call(&mut store, (2,))?, (true,));\n    u32_to_bool.post_return(&mut store)?;\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/filetests/src/function_runner.rs::call", "code": "pub fn call(&self, arguments: &[DataValue]) -> Vec<DataValue> {\n        let mut values = UnboxedValues::make_arguments(arguments, &self.func_signature);\n        let arguments_address = values.as_mut_ptr();\n\n        let function_ptr = self.module.get_finalized_function(self.func_id);\n        let trampoline_ptr = self.module.get_finalized_function(self.trampoline_id);\n\n        let callable_trampoline: fn(*const u8, *mut u128) -> () =\n            unsafe { mem::transmute(trampoline_ptr) };\n        callable_trampoline(function_ptr, arguments_address);\n\n        values.collect_returns(&self.func_signature)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/func.rs::chars", "test": "fn chars() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"pass\") (param i32) (result i32) local.get 0)\n            )\n            (core instance $i (instantiate $m))\n\n            (func (export \"u32-to-char\") (param \"a\" u32) (result char)\n                (canon lift (core func $i \"pass\"))\n            )\n            (func (export \"char-to-u32\") (param \"a\" char) (result u32)\n                (canon lift (core func $i \"pass\"))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let u32_to_char = instance.get_typed_func::<(u32,), (char,)>(&mut store, \"u32-to-char\")?;\n    let char_to_u32 = instance.get_typed_func::<(char,), (u32,)>(&mut store, \"char-to-u32\")?;\n\n    let mut roundtrip = |x: char| -> Result<()> {\n        assert_eq!(char_to_u32.call(&mut store, (x,))?, (x as u32,));\n        char_to_u32.post_return(&mut store)?;\n        assert_eq!(u32_to_char.call(&mut store, (x as u32,))?, (x,));\n        u32_to_char.post_return(&mut store)?;\n        Ok(())\n    };\n\n    roundtrip('x')?;\n    roundtrip('a')?;\n    roundtrip('\\0')?;\n    roundtrip('\\n')?;\n    roundtrip('')?;\n\n    let u32_to_char = |store: &mut Store<()>| {\n        Linker::new(&engine)\n            .instantiate(&mut *store, &component)?\n            .get_typed_func::<(u32,), (char,)>(&mut *store, \"u32-to-char\")\n    };\n    let err = u32_to_char(&mut store)?\n        .call(&mut store, (0xd800,))\n        .unwrap_err();\n    assert!(err.to_string().contains(\"integer out of range\"), \"{}\", err);\n    let err = u32_to_char(&mut store)?\n        .call(&mut store, (0xdfff,))\n        .unwrap_err();\n    assert!(err.to_string().contains(\"integer out of range\"), \"{}\", err);\n    let err = u32_to_char(&mut store)?\n        .call(&mut store, (0x110000,))\n        .unwrap_err();\n    assert!(err.to_string().contains(\"integer out of range\"), \"{}\", err);\n    let err = u32_to_char(&mut store)?\n        .call(&mut store, (u32::MAX,))\n        .unwrap_err();\n    assert!(err.to_string().contains(\"integer out of range\"), \"{}\", err);\n\n    Ok(())\n}\n\n#", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/filetests/src/function_runner.rs::call", "code": "pub fn call(&self, arguments: &[DataValue]) -> Vec<DataValue> {\n        let mut values = UnboxedValues::make_arguments(arguments, &self.func_signature);\n        let arguments_address = values.as_mut_ptr();\n\n        let function_ptr = self.module.get_finalized_function(self.func_id);\n        let trampoline_ptr = self.module.get_finalized_function(self.trampoline_id);\n\n        let callable_trampoline: fn(*const u8, *mut u128) -> () =\n            unsafe { mem::transmute(trampoline_ptr) };\n        callable_trampoline(function_ptr, arguments_address);\n\n        values.collect_returns(&self.func_signature)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::simple", "test": "fn simple() -> Result<()> {\n    let component = r#\"\n        (component\n            (import \"a\" (func $log (param \"a\" string)))\n\n            (core module $libc\n                (memory (export \"memory\") 1)\n\n                (func (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n                    unreachable)\n            )\n            (core instance $libc (instantiate $libc))\n            (core func $log_lower\n                (canon lower (func $log) (memory $libc \"memory\") (realloc (func $libc \"realloc\")))\n            )\n            (core module $m\n                (import \"libc\" \"memory\" (memory 1))\n                (import \"host\" \"log\" (func $log (param i32 i32)))\n\n                (func (export \"call\")\n                    i32.const 5\n                    i32.const 11\n                    call $log)\n\n                (data (i32.const 5) \"hello world\")\n            )\n            (core instance $i (instantiate $m\n                (with \"libc\" (instance $libc))\n                (with \"host\" (instance (export \"log\" (func $log_lower))))\n            ))\n            (func (export \"call\")\n                (canon lift (core func $i \"call\"))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, None);\n    assert!(store.data().is_none());\n\n    // First, test the static API\n\n    let mut linker = Linker::new(&engine);\n    linker.root().func_wrap(\n        \"a\",\n        |mut store: StoreContextMut<'_, Option<String>>, (arg,): (WasmStr,)| -> Result<_> {\n            let s = arg.to_str(&store)?.to_string();\n            assert!(store.data().is_none());\n            *store.data_mut() = Some(s);\n            Ok(())\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    instance\n        .get_typed_func::<(), ()>(&mut store, \"call\")?\n        .call(&mut store, ())?;\n    assert_eq!(store.data().as_ref().unwrap(), \"hello world\");\n\n    // Next, test the dynamic API\n\n    *store.data_mut() = None;\n    let mut linker = Linker::new(&engine);\n    linker.root().func_new(\n        &component,\n        \"a\",\n        |mut store: StoreContextMut<'_, Option<String>>, args, _results| {\n            if let Val::String(s) = &args[0] {\n                assert!(store.data().is_none());\n                *store.data_mut() = Some(s.to_string());\n                Ok(())\n            } else {\n                panic!()\n            }\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    instance\n        .get_func(&mut store, \"call\")\n        .unwrap()\n        .call(&mut store, &[], &mut [])?;\n    assert_eq!(store.data().as_ref().unwrap(), \"hello world\");\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/packed_option.rs::is_none", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::functions_in_instances", "test": "fn functions_in_instances() -> Result<()> {\n    let component = r#\"\n        (component\n            (type $import-type (instance\n                (export \"a\" (func (param \"a\" string)))\n            ))\n            (import (interface \"test:test/foo\") (instance $import (type $import-type)))\n            (alias export $import \"a\" (func $log))\n\n            (core module $libc\n                (memory (export \"memory\") 1)\n\n                (func (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n                    unreachable)\n            )\n            (core instance $libc (instantiate $libc))\n            (core func $log_lower\n                (canon lower (func $log) (memory $libc \"memory\") (realloc (func $libc \"realloc\")))\n            )\n            (core module $m\n                (import \"libc\" \"memory\" (memory 1))\n                (import \"host\" \"log\" (func $log (param i32 i32)))\n\n                (func (export \"call\")\n                    i32.const 5\n                    i32.const 11\n                    call $log)\n\n                (data (i32.const 5) \"hello world\")\n            )\n            (core instance $i (instantiate $m\n                (with \"libc\" (instance $libc))\n                (with \"host\" (instance (export \"log\" (func $log_lower))))\n            ))\n            (func $call\n                (canon lift (core func $i \"call\"))\n            )\n            (component $c\n                (import \"import-call\" (func $f))\n                (export \"call\" (func $f))\n            )\n            (instance $export (instantiate $c\n                (with \"import-call\" (func $call))\n            ))\n            (export (interface \"test:test/foo\") (instance $export))\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, None);\n    assert!(store.data().is_none());\n\n    // First, test the static API\n\n    let mut linker = Linker::new(&engine);\n    linker.instance(\"test:test/foo\")?.func_wrap(\n        \"a\",\n        |mut store: StoreContextMut<'_, Option<String>>, (arg,): (WasmStr,)| -> Result<_> {\n            let s = arg.to_str(&store)?.to_string();\n            assert!(store.data().is_none());\n            *store.data_mut() = Some(s);\n            Ok(())\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    let func = instance\n        .exports(&mut store)\n        .instance(\"test:test/foo\")\n        .unwrap()\n        .typed_func::<(), ()>(\"call\")?;\n    func.call(&mut store, ())?;\n    assert_eq!(store.data().as_ref().unwrap(), \"hello world\");\n\n    // Next, test the dynamic API\n\n    *store.data_mut() = None;\n    let mut linker = Linker::new(&engine);\n    linker.instance(\"test:test/foo\")?.func_new(\n        &component,\n        \"a\",\n        |mut store: StoreContextMut<'_, Option<String>>, args, _results| {\n            if let Val::String(s) = &args[0] {\n                assert!(store.data().is_none());\n                *store.data_mut() = Some(s.to_string());\n                Ok(())\n            } else {\n                panic!()\n            }\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    let func = instance\n        .exports(&mut store)\n        .instance(\"test:test/foo\")\n        .unwrap()\n        .func(\"call\")\n        .unwrap();\n    func.call(&mut store, &[], &mut [])?;\n    assert_eq!(store.data().as_ref().unwrap(), \"hello world\");\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/packed_option.rs::is_none", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::attempt_to_leave_during_malloc", "test": "fn attempt_to_leave_during_malloc() -> Result<()> {\n    let component = r#\"\n(component\n  (import \"thunk\" (func $thunk))\n  (import \"ret-string\" (func $ret_string (result string)))\n\n  (core module $host_shim\n    (table (export \"table\") 2 funcref)\n    (func $shim_thunk (export \"thunk\")\n      i32.const 0\n      call_indirect)\n    (func $shim_ret_string (export \"ret-string\") (param i32)\n      local.get 0\n      i32.const 1\n      call_indirect (param i32))\n  )\n  (core instance $host_shim (instantiate $host_shim))\n\n  (core module $m\n    (import \"host\" \"thunk\" (func $thunk))\n    (import \"host\" \"ret-string\" (func $ret_string (param i32)))\n\n    (memory (export \"memory\") 1)\n\n    (func $realloc (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n      call $thunk\n      unreachable)\n\n    (func $run (export \"run\")\n      i32.const 8\n      call $ret_string)\n\n    (func (export \"take-string\") (param i32 i32)\n        unreachable)\n  )\n  (core instance $m (instantiate $m (with \"host\" (instance $host_shim))))\n\n  (core module $host_shim_filler_inner\n    (import \"shim\" \"table\" (table 2 funcref))\n    (import \"host\" \"thunk\" (func $thunk))\n    (import \"host\" \"ret-string\" (func $ret_string (param i32)))\n    (elem (i32.const 0) $thunk $ret_string)\n  )\n\n  (core func $thunk_lower\n    (canon lower (func $thunk) (memory $m \"memory\") (realloc (func $m \"realloc\")))\n  )\n\n  (core func $ret_string_lower\n    (canon lower (func $ret_string) (memory $m \"memory\") (realloc (func $m \"realloc\")))\n  )\n\n  (core instance (instantiate $host_shim_filler_inner\n    (with \"shim\" (instance $host_shim))\n    (with \"host\" (instance\n      (export \"thunk\" (func $thunk_lower))\n      (export \"ret-string\" (func $ret_string_lower))\n    ))\n  ))\n\n  (func (export \"run\")\n    (canon lift (core func $m \"run\"))\n  )\n  (func (export \"take-string\") (param \"a\" string)\n    (canon lift (core func $m \"take-string\") (memory $m \"memory\") (realloc (func $m \"realloc\")))\n  )\n)\n    \"#;\n\n    let engine = super::engine();\n    let mut linker = Linker::new(&engine);\n    linker.root().func_wrap(\"thunk\", |_, _: ()| -> Result<()> {\n        panic!(\"should not get here\")\n    })?;\n    linker\n        .root()\n        .func_wrap(\"ret-string\", |_, _: ()| -> Result<_> {\n            Ok((\"hello\".to_string(),))\n        })?;\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n\n    // Assert that during a host import if we return values to wasm that a trap\n    // happens if we try to leave the instance.\n    let trap = linker\n        .instantiate(&mut store, &component)?\n        .get_typed_func::<(), ()>(&mut store, \"run\")?\n        .call(&mut store, ())\n        .unwrap_err();\n    assert!(\n        format!(\"{trap:?}\").contains(\"cannot leave component instance\"),\n        \"bad trap: {trap:?}\",\n    );\n\n    let trace = trap.downcast_ref::<WasmBacktrace>().unwrap().frames();\n    assert_eq!(trace.len(), 4);\n\n    // This was our entry point...\n    assert_eq!(trace[3].module().name(), Some(\"m\"));\n    assert_eq!(trace[3].func_name(), Some(\"run\"));\n\n    // ... which called an imported function which ends up being originally\n    // defined by the shim instance. The shim instance then does an indirect\n    // call through a table which goes to the `canon.lower`'d host function\n    assert_eq!(trace[2].module().name(), Some(\"host_shim\"));\n    assert_eq!(trace[2].func_name(), Some(\"shim_ret_string\"));\n\n    // ... and the lowered host function will call realloc to allocate space for\n    // the result\n    assert_eq!(trace[1].module().name(), Some(\"m\"));\n    assert_eq!(trace[1].func_name(), Some(\"realloc\"));\n\n    // ... but realloc calls the shim instance and tries to exit the\n    // component, triggering a dynamic trap\n    assert_eq!(trace[0].module().name(), Some(\"host_shim\"));\n    assert_eq!(trace[0].func_name(), Some(\"shim_thunk\"));\n\n    // In addition to the above trap also ensure that when we enter a wasm\n    // component if we try to leave while lowering then that's also a dynamic\n    // trap.\n    let trap = linker\n        .instantiate(&mut store, &component)?\n        .get_typed_func::<(&str,), ()>(&mut store, \"take-string\")?\n        .call(&mut store, (\"x\",))\n        .unwrap_err();\n    assert!(\n        format!(\"{trap:?}\").contains(\"cannot leave component instance\"),\n        \"bad trap: {trap:?}\",\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::bad_import_alignment", "test": "fn bad_import_alignment() -> Result<()> {\n    let component = format!(\n        r#\"\n(component\n  (import \"unaligned-retptr\" (func $unaligned_retptr (result string)))\n  (type $many_arg (tuple\n    string string string string\n    string string string string\n    string\n  ))\n  (import \"unaligned-argptr\" (func $unaligned_argptr (param \"a\" $many_arg)))\n  (core module $libc_panic\n    (memory (export \"memory\") 1)\n    (func (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n      unreachable)\n  )\n  (core instance $libc_panic (instantiate $libc_panic))\n\n  (core func $unaligned_retptr_lower\n    (canon lower (func $unaligned_retptr) (memory $libc_panic \"memory\") (realloc (func $libc_panic \"realloc\")))\n  )\n  (core func $unaligned_argptr_lower\n    (canon lower (func $unaligned_argptr) (memory $libc_panic \"memory\") (realloc (func $libc_panic \"realloc\")))\n  )\n\n  (core module $m\n    (import \"host\" \"unaligned-retptr\" (func $unaligned_retptr (param i32)))\n    (import \"host\" \"unaligned-argptr\" (func $unaligned_argptr (param i32)))\n\n    (func (export \"unaligned-retptr\")\n     (call $unaligned_retptr (i32.const 1)))\n    (func (export \"unaligned-argptr\")\n     (call $unaligned_argptr (i32.const 1)))\n  )\n  (core instance $m (instantiate $m\n    (with \"host\" (instance\n      (export \"unaligned-retptr\" (func $unaligned_retptr_lower))\n      (export \"unaligned-argptr\" (func $unaligned_argptr_lower))\n    ))\n  ))\n\n  (func (export \"unaligned-retptr2\")\n    (canon lift (core func $m \"unaligned-retptr\"))\n  )\n  (func (export \"unaligned-argptr2\")\n    (canon lift (core func $m \"unaligned-argptr\"))\n  )\n)\n        \"#\n    );\n\n    let engine = super::engine();\n    let mut linker = Linker::new(&engine);\n    linker\n        .root()\n        .func_wrap(\"unaligned-retptr\", |_, _: ()| -> Result<(String,)> {\n            Ok((String::new(),))\n        })?;\n    linker.root().func_wrap(\n        \"unaligned-argptr\",\n        |_,\n         _: ((\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n            WasmStr,\n        ),)|\n         -> Result<()> { unreachable!() },\n    )?;\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n\n    let trap = linker\n        .instantiate(&mut store, &component)?\n        .get_typed_func::<(), ()>(&mut store, \"unaligned-retptr2\")?\n        .call(&mut store, ())\n        .unwrap_err();\n    assert!(\n        format!(\"{:?}\", trap).contains(\"pointer not aligned\"),\n        \"{}\",\n        trap\n    );\n    let trap = linker\n        .instantiate(&mut store, &component)?\n        .get_typed_func::<(), ()>(&mut store, \"unaligned-argptr2\")?\n        .call(&mut store, ())\n        .unwrap_err();\n    assert!(\n        format!(\"{:?}\", trap).contains(\"pointer not aligned\"),\n        \"{}\",\n        trap\n    );\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/import.rs::no_actual_wasm_code", "test": "fn no_actual_wasm_code() -> Result<()> {\n    let component = r#\"\n        (component\n            (import \"f\" (func $f))\n\n            (core func $f_lower\n                (canon lower (func $f))\n            )\n            (core module $m\n                (import \"\" \"\" (func $f))\n                (export \"f\" (func $f))\n            )\n            (core instance $i (instantiate $m\n                (with \"\" (instance\n                    (export \"\" (func $f_lower))\n                ))\n            ))\n            (func (export \"thunk\")\n                (canon lift\n                    (core func $i \"f\")\n                )\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, 0);\n\n    // First, test the static API\n\n    let mut linker = Linker::new(&engine);\n    linker.root().func_wrap(\n        \"f\",\n        |mut store: StoreContextMut<'_, u32>, _: ()| -> Result<()> {\n            *store.data_mut() += 1;\n            Ok(())\n        },\n    )?;\n\n    let instance = linker.instantiate(&mut store, &component)?;\n    let thunk = instance.get_typed_func::<(), ()>(&mut store, \"thunk\")?;\n\n    assert_eq!(*store.data(), 0);\n    thunk.call(&mut store, ())?;\n    assert_eq!(*store.data(), 1);\n\n    // Next, test the dynamic API\n\n    *store.data_mut() = 0;\n    let mut linker = Linker::new(&engine);\n    linker.root().func_new(\n        &component,\n        \"f\",\n        |mut store: StoreContextMut<'_, u32>, _, _| {\n            *store.data_mut() += 1;\n            Ok(())\n        },\n    )?;\n\n    let instance = linker.instantiate(&mut store, &component)?;\n    let thunk = instance.get_func(&mut store, \"thunk\").unwrap();\n\n    assert_eq!(*store.data(), 0);\n    thunk.call(&mut store, &[], &mut [])?;\n    assert_eq!(*store.data(), 1);\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::data", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/instance.rs::instance_exports", "test": "fn instance_exports() -> Result<()> {\n    let engine = super::engine();\n    let component = r#\"\n        (component\n            (import \"a\" (instance $i))\n            (import \"b\" (instance $i2 (export \"m\" (core module))))\n\n            (alias export $i2 \"m\" (core module $m))\n\n            (component $c\n                (component $c\n                    (export \"m\" (core module $m))\n                )\n                (instance $c (instantiate $c))\n                (export \"i\" (instance $c))\n            )\n            (instance $c (instantiate $c))\n            (export \"i\" (instance $c))\n            (export \"r\" (instance $i))\n            (export \"r2\" (instance $i2))\n        )\n    \"#;\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.instance(\"a\")?;\n    linker\n        .instance(\"b\")?\n        .module(\"m\", &Module::new(&engine, \"(module)\")?)?;\n    let instance = linker.instantiate(&mut store, &component)?;\n\n    let mut exports = instance.exports(&mut store);\n    assert!(exports.instance(\"not an instance\").is_none());\n    let mut i = exports.instance(\"r\").unwrap();\n    assert!(i.func(\"x\").is_none());\n    drop(i);\n    exports.root().instance(\"i\").unwrap();\n    let mut i2 = exports.instance(\"r2\").unwrap();\n    assert!(i2.func(\"m\").is_none());\n    assert!(i2.module(\"m\").is_some());\n    drop(i2);\n\n    exports\n        .instance(\"i\")\n        .unwrap()\n        .instance(\"i\")\n        .unwrap()\n        .module(\"m\")\n        .unwrap();\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/entity/src/packed_option.rs::is_none", "code": "pub fn is_none(&self) -> bool {\n        self.0.is_reserved_value()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/nested.rs::nested_many_instantiations", "test": "fn nested_many_instantiations() -> Result<()> {\n    let component = r#\"\n(component\n  (import \"count\" (func $count))\n  (component $c1\n    (import \"count\" (func $count))\n    (core func $count_lower (canon lower (func $count)))\n    (core module $m\n        (import \"\" \"\" (func $count))\n        (start $count)\n    )\n    (core instance (instantiate $m (with \"\" (instance (export \"\" (func $count_lower))))))\n    (core instance (instantiate $m (with \"\" (instance (export \"\" (func $count_lower))))))\n  )\n  (component $c2\n    (import \"count\" (func $count))\n    (instance (instantiate $c1 (with \"count\" (func $count))))\n    (instance (instantiate $c1 (with \"count\" (func $count))))\n  )\n  (component $c3\n    (import \"count\" (func $count))\n    (instance (instantiate $c2 (with \"count\" (func $count))))\n    (instance (instantiate $c2 (with \"count\" (func $count))))\n  )\n  (component $c4\n    (import \"count\" (func $count))\n    (instance (instantiate $c3 (with \"count\" (func $count))))\n    (instance (instantiate $c3 (with \"count\" (func $count))))\n  )\n\n  (instance (instantiate $c4 (with \"count\" (func $count))))\n)\n    \"#;\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, 0);\n    let mut linker = Linker::new(&engine);\n    linker\n        .root()\n        .func_wrap(\"count\", |mut store: StoreContextMut<'_, u32>, _: ()| {\n            *store.data_mut() += 1;\n            Ok(())\n        })?;\n    linker.instantiate(&mut store, &component)?;\n    assert_eq!(*store.data(), 16);\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::data", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/nested.rs::thread_options_through_inner", "test": "fn thread_options_through_inner() -> Result<()> {\n    let component = format!(\n        r#\"\n(component\n  (import \"hostfn\" (func $host (param \"a\" u32) (result string)))\n\n  (component $c\n    (import \"hostfn\" (func $host (param \"a\" u32) (result string)))\n\n    (core module $libc\n        (memory (export \"memory\") 1)\n        {REALLOC_AND_FREE}\n    )\n    (core instance $libc (instantiate $libc))\n\n    (core func $host_lower\n        (canon lower\n            (func $host)\n            (memory $libc \"memory\")\n            (realloc (func $libc \"realloc\"))\n        )\n    )\n\n    (core module $m\n        (import \"\" \"host\" (func $host (param i32 i32)))\n        (import \"libc\" \"memory\" (memory 1))\n        (func (export \"run\") (param i32) (result i32)\n            i32.const 42\n            i32.const 100\n            call $host\n            i32.const 100\n        )\n        (export \"memory\" (memory 0))\n    )\n    (core instance $m (instantiate $m\n        (with \"\" (instance (export \"host\" (func $host_lower))))\n        (with \"libc\" (instance $libc))\n    ))\n\n    (func (export \"run\") (param \"a\" u32) (result string)\n        (canon lift\n            (core func $m \"run\")\n            (memory $m \"memory\")\n        )\n    )\n  )\n  (instance $c (instantiate $c (with \"hostfn\" (func $host))))\n  (export \"run\" (func $c \"run\"))\n)\n    \"#\n    );\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, 0);\n    let mut linker = Linker::new(&engine);\n    linker\n        .root()\n        .func_wrap(\"hostfn\", |_, (param,): (u32,)| Ok((param.to_string(),)))?;\n    let instance = linker.instantiate(&mut store, &component)?;\n    let result = instance\n        .get_typed_func::<(u32,), (WasmStr,)>(&mut store, \"run\")?\n        .call(&mut store, (43,))?\n        .0;\n    assert_eq!(result.to_str(&store)?, \"42\");\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/component/func/typed.rs::to_str", "code": "pub fn to_str<'a, T: 'a>(&self, store: impl Into<StoreContext<'a, T>>) -> Result<Cow<'a, str>> {\n        let store = store.into().0;\n        let memory = self.options.memory(store);\n        self.to_str_from_memory(memory)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/post_return.rs::invoke_post_return", "test": "fn invoke_post_return() -> Result<()> {\n    let component = r#\"\n        (component\n            (import \"f\" (func $f))\n\n            (core func $f_lower\n                (canon lower (func $f))\n            )\n            (core module $m\n                (import \"\" \"\" (func $f))\n\n                (func (export \"thunk\"))\n\n                (func $post_return\n                    call $f)\n                (export \"post-return\" (func $post_return))\n            )\n            (core instance $i (instantiate $m\n                (with \"\" (instance\n                    (export \"\" (func $f_lower))\n                ))\n            ))\n            (func (export \"thunk\")\n                (canon lift\n                    (core func $i \"thunk\")\n                    (post-return (func $i \"post-return\"))\n                )\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, false);\n    let mut linker = Linker::new(&engine);\n    linker.root().func_wrap(\n        \"f\",\n        |mut store: StoreContextMut<'_, bool>, _: ()| -> Result<()> {\n            assert!(!*store.data());\n            *store.data_mut() = true;\n            Ok(())\n        },\n    )?;\n\n    let instance = linker.instantiate(&mut store, &component)?;\n    let thunk = instance.get_typed_func::<(), ()>(&mut store, \"thunk\")?;\n\n    assert!(!*store.data());\n    thunk.call(&mut store, ())?;\n    assert!(!*store.data());\n    thunk.post_return(&mut store)?;\n    assert!(*store.data());\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::data", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/post_return.rs::post_return_all_types", "test": "fn post_return_all_types() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (func (export \"i32\") (result i32)\n                    i32.const 1)\n                (func (export \"i64\") (result i64)\n                    i64.const 2)\n                (func (export \"f32\") (result f32)\n                    f32.const 3)\n                (func (export \"f64\") (result f64)\n                    f64.const 4)\n\n                (func (export \"post-i32\") (param i32)\n                    local.get 0\n                    i32.const 1\n                    i32.ne\n                    if unreachable end)\n                (func (export \"post-i64\") (param i64)\n                    local.get 0\n                    i64.const 2\n                    i64.ne\n                    if unreachable end)\n                (func (export \"post-f32\") (param f32)\n                    local.get 0\n                    f32.const 3\n                    f32.ne\n                    if unreachable end)\n                (func (export \"post-f64\") (param f64)\n                    local.get 0\n                    f64.const 4\n                    f64.ne\n                    if unreachable end)\n            )\n            (core instance $i (instantiate $m))\n            (func (export \"i32\") (result u32)\n                (canon lift (core func $i \"i32\") (post-return (func $i \"post-i32\")))\n            )\n            (func (export \"i64\") (result u64)\n                (canon lift (core func $i \"i64\") (post-return (func $i \"post-i64\")))\n            )\n            (func (export \"f32\") (result float32)\n                (canon lift (core func $i \"f32\") (post-return (func $i \"post-f32\")))\n            )\n            (func (export \"f64\") (result float64)\n                (canon lift (core func $i \"f64\") (post-return (func $i \"post-f64\")))\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, false);\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let i32 = instance.get_typed_func::<(), (u32,)>(&mut store, \"i32\")?;\n    let i64 = instance.get_typed_func::<(), (u64,)>(&mut store, \"i64\")?;\n    let f32 = instance.get_typed_func::<(), (f32,)>(&mut store, \"f32\")?;\n    let f64 = instance.get_typed_func::<(), (f64,)>(&mut store, \"f64\")?;\n\n    assert_eq!(i32.call(&mut store, ())?, (1,));\n    i32.post_return(&mut store)?;\n\n    assert_eq!(i64.call(&mut store, ())?, (2,));\n    i64.post_return(&mut store)?;\n\n    assert_eq!(f32.call(&mut store, ())?, (3.,));\n    f32.post_return(&mut store)?;\n\n    assert_eq!(f64.call(&mut store, ())?, (4.,));\n    f64.post_return(&mut store)?;\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/meta/src/cdsl/instructions.rs::call", "code": "pub fn call(mut self) -> Self {\n        self.is_call = true;\n        self\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/post_return.rs::post_return_string", "test": "fn post_return_string() -> Result<()> {\n    let component = r#\"\n        (component\n            (core module $m\n                (memory (export \"memory\") 1)\n                (func (export \"get\") (result i32)\n                    (i32.store offset=0 (i32.const 8) (i32.const 100))\n                    (i32.store offset=4 (i32.const 8) (i32.const 11))\n                    i32.const 8\n                )\n\n                (func (export \"post\") (param i32)\n                    local.get 0\n                    i32.const 8\n                    i32.ne\n                    if unreachable end)\n\n                (data (i32.const 100) \"hello world\")\n            )\n            (core instance $i (instantiate $m))\n            (func (export \"get\") (result string)\n                (canon lift\n                    (core func $i \"get\")\n                    (post-return (func $i \"post\"))\n                    (memory $i \"memory\")\n                )\n            )\n        )\n    \"#;\n\n    let engine = super::engine();\n    let component = Component::new(&engine, component)?;\n    let mut store = Store::new(&engine, false);\n    let instance = Linker::new(&engine).instantiate(&mut store, &component)?;\n    let get = instance.get_typed_func::<(), (WasmStr,)>(&mut store, \"get\")?;\n    let s = get.call(&mut store, ())?.0;\n    assert_eq!(s.to_str(&store)?, \"hello world\");\n    get.post_return(&mut store)?;\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/component/func/typed.rs::to_str", "code": "pub fn to_str<'a, T: 'a>(&self, store: impl Into<StoreContext<'a, T>>) -> Result<Cow<'a, str>> {\n        let store = store.into().0;\n        let memory = self.options.memory(store);\n        self.to_str_from_memory(memory)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::mismatch_intrinsics", "test": "fn mismatch_intrinsics() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n                (type $u' (resource (rep i32)))\n\n                (export $t \"t\" (type $t'))\n                (export $u \"u\" (type $u'))\n\n                ;; note the mismatch where this is an intrinsic for `u` but\n                ;; we're typing it as `t`\n                (core func $t_ctor (canon resource.new $u))\n\n                (func (export \"ctor\") (param \"x\" u32) (result (own $t))\n                    (canon lift (core func $t_ctor)))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let i = Linker::new(&engine).instantiate(&mut store, &c)?;\n    let ctor = i.get_typed_func::<(u32,), (ResourceAny,)>(&mut store, \"ctor\")?;\n    assert_eq!(\n        ctor.call(&mut store, (100,)).unwrap_err().to_string(),\n        \"unknown handle index 0\"\n    );\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::mismatch_resource_types", "test": "fn mismatch_resource_types() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n                (type $u' (resource (rep i32)))\n\n                (export $t \"t\" (type $t'))\n                (export $u \"u\" (type $u'))\n\n                (core func $t_ctor (canon resource.new $t))\n                (func (export \"ctor\") (param \"x\" u32) (result (own $t))\n                    (canon lift (core func $t_ctor)))\n\n                (core func $u_dtor (canon resource.drop $u))\n                (func (export \"dtor\") (param \"x\" (own $u))\n                    (canon lift (core func $u_dtor)))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let i = Linker::new(&engine).instantiate(&mut store, &c)?;\n    let ctor = i.get_typed_func::<(u32,), (ResourceAny,)>(&mut store, \"ctor\")?;\n    let dtor = i.get_typed_func::<(ResourceAny,), ()>(&mut store, \"dtor\")?;\n\n    let (t,) = ctor.call(&mut store, (100,))?;\n    ctor.post_return(&mut store)?;\n    assert_eq!(\n        dtor.call(&mut store, (t,)).unwrap_err().to_string(),\n        \"mismatched resource types\"\n    );\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-preview1-component-adapter/byte-array-literals/src/lib.rs::to_string", "code": "fn to_string(lit: Literal) -> String {\n    let formatted = lit.to_string();\n\n    let mut it = formatted.chars();\n    assert_eq!(it.next(), Some('\"'));\n\n    let mut rv = String::new();\n    loop {\n        match it.next() {\n            Some('\"') => match it.next() {\n                Some(_) => panic!(),\n                None => break,\n            },\n            Some('\\\\') => match it.next() {\n                Some('x') => {\n                    let hi = it.next().unwrap().to_digit(16).unwrap();\n                    let lo = it.next().unwrap().to_digit(16).unwrap();\n                    let v = (hi << 16) | lo;\n                    rv.push(v as u8 as char);\n                }\n                Some('u') => {\n                    assert_eq!(it.next(), Some('{'));\n                    let mut c = it.next().unwrap();\n                    let mut ch = 0;\n                    while let Some(v) = c.to_digit(16) {\n                        ch *= 16;\n                        ch |= v;\n                        c = it.next().unwrap();\n                    }\n                    assert_eq!(c, '}');\n                    rv.push(::std::char::from_u32(ch).unwrap());\n                }\n                Some('0') => rv.push('\\0'),\n                Some('\\\\') => rv.push('\\\\'),\n                Some('\\\"') => rv.push('\\\"'),\n                Some('r') => rv.push('\\r'),\n                Some('n') => rv.push('\\n'),\n                Some('t') => rv.push('\\t'),\n                Some(_) => panic!(),\n                None => panic!(),\n            },\n            Some(c) => rv.push(c),\n            None => panic!(),\n        }\n    }\n\n    rv\n}", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::drop_guest_twice", "test": "fn drop_guest_twice() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n\n                (export $t \"t\" (type $t'))\n\n                (core func $ctor (canon resource.new $t))\n                (func (export \"ctor\") (param \"x\" u32) (result (own $t))\n                    (canon lift (core func $ctor)))\n\n                (core func $dtor (canon resource.drop $t))\n                (func (export \"dtor\") (param \"x\" (own $t))\n                    (canon lift (core func $dtor)))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let i = Linker::new(&engine).instantiate(&mut store, &c)?;\n    let ctor = i.get_typed_func::<(u32,), (ResourceAny,)>(&mut store, \"ctor\")?;\n    let dtor = i.get_typed_func::<(&ResourceAny,), ()>(&mut store, \"dtor\")?;\n\n    let (t,) = ctor.call(&mut store, (100,))?;\n    ctor.post_return(&mut store)?;\n    dtor.call(&mut store, (&t,))?;\n    dtor.post_return(&mut store)?;\n\n    assert_eq!(\n        dtor.call(&mut store, (&t,)).unwrap_err().to_string(),\n        \"unknown handle index 0\"\n    );\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-preview1-component-adapter/byte-array-literals/src/lib.rs::to_string", "code": "fn to_string(lit: Literal) -> String {\n    let formatted = lit.to_string();\n\n    let mut it = formatted.chars();\n    assert_eq!(it.next(), Some('\"'));\n\n    let mut rv = String::new();\n    loop {\n        match it.next() {\n            Some('\"') => match it.next() {\n                Some(_) => panic!(),\n                None => break,\n            },\n            Some('\\\\') => match it.next() {\n                Some('x') => {\n                    let hi = it.next().unwrap().to_digit(16).unwrap();\n                    let lo = it.next().unwrap().to_digit(16).unwrap();\n                    let v = (hi << 16) | lo;\n                    rv.push(v as u8 as char);\n                }\n                Some('u') => {\n                    assert_eq!(it.next(), Some('{'));\n                    let mut c = it.next().unwrap();\n                    let mut ch = 0;\n                    while let Some(v) = c.to_digit(16) {\n                        ch *= 16;\n                        ch |= v;\n                        c = it.next().unwrap();\n                    }\n                    assert_eq!(c, '}');\n                    rv.push(::std::char::from_u32(ch).unwrap());\n                }\n                Some('0') => rv.push('\\0'),\n                Some('\\\\') => rv.push('\\\\'),\n                Some('\\\"') => rv.push('\\\"'),\n                Some('r') => rv.push('\\r'),\n                Some('n') => rv.push('\\n'),\n                Some('t') => rv.push('\\t'),\n                Some(_) => panic!(),\n                None => panic!(),\n            },\n            Some(c) => rv.push(c),\n            None => panic!(),\n        }\n    }\n\n    rv\n}", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::drop_host_twice", "test": "fn drop_host_twice() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n\n                (core func $dtor (canon resource.drop $t))\n                (func (export \"dtor\") (param \"x\" (own $t))\n                    (canon lift (core func $dtor)))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n    let dtor = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"dtor\")?;\n\n    let t = Resource::new_own(100);\n    dtor.call(&mut store, (&t,))?;\n    dtor.post_return(&mut store)?;\n\n    assert_eq!(\n        dtor.call(&mut store, (&t,)).unwrap_err().to_string(),\n        \"host resource already consumed\"\n    );\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasi-preview1-component-adapter/byte-array-literals/src/lib.rs::to_string", "code": "fn to_string(lit: Literal) -> String {\n    let formatted = lit.to_string();\n\n    let mut it = formatted.chars();\n    assert_eq!(it.next(), Some('\"'));\n\n    let mut rv = String::new();\n    loop {\n        match it.next() {\n            Some('\"') => match it.next() {\n                Some(_) => panic!(),\n                None => break,\n            },\n            Some('\\\\') => match it.next() {\n                Some('x') => {\n                    let hi = it.next().unwrap().to_digit(16).unwrap();\n                    let lo = it.next().unwrap().to_digit(16).unwrap();\n                    let v = (hi << 16) | lo;\n                    rv.push(v as u8 as char);\n                }\n                Some('u') => {\n                    assert_eq!(it.next(), Some('{'));\n                    let mut c = it.next().unwrap();\n                    let mut ch = 0;\n                    while let Some(v) = c.to_digit(16) {\n                        ch *= 16;\n                        ch |= v;\n                        c = it.next().unwrap();\n                    }\n                    assert_eq!(c, '}');\n                    rv.push(::std::char::from_u32(ch).unwrap());\n                }\n                Some('0') => rv.push('\\0'),\n                Some('\\\\') => rv.push('\\\\'),\n                Some('\\\"') => rv.push('\\\"'),\n                Some('r') => rv.push('\\r'),\n                Some('n') => rv.push('\\n'),\n                Some('t') => rv.push('\\t'),\n                Some(_) => panic!(),\n                None => panic!(),\n            },\n            Some(c) => rv.push(c),\n            None => panic!(),\n        }\n    }\n\n    rv\n}", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::manually_destroy", "test": "fn manually_destroy() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t1\" (type $t1 (sub resource)))\n\n                (core module $m\n                  (global $drops (mut i32) i32.const 0)\n                  (global $last-drop (mut i32) i32.const 0)\n\n                  (func (export \"dtor\") (param i32)\n                    (global.set $drops (i32.add (global.get $drops) (i32.const 1)))\n                    (global.set $last-drop (local.get 0))\n                  )\n                  (func (export \"drops\") (result i32) global.get $drops)\n                  (func (export \"last-drop\") (result i32) global.get $last-drop)\n                  (func (export \"pass\") (param i32) (result i32) local.get 0)\n                )\n                (core instance $i (instantiate $m))\n                (type $t2' (resource (rep i32) (dtor (func $i \"dtor\"))))\n                (export $t2 \"t2\" (type $t2'))\n                (core func $ctor (canon resource.new $t2))\n                (func (export \"[constructor]t2\") (param \"rep\" u32) (result (own $t2))\n                  (canon lift (core func $ctor)))\n                (func (export \"[static]t2.drops\") (result u32)\n                  (canon lift (core func $i \"drops\")))\n                (func (export \"[static]t2.last-drop\") (result u32)\n                  (canon lift (core func $i \"last-drop\")))\n\n                (func (export \"t1-pass\") (param \"t\" (own $t1)) (result (own $t1))\n                  (canon lift (core func $i \"pass\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    #[derive(Default)]\n    struct Data {\n        drops: u32,\n        last_drop: Option<u32>,\n    }\n\n    let mut store = Store::new(&engine, Data::default());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t1\", |mut cx, rep| {\n        let data: &mut Data = cx.data_mut();\n        data.drops += 1;\n        data.last_drop = Some(rep);\n        Ok(())\n    })?;\n    let i = linker.instantiate(&mut store, &c)?;\n    let t2_ctor = i.get_typed_func::<(u32,), (ResourceAny,)>(&mut store, \"[constructor]t2\")?;\n    let t2_drops = i.get_typed_func::<(), (u32,)>(&mut store, \"[static]t2.drops\")?;\n    let t2_last_drop = i.get_typed_func::<(), (u32,)>(&mut store, \"[static]t2.last-drop\")?;\n    let t1_pass = i.get_typed_func::<(Resource<MyType>,), (ResourceAny,)>(&mut store, \"t1-pass\")?;\n\n    // Host resources can be destroyed through `resource_drop`\n    let t1 = Resource::new_own(100);\n    let (t1,) = t1_pass.call(&mut store, (t1,))?;\n    t1_pass.post_return(&mut store)?;\n    assert_eq!(store.data().drops, 0);\n    assert_eq!(store.data().last_drop, None);\n    t1.resource_drop(&mut store)?;\n    assert_eq!(store.data().drops, 1);\n    assert_eq!(store.data().last_drop, Some(100));\n\n    // Guest resources can be destroyed through `resource_drop`\n    let (t2,) = t2_ctor.call(&mut store, (200,))?;\n    t2_ctor.post_return(&mut store)?;\n    assert_eq!(t2_drops.call(&mut store, ())?, (0,));\n    t2_drops.post_return(&mut store)?;\n    assert_eq!(t2_last_drop.call(&mut store, ())?, (0,));\n    t2_last_drop.post_return(&mut store)?;\n    t2.resource_drop(&mut store)?;\n    assert_eq!(t2_drops.call(&mut store, ())?, (1,));\n    t2_drops.post_return(&mut store)?;\n    assert_eq!(t2_last_drop.call(&mut store, ())?, (200,));\n    t2_last_drop.post_return(&mut store)?;\n\n    // Wires weren't crossed to drop more resources\n    assert_eq!(store.data().drops, 1);\n    assert_eq!(store.data().last_drop, Some(100));\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/store.rs::data", "code": "pub fn data(&self) -> &T {\n        self.inner.data()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::dynamic_val", "test": "fn dynamic_val() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t1\" (type $t1 (sub resource)))\n                (type $t2' (resource (rep i32)))\n                (export $t2 \"t2\" (type $t2'))\n                (core func $f (canon resource.new $t2))\n\n                (core module $m\n                    (func (export \"pass\") (param i32) (result i32)\n                        (local.get 0)))\n                (core instance $i (instantiate $m))\n\n                (func (export \"a\") (param \"x\" (own $t1)) (result (own $t1))\n                    (canon lift (core func $i \"pass\")))\n                (func (export \"b\") (param \"x\" u32) (result (own $t2))\n                    (canon lift (core func $f)))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t1\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let a = i.get_func(&mut store, \"a\").unwrap();\n    let a_typed = i.get_typed_func::<(Resource<MyType>,), (ResourceAny,)>(&mut store, \"a\")?;\n    let b = i.get_func(&mut store, \"b\").unwrap();\n    let t2 = i.get_resource(&mut store, \"t2\").unwrap();\n\n    let t1 = Resource::new_own(100);\n    let (t1,) = a_typed.call(&mut store, (t1,))?;\n    a_typed.post_return(&mut store)?;\n    assert_eq!(t1.ty(), ResourceType::host::<MyType>());\n\n    let mut results = [Val::Bool(false)];\n    a.call(&mut store, &[Val::Resource(t1)], &mut results)?;\n    a.post_return(&mut store)?;\n    match &results[0] {\n        Val::Resource(resource) => {\n            assert_eq!(resource.ty(), ResourceType::host::<MyType>());\n        }\n        _ => unreachable!(),\n    }\n\n    b.call(&mut store, &[Val::U32(200)], &mut results)?;\n    match &results[0] {\n        Val::Resource(resource) => {\n            assert_eq!(resource.ty(), t2);\n        }\n        _ => unreachable!(),\n    }\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/data_value.rs::ty", "code": "pub fn ty(&self) -> Type {\n        match self {\n            DataValue::I8(_) => types::I8,\n            DataValue::I16(_) => types::I16,\n            DataValue::I32(_) => types::I32,\n            DataValue::I64(_) => types::I64,\n            DataValue::I128(_) => types::I128,\n            DataValue::F32(_) => types::F32,\n            DataValue::F64(_) => types::F64,\n            DataValue::V128(_) => types::I8X16, // A default type.\n            DataValue::V64(_) => types::I8X8,   // A default type.\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::active_borrows_at_end_of_call", "test": "fn active_borrows_at_end_of_call() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n\n                (core module $m\n                    (func (export \"f\") (param i32))\n                )\n                (core instance $i (instantiate $m))\n\n                (func (export \"f\") (param \"x\" (borrow $t))\n                    (canon lift (core func $i \"f\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f\")?;\n\n    let resource = Resource::new_own(1);\n    f.call(&mut store, (&resource,))?;\n    let err = f.post_return(&mut store).unwrap_err();\n    assert_eq!(\n        err.to_string(),\n        \"borrow handles still remain at the end of the call\",\n    );\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::thread_through_borrow", "test": "fn thread_through_borrow() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (import \"f\" (func $f (param \"x\" (borrow $t))))\n\n                (core func $f (canon lower (func $f)))\n                (core func $drop (canon resource.drop $t))\n\n                (core module $m\n                    (import \"\" \"f\" (func $f (param i32)))\n                    (import \"\" \"drop\" (func $drop (param i32)))\n                    (func (export \"f2\") (param i32)\n                        (call $f (local.get 0))\n                        (call $f (local.get 0))\n                        (call $drop (local.get 0))\n                    )\n                )\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"f\" (func $f))\n                        (export \"drop\" (func $drop))\n                    ))\n                ))\n\n                (func (export \"f2\") (param \"x\" (borrow $t))\n                    (canon lift (core func $i \"f2\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    linker\n        .root()\n        .func_wrap(\"f\", |_cx, (r,): (Resource<MyType>,)| {\n            assert!(!r.owned());\n            assert_eq!(r.rep(), 100);\n            Ok(())\n        })?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f2\")?;\n\n    let resource = Resource::new_own(100);\n    f.call(&mut store, (&resource,))?;\n    f.post_return(&mut store)?;\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/component/resources.rs::owned", "code": "pub fn owned(&self) -> bool {\n        match self.state.load(Relaxed) {\n            BORROW => false,\n            _ => true,\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::cannot_use_borrow_for_own", "test": "fn cannot_use_borrow_for_own() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n\n                (core module $m\n                    (func (export \"f\") (param i32) (result i32)\n                        local.get 0\n                    )\n                )\n                (core instance $i (instantiate $m))\n\n                (func (export \"f\") (param \"x\" (borrow $t)) (result (own $t))\n                    (canon lift (core func $i \"f\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>,), (Resource<MyType>,)>(&mut store, \"f\")?;\n\n    let resource = Resource::new_own(100);\n    let err = f.call(&mut store, (&resource,)).unwrap_err();\n    assert_eq!(err.to_string(), \"cannot lift own resource from a borrow\");\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::passthrough_wrong_type", "test": "fn passthrough_wrong_type() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (import \"f\" (func $f (param \"a\" (borrow $t)) (result (own $t))))\n\n                (core func $f (canon lower (func $f)))\n\n                (core module $m\n                    (import \"\" \"f\" (func $f (param i32) (result i32)))\n                    (func (export \"f2\") (param i32)\n                        (drop (call $f (local.get 0)))\n                    )\n                )\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"f\" (func $f))\n                    ))\n                ))\n\n                (func (export \"f2\") (param \"x\" (borrow $t))\n                    (canon lift (core func $i \"f2\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    linker\n        .root()\n        .func_wrap(\"f\", |_cx, (r,): (Resource<MyType>,)| Ok((r,)))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f2\")?;\n\n    let resource = Resource::new_own(100);\n    let err = f.call(&mut store, (&resource,)).unwrap_err();\n    assert!(\n        format!(\"{err:?}\").contains(\"cannot lower a `borrow` resource into an `own`\"),\n        \"bad error: {err:?}\"\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::pass_moved_resource", "test": "fn pass_moved_resource() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (core module $m\n                    (func (export \"f\") (param i32 i32))\n                )\n                (core instance $i (instantiate $m))\n\n                (func (export \"f\") (param \"x\" (own $t)) (param \"y\" (borrow $t))\n                    (canon lift (core func $i \"f\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    let i = linker.instantiate(&mut store, &c)?;\n\n    let f = i.get_typed_func::<(&Resource<MyType>, &Resource<MyType>), ()>(&mut store, \"f\")?;\n\n    let resource = Resource::new_own(100);\n    let err = f.call(&mut store, (&resource, &resource)).unwrap_err();\n    assert!(\n        format!(\"{err:?}\").contains(\"host resource already consumed\"),\n        \"bad error: {err:?}\"\n    );\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::host_borrow_as_resource_any", "test": "fn host_borrow_as_resource_any() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (import \"f\" (func $f (param \"f\" (borrow $t))))\n\n                (core func $f (canon lower (func $f)))\n\n                (core module $m\n                    (import \"\" \"f\" (func $f (param i32)))\n                    (func (export \"f2\") (param i32)\n                        (call $f (local.get 0))\n                    )\n                )\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"f\" (func $f))\n                    ))\n                ))\n\n                (func (export \"f2\") (param \"x\" (borrow $t))\n                    (canon lift (core func $i \"f2\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n\n    // First test the above component where the host properly drops the argument\n    {\n        let mut linker = Linker::new(&engine);\n        linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n        linker\n            .root()\n            .func_wrap(\"f\", |mut cx, (r,): (ResourceAny,)| {\n                r.resource_drop(&mut cx)?;\n                Ok(())\n            })?;\n        let i = linker.instantiate(&mut store, &c)?;\n\n        let f = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f2\")?;\n\n        let resource = Resource::new_own(100);\n        f.call(&mut store, (&resource,))?;\n    }\n\n    // Then also test the case where the host forgets a drop\n    {\n        let mut linker = Linker::new(&engine);\n        linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n        linker.root().func_wrap(\"f\", |_cx, (_r,): (ResourceAny,)| {\n            // ... no drop here\n            Ok(())\n        })?;\n        let i = linker.instantiate(&mut store, &c)?;\n\n        let f = i.get_typed_func::<(&Resource<MyType>,), ()>(&mut store, \"f2\")?;\n\n        let resource = Resource::new_own(100);\n        let err = f.call(&mut store, (&resource,)).unwrap_err();\n        assert!(\n            format!(\"{err:?}\").contains(\"borrow handles still remain at the end of the call\"),\n            \"bad error: {err:?}\"\n        );\n    }\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/bforest/src/set.rs::contains", "code": "pub fn contains<C: Comparator<K>>(&self, key: K, forest: &SetForest<K>, comp: &C) -> bool {\n        self.root\n            .expand()\n            .and_then(|root| Path::default().find(key, root, &forest.nodes, comp))\n            .is_some()\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::pass_guest_back_as_borrow", "test": "fn pass_guest_back_as_borrow() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (type $t' (resource (rep i32)))\n\n                (export $t \"t\" (type $t'))\n\n                (core func $new (canon resource.new $t))\n\n                (core module $m\n                    (import \"\" \"new\" (func $new (param i32) (result i32)))\n\n                    (func (export \"mk\") (result i32)\n                        (call $new (i32.const 100))\n                    )\n\n                    (func (export \"take\") (param i32)\n                        (if (i32.ne (local.get 0) (i32.const 100)) (then (unreachable)))\n                    )\n                )\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"new\" (func $new))\n                    ))\n                ))\n\n                (func (export \"mk\") (result (own $t))\n                    (canon lift (core func $i \"mk\")))\n                (func (export \"take\") (param \"x\" (borrow $t))\n                    (canon lift (core func $i \"take\")))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let i = Linker::new(&engine).instantiate(&mut store, &c)?;\n    let mk = i.get_typed_func::<(), (ResourceAny,)>(&mut store, \"mk\")?;\n    let take = i.get_typed_func::<(&ResourceAny,), ()>(&mut store, \"take\")?;\n\n    let (resource,) = mk.call(&mut store, ())?;\n    mk.post_return(&mut store)?;\n    take.call(&mut store, (&resource,))?;\n    take.post_return(&mut store)?;\n\n    resource.resource_drop(&mut store)?;\n\n    // Should not be valid to use `resource` again\n    let err = take.call(&mut store, (&resource,)).unwrap_err();\n    assert_eq!(err.to_string(), \"unknown handle index 0\");\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/cranelift/codegen/src/machinst/buffer.rs::to_string", "code": "pub fn to_string(&self) -> String {\n        format!(\"label{}\", self.0)\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::drop_on_owned_resource", "test": "fn drop_on_owned_resource() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t\" (type $t (sub resource)))\n                (import \"[constructor]t\" (func $ctor (result (own $t))))\n                (import \"[method]t.foo\" (func $foo (param \"self\" (borrow $t)) (result (list u8))))\n\n                (core func $ctor (canon lower (func $ctor)))\n                (core func $drop (canon resource.drop $t))\n\n                (core module $m1\n                    (import \"\" \"drop\" (func $drop (param i32)))\n                    (memory (export \"memory\") 1)\n                    (global $to-drop (export \"to-drop\") (mut i32) (i32.const 0))\n                    (func (export \"realloc\") (param i32 i32 i32 i32) (result i32)\n                        (call $drop (global.get $to-drop))\n                        unreachable)\n                )\n                (core instance $i1 (instantiate $m1\n                    (with \"\" (instance\n                        (export \"drop\" (func $drop))\n                    ))\n                ))\n\n                (core func $foo (canon lower (func $foo)\n                    (memory $i1 \"memory\")\n                    (realloc (func $i1 \"realloc\"))))\n\n                (core module $m2\n                    (import \"\" \"ctor\" (func $ctor (result i32)))\n                    (import \"\" \"foo\" (func $foo (param i32 i32)))\n                    (import \"i1\" \"to-drop\" (global $to-drop (mut i32)))\n\n                    (func (export \"f\")\n                        (local $r i32)\n                        (local.set $r (call $ctor))\n                        (global.set $to-drop (local.get $r))\n                        (call $foo\n                            (local.get $r)\n                            (i32.const 200))\n                    )\n                )\n                (core instance $i2 (instantiate $m2\n                    (with \"\" (instance\n                        (export \"ctor\" (func $ctor))\n                        (export \"foo\" (func $foo))\n                    ))\n                    (with \"i1\" (instance $i1))\n                ))\n                (func (export \"f\") (canon lift (core func $i2 \"f\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t\", |_, _| Ok(()))?;\n    linker.root().func_wrap(\"[constructor]t\", |_cx, ()| {\n        Ok((Resource::<MyType>::new_own(300),))\n    })?;\n    linker\n        .root()\n        .func_wrap(\"[method]t.foo\", |_cx, (r,): (Resource<MyType>,)| {\n            assert!(!r.owned());\n            Ok((vec![2u8],))\n        })?;\n    let i = linker.instantiate(&mut store, &c)?;\n    let f = i.get_typed_func::<(), ()>(&mut store, \"f\")?;\n\n    let err = f.call(&mut store, ()).unwrap_err();\n    assert!(\n        format!(\"{err:?}\").contains(\"cannot remove owned resource while borrowed\"),\n        \"bad error: {err:?}\"\n    );\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/component/resources.rs::owned", "code": "pub fn owned(&self) -> bool {\n        match self.state.load(Relaxed) {\n            BORROW => false,\n            _ => true,\n        }\n    }", "docstring": null}
{"test_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/tests/all/component_model/resources.rs::guest_different_host_same", "test": "fn guest_different_host_same() -> Result<()> {\n    let engine = super::engine();\n    let c = Component::new(\n        &engine,\n        r#\"\n            (component\n                (import \"t1\" (type $t1 (sub resource)))\n                (import \"t2\" (type $t2 (sub resource)))\n\n                (import \"f\" (func $f (param \"a\" (borrow $t1)) (param \"b\" (borrow $t2))))\n\n                (export $g1 \"g1\" (type $t1))\n                (export $g2 \"g2\" (type $t2))\n\n                (core func $f (canon lower (func $f)))\n                (core func $drop1 (canon resource.drop $t1))\n                (core func $drop2 (canon resource.drop $t2))\n\n                (core module $m\n                    (import \"\" \"f\" (func $f (param i32 i32)))\n                    (import \"\" \"drop1\" (func $drop1 (param i32)))\n                    (import \"\" \"drop2\" (func $drop2 (param i32)))\n\n                    (func (export \"f\") (param i32 i32)\n                        ;; separate tables both have initial index of 0\n                        (if (i32.ne (local.get 0) (i32.const 0)) (then (unreachable)))\n                        (if (i32.ne (local.get 1) (i32.const 0)) (then (unreachable)))\n\n                        ;; host should end up getting the same resource\n                        (call $f (local.get 0) (local.get 1))\n\n                        ;; drop our borrows\n                        (call $drop1 (local.get 0))\n                        (call $drop2 (local.get 0))\n                    )\n                )\n                (core instance $i (instantiate $m\n                    (with \"\" (instance\n                        (export \"f\" (func $f))\n                        (export \"drop1\" (func $drop1))\n                        (export \"drop2\" (func $drop2))\n                    ))\n                ))\n\n                (func (export \"f2\") (param \"a\" (borrow $g1)) (param \"b\" (borrow $g2))\n                    (canon lift (core func $i \"f\")))\n            )\n        \"#,\n    )?;\n\n    struct MyType;\n\n    let mut store = Store::new(&engine, ());\n    let mut linker = Linker::new(&engine);\n    linker.root().resource::<MyType>(\"t1\", |_, _| Ok(()))?;\n    linker.root().resource::<MyType>(\"t2\", |_, _| Ok(()))?;\n    linker.root().func_wrap(\n        \"f\",\n        |_cx, (r1, r2): (Resource<MyType>, Resource<MyType>)| {\n            assert!(!r1.owned());\n            assert!(!r2.owned());\n            assert_eq!(r1.rep(), 100);\n            assert_eq!(r2.rep(), 100);\n            Ok(())\n        },\n    )?;\n    let i = linker.instantiate(&mut store, &c)?;\n    let f = i.get_typed_func::<(&Resource<MyType>, &Resource<MyType>), ()>(&mut store, \"f2\")?;\n\n    let t1 = i.get_resource(&mut store, \"g1\").unwrap();\n    let t2 = i.get_resource(&mut store, \"g2\").unwrap();\n    assert_eq!(t1, t2);\n    assert_eq!(t1, ResourceType::host::<MyType>());\n\n    let resource = Resource::new_own(100);\n    f.call(&mut store, (&resource, &resource))?;\n    f.post_return(&mut store)?;\n\n    Ok(())\n}", "code_id": "bytecodealliance-wasmtime/bytecodealliance-wasmtime-5fc1252/crates/wasmtime/src/component/resources.rs::owned", "code": "pub fn owned(&self) -> bool {\n        match self.state.load(Relaxed) {\n            BORROW => false,\n            _ => true,\n        }\n    }", "docstring": null}
