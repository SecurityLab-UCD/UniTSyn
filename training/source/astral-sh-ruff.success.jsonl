{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::unit_struct_cache_key", "test": "fn unit_struct_cache_key() {\n    #[derive(CacheKey, Hash)]\n    struct UnitStruct;\n\n    let mut key = CacheKeyHasher::new();\n\n    UnitStruct.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    UnitStruct.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}", "code_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/src/cache_key.rs::finish", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "docstring": null}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::named_field_struct", "test": "fn named_field_struct() {\n    #[derive(CacheKey, Hash)]\n    struct NamedFieldsStruct {\n        a: String,\n        b: String,\n    }\n\n    let mut key = CacheKeyHasher::new();\n\n    let named_fields = NamedFieldsStruct {\n        a: \"Hello\".into(),\n        b: \"World\".into(),\n    };\n\n    named_fields.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    named_fields.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}", "code_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/src/cache_key.rs::finish", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "docstring": null}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::struct_ignored_fields", "test": "fn struct_ignored_fields() {\n    #[derive(CacheKey)]\n    struct NamedFieldsStruct {\n        a: String,\n        #[cache_key(ignore)]\n        #[allow(unused)]\n        b: String,\n    }\n\n    impl Hash for NamedFieldsStruct {\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            self.a.hash(state);\n        }\n    }\n\n    let mut key = CacheKeyHasher::new();\n\n    let named_fields = NamedFieldsStruct {\n        a: \"Hello\".into(),\n        b: \"World\".into(),\n    };\n\n    named_fields.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    named_fields.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}", "code_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/src/cache_key.rs::finish", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "docstring": null}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::unnamed_field_struct", "test": "fn unnamed_field_struct() {\n    #[derive(CacheKey, Hash)]\n    struct UnnamedFieldsStruct(String, String);\n\n    let mut key = CacheKeyHasher::new();\n\n    let unnamed_fields = UnnamedFieldsStruct(\"Hello\".into(), \"World\".into());\n\n    unnamed_fields.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    unnamed_fields.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}", "code_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/src/cache_key.rs::finish", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "docstring": null}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::enum_unit_variant", "test": "fn enum_unit_variant() {\n    let mut key = CacheKeyHasher::new();\n\n    let variant = Enum::Unit;\n    variant.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    variant.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}", "code_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/src/cache_key.rs::finish", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "docstring": null}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::enum_named_fields_variant", "test": "fn enum_named_fields_variant() {\n    let mut key = CacheKeyHasher::new();\n\n    let variant = Enum::NamedFields {\n        a: \"Hello\".to_string(),\n        b: \"World\".to_string(),\n    };\n    variant.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    variant.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}", "code_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/src/cache_key.rs::finish", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "docstring": null}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/tests/cache_key.rs::enum_unnamed_fields_variant", "test": "fn enum_unnamed_fields_variant() {\n    let mut key = CacheKeyHasher::new();\n\n    let variant = Enum::UnnamedFields(\"Hello\".to_string(), \"World\".to_string());\n    variant.cache_key(&mut key);\n\n    let mut hash = CacheKeyHasher::new();\n    variant.hash(&mut hash);\n\n    assert_eq!(hash.finish(), key.finish());\n}", "code_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_cache/src/cache_key.rs::finish", "code": "fn finish(&self) -> u64 {\n        self.inner.finish()\n    }", "docstring": null}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_python_ast/tests/stmt_if.rs::extract_elif_else_range", "test": "fn extract_elif_else_range() -> Result<(), ParseError> {\n    let contents = \"if a:\n    ...\nelif b:\n    ...\n\";\n    let mut stmts = parse_suite(contents, \"<filename>\")?;\n    let stmt = stmts\n        .pop()\n        .and_then(ruff_python_ast::Stmt::if_stmt)\n        .unwrap();\n    let range = elif_else_range(&stmt.elif_else_clauses[0], contents).unwrap();\n    assert_eq!(range.start(), TextSize::from(14));\n    assert_eq!(range.end(), TextSize::from(18));\n\n    let contents = \"if a:\n    ...\nelse:\n    ...\n\";\n    let mut stmts = parse_suite(contents, \"<filename>\")?;\n    let stmt = stmts\n        .pop()\n        .and_then(ruff_python_ast::Stmt::if_stmt)\n        .unwrap();\n    let range = elif_else_range(&stmt.elif_else_clauses[0], contents).unwrap();\n    assert_eq!(range.start(), TextSize::from(14));\n    assert_eq!(range.end(), TextSize::from(18));\n\n    Ok(())\n}", "code_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/src/range.rs::start", "code": "pub const fn start(self) -> TextSize {\n        self.start\n    }", "docstring": null}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/tests/main.rs::math", "test": "fn math() {\n    assert_eq!(size(10) + size(5), size(15));\n    assert_eq!(size(10) - size(5), size(5));\n}", "code_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/tests/main.rs::size", "code": "fn size(x: u32) -> TextSize {\n    TextSize::from(x)\n}", "docstring": null}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/tests/main.rs::checked_math", "test": "fn checked_math() {\n    assert_eq!(size(1).checked_add(size(1)), Some(size(2)));\n    assert_eq!(size(1).checked_sub(size(1)), Some(size(0)));\n    assert_eq!(size(1).checked_sub(size(2)), None);\n    assert_eq!(size(!0).checked_add(size(1)), None);\n}", "code_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/src/range.rs::checked_add", "code": "pub fn checked_add(self, offset: TextSize) -> Option<TextRange> {\n        Some(TextRange {\n            start: self.start.checked_add(offset)?,\n            end: self.end.checked_add(offset)?,\n        })\n    }", "docstring": null}
{"test_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/tests/main.rs::cover_offset", "test": "fn cover_offset() {\n    assert_eq!(range(1..3).cover_offset(size(0)), range(0..3));\n    assert_eq!(range(1..3).cover_offset(size(1)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(2)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(3)), range(1..3));\n    assert_eq!(range(1..3).cover_offset(size(4)), range(1..4));\n}", "code_id": "astral-sh-ruff/astral-sh-ruff-1a6898a/crates/ruff_text_size/src/range.rs::cover_offset", "code": "pub fn cover_offset(self, offset: TextSize) -> TextRange {\n        self.cover(TextRange::empty(offset))\n    }", "docstring": null}
