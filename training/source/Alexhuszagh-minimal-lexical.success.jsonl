{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/bellerophon_tests.rs::compute_float_f32_test", "test": "fn compute_float_f32_test() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_float32(0, 16777216), (151, 0));\n    assert_eq!(compute_float32(0, 16777217), (111 + f32::INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_float32(0, 16777218), (151, 1));\n    assert_eq!(compute_float32(0, 16777219), (111 + f32::INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_float32(0, 16777220), (151, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float32(-10, 167772160000000000), (151, 0));\n    assert_eq!(\n        compute_float32(-10, 167772170000000000),\n        (111 + f32::INVALID_FP, 9223372586610589696)\n    );\n    assert_eq!(compute_float32(-10, 167772180000000000), (151, 1));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(\n        compute_float32(-10, 167772190000000000),\n        (111 + f32::INVALID_FP, 9223373686122217472)\n    );\n    assert_eq!(compute_float32(-10, 167772200000000000), (151, 2));\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/bellerophon.rs::compute_float32", "code": "pub fn compute_float32(q: i32, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        many_digits: false,\n    };\n    let fp = bellerophon::<f32>(&num);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/bellerophon_tests.rs::compute_float_f64_test", "test": "fn compute_float_f64_test() {\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_float64(0, 9007199254740992), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740993), (1065 + f64::INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_float64(0, 9007199254740994), (1076, 1));\n    assert_eq!(compute_float64(0, 9007199254740995), (1065 + f64::INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_float64(0, 9007199254740996), (1076, 2));\n    assert_eq!(compute_float64(0, 18014398509481984), (1077, 0));\n    assert_eq!(\n        compute_float64(0, 18014398509481986),\n        (1066 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(compute_float64(0, 18014398509481988), (1077, 1));\n    assert_eq!(\n        compute_float64(0, 18014398509481990),\n        (1066 + f64::INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(compute_float64(0, 18014398509481992), (1077, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float64(-3, 9007199254740992000), (1076, 0));\n    assert_eq!(\n        compute_float64(-3, 9007199254740993000),\n        (1065 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(compute_float64(-3, 9007199254740994000), (1076, 1));\n    assert_eq!(\n        compute_float64(-3, 9007199254740995000),\n        (1065 + f64::INVALID_FP, 9223372036854778879)\n    );\n    assert_eq!(compute_float64(-3, 9007199254740996000), (1076, 2));\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/bellerophon.rs::compute_float64", "code": "pub fn compute_float64(q: i32, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        many_digits: false,\n    };\n    let fp = bellerophon::<f64>(&num);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_error32_test", "test": "fn compute_error32_test() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_error32(0, 16777216), (111 + f32::INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error32(0, 16777217), (111 + f32::INVALID_FP, 9223372586610589696));\n    assert_eq!(compute_error32(0, 16777218), (111 + f32::INVALID_FP, 9223373136366403584));\n    assert_eq!(compute_error32(0, 16777219), (111 + f32::INVALID_FP, 9223373686122217472));\n    assert_eq!(compute_error32(0, 16777220), (111 + f32::INVALID_FP, 9223374235878031360));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(\n        compute_error32(-10, 167772160000000000),\n        (111 + f32::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error32(-10, 167772170000000000),\n        (111 + f32::INVALID_FP, 9223372586610589696)\n    );\n    assert_eq!(\n        compute_error32(-10, 167772180000000000),\n        (111 + f32::INVALID_FP, 9223373136366403584)\n    );\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(\n        compute_error32(-10, 167772190000000000),\n        (111 + f32::INVALID_FP, 9223373686122217472)\n    );\n    assert_eq!(\n        compute_error32(-10, 167772200000000000),\n        (111 + f32::INVALID_FP, 9223374235878031360)\n    );\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_error32", "code": "fn compute_error32(q: i32, w: u64) -> (i32, u64) {\n    let fp = lemire::compute_error::<f32>(q, w);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_error64_test", "test": "fn compute_error64_test() {\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_error64(0, 9007199254740992), (1065 + f64::INVALID_FP, 9223372036854775808));\n    assert_eq!(compute_error64(0, 9007199254740993), (1065 + f64::INVALID_FP, 9223372036854776832));\n    assert_eq!(compute_error64(0, 9007199254740994), (1065 + f64::INVALID_FP, 9223372036854777856));\n    assert_eq!(compute_error64(0, 9007199254740995), (1065 + f64::INVALID_FP, 9223372036854778880));\n    assert_eq!(compute_error64(0, 9007199254740996), (1065 + f64::INVALID_FP, 9223372036854779904));\n    assert_eq!(\n        compute_error64(0, 18014398509481984),\n        (1066 + f64::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error64(0, 18014398509481986),\n        (1066 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error64(0, 18014398509481988),\n        (1066 + f64::INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error64(0, 18014398509481990),\n        (1066 + f64::INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error64(0, 18014398509481992),\n        (1066 + f64::INVALID_FP, 9223372036854779904)\n    );\n\n    // Test a much closer set of examples.\n    assert_eq!(\n        compute_error64(0, 9007199254740991),\n        (1064 + f64::INVALID_FP, 18446744073709549568)\n    );\n    assert_eq!(\n        compute_error64(0, 9223372036854776831),\n        (1075 + f64::INVALID_FP, 9223372036854776830)\n    );\n    assert_eq!(\n        compute_error64(0, 9223372036854776832),\n        (1075 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error64(0, 9223372036854776833),\n        (1075 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error64(-42, 9123456727292927),\n        (925 + f64::INVALID_FP, 13021432563531497894)\n    );\n    assert_eq!(\n        compute_error64(-43, 91234567272929275),\n        (925 + f64::INVALID_FP, 13021432563531498606)\n    );\n    assert_eq!(\n        compute_error64(-42, 9123456727292928),\n        (925 + f64::INVALID_FP, 13021432563531499320)\n    );\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(\n        compute_error64(-3, 9007199254740992000),\n        (1065 + f64::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error64(-3, 9007199254740993000),\n        (1065 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error64(-3, 9007199254740994000),\n        (1065 + f64::INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error64(-3, 9007199254740995000),\n        (1065 + f64::INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error64(-3, 9007199254740996000),\n        (1065 + f64::INVALID_FP, 9223372036854779904)\n    );\n\n    // Test from errors in atof.\n    assert_eq!(\n        compute_error64(-18, 1000000178813934326),\n        (1012 + f64::INVALID_FP, 9223373686122217470)\n    );\n\n    // Check edge-cases from previous errors.\n    assert_eq!(\n        compute_error64(-342, 2470328229206232720),\n        (-64 + f64::INVALID_FP, 18446744073709551608)\n    );\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_error64", "code": "fn compute_error64(q: i32, w: u64) -> (i32, u64) {\n    let fp = lemire::compute_error::<f64>(q, w);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_error_scaled32_test", "test": "fn compute_error_scaled32_test() {\n    // These are the same examples above, just using pre-computed scaled values.\n\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(\n        compute_error_scaled32(0, 4611686018427387904, 39),\n        (111 + f32::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611686293305294848, 39),\n        (111 + f32::INVALID_FP, 9223372586610589696)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611686568183201792, 39),\n        (111 + f32::INVALID_FP, 9223373136366403584)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611686843061108736, 39),\n        (111 + f32::INVALID_FP, 9223373686122217472)\n    );\n    assert_eq!(\n        compute_error_scaled32(0, 4611687117939015680, 39),\n        (111 + f32::INVALID_FP, 9223374235878031360)\n    );\n\n    assert_eq!(\n        compute_error_scaled32(-10, 9223372036854775808, 6),\n        (111 + f32::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223372586610589696, 6),\n        (111 + f32::INVALID_FP, 9223372586610589696)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223373136366403584, 6),\n        (111 + f32::INVALID_FP, 9223373136366403584)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223373686122217472, 6),\n        (111 + f32::INVALID_FP, 9223373686122217472)\n    );\n    assert_eq!(\n        compute_error_scaled32(-10, 9223374235878031360, 6),\n        (111 + f32::INVALID_FP, 9223374235878031360)\n    );\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_error_scaled32", "code": "fn compute_error_scaled32(q: i32, w: u64, lz: i32) -> (i32, u64) {\n    let fp = lemire::compute_error_scaled::<f32>(q, w, lz);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_error_scaled64_test", "test": "fn compute_error_scaled64_test() {\n    // These are the same examples above, just using pre-computed scaled values.\n\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427387904, 10),\n        (1065 + f64::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 10),\n        (1065 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388928, 10),\n        (1065 + f64::INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389440, 10),\n        (1065 + f64::INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389952, 10),\n        (1065 + f64::INVALID_FP, 9223372036854779904)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427387904, 9),\n        (1066 + f64::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 9),\n        (1066 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388928, 9),\n        (1066 + f64::INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389440, 9),\n        (1066 + f64::INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427389952, 9),\n        (1066 + f64::INVALID_FP, 9223372036854779904)\n    );\n\n    // Test a much closer set of examples.\n    assert_eq!(\n        compute_error_scaled64(0, 9223372036854774784, 11),\n        (1064 + f64::INVALID_FP, 18446744073709549568)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388415, 0),\n        (1075 + f64::INVALID_FP, 9223372036854776830)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 0),\n        (1075 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(0, 4611686018427388416, 0),\n        (1075 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(-42, 6510716281765748947, 10),\n        (925 + f64::INVALID_FP, 13021432563531497894)\n    );\n    assert_eq!(\n        compute_error_scaled64(-43, 6510716281765749303, 7),\n        (925 + f64::INVALID_FP, 13021432563531498606)\n    );\n    assert_eq!(\n        compute_error_scaled64(-42, 6510716281765749660, 10),\n        (925 + f64::INVALID_FP, 13021432563531499320)\n    );\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854775808, 1),\n        (1065 + f64::INVALID_FP, 9223372036854775808)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854776832, 1),\n        (1065 + f64::INVALID_FP, 9223372036854776832)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854777856, 1),\n        (1065 + f64::INVALID_FP, 9223372036854777856)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854778880, 1),\n        (1065 + f64::INVALID_FP, 9223372036854778880)\n    );\n    assert_eq!(\n        compute_error_scaled64(-3, 9223372036854779904, 1),\n        (1065 + f64::INVALID_FP, 9223372036854779904)\n    );\n\n    // Test from errors in atof.\n    assert_eq!(\n        compute_error_scaled64(-18, 9223373686122217470, 4),\n        (1012 + f64::INVALID_FP, 9223373686122217470)\n    );\n\n    // Check edge-cases from previous errors.\n    assert_eq!(\n        compute_error_scaled64(-342, 9223372036854775804, 2),\n        (-64 + f64::INVALID_FP, 18446744073709551608)\n    );\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_error_scaled64", "code": "fn compute_error_scaled64(q: i32, w: u64, lz: i32) -> (i32, u64) {\n    let fp = lemire::compute_error_scaled::<f64>(q, w, lz);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_float_f32_rounding", "test": "fn compute_float_f32_rounding() {\n    // These test near-halfway cases for single-precision floats.\n    assert_eq!(compute_float32(0, 16777216), (151, 0));\n    assert_eq!(compute_float32(0, 16777217), (151, 0));\n    assert_eq!(compute_float32(0, 16777218), (151, 1));\n    assert_eq!(compute_float32(0, 16777219), (151, 2));\n    assert_eq!(compute_float32(0, 16777220), (151, 2));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float32(-10, 167772160000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772170000000000), (151, 0));\n    assert_eq!(compute_float32(-10, 167772180000000000), (151, 1));\n    // Let's check the lines to see if anything is different in table...\n    assert_eq!(compute_float32(-10, 167772190000000000), (151, 2));\n    assert_eq!(compute_float32(-10, 167772200000000000), (151, 2));\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/bellerophon.rs::compute_float32", "code": "pub fn compute_float32(q: i32, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        many_digits: false,\n    };\n    let fp = bellerophon::<f32>(&num);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/lemire_tests.rs::compute_float_f64_rounding", "test": "fn compute_float_f64_rounding() {\n    // Also need to check halfway cases **inside** that exponent range.\n\n    // These test near-halfway cases for double-precision floats.\n    assert_eq!(compute_float64(0, 9007199254740992), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740993), (1076, 0));\n    assert_eq!(compute_float64(0, 9007199254740994), (1076, 1));\n    assert_eq!(compute_float64(0, 9007199254740995), (1076, 2));\n    assert_eq!(compute_float64(0, 9007199254740996), (1076, 2));\n    assert_eq!(compute_float64(0, 18014398509481984), (1077, 0));\n    assert_eq!(compute_float64(0, 18014398509481986), (1077, 0));\n    assert_eq!(compute_float64(0, 18014398509481988), (1077, 1));\n    assert_eq!(compute_float64(0, 18014398509481990), (1077, 2));\n    assert_eq!(compute_float64(0, 18014398509481992), (1077, 2));\n\n    // Test a much closer set of examples.\n    assert_eq!(compute_float64(0, 9007199254740991), (1075, 4503599627370495));\n    assert_eq!(compute_float64(0, 9223372036854776831), (1086, 0));\n    assert_eq!(compute_float64(0, 9223372036854776832), (1086, 0));\n    assert_eq!(compute_float64(0, 9223372036854776833), (1086, 1));\n    assert_eq!(compute_float64(-42, 9123456727292927), (936, 1854521741541368));\n    assert_eq!(compute_float64(-43, 91234567272929275), (936, 1854521741541369));\n    assert_eq!(compute_float64(-42, 9123456727292928), (936, 1854521741541369));\n\n    // These are examples of the above tests, with\n    // digits from the exponent shifted to the mantissa.\n    assert_eq!(compute_float64(-3, 9007199254740992000), (1076, 0));\n    assert_eq!(compute_float64(-3, 9007199254740993000), (1076, 0));\n    assert_eq!(compute_float64(-3, 9007199254740994000), (1076, 1));\n    assert_eq!(compute_float64(-3, 9007199254740995000), (1076, 2));\n    assert_eq!(compute_float64(-3, 9007199254740996000), (1076, 2));\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/bellerophon.rs::compute_float64", "code": "pub fn compute_float64(q: i32, w: u64) -> (i32, u64) {\n    let num = Number {\n        exponent: q,\n        mantissa: w,\n        many_digits: false,\n    };\n    let fp = bellerophon::<f64>(&num);\n    (fp.exp, fp.mant)\n}", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/slow_tests.rs::b_test", "test": "fn b_test() {\n    assert_eq!(b(1e-45_f32), (1, -149));\n    assert_eq!(b(5e-324_f64), (1, -1074));\n    assert_eq!(b(1e-323_f64), (2, -1074));\n    assert_eq!(b(2e-323_f64), (4, -1074));\n    assert_eq!(b(3e-323_f64), (6, -1074));\n    assert_eq!(b(4e-323_f64), (8, -1074));\n    assert_eq!(b(5e-323_f64), (10, -1074));\n    assert_eq!(b(6e-323_f64), (12, -1074));\n    assert_eq!(b(7e-323_f64), (14, -1074));\n    assert_eq!(b(8e-323_f64), (16, -1074));\n    assert_eq!(b(9e-323_f64), (18, -1074));\n    assert_eq!(b(1_f32), (8388608, -23));\n    assert_eq!(b(1_f64), (4503599627370496, -52));\n    assert_eq!(b(1e38_f32), (9860761, 103));\n    assert_eq!(b(1e308_f64), (5010420900022432, 971));\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/slow_tests.rs::b", "code": "fn b<F: Float>(float: F) -> (u64, i32) {\n    let fp = slow::b(float);\n    (fp.mant, fp.exp)\n}", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/slow_tests.rs::bh_test", "test": "fn bh_test() {\n    assert_eq!(bh(1e-45_f32), (3, -150));\n    assert_eq!(bh(5e-324_f64), (3, -1075));\n    assert_eq!(bh(1_f32), (16777217, -24));\n    assert_eq!(bh(1_f64), (9007199254740993, -53));\n    assert_eq!(bh(1e38_f32), (19721523, 102));\n    assert_eq!(bh(1e308_f64), (10020841800044865, 970));\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/slow_tests.rs::bh", "code": "fn bh<F: Float>(float: F) -> (u64, i32) {\n    let fp = slow::bh(float);\n    (fp.mant, fp.exp)\n}", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::simple_test", "test": "fn simple_test() {\n    // Test the simple properties of the stack vector.\n    let mut x = VecType::from_u64(1);\n    assert_eq!(x.len(), 1);\n    assert_eq!(x.is_empty(), false);\n    assert_eq!(x.capacity(), bigint::BIGINT_LIMBS);\n    x.try_push(5).unwrap();\n    assert_eq!(x.len(), 2);\n    assert_eq!(x.pop(), Some(5));\n    assert_eq!(x.len(), 1);\n    assert_eq!(&*x, &[1]);\n    x.try_extend(&[2, 3, 4]).unwrap();\n    assert_eq!(x.len(), 4);\n    assert_eq!(&*x, &[1, 2, 3, 4]);\n    x.try_resize(6, 0).unwrap();\n    assert_eq!(x.len(), 6);\n    assert_eq!(&*x, &[1, 2, 3, 4, 0, 0]);\n    x.try_resize(0, 0).unwrap();\n    assert_eq!(x.len(), 0);\n    assert_eq!(x.is_empty(), true);\n\n    let x = VecType::try_from(&[5, 1]).unwrap();\n    assert_eq!(x.len(), 2);\n    assert_eq!(x.is_empty(), false);\n    if bigint::LIMB_BITS == 32 {\n        assert_eq!(x.hi64(), (0x8000000280000000, false));\n    } else {\n        assert_eq!(x.hi64(), (0x8000000000000002, true));\n    }\n    let rview = bigint::rview(&x);\n    assert_eq!(x[0], 5);\n    assert_eq!(x[1], 1);\n    assert_eq!(rview[0], 1);\n    assert_eq!(rview[1], 5);\n    assert_eq!(x.len(), 2);\n\n    assert_eq!(VecType::from_u64(U64_MAX).hi64(), (U64_MAX, false));\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/src/heapvec.rs::len", "code": "pub fn len(&self) -> usize {\n        self.data.len()\n    }", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::hi64_test", "test": "fn hi64_test() {\n    assert_eq!(VecType::from_u64(0xA).hi64(), (0xA000000000000000, false));\n    assert_eq!(VecType::from_u64(0xAB).hi64(), (0xAB00000000000000, false));\n    assert_eq!(VecType::from_u64(0xAB00000000).hi64(), (0xAB00000000000000, false));\n    assert_eq!(VecType::from_u64(0xA23456789A).hi64(), (0xA23456789A000000, false));\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/src/heapvec.rs::hi64", "code": "pub fn hi64(&self) -> (u64, bool) {\n        bigint::hi64(&self.data)\n    }", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::cmp_test", "test": "fn cmp_test() {\n    // Simple\n    let x = VecType::from_u64(1);\n    let y = VecType::from_u64(2);\n    assert_eq!(x.partial_cmp(&x), Some(cmp::Ordering::Equal));\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Less);\n\n    // Check asymmetric\n    let x = VecType::try_from(&[5, 1]).unwrap();\n    let y = VecType::from_u64(2);\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n\n    // Check when we use reverse ordering properly.\n    let x = VecType::try_from(&[5, 1, 9]).unwrap();\n    let y = VecType::try_from(&[6, 2, 8]).unwrap();\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n\n    // Complex scenario, check it properly uses reverse ordering.\n    let x = VecType::try_from(&[0, 1, 9]).unwrap();\n    let y = VecType::try_from(&[4294967295, 0, 9]).unwrap();\n    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);\n    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/src/heapvec.rs::partial_cmp", "code": "fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n        Some(bigint::compare(self, other))\n    }", "docstring": null}
{"test_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/tests/vec_tests.rs::math_test", "test": "fn math_test() {\n    let mut x = VecType::try_from(&[0, 1, 9]).unwrap();\n    assert_eq!(x.is_normalized(), true);\n    x.try_push(0).unwrap();\n    assert_eq!(&*x, &[0, 1, 9, 0]);\n    assert_eq!(x.is_normalized(), false);\n    x.normalize();\n    assert_eq!(&*x, &[0, 1, 9]);\n    assert_eq!(x.is_normalized(), true);\n\n    x.add_small(1);\n    assert_eq!(&*x, &[1, 1, 9]);\n    x.add_small(LIMB_MAX);\n    assert_eq!(&*x, &[0, 2, 9]);\n\n    x.mul_small(3);\n    assert_eq!(&*x, &[0, 6, 27]);\n    x.mul_small(LIMB_MAX);\n    let expected: VecType = if bigint::LIMB_BITS == 32 {\n        vec_from_u32(&[0, 4294967290, 4294967274, 26])\n    } else {\n        vec_from_u32(&[0, 0, 4294967290, 4294967295, 4294967274, 4294967295, 26])\n    };\n    assert_eq!(&*x, &*expected);\n\n    let mut x = VecType::from_u64(0xFFFFFFFF);\n    let y = VecType::from_u64(5);\n    x *= &y;\n    let expected: VecType = vec_from_u32(&[0xFFFFFFFB, 0x4]);\n    assert_eq!(&*x, &*expected);\n\n    // Test with carry\n    let mut x = VecType::from_u64(1);\n    assert_eq!(&*x, &[1]);\n    x.add_small(LIMB_MAX);\n    assert_eq!(&*x, &[0, 1]);\n}", "code_id": "Alexhuszagh-minimal-lexical/Alexhuszagh-minimal-lexical-e997c46/src/heapvec.rs::is_normalized", "code": "pub fn is_normalized(&self) -> bool {\n        bigint::is_normalized(self)\n    }", "docstring": null}
