{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/json_api.rs::get_sat_without_sat_index", "test": "fn get_sat_without_sat_index() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n\n  let response = TestServer::spawn_with_server_args(&rpc_server, &[], &[\"--enable-json-api\"])\n    .json_request(\"/sat/2099999997689999\");\n\n  assert_eq!(response.status(), StatusCode::OK);\n\n  let mut sat_json: SatJson = serde_json::from_str(&response.text().unwrap()).unwrap();\n\n  // this is a hack to ignore the timestamp, since it changes for every request\n  sat_json.timestamp = 0;\n\n  pretty_assert_eq!(\n    sat_json,\n    SatJson {\n      number: 2099999997689999,\n      decimal: \"6929999.0\".into(),\n      degree: \"5°209999′1007″0‴\".into(),\n      name: \"a\".into(),\n      block: 6929999,\n      cycle: 5,\n      epoch: 32,\n      period: 3437,\n      offset: 0,\n      rarity: Rarity::Uncommon,\n      percentile: \"100%\".into(),\n      satpoint: None,\n      timestamp: 0,\n      inscriptions: vec![],\n    }\n  )\n}\n\n#[tes", "code_id": "ordinals-ord/ordinals-ord-8090538/src/subcommand/server.rs::status", "code": "async fn status(Extension(index): Extension<Arc<Index>>) -> (StatusCode, &'static str) {\n    if index.is_unrecoverably_reorged() {\n      (\n        StatusCode::OK,\n        \"unrecoverable reorg detected, please rebuild the database.\",\n      )\n    } else {\n      (\n        StatusCode::OK,\n        StatusCode::OK.canonical_reason().unwrap_or_default(),\n      )\n    }\n  }", "docstring": null}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/server.rs::inscription_content", "test": "fn inscription_content() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  rpc_server.mine_blocks(1);\n\n  let (inscription, _) = inscribe(&rpc_server);\n\n  rpc_server.mine_blocks(1);\n\n  let response =\n    TestServer::spawn_with_args(&rpc_server, &[]).request(format!(\"/content/{inscription}\"));\n\n  assert_eq!(response.status(), StatusCode::OK);\n  assert_eq!(\n    response.headers().get(\"content-type\").unwrap(),\n    \"text/plain;charset=utf-8\"\n  );\n  assert_eq!(\n    response\n      .headers()\n      .get_all(\"content-security-policy\")\n      .into_iter()\n      .collect::<Vec<&http::HeaderValue>>(),\n    &[\n      \"default-src 'self' 'unsafe-eval' 'unsafe-inline' data: blob:\",\n      \"default-src *:*/content/ *:*/blockheight *:*/blockhash *:*/blockhash/ *:*/blocktime *:*/r/ 'unsafe-eval' 'unsafe-inline' data: blob:\",\n    ]\n  );\n  assert_eq!(response.bytes().unwrap(), \"FOO\");\n}", "code_id": "ordinals-ord/ordinals-ord-8090538/src/subcommand/server.rs::status", "code": "async fn status(Extension(index): Extension<Arc<Index>>) -> (StatusCode, &'static str) {\n    if index.is_unrecoverably_reorged() {\n      (\n        StatusCode::OK,\n        \"unrecoverable reorg detected, please rebuild the database.\",\n      )\n    } else {\n      (\n        StatusCode::OK,\n        StatusCode::OK.canonical_reason().unwrap_or_default(),\n      )\n    }\n  }", "docstring": null}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/server.rs::inscription_metadata", "test": "fn inscription_metadata() {\n  let metadata = r#\"{\"foo\":\"bar\",\"baz\":1}\"#;\n  let mut encoded_metadata = Vec::new();\n  let cbor_map = ciborium::value::Value::Map(vec![\n    (\n      ciborium::value::Value::Text(\"foo\".into()),\n      ciborium::value::Value::Text(\"bar\".into()),\n    ),\n    (\n      ciborium::value::Value::Text(\"baz\".into()),\n      ciborium::value::Value::Integer(Integer::from(1)),\n    ),\n  ]);\n  ciborium::ser::into_writer(&cbor_map, &mut encoded_metadata).unwrap();\n\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  rpc_server.mine_blocks(1);\n\n  let inscription_id = CommandBuilder::new(\n    \"wallet inscribe --fee-rate 1 --json-metadata metadata.json --file foo.txt\",\n  )\n  .write(\"foo.txt\", \"FOO\")\n  .write(\"metadata.json\", metadata)\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Inscribe>()\n  .inscriptions\n  .get(0)\n  .unwrap()\n  .id;\n\n  rpc_server.mine_blocks(1);\n\n  let response =\n    TestServer::spawn_with_args(&rpc_server, &[]).request(format!(\"/r/metadata/{inscription_id}\"));\n\n  assert_eq!(response.status(), StatusCode::OK);\n  assert_eq!(\n    response.headers().get(\"content-type\").unwrap(),\n    \"application/json\"\n  );\n  assert_eq!(\n    response.text().unwrap(),\n    format!(\"\\\"{}\\\"\", hex::encode(encoded_metadata))\n  );\n}", "code_id": "ordinals-ord/ordinals-ord-8090538/src/subcommand/server.rs::status", "code": "async fn status(Extension(index): Extension<Arc<Index>>) -> (StatusCode, &'static str) {\n    if index.is_unrecoverably_reorged() {\n      (\n        StatusCode::OK,\n        \"unrecoverable reorg detected, please rebuild the database.\",\n      )\n    } else {\n      (\n        StatusCode::OK,\n        StatusCode::OK.canonical_reason().unwrap_or_default(),\n      )\n    }\n  }", "docstring": null}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/restore.rs::restore_generates_same_descriptors", "test": "fn restore_generates_same_descriptors() {\n  let (mnemonic, descriptors) = {\n    let rpc_server = test_bitcoincore_rpc::spawn();\n\n    let create::Output { mnemonic, .. } = CommandBuilder::new(\"wallet create\")\n      .rpc_server(&rpc_server)\n      .run_and_deserialize_output();\n\n    (mnemonic, rpc_server.descriptors())\n  };\n\n  let rpc_server = test_bitcoincore_rpc::spawn();\n\n  CommandBuilder::new([\"wallet\", \"restore\", &mnemonic.to_string()])\n    .rpc_server(&rpc_server)\n    .run_and_deserialize_output::<Empty>();\n\n  assert_eq!(rpc_server.descriptors(), descriptors);\n}", "code_id": "ordinals-ord/ordinals-ord-8090538/test-bitcoincore-rpc/src/lib.rs::descriptors", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "docstring": null}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/restore.rs::restore_generates_same_descriptors_with_passphrase", "test": "fn restore_generates_same_descriptors_with_passphrase() {\n  let passphrase = \"foo\";\n  let (mnemonic, descriptors) = {\n    let rpc_server = test_bitcoincore_rpc::spawn();\n\n    let create::Output { mnemonic, .. } =\n      CommandBuilder::new([\"wallet\", \"create\", \"--passphrase\", passphrase])\n        .rpc_server(&rpc_server)\n        .run_and_deserialize_output();\n\n    (mnemonic, rpc_server.descriptors())\n  };\n\n  let rpc_server = test_bitcoincore_rpc::spawn();\n\n  CommandBuilder::new([\n    \"wallet\",\n    \"restore\",\n    \"--passphrase\",\n    passphrase,\n    &mnemonic.to_string(),\n  ])\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Empty>();\n\n  assert_eq!(rpc_server.descriptors(), descriptors);\n}", "code_id": "ordinals-ord/ordinals-ord-8090538/test-bitcoincore-rpc/src/lib.rs::descriptors", "code": "pub fn descriptors(&self) -> Vec<String> {\n    self.state().descriptors.clone()\n  }", "docstring": null}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::splitting_merged_inscriptions_is_possible", "test": "fn splitting_merged_inscriptions_is_possible() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n  rpc_server.mine_blocks(3);\n\n  let inscription = envelope(&[b\"ord\", &[1], b\"text/plain;charset=utf-8\", &[], b\"bar\"]);\n\n  // merging 3 inscriptions into one utxo\n  let reveal_txid = rpc_server.broadcast_tx(TransactionTemplate {\n    inputs: &[\n      (1, 0, 0, inscription.clone()),\n      (2, 0, 0, inscription.clone()),\n      (3, 0, 0, inscription.clone()),\n    ],\n    outputs: 1,\n    ..Default::default()\n  });\n\n  rpc_server.mine_blocks(1);\n\n  let server =\n    TestServer::spawn_with_server_args(&rpc_server, &[\"--index-sats\"], &[\"--enable-json-api\"]);\n\n  let response = server.json_request(format!(\"/output/{}:0\", reveal_txid));\n  assert_eq!(response.status(), StatusCode::OK);\n\n  let output_json: OutputJson = serde_json::from_str(&response.text().unwrap()).unwrap();\n\n  pretty_assert_eq!(\n    output_json,\n    OutputJson {\n      value: 3 * 50 * COIN_VALUE,\n      script_pubkey: \"\".to_string(),\n      address: None,\n      transaction: reveal_txid.to_string(),\n      sat_ranges: Some(vec![\n        (5000000000, 10000000000,),\n        (10000000000, 15000000000,),\n        (15000000000, 20000000000,),\n      ],),\n      inscriptions: vec![\n        InscriptionId {\n          txid: reveal_txid,\n          index: 0\n        },\n        InscriptionId {\n          txid: reveal_txid,\n          index: 1\n        },\n        InscriptionId {\n          txid: reveal_txid,\n          index: 2\n        },\n      ],\n      runes: BTreeMap::new(),\n    }\n  );\n\n  // try and fail to send first\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 {}i0\",\n    reveal_txid,\n  ))\n  .rpc_server(&rpc_server)\n  .expected_exit_code(1)\n  .expected_stderr(format!(\n    \"error: cannot send {reveal_txid}:0:0 without also sending inscription {reveal_txid}i2 at {reveal_txid}:0:{}\\n\", 100 * COIN_VALUE\n  ))\n  .run_and_extract_stdout();\n\n  // splitting out last\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 {}i2\",\n    reveal_txid,\n  ))\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Output>();\n\n  rpc_server.mine_blocks(1);\n\n  // splitting second to last\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 {}i1\",\n    reveal_txid,\n  ))\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Output>();\n\n  rpc_server.mine_blocks(1);\n\n  // splitting send first\n  CommandBuilder::new(format!(\n    \"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 {}i0\",\n    reveal_txid,\n  ))\n  .rpc_server(&rpc_server)\n  .run_and_deserialize_output::<Output>();\n}", "code_id": "ordinals-ord/ordinals-ord-8090538/src/subcommand/server.rs::status", "code": "async fn status(Extension(index): Extension<Arc<Index>>) -> (StatusCode, &'static str) {\n    if index.is_unrecoverably_reorged() {\n      (\n        StatusCode::OK,\n        \"unrecoverable reorg detected, please rebuild the database.\",\n      )\n    } else {\n      (\n        StatusCode::OK,\n        StatusCode::OK.canonical_reason().unwrap_or_default(),\n      )\n    }\n  }", "docstring": null}
{"test_id": "ordinals-ord/ordinals-ord-8090538/tests/wallet/send.rs::send_btc_locks_inscriptions", "test": "fn send_btc_locks_inscriptions() {\n  let rpc_server = test_bitcoincore_rpc::spawn();\n  create_wallet(&rpc_server);\n\n  rpc_server.mine_blocks(1);\n\n  let (_, reveal) = inscribe(&rpc_server);\n\n  let output =\n    CommandBuilder::new(\"wallet send --fee-rate 1 bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4 1btc\")\n      .rpc_server(&rpc_server)\n      .run_and_deserialize_output::<Output>();\n\n  assert_eq!(\n    output.transaction,\n    \"0000000000000000000000000000000000000000000000000000000000000000\"\n      .parse()\n      .unwrap()\n  );\n\n  assert_eq!(\n    rpc_server.sent(),\n    &[Sent {\n      amount: 1.0,\n      address: \"bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4\"\n        .parse::<Address<NetworkUnchecked>>()\n        .unwrap()\n        .assume_checked(),\n      locked: vec![OutPoint {\n        txid: reveal,\n        vout: 0,\n      }]\n    }]\n  )\n}", "code_id": "ordinals-ord/ordinals-ord-8090538/src/envelope.rs::parse", "code": "fn parse(witnesses: &[Witness]) -> Vec<ParsedEnvelope> {\n    ParsedEnvelope::from_transaction(&Transaction {\n      version: 0,\n      lock_time: LockTime::ZERO,\n      input: witnesses\n        .iter()\n        .map(|witness| TxIn {\n          previous_output: OutPoint::null(),\n          script_sig: ScriptBuf::new(),\n          sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,\n          witness: witness.clone(),\n        })\n        .collect(),\n      output: Vec::new(),\n    })\n  }", "docstring": null}
