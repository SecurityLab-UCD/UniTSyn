{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/common_test.rs::test_decimal_length9", "test": "fn test_decimal_length9() {\n    assert_eq!(1, decimal_length9(0));\n    assert_eq!(1, decimal_length9(1));\n    assert_eq!(1, decimal_length9(9));\n    assert_eq!(2, decimal_length9(10));\n    assert_eq!(2, decimal_length9(99));\n    assert_eq!(3, decimal_length9(100));\n    assert_eq!(3, decimal_length9(999));\n    assert_eq!(9, decimal_length9(999999999));\n}", "code_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/src/common.rs::decimal_length9", "code": "pub fn decimal_length9(v: u32) -> u32 {\n    // Function precondition: v is not a 10-digit number.\n    // (f2s: 9 digits are sufficient for round-tripping.)\n    debug_assert!(v < 1000000000);\n\n    if v >= 100000000 {\n        9\n    } else if v >= 10000000 {\n        8\n    } else if v >= 1000000 {\n        7\n    } else if v >= 100000 {\n        6\n    } else if v >= 10000 {\n        5\n    } else if v >= 1000 {\n        4\n    } else if v >= 100 {\n        3\n    } else if v >= 10 {\n        2\n    } else {\n        1\n    }\n}", "docstring": null}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/common_test.rs::test_ceil_log2_pow5", "test": "fn test_ceil_log2_pow5() {\n    assert_eq!(1, ceil_log2_pow5(0));\n    assert_eq!(3, ceil_log2_pow5(1));\n    assert_eq!(5, ceil_log2_pow5(2));\n    assert_eq!(7, ceil_log2_pow5(3));\n    assert_eq!(10, ceil_log2_pow5(4));\n    assert_eq!(8192, ceil_log2_pow5(3528));\n}", "code_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/src/common.rs::ceil_log2_pow5", "code": "pub fn ceil_log2_pow5(e: i32) -> i32 /* or u32 -> u32 */ {\n    log2_pow5(e) + 1\n}", "docstring": null}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/common_test.rs::test_log10_pow2", "test": "fn test_log10_pow2() {\n    assert_eq!(0, log10_pow2(0));\n    assert_eq!(0, log10_pow2(1));\n    assert_eq!(0, log10_pow2(2));\n    assert_eq!(0, log10_pow2(3));\n    assert_eq!(1, log10_pow2(4));\n    assert_eq!(496, log10_pow2(1650));\n}", "code_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/src/common.rs::log10_pow2", "code": "pub fn log10_pow2(e: i32) -> u32 /* or u32 -> u32 */ {\n    // The first value this approximation fails for is 2^1651 which is just greater than 10^297.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 1650);\n    (e as u32 * 78913) >> 18\n}", "docstring": null}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/common_test.rs::test_log10_pow5", "test": "fn test_log10_pow5() {\n    assert_eq!(0, log10_pow5(0));\n    assert_eq!(0, log10_pow5(1));\n    assert_eq!(1, log10_pow5(2));\n    assert_eq!(2, log10_pow5(3));\n    assert_eq!(2, log10_pow5(4));\n    assert_eq!(1831, log10_pow5(2620));\n}", "code_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/src/common.rs::log10_pow5", "code": "pub fn log10_pow5(e: i32) -> u32 /* or u32 -> u32 */ {\n    // The first value this approximation fails for is 5^2621 which is just greater than 10^1832.\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 2620);\n    (e as u32 * 732923) >> 20\n}", "docstring": null}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/d2s_test.rs::test_basic", "test": "fn test_basic() {\n    check!(0.0);\n    check!(-0.0);\n    check!(1.0);\n    check!(-1.0);\n    assert_eq!(pretty(f64::NAN), \"NaN\");\n    assert_eq!(pretty(f64::INFINITY), \"inf\");\n    assert_eq!(pretty(f64::NEG_INFINITY), \"-inf\");\n}", "code_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/d2s_test.rs::pretty", "code": "fn pretty(f: f64) -> String {\n    ryu::Buffer::new().format(f).to_owned()\n}", "docstring": null}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/f2s_test.rs::test_basic", "test": "fn test_basic() {\n    check!(0.0);\n    check!(-0.0);\n    check!(1.0);\n    check!(-1.0);\n    assert_eq!(pretty(f32::NAN), \"NaN\");\n    assert_eq!(pretty(f32::INFINITY), \"inf\");\n    assert_eq!(pretty(f32::NEG_INFINITY), \"-inf\");\n}", "code_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/d2s_test.rs::pretty", "code": "fn pretty(f: f64) -> String {\n    ryu::Buffer::new().format(f).to_owned()\n}", "docstring": null}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_bad_input", "test": "fn test_bad_input() {\n    assert_eq!(Error::MalformedInput, s2d(b\"x\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1..1\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"..\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1..1\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1ee1\").unwrap_err());\n    assert_eq!(Error::MalformedInput, s2d(b\"1e.1\").unwrap_err());\n    assert_eq!(Error::InputTooShort, s2d(b\"\").unwrap_err());\n    assert_eq!(Error::InputTooLong, s2d(b\"123456789012345678\").unwrap_err());\n    assert_eq!(Error::InputTooLong, s2d(b\"1e12345\").unwrap_err());\n}", "code_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/src/s2d.rs::s2d", "code": "pub fn s2d(buffer: &[u8]) -> Result<f64, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u64;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index != len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 17 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u64;\n        if m10 != 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.\n                return Err(Error::InputTooLong);\n            }\n            e10 = 10 * e10 + (c - b'0') as i32;\n            if e10 != 0 {\n                e10digits += 1;\n            }\n            i += 1;\n        }\n    }\n\n    if i < len {\n        return Err(Error::MalformedInput);\n    }\n    if signed_e {\n        e10 = -e10;\n    }\n    e10 -= if dot_index < e_index {\n        (e_index - dot_index - 1) as i32\n    } else {\n        0\n    };\n    if m10 == 0 {\n        return Ok(if signed_m { -0.0 } else { 0.0 });\n    }\n\n    if m10digits + e10 <= -324 || m10 == 0 {\n        // Number is less than 1e-324, which should be rounded down to 0; return\n        // +/-0.0.\n        let ieee = (signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n    if m10digits + e10 >= 310 {\n        // Number is larger than 1e+309, which should be rounded to +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // Convert to binary float m2 * 2^e2, while retaining information about\n    // whether the conversion was exact (trailing_zeros).\n    let e2: i32;\n    let m2: u64;\n    let mut trailing_zeros: bool;\n    if e10 >= 0 {\n        // The length of m * 10^e in bits is:\n        //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)\n        //\n        // We want to compute the DOUBLE_MANTISSA_BITS + 1 top-most bits (+1 for\n        // the implicit leading one in IEEE format). We therefore choose a\n        // binary output exponent of\n        //   log2(m10 * 10^e10) - (DOUBLE_MANTISSA_BITS + 1).\n        //\n        // We use floor(log2(5^e10)) so that we get at least this many bits;\n        // better to have an additional bit than to not have enough bits.\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_add(log2_pow5(e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].\n        // To that end, we use the DOUBLE_POW5_SPLIT table.\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_sub(ceil_log2_pow5(e10))\n            .wrapping_add(d2s::DOUBLE_POW5_BITCOUNT);\n        debug_assert!(j >= 0);\n        debug_assert!(e10 < d2s::DOUBLE_POW5_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_SPLIT.get_unchecked(e10 as usize) },\n            j as u32,\n        );\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.\n        // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn\n        // requires that the largest power of 2 that divides m10 + e10 is\n        // greater than e2. If e2 is less than e10, then the result must be\n        // exact. Otherwise we use the existing multiple_of_power_of_2 function.\n        trailing_zeros =\n            e2 < e10 || e2 - e10 < 64 && multiple_of_power_of_2(m10, (e2 - e10) as u32);\n    } else {\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_sub(ceil_log2_pow5(-e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_add(ceil_log2_pow5(-e10))\n            .wrapping_sub(1)\n            .wrapping_add(d2s::DOUBLE_POW5_INV_BITCOUNT);\n        debug_assert!(-e10 < d2s::DOUBLE_POW5_INV_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_INV_SPLIT.get_unchecked(-e10 as usize) },\n            j as u32,\n        );\n        trailing_zeros = multiple_of_power_of_5(m10, -e10 as u32);\n    }\n\n    // Compute the final IEEE exponent.\n    let mut ieee_e2 = i32::max(0, e2 + DOUBLE_EXPONENT_BIAS as i32 + floor_log2(m2) as i32) as u32;\n\n    if ieee_e2 > 0x7fe {\n        // Final IEEE exponent is larger than the maximum representable; return +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // We need to figure out how much we need to shift m2. The tricky part is\n    // that we need to take the final IEEE exponent into account, so we need to\n    // reverse the bias and also special-case the value 0.\n    let shift = if ieee_e2 == 0 { 1 } else { ieee_e2 as i32 }\n        .wrapping_sub(e2)\n        .wrapping_sub(DOUBLE_EXPONENT_BIAS as i32)\n        .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS as i32);\n    debug_assert!(shift >= 0);\n\n    // We need to round up if the exact value is more than 0.5 above the value\n    // we computed. That's equivalent to checking if the last removed bit was 1\n    // and either the value was not just trailing zeros or the result would\n    // otherwise be odd.\n    //\n    // We need to update trailing_zeros given that we have the exact output\n    // exponent ieee_e2 now.\n    trailing_zeros &= (m2 & ((1_u64 << (shift - 1)) - 1)) == 0;\n    let last_removed_bit = (m2 >> (shift - 1)) & 1;\n    let round_up = last_removed_bit != 0 && (!trailing_zeros || ((m2 >> shift) & 1) != 0);\n\n    let mut ieee_m2 = (m2 >> shift).wrapping_add(round_up as u64);\n    debug_assert!(ieee_m2 <= 1_u64 << (d2s::DOUBLE_MANTISSA_BITS + 1));\n    ieee_m2 &= (1_u64 << d2s::DOUBLE_MANTISSA_BITS) - 1;\n    if ieee_m2 == 0 && round_up {\n        // Due to how the IEEE represents +/-Infinity, we don't need to check\n        // for overflow here.\n        ieee_e2 += 1;\n    }\n    let ieee = ((((signed_m as u64) << d2s::DOUBLE_EXPONENT_BITS) | ieee_e2 as u64)\n        << d2s::DOUBLE_MANTISSA_BITS)\n        | ieee_m2;\n    Ok(f64::from_bits(ieee))\n}", "docstring": null}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_basic", "test": "fn test_basic() {\n    assert_eq!(0.0, s2d(b\"0\").unwrap());\n    assert_eq!(-0.0, s2d(b\"-0\").unwrap());\n    assert_eq!(1.0, s2d(b\"1\").unwrap());\n    assert_eq!(2.0, s2d(b\"2\").unwrap());\n    assert_eq!(123456789.0, s2d(b\"123456789\").unwrap());\n    assert_eq!(123.456, s2d(b\"123.456\").unwrap());\n    assert_eq!(123.456, s2d(b\"123456e-3\").unwrap());\n    assert_eq!(123.456, s2d(b\"1234.56e-1\").unwrap());\n    assert_eq!(1.453, s2d(b\"1.453\").unwrap());\n    assert_eq!(1453.0, s2d(b\"1.453e+3\").unwrap());\n    assert_eq!(0.0, s2d(b\".0\").unwrap());\n    assert_eq!(1.0, s2d(b\"1e0\").unwrap());\n    assert_eq!(1.0, s2d(b\"1E0\").unwrap());\n    assert_eq!(1.0, s2d(b\"000001.000000\").unwrap());\n    assert_eq!(0.2316419, s2d(b\"0.2316419\").unwrap());\n}", "code_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/src/s2d.rs::s2d", "code": "pub fn s2d(buffer: &[u8]) -> Result<f64, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u64;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index != len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 17 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u64;\n        if m10 != 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.\n                return Err(Error::InputTooLong);\n            }\n            e10 = 10 * e10 + (c - b'0') as i32;\n            if e10 != 0 {\n                e10digits += 1;\n            }\n            i += 1;\n        }\n    }\n\n    if i < len {\n        return Err(Error::MalformedInput);\n    }\n    if signed_e {\n        e10 = -e10;\n    }\n    e10 -= if dot_index < e_index {\n        (e_index - dot_index - 1) as i32\n    } else {\n        0\n    };\n    if m10 == 0 {\n        return Ok(if signed_m { -0.0 } else { 0.0 });\n    }\n\n    if m10digits + e10 <= -324 || m10 == 0 {\n        // Number is less than 1e-324, which should be rounded down to 0; return\n        // +/-0.0.\n        let ieee = (signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n    if m10digits + e10 >= 310 {\n        // Number is larger than 1e+309, which should be rounded to +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // Convert to binary float m2 * 2^e2, while retaining information about\n    // whether the conversion was exact (trailing_zeros).\n    let e2: i32;\n    let m2: u64;\n    let mut trailing_zeros: bool;\n    if e10 >= 0 {\n        // The length of m * 10^e in bits is:\n        //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)\n        //\n        // We want to compute the DOUBLE_MANTISSA_BITS + 1 top-most bits (+1 for\n        // the implicit leading one in IEEE format). We therefore choose a\n        // binary output exponent of\n        //   log2(m10 * 10^e10) - (DOUBLE_MANTISSA_BITS + 1).\n        //\n        // We use floor(log2(5^e10)) so that we get at least this many bits;\n        // better to have an additional bit than to not have enough bits.\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_add(log2_pow5(e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].\n        // To that end, we use the DOUBLE_POW5_SPLIT table.\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_sub(ceil_log2_pow5(e10))\n            .wrapping_add(d2s::DOUBLE_POW5_BITCOUNT);\n        debug_assert!(j >= 0);\n        debug_assert!(e10 < d2s::DOUBLE_POW5_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_SPLIT.get_unchecked(e10 as usize) },\n            j as u32,\n        );\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.\n        // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn\n        // requires that the largest power of 2 that divides m10 + e10 is\n        // greater than e2. If e2 is less than e10, then the result must be\n        // exact. Otherwise we use the existing multiple_of_power_of_2 function.\n        trailing_zeros =\n            e2 < e10 || e2 - e10 < 64 && multiple_of_power_of_2(m10, (e2 - e10) as u32);\n    } else {\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_sub(ceil_log2_pow5(-e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_add(ceil_log2_pow5(-e10))\n            .wrapping_sub(1)\n            .wrapping_add(d2s::DOUBLE_POW5_INV_BITCOUNT);\n        debug_assert!(-e10 < d2s::DOUBLE_POW5_INV_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_INV_SPLIT.get_unchecked(-e10 as usize) },\n            j as u32,\n        );\n        trailing_zeros = multiple_of_power_of_5(m10, -e10 as u32);\n    }\n\n    // Compute the final IEEE exponent.\n    let mut ieee_e2 = i32::max(0, e2 + DOUBLE_EXPONENT_BIAS as i32 + floor_log2(m2) as i32) as u32;\n\n    if ieee_e2 > 0x7fe {\n        // Final IEEE exponent is larger than the maximum representable; return +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // We need to figure out how much we need to shift m2. The tricky part is\n    // that we need to take the final IEEE exponent into account, so we need to\n    // reverse the bias and also special-case the value 0.\n    let shift = if ieee_e2 == 0 { 1 } else { ieee_e2 as i32 }\n        .wrapping_sub(e2)\n        .wrapping_sub(DOUBLE_EXPONENT_BIAS as i32)\n        .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS as i32);\n    debug_assert!(shift >= 0);\n\n    // We need to round up if the exact value is more than 0.5 above the value\n    // we computed. That's equivalent to checking if the last removed bit was 1\n    // and either the value was not just trailing zeros or the result would\n    // otherwise be odd.\n    //\n    // We need to update trailing_zeros given that we have the exact output\n    // exponent ieee_e2 now.\n    trailing_zeros &= (m2 & ((1_u64 << (shift - 1)) - 1)) == 0;\n    let last_removed_bit = (m2 >> (shift - 1)) & 1;\n    let round_up = last_removed_bit != 0 && (!trailing_zeros || ((m2 >> shift) & 1) != 0);\n\n    let mut ieee_m2 = (m2 >> shift).wrapping_add(round_up as u64);\n    debug_assert!(ieee_m2 <= 1_u64 << (d2s::DOUBLE_MANTISSA_BITS + 1));\n    ieee_m2 &= (1_u64 << d2s::DOUBLE_MANTISSA_BITS) - 1;\n    if ieee_m2 == 0 && round_up {\n        // Due to how the IEEE represents +/-Infinity, we don't need to check\n        // for overflow here.\n        ieee_e2 += 1;\n    }\n    let ieee = ((((signed_m as u64) << d2s::DOUBLE_EXPONENT_BITS) | ieee_e2 as u64)\n        << d2s::DOUBLE_MANTISSA_BITS)\n        | ieee_m2;\n    Ok(f64::from_bits(ieee))\n}", "docstring": null}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2d_test.rs::test_overflow", "test": "fn test_overflow() {\n    assert_eq!(f64::INFINITY, s2d(b\"2e308\").unwrap());\n    assert_eq!(f64::INFINITY, s2d(b\"1e309\").unwrap());\n}", "code_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/src/s2d.rs::s2d", "code": "pub fn s2d(buffer: &[u8]) -> Result<f64, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u64;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index != len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 17 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u64;\n        if m10 != 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.\n                return Err(Error::InputTooLong);\n            }\n            e10 = 10 * e10 + (c - b'0') as i32;\n            if e10 != 0 {\n                e10digits += 1;\n            }\n            i += 1;\n        }\n    }\n\n    if i < len {\n        return Err(Error::MalformedInput);\n    }\n    if signed_e {\n        e10 = -e10;\n    }\n    e10 -= if dot_index < e_index {\n        (e_index - dot_index - 1) as i32\n    } else {\n        0\n    };\n    if m10 == 0 {\n        return Ok(if signed_m { -0.0 } else { 0.0 });\n    }\n\n    if m10digits + e10 <= -324 || m10 == 0 {\n        // Number is less than 1e-324, which should be rounded down to 0; return\n        // +/-0.0.\n        let ieee = (signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n    if m10digits + e10 >= 310 {\n        // Number is larger than 1e+309, which should be rounded to +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // Convert to binary float m2 * 2^e2, while retaining information about\n    // whether the conversion was exact (trailing_zeros).\n    let e2: i32;\n    let m2: u64;\n    let mut trailing_zeros: bool;\n    if e10 >= 0 {\n        // The length of m * 10^e in bits is:\n        //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)\n        //\n        // We want to compute the DOUBLE_MANTISSA_BITS + 1 top-most bits (+1 for\n        // the implicit leading one in IEEE format). We therefore choose a\n        // binary output exponent of\n        //   log2(m10 * 10^e10) - (DOUBLE_MANTISSA_BITS + 1).\n        //\n        // We use floor(log2(5^e10)) so that we get at least this many bits;\n        // better to have an additional bit than to not have enough bits.\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_add(log2_pow5(e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].\n        // To that end, we use the DOUBLE_POW5_SPLIT table.\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_sub(ceil_log2_pow5(e10))\n            .wrapping_add(d2s::DOUBLE_POW5_BITCOUNT);\n        debug_assert!(j >= 0);\n        debug_assert!(e10 < d2s::DOUBLE_POW5_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_SPLIT.get_unchecked(e10 as usize) },\n            j as u32,\n        );\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.\n        // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn\n        // requires that the largest power of 2 that divides m10 + e10 is\n        // greater than e2. If e2 is less than e10, then the result must be\n        // exact. Otherwise we use the existing multiple_of_power_of_2 function.\n        trailing_zeros =\n            e2 < e10 || e2 - e10 < 64 && multiple_of_power_of_2(m10, (e2 - e10) as u32);\n    } else {\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_sub(ceil_log2_pow5(-e10) as u32)\n            .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS + 1) as i32;\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_add(ceil_log2_pow5(-e10))\n            .wrapping_sub(1)\n            .wrapping_add(d2s::DOUBLE_POW5_INV_BITCOUNT);\n        debug_assert!(-e10 < d2s::DOUBLE_POW5_INV_SPLIT.len() as i32);\n        m2 = mul_shift_64(\n            m10,\n            unsafe { d2s::DOUBLE_POW5_INV_SPLIT.get_unchecked(-e10 as usize) },\n            j as u32,\n        );\n        trailing_zeros = multiple_of_power_of_5(m10, -e10 as u32);\n    }\n\n    // Compute the final IEEE exponent.\n    let mut ieee_e2 = i32::max(0, e2 + DOUBLE_EXPONENT_BIAS as i32 + floor_log2(m2) as i32) as u32;\n\n    if ieee_e2 > 0x7fe {\n        // Final IEEE exponent is larger than the maximum representable; return +/-Infinity.\n        let ieee = ((signed_m as u64) << (d2s::DOUBLE_EXPONENT_BITS + d2s::DOUBLE_MANTISSA_BITS))\n            | (0x7ff_u64 << d2s::DOUBLE_MANTISSA_BITS);\n        return Ok(f64::from_bits(ieee));\n    }\n\n    // We need to figure out how much we need to shift m2. The tricky part is\n    // that we need to take the final IEEE exponent into account, so we need to\n    // reverse the bias and also special-case the value 0.\n    let shift = if ieee_e2 == 0 { 1 } else { ieee_e2 as i32 }\n        .wrapping_sub(e2)\n        .wrapping_sub(DOUBLE_EXPONENT_BIAS as i32)\n        .wrapping_sub(d2s::DOUBLE_MANTISSA_BITS as i32);\n    debug_assert!(shift >= 0);\n\n    // We need to round up if the exact value is more than 0.5 above the value\n    // we computed. That's equivalent to checking if the last removed bit was 1\n    // and either the value was not just trailing zeros or the result would\n    // otherwise be odd.\n    //\n    // We need to update trailing_zeros given that we have the exact output\n    // exponent ieee_e2 now.\n    trailing_zeros &= (m2 & ((1_u64 << (shift - 1)) - 1)) == 0;\n    let last_removed_bit = (m2 >> (shift - 1)) & 1;\n    let round_up = last_removed_bit != 0 && (!trailing_zeros || ((m2 >> shift) & 1) != 0);\n\n    let mut ieee_m2 = (m2 >> shift).wrapping_add(round_up as u64);\n    debug_assert!(ieee_m2 <= 1_u64 << (d2s::DOUBLE_MANTISSA_BITS + 1));\n    ieee_m2 &= (1_u64 << d2s::DOUBLE_MANTISSA_BITS) - 1;\n    if ieee_m2 == 0 && round_up {\n        // Due to how the IEEE represents +/-Infinity, we don't need to check\n        // for overflow here.\n        ieee_e2 += 1;\n    }\n    let ieee = ((((signed_m as u64) << d2s::DOUBLE_EXPONENT_BITS) | ieee_e2 as u64)\n        << d2s::DOUBLE_MANTISSA_BITS)\n        | ieee_m2;\n    Ok(f64::from_bits(ieee))\n}", "docstring": null}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2f_test.rs::test_basic", "test": "fn test_basic() {\n    assert_eq!(0.0, s2f(b\"0\").unwrap());\n    assert_eq!(-0.0, s2f(b\"-0\").unwrap());\n    assert_eq!(1.0, s2f(b\"1\").unwrap());\n    assert_eq!(-1.0, s2f(b\"-1\").unwrap());\n    assert_eq!(123456792.0, s2f(b\"123456789\").unwrap());\n    assert_eq!(299792448.0, s2f(b\"299792458\").unwrap());\n}", "code_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/src/s2f.rs::s2f", "code": "pub fn s2f(buffer: &[u8]) -> Result<f32, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u32;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index != len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 9 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u32;\n        if m10 != 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.\n                return Err(Error::InputTooLong);\n            }\n            e10 = 10 * e10 + (c - b'0') as i32;\n            if e10 != 0 {\n                e10digits += 1;\n            }\n            i += 1;\n        }\n    }\n\n    if i < len {\n        return Err(Error::MalformedInput);\n    }\n    if signed_e {\n        e10 = -e10;\n    }\n    e10 -= if dot_index < e_index {\n        (e_index - dot_index - 1) as i32\n    } else {\n        0\n    };\n    if m10 == 0 {\n        return Ok(if signed_m { -0.0 } else { 0.0 });\n    }\n\n    if m10digits + e10 <= -46 || m10 == 0 {\n        // Number is less than 1e-46, which should be rounded down to 0; return\n        // +/-0.0.\n        let ieee = (signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n    if m10digits + e10 >= 40 {\n        // Number is larger than 1e+39, which should be rounded to +/-Infinity.\n        let ieee = ((signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS))\n            | (0xff_u32 << f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n\n    // Convert to binary float m2 * 2^e2, while retaining information about\n    // whether the conversion was exact (trailing_zeros).\n    let e2: i32;\n    let m2: u32;\n    let mut trailing_zeros: bool;\n    if e10 >= 0 {\n        // The length of m * 10^e in bits is:\n        //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)\n        //\n        // We want to compute the FLOAT_MANTISSA_BITS + 1 top-most bits (+1 for\n        // the implicit leading one in IEEE format). We therefore choose a\n        // binary output exponent of\n        //   log2(m10 * 10^e10) - (FLOAT_MANTISSA_BITS + 1).\n        //\n        // We use floor(log2(5^e10)) so that we get at least this many bits; better to\n        // have an additional bit than to not have enough bits.\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_add(log2_pow5(e10) as u32)\n            .wrapping_sub(f2s::FLOAT_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].\n        // To that end, we use the FLOAT_POW5_SPLIT table.\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_sub(ceil_log2_pow5(e10))\n            .wrapping_add(f2s::FLOAT_POW5_BITCOUNT);\n        debug_assert!(j >= 0);\n        m2 = mul_pow5_div_pow2(m10, e10 as u32, j);\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.\n        // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn\n        // requires that the largest power of 2 that divides m10 + e10 is\n        // greater than e2. If e2 is less than e10, then the result must be\n        // exact. Otherwise we use the existing multiple_of_power_of_2 function.\n        trailing_zeros =\n            e2 < e10 || e2 - e10 < 32 && multiple_of_power_of_2_32(m10, (e2 - e10) as u32);\n    } else {\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_sub(ceil_log2_pow5(-e10) as u32)\n            .wrapping_sub(f2s::FLOAT_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 / (5^(-e10) 2^(e2-e10))].\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_add(ceil_log2_pow5(-e10))\n            .wrapping_sub(1)\n            .wrapping_add(f2s::FLOAT_POW5_INV_BITCOUNT);\n        m2 = mul_pow5_inv_div_pow2(m10, -e10 as u32, j);\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 / (5^(-e10) 2^(e2-e10))] == m10 / (5^(-e10) 2^(e2-e10))\n        //\n        // If e2-e10 >= 0, we need to check whether (5^(-e10) 2^(e2-e10))\n        // divides m10, which is the case iff pow5(m10) >= -e10 AND pow2(m10) >=\n        // e2-e10.\n        //\n        // If e2-e10 < 0, we have actually computed [m10 * 2^(e10 e2) /\n        // 5^(-e10)] above, and we need to check whether 5^(-e10) divides (m10 *\n        // 2^(e10-e2)), which is the case iff pow5(m10 * 2^(e10-e2)) = pow5(m10)\n        // >= -e10.\n        trailing_zeros = (e2 < e10\n            || (e2 - e10 < 32 && multiple_of_power_of_2_32(m10, (e2 - e10) as u32)))\n            && multiple_of_power_of_5_32(m10, -e10 as u32);\n    }\n\n    // Compute the final IEEE exponent.\n    let mut ieee_e2 = i32::max(0, e2 + FLOAT_EXPONENT_BIAS as i32 + floor_log2(m2) as i32) as u32;\n\n    if ieee_e2 > 0xfe {\n        // Final IEEE exponent is larger than the maximum representable; return\n        // +/-Infinity.\n        let ieee = ((signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS))\n            | (0xff_u32 << f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n\n    // We need to figure out how much we need to shift m2. The tricky part is\n    // that we need to take the final IEEE exponent into account, so we need to\n    // reverse the bias and also special-case the value 0.\n    let shift = if ieee_e2 == 0 { 1 } else { ieee_e2 as i32 }\n        .wrapping_sub(e2)\n        .wrapping_sub(FLOAT_EXPONENT_BIAS as i32)\n        .wrapping_sub(f2s::FLOAT_MANTISSA_BITS as i32);\n    debug_assert!(shift >= 0);\n\n    // We need to round up if the exact value is more than 0.5 above the value\n    // we computed. That's equivalent to checking if the last removed bit was 1\n    // and either the value was not just trailing zeros or the result would\n    // otherwise be odd.\n    //\n    // We need to update trailing_zeros given that we have the exact output\n    // exponent ieee_e2 now.\n    trailing_zeros &= (m2 & ((1_u32 << (shift - 1)) - 1)) == 0;\n    let last_removed_bit = (m2 >> (shift - 1)) & 1;\n    let round_up = last_removed_bit != 0 && (!trailing_zeros || ((m2 >> shift) & 1) != 0);\n\n    let mut ieee_m2 = (m2 >> shift).wrapping_add(round_up as u32);\n    debug_assert!(ieee_m2 <= 1_u32 << (f2s::FLOAT_MANTISSA_BITS + 1));\n    ieee_m2 &= (1_u32 << f2s::FLOAT_MANTISSA_BITS) - 1;\n    if ieee_m2 == 0 && round_up {\n        // Rounding up may overflow the mantissa.\n        // In this case we move a trailing zero of the mantissa into the\n        // exponent.\n        // Due to how the IEEE represents +/-Infinity, we don't need to check\n        // for overflow here.\n        ieee_e2 += 1;\n    }\n    let ieee = ((((signed_m as u32) << f2s::FLOAT_EXPONENT_BITS) | ieee_e2)\n        << f2s::FLOAT_MANTISSA_BITS)\n        | ieee_m2;\n    Ok(f32::from_bits(ieee))\n}", "docstring": null}
{"test_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/tests/s2f_test.rs::test_min_max", "test": "fn test_min_max() {\n    assert_eq!(1e-45, s2f(b\"1e-45\").unwrap());\n    assert_eq!(f32::MIN_POSITIVE, s2f(b\"1.1754944e-38\").unwrap());\n    assert_eq!(f32::MAX, s2f(b\"3.4028235e+38\").unwrap());\n}", "code_id": "dtolnay-ryu/dtolnay-ryu-2fc2d1c/src/s2f.rs::s2f", "code": "pub fn s2f(buffer: &[u8]) -> Result<f32, Error> {\n    let len = buffer.len();\n    if len == 0 {\n        return Err(Error::InputTooShort);\n    }\n\n    let mut m10digits = 0;\n    let mut e10digits = 0;\n    let mut dot_index = len;\n    let mut e_index = len;\n    let mut m10 = 0u32;\n    let mut e10 = 0i32;\n    let mut signed_m = false;\n    let mut signed_e = false;\n\n    let mut i = 0;\n    if unsafe { *buffer.get_unchecked(0) } == b'-' {\n        signed_m = true;\n        i += 1;\n    }\n\n    while let Some(c) = buffer.get(i).copied() {\n        if c == b'.' {\n            if dot_index != len {\n                return Err(Error::MalformedInput);\n            }\n            dot_index = i;\n            i += 1;\n            continue;\n        }\n        if c < b'0' || c > b'9' {\n            break;\n        }\n        if m10digits >= 9 {\n            return Err(Error::InputTooLong);\n        }\n        m10 = 10 * m10 + (c - b'0') as u32;\n        if m10 != 0 {\n            m10digits += 1;\n        }\n        i += 1;\n    }\n\n    if let Some(b'e') | Some(b'E') = buffer.get(i) {\n        e_index = i;\n        i += 1;\n        match buffer.get(i) {\n            Some(b'-') => {\n                signed_e = true;\n                i += 1;\n            }\n            Some(b'+') => i += 1,\n            _ => {}\n        }\n        while let Some(c) = buffer.get(i).copied() {\n            if c < b'0' || c > b'9' {\n                return Err(Error::MalformedInput);\n            }\n            if e10digits > 3 {\n                // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.\n                return Err(Error::InputTooLong);\n            }\n            e10 = 10 * e10 + (c - b'0') as i32;\n            if e10 != 0 {\n                e10digits += 1;\n            }\n            i += 1;\n        }\n    }\n\n    if i < len {\n        return Err(Error::MalformedInput);\n    }\n    if signed_e {\n        e10 = -e10;\n    }\n    e10 -= if dot_index < e_index {\n        (e_index - dot_index - 1) as i32\n    } else {\n        0\n    };\n    if m10 == 0 {\n        return Ok(if signed_m { -0.0 } else { 0.0 });\n    }\n\n    if m10digits + e10 <= -46 || m10 == 0 {\n        // Number is less than 1e-46, which should be rounded down to 0; return\n        // +/-0.0.\n        let ieee = (signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n    if m10digits + e10 >= 40 {\n        // Number is larger than 1e+39, which should be rounded to +/-Infinity.\n        let ieee = ((signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS))\n            | (0xff_u32 << f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n\n    // Convert to binary float m2 * 2^e2, while retaining information about\n    // whether the conversion was exact (trailing_zeros).\n    let e2: i32;\n    let m2: u32;\n    let mut trailing_zeros: bool;\n    if e10 >= 0 {\n        // The length of m * 10^e in bits is:\n        //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)\n        //\n        // We want to compute the FLOAT_MANTISSA_BITS + 1 top-most bits (+1 for\n        // the implicit leading one in IEEE format). We therefore choose a\n        // binary output exponent of\n        //   log2(m10 * 10^e10) - (FLOAT_MANTISSA_BITS + 1).\n        //\n        // We use floor(log2(5^e10)) so that we get at least this many bits; better to\n        // have an additional bit than to not have enough bits.\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_add(log2_pow5(e10) as u32)\n            .wrapping_sub(f2s::FLOAT_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].\n        // To that end, we use the FLOAT_POW5_SPLIT table.\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_sub(ceil_log2_pow5(e10))\n            .wrapping_add(f2s::FLOAT_POW5_BITCOUNT);\n        debug_assert!(j >= 0);\n        m2 = mul_pow5_div_pow2(m10, e10 as u32, j);\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.\n        // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn\n        // requires that the largest power of 2 that divides m10 + e10 is\n        // greater than e2. If e2 is less than e10, then the result must be\n        // exact. Otherwise we use the existing multiple_of_power_of_2 function.\n        trailing_zeros =\n            e2 < e10 || e2 - e10 < 32 && multiple_of_power_of_2_32(m10, (e2 - e10) as u32);\n    } else {\n        e2 = floor_log2(m10)\n            .wrapping_add(e10 as u32)\n            .wrapping_sub(ceil_log2_pow5(-e10) as u32)\n            .wrapping_sub(f2s::FLOAT_MANTISSA_BITS + 1) as i32;\n\n        // We now compute [m10 * 10^e10 / 2^e2] = [m10 / (5^(-e10) 2^(e2-e10))].\n        let j = e2\n            .wrapping_sub(e10)\n            .wrapping_add(ceil_log2_pow5(-e10))\n            .wrapping_sub(1)\n            .wrapping_add(f2s::FLOAT_POW5_INV_BITCOUNT);\n        m2 = mul_pow5_inv_div_pow2(m10, -e10 as u32, j);\n\n        // We also compute if the result is exact, i.e.,\n        //   [m10 / (5^(-e10) 2^(e2-e10))] == m10 / (5^(-e10) 2^(e2-e10))\n        //\n        // If e2-e10 >= 0, we need to check whether (5^(-e10) 2^(e2-e10))\n        // divides m10, which is the case iff pow5(m10) >= -e10 AND pow2(m10) >=\n        // e2-e10.\n        //\n        // If e2-e10 < 0, we have actually computed [m10 * 2^(e10 e2) /\n        // 5^(-e10)] above, and we need to check whether 5^(-e10) divides (m10 *\n        // 2^(e10-e2)), which is the case iff pow5(m10 * 2^(e10-e2)) = pow5(m10)\n        // >= -e10.\n        trailing_zeros = (e2 < e10\n            || (e2 - e10 < 32 && multiple_of_power_of_2_32(m10, (e2 - e10) as u32)))\n            && multiple_of_power_of_5_32(m10, -e10 as u32);\n    }\n\n    // Compute the final IEEE exponent.\n    let mut ieee_e2 = i32::max(0, e2 + FLOAT_EXPONENT_BIAS as i32 + floor_log2(m2) as i32) as u32;\n\n    if ieee_e2 > 0xfe {\n        // Final IEEE exponent is larger than the maximum representable; return\n        // +/-Infinity.\n        let ieee = ((signed_m as u32) << (f2s::FLOAT_EXPONENT_BITS + f2s::FLOAT_MANTISSA_BITS))\n            | (0xff_u32 << f2s::FLOAT_MANTISSA_BITS);\n        return Ok(f32::from_bits(ieee));\n    }\n\n    // We need to figure out how much we need to shift m2. The tricky part is\n    // that we need to take the final IEEE exponent into account, so we need to\n    // reverse the bias and also special-case the value 0.\n    let shift = if ieee_e2 == 0 { 1 } else { ieee_e2 as i32 }\n        .wrapping_sub(e2)\n        .wrapping_sub(FLOAT_EXPONENT_BIAS as i32)\n        .wrapping_sub(f2s::FLOAT_MANTISSA_BITS as i32);\n    debug_assert!(shift >= 0);\n\n    // We need to round up if the exact value is more than 0.5 above the value\n    // we computed. That's equivalent to checking if the last removed bit was 1\n    // and either the value was not just trailing zeros or the result would\n    // otherwise be odd.\n    //\n    // We need to update trailing_zeros given that we have the exact output\n    // exponent ieee_e2 now.\n    trailing_zeros &= (m2 & ((1_u32 << (shift - 1)) - 1)) == 0;\n    let last_removed_bit = (m2 >> (shift - 1)) & 1;\n    let round_up = last_removed_bit != 0 && (!trailing_zeros || ((m2 >> shift) & 1) != 0);\n\n    let mut ieee_m2 = (m2 >> shift).wrapping_add(round_up as u32);\n    debug_assert!(ieee_m2 <= 1_u32 << (f2s::FLOAT_MANTISSA_BITS + 1));\n    ieee_m2 &= (1_u32 << f2s::FLOAT_MANTISSA_BITS) - 1;\n    if ieee_m2 == 0 && round_up {\n        // Rounding up may overflow the mantissa.\n        // In this case we move a trailing zero of the mantissa into the\n        // exponent.\n        // Due to how the IEEE represents +/-Infinity, we don't need to check\n        // for overflow here.\n        ieee_e2 += 1;\n    }\n    let ieee = ((((signed_m as u32) << f2s::FLOAT_EXPONENT_BITS) | ieee_e2)\n        << f2s::FLOAT_MANTISSA_BITS)\n        | ieee_m2;\n    Ok(f32::from_bits(ieee))\n}", "docstring": null}
