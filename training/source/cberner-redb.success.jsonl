{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::len", "test": "fn len() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        table.insert(\"hello2\", \"world2\").unwrap();\n        table.insert(\"hi\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(table.len().unwrap(), 3);\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/multimap_table.rs::len", "code": "fn len(&self) -> Result<u64> {\n        let mut count = 0;\n        for item in self.iter()? {\n            let (_, values) = item?;\n            for v in values {\n                v?;\n                count += 1;\n            }\n        }\n        Ok(count)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::drain", "test": "fn drain() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n        // Test draining uncommitted data\n        drop(table.drain(0..10).unwrap());\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        assert_eq!(table.len().unwrap(), 10);\n        for (i, item) in table.drain(0..5).unwrap().enumerate() {\n            let (k, v) = item.unwrap();\n            assert_eq!(i as u64, k.value());\n            assert_eq!(i as u64, v.value());\n        }\n        assert_eq!(table.len().unwrap(), 5);\n        let mut i = 5u64;\n        for item in table.range(0..10).unwrap() {\n            let (k, v) = item.unwrap();\n            assert_eq!(i, k.value());\n            assert_eq!(i, v.value());\n            i += 1;\n        }\n    }\n    write_txn.abort().unwrap();\n\n    // Check that dropping the iter early works too\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        assert_eq!(table.len().unwrap(), 10);\n        drop(table.drain(0..5).unwrap());\n        assert_eq!(table.len().unwrap(), 5);\n    }\n    write_txn.abort().unwrap();\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/multimap_table.rs::len", "code": "fn len(&self) -> Result<u64> {\n        let mut count = 0;\n        for item in self.iter()? {\n            let (_, values) = item?;\n            for v in values {\n                v?;\n                count += 1;\n            }\n        }\n        Ok(count)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::drain_filter", "test": "fn drain_filter() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n        // Test draining uncommitted data\n        drop(table.drain_filter(0..10, |k, _| k < 5).unwrap());\n        for i in 0..5 {\n            table.insert(&i, &i).unwrap();\n        }\n        assert_eq!(table.len().unwrap(), 10);\n\n        // Test matching on the value\n        drop(table.drain_filter(0..10, |_, v| v < 5).unwrap());\n        for i in 0..5 {\n            table.insert(&i, &i).unwrap();\n        }\n        assert_eq!(table.len().unwrap(), 10);\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        assert_eq!(table.len().unwrap(), 10);\n        for (i, item) in table.drain_filter(0.., |x, _| x < 5).unwrap().enumerate() {\n            let (k, v) = item.unwrap();\n            assert_eq!(i as u64, k.value());\n            assert_eq!(i as u64, v.value());\n        }\n        assert_eq!(table.len().unwrap(), 5);\n        let mut i = 5u64;\n        for item in table.range(0..10).unwrap() {\n            let (k, v) = item.unwrap();\n            assert_eq!(i, k.value());\n            assert_eq!(i, v.value());\n            i += 1;\n        }\n    }\n    write_txn.abort().unwrap();\n\n    // Check that dropping the iter early works too\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        assert_eq!(table.len().unwrap(), 10);\n        drop(table.drain_filter(0.., |x, _| x < 5).unwrap());\n        assert_eq!(table.len().unwrap(), 5);\n    }\n    write_txn.abort().unwrap();\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/multimap_table.rs::len", "code": "fn len(&self) -> Result<u64> {\n        let mut count = 0;\n        for item in self.iter()? {\n            let (_, values) = item?;\n            for v in values {\n                v?;\n                count += 1;\n            }\n        }\n        Ok(count)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::stored_size", "test": "fn stored_size() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    assert_eq!(write_txn.stats().unwrap().stored_bytes(), 10);\n    assert!(write_txn.stats().unwrap().fragmented_bytes() > 0);\n    assert!(write_txn.stats().unwrap().metadata_bytes() > 0);\n    write_txn.abort().unwrap();\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/transactions.rs::stored_bytes", "code": "pub fn stored_bytes(&self) -> u64 {\n        self.stored_leaf_bytes\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::create_open", "test": "fn create_open() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        table.insert(&0, &1).unwrap();\n    }\n    write_txn.commit().unwrap();\n    drop(db);\n\n    let db2 = Database::open(tmpfile.path()).unwrap();\n\n    let read_txn = db2.begin_read().unwrap();\n    let table = read_txn.open_table(U64_TABLE).unwrap();\n    assert_eq!(1, table.get(&0).unwrap().unwrap().value());\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::multiple_tables", "test": "fn multiple_tables() {\n    let definition1: TableDefinition<&str, &str> = TableDefinition::new(\"1\");\n    let definition2: TableDefinition<&str, &str> = TableDefinition::new(\"2\");\n\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition1).unwrap();\n        let mut table2 = write_txn.open_table(definition2).unwrap();\n\n        table.insert(\"hello\", \"world\").unwrap();\n        table2.insert(\"hello\", \"world2\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition1).unwrap();\n    let table2 = read_txn.open_table(definition2).unwrap();\n    assert_eq!(table.len().unwrap(), 1);\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert_eq!(table2.len().unwrap(), 1);\n    assert_eq!(\"world2\", table2.get(\"hello\").unwrap().unwrap().value());\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/multimap_table.rs::len", "code": "fn len(&self) -> Result<u64> {\n        let mut count = 0;\n        for item in self.iter()? {\n            let (_, values) = item?;\n            for v in values {\n                v?;\n                count += 1;\n            }\n        }\n        Ok(count)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::tuple_type_lifetime", "test": "fn tuple_type_lifetime() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<(&str, u8), (u16, u32)> = TableDefinition::new(\"table\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(table_def).unwrap();\n        table\n            .insert(&(String::from(\"hello\").as_str(), 5), &(0, 123))\n            .unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(table_def).unwrap();\n    assert_eq!(table.get(&(\"hello\", 5)).unwrap().unwrap().value(), (0, 123));\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::tuple2_type", "test": "fn tuple2_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<(&str, u8), (u16, u32)> = TableDefinition::new(\"table\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(table_def).unwrap();\n        table.insert(&(\"hello\", 5), &(0, 123)).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(table_def).unwrap();\n    assert_eq!(table.get(&(\"hello\", 5)).unwrap().unwrap().value(), (0, 123));\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::tuple3_type", "test": "fn tuple3_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<(&str, u8, u16), (u16, u32)> = TableDefinition::new(\"table\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(table_def).unwrap();\n        table.insert(&(\"hello\", 5, 6), &(0, 123)).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(table_def).unwrap();\n    assert_eq!(\n        table.get(&(\"hello\", 5, 6)).unwrap().unwrap().value(),\n        (0, 123)\n    );\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::tuple4_type", "test": "fn tuple4_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<(&str, u8, u16, u32), (u16, u32)> =\n        TableDefinition::new(\"table\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(table_def).unwrap();\n        table.insert(&(\"hello\", 5, 6, 7), &(0, 123)).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(table_def).unwrap();\n    assert_eq!(\n        table.get(&(\"hello\", 5, 6, 7)).unwrap().unwrap().value(),\n        (0, 123)\n    );\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::is_empty", "test": "fn is_empty() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        assert!(table.is_empty().unwrap());\n        table.insert(\"hello\", \"world\").unwrap();\n        assert!(!table.is_empty().unwrap());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert!(!table.is_empty().unwrap());\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/multimap_table.rs::is_empty", "code": "fn is_empty(&self) -> Result<bool> {\n        self.len().map(|x| x == 0)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::abort", "test": "fn abort() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"aborted\").unwrap();\n        assert_eq!(\"aborted\", table.get(\"hello\").unwrap().unwrap().value());\n    }\n    write_txn.abort().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE);\n    assert!(table.is_err());\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert_eq!(table.len().unwrap(), 1);\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::insert_reserve", "test": "fn insert_reserve() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let def: TableDefinition<&str, &[u8]> = TableDefinition::new(\"x\");\n    let value = \"world\";\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(def).unwrap();\n        let mut reserved = table\n            .insert_reserve(\"hello\", value.len().try_into().unwrap())\n            .unwrap();\n        reserved.as_mut().copy_from_slice(value.as_bytes());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(def).unwrap();\n    assert_eq!(\n        value.as_bytes(),\n        table.get(\"hello\").unwrap().unwrap().value()\n    );\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/multimap_table.rs::as_bytes", "code": "fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> &'a [u8]\n    where\n        Self: 'a,\n        Self: 'b,\n    {\n        &value.data\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::delete", "test": "fn delete() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        table.insert(\"hello2\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert_eq!(table.len().unwrap(), 2);\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        assert_eq!(\"world\", table.remove(\"hello\").unwrap().unwrap().value());\n        assert!(table.remove(\"hello\").unwrap().is_none());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert!(table.get(\"hello\").unwrap().is_none());\n    assert_eq!(table.len().unwrap(), 1);\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::read_isolation", "test": "fn read_isolation() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut write_table = write_txn.open_table(STR_TABLE).unwrap();\n        write_table.remove(\"hello\").unwrap();\n        write_table.insert(\"hello2\", \"world2\").unwrap();\n        write_table.insert(\"hello3\", \"world3\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn2 = db.begin_read().unwrap();\n    let table2 = read_txn2.open_table(STR_TABLE).unwrap();\n    assert!(table2.get(\"hello\").unwrap().is_none());\n    assert_eq!(\"world2\", table2.get(\"hello2\").unwrap().unwrap().value());\n    assert_eq!(\"world3\", table2.get(\"hello3\").unwrap().unwrap().value());\n    assert_eq!(table2.len().unwrap(), 2);\n\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert!(table.get(\"hello2\").unwrap().is_none());\n    assert!(table.get(\"hello3\").unwrap().is_none());\n    assert_eq!(table.len().unwrap(), 1);\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::read_isolation2", "test": "fn read_isolation2() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    {\n        let mut write_table = write_txn.open_table(STR_TABLE).unwrap();\n        write_table.remove(\"hello\").unwrap();\n        write_table.insert(\"hello2\", \"world2\").unwrap();\n        write_table.insert(\"hello3\", \"world3\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn2 = db.begin_read().unwrap();\n    let table2 = read_txn2.open_table(STR_TABLE).unwrap();\n    assert!(table2.get(\"hello\").unwrap().is_none());\n    assert_eq!(\"world2\", table2.get(\"hello2\").unwrap().unwrap().value());\n    assert_eq!(\"world3\", table2.get(\"hello3\").unwrap().unwrap().value());\n    assert_eq!(table2.len().unwrap(), 2);\n\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n    assert!(table.get(\"hello2\").unwrap().is_none());\n    assert!(table.get(\"hello3\").unwrap().is_none());\n    assert_eq!(table.len().unwrap(), 1);\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::i128_type", "test": "fn i128_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n\n    let definition: TableDefinition<i128, i128> = TableDefinition::new(\"x\");\n\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        for i in -10..=10 {\n            table.insert(&i, &(i - 1)).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(-2, table.get(&-1).unwrap().unwrap().value());\n    let mut iter: Range<i128, i128> = table.range::<i128>(..).unwrap();\n    for i in -11..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), i);\n    }\n    assert!(iter.next().is_none());\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::f32_type", "test": "fn f32_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, f32> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(&0, &0.3).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(0.3, table.get(&0).unwrap().unwrap().value());\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::str_type", "test": "fn str_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<&str, &str> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(\"world\", table.get(\"hello\").unwrap().unwrap().value());\n\n    let mut iter = table.iter().unwrap();\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), \"world\");\n    assert!(iter.next().is_none());\n\n    let mut iter: Range<&str, &str> = table.range(\"a\"..\"z\").unwrap();\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), \"world\");\n    assert!(iter.next().is_none());\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::empty_type", "test": "fn empty_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, ()> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(&0, &()).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert!(!table.is_empty().unwrap());\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/multimap_table.rs::is_empty", "code": "fn is_empty(&self) -> Result<bool> {\n        self.len().map(|x| x == 0)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::option_type", "test": "fn option_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<Option<u8>, Option<u32>> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(None, None).unwrap();\n        table.insert(None, Some(0)).unwrap();\n        table.insert(Some(1), Some(1)).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(table.get(None).unwrap().unwrap().value(), Some(0));\n    assert_eq!(table.get(Some(1)).unwrap().unwrap().value(), Some(1));\n    let mut iter = table.iter().unwrap();\n    assert_eq!(iter.next().unwrap().unwrap().0.value(), None);\n    assert_eq!(iter.next().unwrap().unwrap().0.value(), Some(1));\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::array_type", "test": "fn array_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<&[u8; 5], &[u8; 9]> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(b\"hello\", b\"world_123\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    let hello = b\"hello\";\n    assert_eq!(b\"world_123\", table.get(hello).unwrap().unwrap().value());\n\n    let mut iter: Range<&[u8; 5], &[u8; 9]> = table.range::<&[u8; 5]>(..).unwrap();\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), b\"world_123\");\n    assert!(iter.next().is_none());\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::vec_fixed_width_value_type", "test": "fn vec_fixed_width_value_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, Vec<u64>> = TableDefinition::new(\"x\");\n\n    let value = vec![0, 1, 2, 3];\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(0, &value).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(value, table.get(0).unwrap().unwrap().value());\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::vec_var_width_value_type", "test": "fn vec_var_width_value_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, Vec<&str>> = TableDefinition::new(\"x\");\n\n    let value = vec![\"hello\", \"world\"];\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(0, &value).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(value, table.get(0).unwrap().unwrap().value());\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::vec_vec_type", "test": "fn vec_vec_type() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u8, Vec<Vec<&str>>> = TableDefinition::new(\"x\");\n\n    let value = vec![vec![\"hello\", \"world\"], vec![\"this\", \"is\", \"a\", \"test\"]];\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(0, &value).unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n    assert_eq!(value, table.get(0).unwrap().unwrap().value());\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::range_lifetime", "test": "fn range_lifetime() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<&str, &str> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n\n    let mut iter = {\n        let start = \"hello\".to_string();\n        table.range::<&str>(start.as_str()..).unwrap()\n    };\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), \"world\");\n    assert!(iter.next().is_none());\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/tree_store/btree_iters.rs::value", "code": "pub(crate) fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.page.memory()[self.value_range.clone()])\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::drain_lifetime", "test": "fn drain_lifetime() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<&str, &str> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    let mut table = txn.open_table(definition).unwrap();\n\n    let mut iter = {\n        let start = \"hello\".to_string();\n        table.drain::<&str>(start.as_str()..).unwrap()\n    };\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), \"world\");\n    assert!(iter.next().is_none());\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/tree_store/btree_iters.rs::value", "code": "pub(crate) fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.page.memory()[self.value_range.clone()])\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::drain_filter_lifetime", "test": "fn drain_filter_lifetime() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<&str, &str> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    let mut table = txn.open_table(definition).unwrap();\n\n    let mut iter = {\n        let start = \"hello\".to_string();\n        table.drain_filter(start.as_str().., |_, _| true).unwrap()\n    };\n    assert_eq!(iter.next().unwrap().unwrap().1.value(), \"world\");\n    assert!(iter.next().is_none());\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/tree_store/btree_iters.rs::value", "code": "pub(crate) fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.page.memory()[self.value_range.clone()])\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::owned_get_signatures", "test": "fn owned_get_signatures() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: TableDefinition<u32, u32> = TableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(definition).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &(i + 1)).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(definition).unwrap();\n\n    assert_eq!(2, table.get(&1).unwrap().unwrap().value());\n\n    let mut iter: Range<u32, u32> = table.range::<u32>(..).unwrap();\n    for i in 0..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), i + 1);\n    }\n    assert!(iter.next().is_none());\n    let mut iter: Range<u32, u32> = table.range(0..10).unwrap();\n    for i in 0..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), i + 1);\n    }\n    assert!(iter.next().is_none());\n    let mut iter = table.range::<&u32>(&0..&10).unwrap();\n    for i in 0..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), i + 1);\n    }\n    assert!(iter.next().is_none());\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::ref_get_signatures", "test": "fn ref_get_signatures() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..10u8 {\n            table.insert([i].as_slice(), [i + 1].as_slice()).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(SLICE_TABLE).unwrap();\n\n    let zero = vec![0u8];\n    assert_eq!(&[1], table.get([0].as_slice()).unwrap().unwrap().value());\n    assert_eq!(&[1], table.get(b\"\\0\".as_slice()).unwrap().unwrap().value());\n    assert_eq!(&[1], table.get(zero.as_slice()).unwrap().unwrap().value());\n\n    let start = vec![0u8];\n    let end = vec![10u8];\n    let mut iter = table.range::<&[u8]>(..).unwrap();\n    for i in 0..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), &[i + 1]);\n    }\n    assert!(iter.next().is_none());\n\n    let mut iter = table.range(start.as_slice()..&end).unwrap();\n    for i in 0..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), &[i + 1]);\n    }\n    assert!(iter.next().is_none());\n    drop(iter);\n\n    let mut iter = table.range(start.as_slice()..end.as_slice()).unwrap();\n    for i in 0..10 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), &[i + 1]);\n    }\n    assert!(iter.next().is_none());\n\n    let mut iter = table.range([0u8].as_slice()..[10u8].as_slice()).unwrap();\n    for i in 0..10u8 {\n        assert_eq!(iter.next().unwrap().unwrap().1.value(), [i + 1].as_slice());\n    }\n    assert!(iter.next().is_none());\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::iter", "test": "fn iter() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.iter().unwrap();\n    for i in 0..10 {\n        let (k, v) = iter.next().unwrap().unwrap();\n        assert_eq!(i, k.value());\n        assert_eq!(i, v.value());\n    }\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::drain_next_back", "test": "fn drain_next_back() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    let mut table = write_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.drain(0..10).unwrap();\n    for i in (0..10).rev() {\n        let (k, v) = iter.next_back().unwrap().unwrap();\n        assert_eq!(i, k.value());\n        assert_eq!(i, v.value());\n    }\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::drain_filter_all_elements_next_back", "test": "fn drain_filter_all_elements_next_back() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    let mut table = write_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.drain_filter(0..10, |_, _| true).unwrap();\n    for i in (0..10).rev() {\n        let (k, v) = iter.next_back().unwrap().unwrap();\n        assert_eq!(i, k.value());\n        assert_eq!(i, v.value());\n    }\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/basic_tests.rs::generic_signature_lifetimes", "test": "fn generic_signature_lifetimes() {\n    fn write_key_generic<K: RedbKey>(\n        table: TableDefinition<K, &[u8]>,\n        key: K::SelfType<'_>,\n        db: &Database,\n    ) {\n        let buf = [1, 2, 3];\n        let write_txn = db.begin_write().unwrap();\n        {\n            let mut table = write_txn.open_table(table).unwrap();\n            table.insert(key, buf.as_slice()).unwrap();\n        }\n        write_txn.commit().unwrap();\n    }\n\n    fn read_key_generic<K: RedbKey>(\n        table: TableDefinition<K, &[u8]>,\n        key: K::SelfType<'_>,\n        db: &Database,\n    ) {\n        let buf = [1, 2, 3];\n        let read_txn = db.begin_read().unwrap();\n        let table = read_txn.open_table(table).unwrap();\n        assert_eq!(table.get(key).unwrap().unwrap().value(), buf);\n    }\n\n    let tmpfile = create_tempfile();\n    let db = &Database::create(tmpfile.path()).unwrap();\n    {\n        let (table, key) = (TableDefinition::<&str, _>::new(\"&str\"), \"key\");\n        write_key_generic(table, key, db);\n        read_key_generic(table, key, db);\n    }\n    {\n        let (table, key) = (TableDefinition::<(), _>::new(\"()\"), ());\n        write_key_generic(table, key, db);\n        read_key_generic(table, key, db);\n    }\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::non_durable_commit_persistence", "test": "fn non_durable_commit_persistence() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let mut txn = db.begin_write().unwrap();\n    txn.set_durability(Durability::None);\n    let pairs = gen_data(100, 16, 20);\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..ELEMENTS {\n            let (key, value) = &pairs[i % pairs.len()];\n            table.insert(key.as_slice(), value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    // Check that cleanly closing the database persists the non-durable commit\n    drop(db);\n    let db = Database::create(tmpfile.path()).unwrap();\n    let txn = db.begin_read().unwrap();\n    let table = txn.open_table(SLICE_TABLE).unwrap();\n\n    let mut key_order: Vec<usize> = (0..ELEMENTS).collect();\n    key_order.shuffle(&mut rand::thread_rng());\n\n    {\n        for i in &key_order {\n            let (key, value) = &pairs[*i % pairs.len()];\n            assert_eq!(table.get(key.as_slice()).unwrap().unwrap().value(), value);\n        }\n    }\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::multi_page_kv", "test": "fn multi_page_kv() {\n    let tmpfile = create_tempfile();\n    let elements = 4;\n    let page_size = 4096;\n\n    let db = Builder::new().create(tmpfile.path()).unwrap();\n    let txn = db.begin_write().unwrap();\n\n    let mut key = vec![0u8; page_size + 1];\n    let mut value = vec![0; page_size + 1];\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..elements {\n            key[0] = i;\n            value[0] = i;\n            table.insert(key.as_slice(), value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_read().unwrap();\n    let table = txn.open_table(SLICE_TABLE).unwrap();\n    for i in 0..elements {\n        key[0] = i;\n        value[0] = i;\n        assert_eq!(&value, table.get(key.as_slice()).unwrap().unwrap().value());\n    }\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        for i in 0..elements {\n            key[0] = i;\n            table.remove(key.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression7", "test": "fn regression7() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let big_value = vec![0u8; 4063];\n        t.insert(&35723, big_value.as_slice()).unwrap();\n        t.remove(&145278).unwrap();\n        t.remove(&145227).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let mut tx = db.begin_write().unwrap();\n    tx.set_durability(Durability::None);\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 47];\n        t.insert(&66469, v.as_slice()).unwrap();\n        let v = vec![0u8; 2414];\n        t.insert(&146255, v.as_slice()).unwrap();\n        let v = vec![0u8; 159];\n        t.insert(&153701, v.as_slice()).unwrap();\n        let v = vec![0u8; 1186];\n        t.insert(&145227, v.as_slice()).unwrap();\n        let v = vec![0u8; 223];\n        t.insert(&118749, v.as_slice()).unwrap();\n\n        t.remove(&145227).unwrap();\n\n        let mut iter = t.range(138763..(138763 + 232359)).unwrap().rev();\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 153701);\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 146255);\n        assert!(iter.next().is_none());\n    }\n    tx.commit().unwrap();\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/tree_store/btree_iters.rs::value", "code": "pub(crate) fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.page.memory()[self.value_range.clone()])\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression8", "test": "fn regression8() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: TableDefinition<u64, &[u8]> = TableDefinition::new(\"x\");\n\n    let mut tx = db.begin_write().unwrap();\n    tx.set_durability(Durability::None);\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 1186];\n        t.insert(&145227, v.as_slice()).unwrap();\n        let v = vec![0u8; 1585];\n        t.insert(&565922, v.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 2040];\n        t.insert(&94937, v.as_slice()).unwrap();\n        let v = vec![0u8; 2058];\n        t.insert(&130571, v.as_slice()).unwrap();\n        t.remove(&145227).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let mut t = tx.open_table(table_def).unwrap();\n        let v = vec![0u8; 947];\n        t.insert(&118749, v.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let tx = db.begin_write().unwrap();\n    {\n        let t = tx.open_table(table_def).unwrap();\n        let mut iter = t.range(118749..142650).unwrap();\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 118749);\n        assert_eq!(iter.next().unwrap().unwrap().0.value(), 130571);\n        assert!(iter.next().is_none());\n    }\n    tx.commit().unwrap();\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/tree_store/btree_iters.rs::value", "code": "pub(crate) fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.page.memory()[self.value_range.clone()])\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::regression14", "test": "fn regression14() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let table_def: MultimapTableDefinition<u64, &[u8]> = MultimapTableDefinition::new(\"x\");\n\n    let mut tx = db.begin_write().unwrap();\n    tx.set_durability(Durability::None);\n    {\n        let mut t = tx.open_multimap_table(table_def).unwrap();\n        let value = vec![0; 1424];\n        t.insert(&539749, value.as_slice()).unwrap();\n    }\n    tx.commit().unwrap();\n\n    let mut tx = db.begin_write().unwrap();\n    tx.set_durability(Durability::None);\n    {\n        let mut t = tx.open_multimap_table(table_def).unwrap();\n        let value = vec![0; 2230];\n        t.insert(&776971, value.as_slice()).unwrap();\n\n        let mut iter = t.range(514043..(514043 + 514043)).unwrap().rev();\n        {\n            let (key, mut value_iter) = iter.next().unwrap().unwrap();\n            assert_eq!(key.value(), 776971);\n            assert_eq!(value_iter.next().unwrap().unwrap().value(), &[0; 2230]);\n        }\n        {\n            let (key, mut value_iter) = iter.next().unwrap().unwrap();\n            assert_eq!(key.value(), 539749);\n            assert_eq!(value_iter.next().unwrap().unwrap().value(), &[0; 1424]);\n        }\n    }\n    tx.abort().unwrap();\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::non_durable_read_isolation", "test": "fn non_durable_read_isolation() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let mut write_txn = db.begin_write().unwrap();\n    write_txn.set_durability(Durability::None);\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let read_table = read_txn.open_table(STR_TABLE).unwrap();\n    assert_eq!(\"world\", read_table.get(\"hello\").unwrap().unwrap().value());\n\n    let mut write_txn = db.begin_write().unwrap();\n    write_txn.set_durability(Durability::None);\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.remove(\"hello\").unwrap();\n        table.insert(\"hello2\", \"world2\").unwrap();\n        table.insert(\"hello3\", \"world3\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn2 = db.begin_read().unwrap();\n    let read_table2 = read_txn2.open_table(STR_TABLE).unwrap();\n    assert!(read_table2.get(\"hello\").unwrap().is_none());\n    assert_eq!(\n        \"world2\",\n        read_table2.get(\"hello2\").unwrap().unwrap().value()\n    );\n    assert_eq!(\n        \"world3\",\n        read_table2.get(\"hello3\").unwrap().unwrap().value()\n    );\n    assert_eq!(read_table2.len().unwrap(), 2);\n\n    assert_eq!(\"world\", read_table.get(\"hello\").unwrap().unwrap().value());\n    assert!(read_table.get(\"hello2\").unwrap().is_none());\n    assert!(read_table.get(\"hello3\").unwrap().is_none());\n    assert_eq!(read_table.len().unwrap(), 1);\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::range_query", "test": "fn range_query() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.range(3..7).unwrap();\n    for i in 3..7u64 {\n        let (key, value) = iter.next().unwrap().unwrap();\n        assert_eq!(i, key.value());\n        assert_eq!(i, value.value());\n    }\n    assert!(iter.next().is_none());\n\n    let mut iter = table.range(3..=7).unwrap();\n    for i in 3..=7u64 {\n        let (key, value) = iter.next().unwrap().unwrap();\n        assert_eq!(i, key.value());\n        assert_eq!(i, value.value());\n    }\n    assert!(iter.next().is_none());\n\n    let total: u64 = table\n        .range(1..=3)\n        .unwrap()\n        .map(|item| item.unwrap().1.value())\n        .sum();\n    assert_eq!(total, 6);\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::range_query_reversed", "test": "fn range_query_reversed() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            table.insert(&i, &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(U64_TABLE).unwrap();\n    let mut iter = table.range(3..7).unwrap().rev();\n    for i in (3..7u64).rev() {\n        let (key, value) = iter.next().unwrap().unwrap();\n        assert_eq!(i, key.value());\n        assert_eq!(i, value.value());\n    }\n    assert!(iter.next().is_none());\n\n    // Test reversing multiple times\n    let mut iter = table.range(3..7).unwrap();\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(3, key.value());\n\n    let mut iter = iter.rev();\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(6, key.value());\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(5, key.value());\n\n    let mut iter = iter.rev();\n    let (key, _) = iter.next().unwrap().unwrap();\n    assert_eq!(4, key.value());\n\n    assert!(iter.next().is_none());\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::delete_table", "test": "fn delete_table() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let y_def: MultimapTableDefinition<&str, &str> = MultimapTableDefinition::new(\"y\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        let mut multitable = write_txn.open_multimap_table(y_def).unwrap();\n        multitable.insert(\"hello2\", \"world2\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    assert!(write_txn.delete_table(STR_TABLE).unwrap());\n    assert!(!write_txn.delete_table(STR_TABLE).unwrap());\n    assert!(write_txn.delete_multimap_table(y_def).unwrap());\n    assert!(!write_txn.delete_multimap_table(y_def).unwrap());\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let result = read_txn.open_table(STR_TABLE);\n    assert!(result.is_err());\n    let result = read_txn.open_multimap_table(y_def);\n    assert!(result.is_err());\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/tree_store/table_tree.rs::delete_table", "code": "pub(crate) fn delete_table(\n        &mut self,\n        name: &str,\n        table_type: TableType,\n    ) -> Result<bool, TableError> {\n        if let Some(definition) = self.get_table_untyped(name, table_type)? {\n            if let Some((table_root, _)) = definition.get_root() {\n                let iter = AllPageNumbersBtreeIter::new(\n                    table_root,\n                    definition.fixed_key_size,\n                    definition.fixed_value_size,\n                    self.mem,\n                )?;\n                let mut freed_pages = self.freed_pages.lock().unwrap();\n                for page_number in iter {\n                    freed_pages.push(page_number?);\n                }\n            }\n\n            self.pending_table_updates.remove(name);\n\n            let found = self.tree.remove(&name)?.is_some();\n            return Ok(found);\n        }\n\n        Ok(false)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::non_page_size_multiple", "test": "fn non_page_size_multiple() {\n    let tmpfile = create_tempfile();\n\n    let db = Database::create(tmpfile.path()).unwrap();\n    let txn = db.begin_write().unwrap();\n    let key = vec![0u8; 1024];\n    let value = vec![0u8; 1];\n    {\n        let mut table = txn.open_table(SLICE_TABLE).unwrap();\n        table.insert(key.as_slice(), value.as_slice()).unwrap();\n    }\n    txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_table(SLICE_TABLE).unwrap();\n    assert_eq!(table.len().unwrap(), 1);\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/multimap_table.rs::len", "code": "fn len(&self) -> Result<u64> {\n        let mut count = 0;\n        for item in self.iter()? {\n            let (_, values) = item?;\n            for v in values {\n                v?;\n                count += 1;\n            }\n        }\n        Ok(count)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::persistent_savepoint", "test": "fn persistent_savepoint() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let definition: TableDefinition<u32, &str> = TableDefinition::new(\"x\");\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(definition).unwrap();\n        table.insert(&0, \"hello\").unwrap();\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    let savepoint_id = txn.persistent_savepoint().unwrap();\n    {\n        let mut table = txn.open_table(definition).unwrap();\n        table.remove(&0).unwrap();\n    }\n    txn.commit().unwrap();\n\n    drop(db);\n    let db = Database::create(tmpfile.path()).unwrap();\n    // Make sure running the GC doesn't invalidate the savepoint\n    let txn = db.begin_write().unwrap();\n    txn.commit().unwrap();\n    let txn = db.begin_write().unwrap();\n    txn.commit().unwrap();\n\n    let mut txn = db.begin_write().unwrap();\n    let savepoint = txn.get_persistent_savepoint(savepoint_id).unwrap();\n\n    txn.restore_savepoint(&savepoint).unwrap();\n    txn.commit().unwrap();\n\n    let txn = db.begin_read().unwrap();\n    let table = txn.open_table(definition).unwrap();\n    assert_eq!(table.get(&0).unwrap().unwrap().value(), \"hello\");\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/integration_tests.rs::compaction", "test": "fn compaction() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let definition: TableDefinition<u32, &[u8]> = TableDefinition::new(\"x\");\n\n    let big_value = vec![0u8; 100 * 1024];\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(definition).unwrap();\n        // Insert 10MiB of data\n        for i in 0..100 {\n            table.insert(&i, big_value.as_slice()).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n\n    let txn = db.begin_write().unwrap();\n    {\n        let mut table = txn.open_table(definition).unwrap();\n        // Delete 90% of it\n        for i in 0..90 {\n            table.remove(&i).unwrap();\n        }\n    }\n    txn.commit().unwrap();\n    // Second commit to trigger dynamic compaction\n    let txn = db.begin_write().unwrap();\n    txn.commit().unwrap();\n\n    // The values are > 1 page, so shouldn't get relocated. Therefore there should be a bunch of fragmented space,\n    // since we left the last 100 values in the db.\n    drop(db);\n    let file_size = tmpfile.as_file().metadata().unwrap().len();\n    let mut db = Database::open(tmpfile.path()).unwrap();\n\n    assert!(db.compact().unwrap());\n    drop(db);\n    let file_size2 = tmpfile.as_file().metadata().unwrap().len();\n    assert!(file_size2 < file_size);\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/db.rs::compact", "code": "pub fn compact(&mut self) -> Result<bool, CompactionError> {\n        // Commit to free up any pending free pages\n        // Use 2-phase commit to avoid any possible security issues. Plus this compaction is going to be so slow that it doesn't matter\n        let mut txn = self.begin_write().map_err(|e| e.into_storage_error())?;\n        if txn.list_persistent_savepoints()?.next().is_some() {\n            return Err(CompactionError::PersistentSavepointExists);\n        }\n        if self\n            .transaction_tracker\n            .lock()\n            .unwrap()\n            .any_savepoint_exists()\n        {\n            return Err(CompactionError::EphemeralSavepointExists);\n        }\n        txn.set_durability(Durability::Paranoid);\n        txn.commit().map_err(|e| e.into_storage_error())?;\n        // Repeat, just in case executing list_persistent_savepoints() created a new table\n        let mut txn = self.begin_write().map_err(|e| e.into_storage_error())?;\n        txn.set_durability(Durability::Paranoid);\n        txn.commit().map_err(|e| e.into_storage_error())?;\n        // There can't be any outstanding transactions because we have a `&mut self`, so all pending free pages\n        // should have been cleared out by the above commit()\n        assert!(self.mem.get_freed_root().is_none());\n\n        let mut compacted = false;\n        // Iteratively compact until no progress is made\n        loop {\n            let mut progress = false;\n\n            let mut txn = self.begin_write().map_err(|e| e.into_storage_error())?;\n            if txn.compact_pages()? {\n                progress = true;\n                txn.commit().map_err(|e| e.into_storage_error())?;\n            } else {\n                txn.abort()?;\n            }\n\n            // Double commit to free up the relocated pages for reuse\n            let mut txn = self.begin_write().map_err(|e| e.into_storage_error())?;\n            txn.set_durability(Durability::Paranoid);\n            txn.commit().map_err(|e| e.into_storage_error())?;\n            assert!(self.mem.get_freed_root().is_none());\n\n            if !progress {\n                break;\n            } else {\n                compacted = true;\n            }\n        }\n\n        Ok(compacted)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::len", "test": "fn len() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        table.insert(\"hello\", \"world2\").unwrap();\n        table.insert(\"hi\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert_eq!(table.len().unwrap(), 3);\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/multimap_table.rs::len", "code": "fn len(&self) -> Result<u64> {\n        let mut count = 0;\n        for item in self.iter()? {\n            let (_, values) = item?;\n            for v in values {\n                v?;\n                count += 1;\n            }\n        }\n        Ok(count)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::is_empty", "test": "fn is_empty() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert!(!table.is_empty().unwrap());\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/multimap_table.rs::is_empty", "code": "fn is_empty(&self) -> Result<bool> {\n        self.len().map(|x| x == 0)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::insert", "test": "fn insert() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        assert!(!table.insert(\"hello\", \"world\").unwrap());\n        assert!(!table.insert(\"hello\", \"world2\").unwrap());\n        assert!(table.insert(\"hello\", \"world2\").unwrap());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert_eq!(\n        vec![\"world\".to_string(), \"world2\".to_string()],\n        get_vec(&table, \"hello\")\n    );\n    assert_eq!(table.len().unwrap(), 2);\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/multimap_table.rs::insert", "code": "pub fn insert<'k, 'v>(\n        &mut self,\n        key: impl Borrow<K::SelfType<'k>>,\n        value: impl Borrow<V::SelfType<'v>>,\n    ) -> Result<bool> {\n        let value_bytes = V::as_bytes(value.borrow());\n        let value_bytes_ref = value_bytes.as_ref();\n        if value_bytes_ref.len() > MAX_VALUE_LENGTH {\n            return Err(StorageError::ValueTooLarge(value_bytes_ref.len()));\n        }\n        let key_bytes = K::as_bytes(key.borrow());\n        if key_bytes.as_ref().len() > MAX_VALUE_LENGTH {\n            return Err(StorageError::ValueTooLarge(key_bytes.as_ref().len()));\n        }\n        let get_result = self.tree.get(key.borrow())?;\n        let existed = if get_result.is_some() {\n            #[allow(clippy::unnecessary_unwrap)]\n            let guard = get_result.unwrap();\n            let collection_type = guard.value().collection_type();\n            match collection_type {\n                Inline => {\n                    let leaf_data = guard.value().as_inline();\n                    let accessor = LeafAccessor::new(\n                        leaf_data,\n                        V::fixed_width(),\n                        <() as RedbValue>::fixed_width(),\n                    );\n                    let (position, found) = accessor.position::<V>(value_bytes_ref);\n                    if found {\n                        return Ok(true);\n                    }\n\n                    let new_pairs = accessor.num_pairs() + 1;\n                    let new_pair_bytes =\n                        accessor.length_of_pairs(0, accessor.num_pairs()) + value_bytes_ref.len();\n                    let new_key_bytes =\n                        accessor.length_of_keys(0, accessor.num_pairs()) + value_bytes_ref.len();\n                    let required_inline_bytes =\n                        RawLeafBuilder::required_bytes(new_pairs, new_pair_bytes);\n\n                    if required_inline_bytes < self.mem.get_page_size() / 2 {\n                        let mut data = vec![0; required_inline_bytes];\n                        let mut builder = RawLeafBuilder::new(\n                            &mut data,\n                            new_pairs,\n                            V::fixed_width(),\n                            <() as RedbValue>::fixed_width(),\n                            new_key_bytes,\n                        );\n                        for i in 0..accessor.num_pairs() {\n                            if i == position {\n                                builder.append(\n                                    value_bytes_ref,\n                                    <() as RedbValue>::as_bytes(&()).as_ref(),\n                                );\n                            }\n                            let entry = accessor.entry(i).unwrap();\n                            builder.append(entry.key(), entry.value());\n                        }\n                        if position == accessor.num_pairs() {\n                            builder\n                                .append(value_bytes_ref, <() as RedbValue>::as_bytes(&()).as_ref());\n                        }\n                        drop(builder);\n                        drop(guard);\n                        let inline_data = DynamicCollection::<V>::make_inline_data(&data);\n                        self.tree\n                            .insert(key.borrow(), &DynamicCollection::new(&inline_data))?;\n                    } else {\n                        // convert into a subtree\n                        let mut page = self.mem.allocate(leaf_data.len(), CachePriority::Low)?;\n                        page.memory_mut()[..leaf_data.len()].copy_from_slice(leaf_data);\n                        let page_number = page.get_page_number();\n                        drop(page);\n                        drop(guard);\n\n                        // Don't bother computing the checksum, since we're about to modify the tree\n                        let mut subtree: BtreeMut<'_, V, ()> = BtreeMut::new(\n                            Some((page_number, 0)),\n                            self.mem,\n                            self.freed_pages.clone(),\n                        );\n                        let existed = subtree.insert(value.borrow(), &())?.is_some();\n                        assert_eq!(existed, found);\n                        let (new_root, new_checksum) = subtree.get_root().unwrap();\n                        let subtree_data =\n                            DynamicCollection::<V>::make_subtree_data(new_root, new_checksum);\n                        self.tree\n                            .insert(key.borrow(), &DynamicCollection::new(&subtree_data))?;\n                    }\n\n                    found\n                }\n                Subtree => {\n                    let mut subtree: BtreeMut<'_, V, ()> = BtreeMut::new(\n                        Some(guard.value().as_subtree()),\n                        self.mem,\n                        self.freed_pages.clone(),\n                    );\n                    drop(guard);\n                    let existed = subtree.insert(value.borrow(), &())?.is_some();\n                    let (new_root, new_checksum) = subtree.get_root().unwrap();\n                    let subtree_data =\n                        DynamicCollection::<V>::make_subtree_data(new_root, new_checksum);\n                    self.tree\n                        .insert(key.borrow(), &DynamicCollection::new(&subtree_data))?;\n\n                    existed\n                }\n            }\n        } else {\n            drop(get_result);\n            let required_inline_bytes = RawLeafBuilder::required_bytes(1, value_bytes_ref.len());\n            if required_inline_bytes < self.mem.get_page_size() / 2 {\n                let mut data = vec![0; required_inline_bytes];\n                let mut builder = RawLeafBuilder::new(\n                    &mut data,\n                    1,\n                    V::fixed_width(),\n                    <() as RedbValue>::fixed_width(),\n                    value_bytes_ref.len(),\n                );\n                builder.append(value_bytes_ref, <() as RedbValue>::as_bytes(&()).as_ref());\n                drop(builder);\n                let inline_data = DynamicCollection::<V>::make_inline_data(&data);\n                self.tree\n                    .insert(key.borrow(), &DynamicCollection::new(&inline_data))?;\n            } else {\n                let mut subtree: BtreeMut<'_, V, ()> =\n                    BtreeMut::new(None, self.mem, self.freed_pages.clone());\n                subtree.insert(value.borrow(), &())?;\n                let (new_root, new_checksum) = subtree.get_root().unwrap();\n                let subtree_data =\n                    DynamicCollection::<V>::make_subtree_data(new_root, new_checksum);\n                self.tree\n                    .insert(key.borrow(), &DynamicCollection::new(&subtree_data))?;\n            }\n            false\n        };\n\n        Ok(existed)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::range_query", "test": "fn range_query() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(SLICE_U64_TABLE).unwrap();\n        for i in 0..5 {\n            table.insert(b\"0\".as_slice(), &i).unwrap();\n        }\n        for i in 5..10 {\n            table.insert(b\"1\".as_slice(), &i).unwrap();\n        }\n        for i in 10..15 {\n            table.insert(b\"2\".as_slice(), &i).unwrap();\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(SLICE_U64_TABLE).unwrap();\n    let start = b\"0\".as_ref();\n    let end = b\"1\".as_ref();\n    let mut iter = table.range(start..=end).unwrap();\n\n    {\n        let (key, mut values) = iter.next().unwrap().unwrap();\n        for i in 0..5 {\n            assert_eq!(b\"0\", key.value());\n            let value = values.next().unwrap().unwrap();\n            assert_eq!(i, value.value());\n        }\n    }\n    {\n        let (key, mut values) = iter.next().unwrap().unwrap();\n        for i in 5..10 {\n            assert_eq!(b\"1\", key.value());\n            let value = values.next().unwrap().unwrap();\n            assert_eq!(i, value.value());\n        }\n    }\n    assert!(iter.next().is_none());\n\n    let mut total: u64 = 0;\n    for item in table.range(start..=end).unwrap() {\n        let (_, values) = item.unwrap();\n        total += values.map(|x| x.unwrap().value()).sum::<u64>();\n    }\n    assert_eq!(total, 45);\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::range_lifetime", "test": "fn range_lifetime() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n\n    let definition: MultimapTableDefinition<&str, &str> = MultimapTableDefinition::new(\"x\");\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(definition).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(definition).unwrap();\n\n    let mut iter = {\n        let start = \"hello\".to_string();\n        table.range::<&str>(start.as_str()..).unwrap()\n    };\n    assert_eq!(\n        iter.next()\n            .unwrap()\n            .unwrap()\n            .1\n            .next()\n            .unwrap()\n            .unwrap()\n            .value(),\n        \"world\"\n    );\n    assert!(iter.next().is_none());\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/tree_store/btree_iters.rs::value", "code": "pub(crate) fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.page.memory()[self.value_range.clone()])\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::delete", "test": "fn delete() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        table.insert(\"hello\", \"world\").unwrap();\n        table.insert(\"hello\", \"world2\").unwrap();\n        table.insert(\"hello\", \"world3\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert_eq!(\n        vec![\n            \"world\".to_string(),\n            \"world2\".to_string(),\n            \"world3\".to_string()\n        ],\n        get_vec(&table, \"hello\")\n    );\n    assert_eq!(table.len().unwrap(), 3);\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        table.remove(\"hello\", \"world2\").unwrap();\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert_eq!(\n        vec![\"world\".to_string(), \"world3\".to_string()],\n        get_vec(&table, \"hello\")\n    );\n    assert_eq!(table.len().unwrap(), 2);\n\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(STR_TABLE).unwrap();\n        let mut iter = table.remove_all(\"hello\").unwrap();\n        assert_eq!(\"world\", iter.next().unwrap().unwrap().value());\n        assert_eq!(\"world3\", iter.next().unwrap().unwrap().value());\n        assert!(iter.next().is_none());\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(STR_TABLE).unwrap();\n    assert!(table.is_empty().unwrap());\n    let empty: Vec<String> = vec![];\n    assert_eq!(empty, get_vec(&table, \"hello\"));\n}", "code_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::get_vec", "code": "fn get_vec(\n    table: &impl ReadableMultimapTable<&'static str, &'static str>,\n    key: &str,\n) -> Vec<String> {\n    let mut result = vec![];\n    let mut iter = table.get(key).unwrap();\n    loop {\n        let item = iter.next();\n        if let Some(item_value) = item {\n            result.push(item_value.unwrap().value().to_string());\n        } else {\n            return result;\n        }\n    }\n}", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::efficient_storage", "test": "fn efficient_storage() {\n    let tmpfile = create_tempfile();\n    let expected_max_size = 1024 * 1024;\n    // Write enough values that big_key.len() * entries > db_size to check that duplicate key data is not stored\n    // and entries * sizeof(u32) > page_size to validate that large numbers of values can be stored per key\n    let entries = 10000;\n    let db = Database::create(tmpfile.path()).unwrap();\n    let table_def: MultimapTableDefinition<&[u8], u32> = MultimapTableDefinition::new(\"x\");\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(table_def).unwrap();\n        let big_key = [0u8; 1000];\n        for i in 0..entries {\n            table.insert(big_key.as_slice(), &i).unwrap();\n        }\n    }\n    assert!(write_txn.stats().unwrap().stored_bytes() <= expected_max_size);\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(table_def).unwrap();\n    assert_eq!(table.len().unwrap(), entries as u64);\n}", "code_id": "cberner-redb/cberner-redb-267b473/src/transactions.rs::stored_bytes", "code": "pub fn stored_bytes(&self) -> u64 {\n        self.stored_leaf_bytes\n    }", "docstring": null}
{"test_id": "cberner-redb/cberner-redb-267b473/tests/multimap_tests.rs::iter", "test": "fn iter() {\n    let tmpfile = create_tempfile();\n    let db = Database::create(tmpfile.path()).unwrap();\n    let write_txn = db.begin_write().unwrap();\n    {\n        let mut table = write_txn.open_multimap_table(U64_TABLE).unwrap();\n        for i in 0..10 {\n            for j in 0..10 {\n                table.insert(&i, &j).unwrap();\n            }\n        }\n    }\n    write_txn.commit().unwrap();\n\n    let read_txn = db.begin_read().unwrap();\n    let table = read_txn.open_multimap_table(U64_TABLE).unwrap();\n    let mut iter = table.iter().unwrap();\n    for i in 0..10 {\n        let (k, mut values) = iter.next().unwrap().unwrap();\n        assert_eq!(k.value(), i);\n        for j in 0..10 {\n            assert_eq!(values.next().unwrap().unwrap().value(), j);\n        }\n    }\n}", "code_id": "cberner-redb/cberner-redb-267b473/examples/special_values.rs::value", "code": "fn value(&self) -> V::SelfType<'_> {\n        V::from_bytes(&self.data)\n    }", "docstring": null}
