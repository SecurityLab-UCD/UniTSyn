{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/lib/api/tests/module.rs::exports", "test": "fn exports() -> Result<(), String> {\n    let store = Store::default();\n    let wat = r#\"(module\n(func (export \"func\") nop)\n(memory (export \"memory\") 1)\n(table (export \"table\") 1 funcref)\n(global (export \"global\") i32 (i32.const 0))\n)\"#;\n    let module = Module::new(&store, wat).map_err(|e| format!(\"{e:?}\"))?;\n    assert_eq!(\n        module.exports().collect::<Vec<_>>(),\n        vec![\n            ExportType::new(\n                \"func\",\n                ExternType::Function(FunctionType::new(vec![], vec![]))\n            ),\n            ExportType::new(\n                \"memory\",\n                ExternType::Memory(MemoryType::new(Pages(1), None, false))\n            ),\n            ExportType::new(\n                \"table\",\n                ExternType::Table(TableType::new(Type::FuncRef, 1, None))\n            ),\n            ExportType::new(\n                \"global\",\n                ExternType::Global(GlobalType::new(Type::I32, Mutability::Const))\n            )\n        ]\n    );\n\n    // Now we test the iterators\n    assert_eq!(\n        module.exports().functions().collect::<Vec<_>>(),\n        vec![ExportType::new(\"func\", FunctionType::new(vec![], vec![])),]\n    );\n    assert_eq!(\n        module.exports().memories().collect::<Vec<_>>(),\n        vec![ExportType::new(\n            \"memory\",\n            MemoryType::new(Pages(1), None, false)\n        ),]\n    );\n    assert_eq!(\n        module.exports().tables().collect::<Vec<_>>(),\n        vec![ExportType::new(\n            \"table\",\n            TableType::new(Type::FuncRef, 1, None)\n        ),]\n    );\n    assert_eq!(\n        module.exports().globals().collect::<Vec<_>>(),\n        vec![ExportType::new(\n            \"global\",\n            GlobalType::new(Type::I32, Mutability::Const)\n        ),]\n    );\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/compilers/serialize.rs::sanity_test_artifact_deserialize", "test": "fn sanity_test_artifact_deserialize() {\n    let engine = Engine::headless();\n    let result = unsafe { Module::deserialize(&engine, &[]) };\n    assert!(result.is_err());\n}", "error": "Not Definition Found"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/config.rs::get_and_set_config_fields", "test": "fn get_and_set_config_fields() -> anyhow::Result<()> {\n    let temp = setup_wasmer_dir();\n\n    // ---- config get\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"registry.token\")\n        .output()?;\n\n    let original_token = String::from_utf8_lossy(&output.stdout);\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"set\")\n        .arg(\"registry.token\")\n        .arg(\"abc123\")\n        .output()?;\n\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"\".to_string());\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"registry.token\")\n        .output()?;\n\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        \"abc123\\n\".to_string()\n    );\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"set\")\n        .arg(\"registry.token\")\n        .arg(original_token.to_string().trim())\n        .output()?;\n\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"\".to_string());\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"registry.token\")\n        .output()?;\n\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        format!(\"{}\\n\", original_token.to_string().trim())\n    );\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"registry.url\")\n        .output()?;\n\n    let original_url = String::from_utf8_lossy(&output.stdout);\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"set\")\n        .arg(\"registry.url\")\n        .arg(\"wasmer.wtf\")\n        .output()?;\n\n    let output_str = String::from_utf8_lossy(&output.stdout);\n\n    assert_eq!(output_str, \"\".to_string());\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"registry.url\")\n        .output()?;\n\n    let output_str = String::from_utf8_lossy(&output.stdout);\n    assert_eq!(\n        output_str,\n        \"https://registry.wasmer.wtf/graphql\\n\".to_string()\n    );\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"set\")\n        .arg(\"registry.url\")\n        .arg(original_url.to_string().trim())\n        .output()?;\n\n    let output_str = String::from_utf8_lossy(&output.stdout);\n    assert_eq!(output_str, \"\".to_string());\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"registry.url\")\n        .output()?;\n\n    let output_str = String::from_utf8_lossy(&output.stdout);\n    assert_eq!(output_str, original_url.to_string());\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"telemetry.enabled\")\n        .output()?;\n\n    let original_output = String::from_utf8_lossy(&output.stdout);\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"set\")\n        .arg(\"telemetry.enabled\")\n        .arg(\"true\")\n        .output()?;\n\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"\".to_string());\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"telemetry.enabled\")\n        .output()?;\n\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        \"true\\n\".to_string()\n    );\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"set\")\n        .arg(\"telemetry.enabled\")\n        .arg(original_output.to_string().trim())\n        .output()?;\n\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"\".to_string());\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"telemetry.enabled\")\n        .output()?;\n\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        original_output.to_string()\n    );\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"update-notifications.enabled\")\n        .output()?;\n\n    let original_output = String::from_utf8_lossy(&output.stdout);\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"set\")\n        .arg(\"update-notifications.enabled\")\n        .arg(\"true\")\n        .output()?;\n\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"\".to_string());\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"update-notifications.enabled\")\n        .output()?;\n\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        \"true\\n\".to_string()\n    );\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"set\")\n        .arg(\"update-notifications.enabled\")\n        .arg(original_output.to_string().trim())\n        .output()?;\n\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"\".to_string());\n\n    let output = wasmer_cmd(&temp)\n        .arg(\"config\")\n        .arg(\"get\")\n        .arg(\"update-notifications.enabled\")\n        .output()?;\n\n    assert_eq!(\n        String::from_utf8_lossy(&output.stdout),\n        original_output.to_string()\n    );\n\n    Ok(())\n}", "error": "Not Definition Found"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/create_exe.rs::test_create_exe_with_pirita_works_1", "test": "fn test_create_exe_with_pirita_works_1() {\n    let tempdir = TempDir::new().unwrap();\n    let path = tempdir.path();\n    let wasm_out = path.join(\"out.obj\");\n    let cmd = Command::new(get_wasmer_path())\n        .arg(\"create-obj\")\n        .arg(fixtures::wabt())\n        .arg(\"-o\")\n        .arg(&wasm_out)\n        .output()\n        .unwrap();\n\n    let stderr = String::from_utf8_lossy(&cmd.stderr);\n\n    assert_eq!(stderr.lines().map(|s| s.trim().to_string()).collect::<Vec<_>>(), vec![\n        format!(\"error: cannot compile more than one atom at a time\"),\n        format!(\"│   1: note: use --atom <ATOM> to specify which atom to compile\"),\n        format!(\"╰─▶ 2: where <ATOM> is one of: wabt, wasm-interp, wasm-strip, wasm-validate, wasm2wat, wast2json, wat2wasm\"),\n    ]);\n\n    assert!(!cmd.status.success());\n\n    let cmd = Command::new(get_wasmer_path())\n        .arg(\"create-obj\")\n        .arg(fixtures::wabt())\n        .arg(\"--atom\")\n        .arg(\"wasm2wat\")\n        .arg(\"-o\")\n        .arg(&wasm_out)\n        .output()\n        .unwrap();\n\n    let stderr = String::from_utf8_lossy(&cmd.stderr);\n\n    let real_out = wasm_out.canonicalize().unwrap().display().to_string();\n    let real_out = real_out\n        .strip_prefix(r\"\\\\?\\\")\n        .unwrap_or(&real_out)\n        .to_string();\n    assert_eq!(\n        stderr\n            .lines()\n            .map(|s| s.trim().to_string())\n            .collect::<Vec<_>>(),\n        vec![format!(\"✔ Object compiled successfully to `{real_out}`\"),]\n    );\n\n    assert!(cmd.status.success());\n}\n\n#[test]\n", "error": "Not Definition Found"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/init.rs::wasmer_init_works_1", "test": "fn wasmer_init_works_1() {\n    let wasmer_dir = TempDir::new().unwrap();\n    let tempdir = tempfile::tempdir().unwrap();\n    let path = tempdir.path().join(\"testfirstproject\");\n    std::fs::create_dir_all(&path).unwrap();\n\n    Command::new(get_wasmer_path())\n        .arg(\"init\")\n        .arg(\"--namespace=ciuser\")\n        .current_dir(&path)\n        .env(\"WASMER_DIR\", wasmer_dir.path())\n        .assert()\n        .success();\n\n    assert_eq!(\n        std::fs::read_to_string(path.join(\"wasmer.toml\")).unwrap(),\n        include_str!(\"./fixtures/init1.toml\"),\n    );\n}", "error": "Not Definition Found"}
{"test_id": "wasmerio-wasmer/wasmerio-wasmer-7cb550d/tests/integration/cli/tests/init.rs::wasmer_init_works_2", "test": "fn wasmer_init_works_2() {\n    let tempdir = tempfile::tempdir().unwrap();\n    let path = tempdir.path();\n    let path = path.join(\"testfirstproject\");\n    std::fs::create_dir_all(&path).unwrap();\n    std::fs::write(\n        path.join(\"Cargo.toml\"),\n        include_bytes!(\"./fixtures/init2.toml\"),\n    )\n    .unwrap();\n    std::fs::create_dir_all(path.join(\"src\")).unwrap();\n    std::fs::write(path.join(\"src\").join(\"main.rs\"), b\"fn main() { }\").unwrap();\n\n    Command::new(get_wasmer_path())\n        .arg(\"init\")\n        .arg(\"--namespace=ciuser\")\n        .current_dir(&path)\n        .assert()\n        .success();\n\n    assert_eq!(\n        std::fs::read_to_string(path.join(\"Cargo.toml\")).unwrap(),\n        include_str!(\"./fixtures/init2.toml\")\n    );\n    assert_eq!(\n        std::fs::read_to_string(path.join(\"wasmer.toml\")).unwrap(),\n        include_str!(\"./fixtures/init4.toml\")\n    );\n}", "error": "Not Definition Found"}
