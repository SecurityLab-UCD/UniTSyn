fn fabsd_sanity_test() {
    assert_eq!(libm::fabsd(-1.0), 1.0);
    assert_eq!(libm::fabsd(2.8), 2.8);
}
fn math_test() {
    let mut x = VecType::try_from(&[0, 1, 9]).unwrap();
    assert_eq!(x.is_normalized(), true);
    x.try_push(0).unwrap();
    assert_eq!(&*x, &[0, 1, 9, 0]);
    assert_eq!(x.is_normalized(), false);
    x.normalize();
    assert_eq!(&*x, &[0, 1, 9]);
    assert_eq!(x.is_normalized(), true);

    x.add_small(1);
    assert_eq!(&*x, &[1, 1, 9]);
    x.add_small(Limb::MAX);
    assert_eq!(&*x, &[0, 2, 9]);

    x.mul_small(3);
    assert_eq!(&*x, &[0, 6, 27]);
    x.mul_small(Limb::MAX);
    let expected: VecType = if LIMB_BITS == 32 {
        vec_from_u32(&[0, 4294967290, 4294967274, 26])
    } else {
        vec_from_u32(&[0, 0, 4294967290, 4294967295, 4294967274, 4294967295, 26])
    };
    assert_eq!(&*x, &*expected);

    #[cfg(feature = "radix")]
    {
        let mut x: VecType = vec_from_u32(&[0, 0, 0, 536870912]);
        let y: VecType = vec_from_u32(&[3358091099, 2770363594, 2782716766, 217327764]);
        assert_eq!(x.quorem(&y), 2);
        let expected: VecType = vec_from_u32(&[1873752394, 3049207402, 3024501058, 102215382]);
        assert_eq!(&*x, &*expected);
    }

    let mut x = VecType::from_u32(0xFFFFFFFF);
    let y = VecType::from_u32(5);
    x *= &y;
    let expected: VecType = vec_from_u32(&[0xFFFFFFFB, 0x4]);
    assert_eq!(&*x, &*expected);

    // Test with carry
    let mut x = VecType::from_u32(1);
    assert_eq!(&*x, &[1]);
    x.add_small(Limb::MAX);
    assert_eq!(&*x, &[0, 1]);
}
fn i32_decimal_test() {
    assert_eq!(Ok(0), i32::from_lexical(b"0"));
    assert_eq!(Ok(2147483647), i32::from_lexical(b"2147483647"));
    assert_eq!(Err(Error::Overflow(9)), i32::from_lexical(b"2147483648"));
    assert_eq!(Err(Error::Overflow(9)), i32::from_lexical(b"4294967295"));
    assert_eq!(Ok(-1), i32::from_lexical(b"-1"));
    assert_eq!(Err(Error::InvalidDigit(1)), i32::from_lexical(b"1a"));
}
fn f64_lossy_decimal_test() {
    const FORMAT: u128 = STANDARD;

    let options = Options::builder().lossy(true).build().unwrap();
    assert_eq!(
        Err(Error::EmptyMantissa(1)),
        f64::from_lexical_with_options::<FORMAT>(b".", &options)
    );
    assert_eq!(Err(Error::Empty(0)), f64::from_lexical_with_options::<FORMAT>(b"", &options));
    assert_eq!(Ok(0.0), f64::from_lexical_with_options::<FORMAT>(b"0.0", &options));
    assert_eq!(
        Err((Error::InvalidDigit(1)).into()),
        f64::from_lexical_with_options::<FORMAT>(b"1a", &options)
    );

    // Bug fix for Issue #8
    assert_eq!(
        Ok(5.002868148396374),
        f64::from_lexical_with_options::<FORMAT>(b"5.002868148396374", &options)
    );
}
fn calculate_shift_test() {
    assert_eq!(shared::calculate_shift::<f64>(-63), 64);
    assert_eq!(shared::calculate_shift::<f64>(-15), 16);
    assert_eq!(shared::calculate_shift::<f64>(-8), 11);
    assert_eq!(shared::calculate_shift::<f64>(0), 11);
    assert_eq!(shared::calculate_shift::<f64>(50), 11);
}
fn compute_nearest_normal_test() {
    assert_eq!(compute_nearest_normal(1.23456), (123456, -5));
    assert_eq!(compute_nearest_normal(13.9999999999999982236431606), (13999999999999998, -15));
}
fn fast_path_partial_test() {
    const FORMAT: u128 = STANDARD;
    let options = Options::new();
    let string = b"1.2345e10";
    let result = parse::fast_path_partial::<f64, FORMAT>(string, &options);
    assert_eq!(result, Ok((1.2345e10, 9)));

    let string = b"1.2345e";
    let result = parse::fast_path_partial::<f64, FORMAT>(string, &options);
    assert!(result.is_err());

    let string = b"1.2345 ";
    let result = parse::fast_path_partial::<f64, FORMAT>(string, &options);
    assert_eq!(result, Ok((1.2345, 6)));
}
fn parse_f32_lossy_test() {
    const FORMAT: u128 = STANDARD;
    let options = Options::builder().lossy(true).build().unwrap();
    let parse = move |x| f32::from_lexical_partial_with_options::<FORMAT>(x, &options);

    assert_eq!(Ok((1.2345, 6)), parse(b"1.2345"));
    assert_eq!(Ok((12.345, 6)), parse(b"12.345"));
    assert_eq!(Ok((12345.6789, 10)), parse(b"12345.6789"));
    assert_eq!(Ok((1.2345e10, 9)), parse(b"1.2345e10"));
}
fn i64_decimal_test() {
    assert_eq!(Ok(0), i64::from_lexical(b"0"));
    assert_eq!(Ok(9223372036854775807), i64::from_lexical(b"9223372036854775807"));
    assert_eq!(Err(Error::Overflow(18)), i64::from_lexical(b"9223372036854775808"));
    assert_eq!(Err(Error::Overflow(19)), i64::from_lexical(b"18446744073709551615"));
    assert_eq!(Ok(-1), i64::from_lexical(b"-1"));
    assert_eq!(Err(Error::InvalidDigit(1)), i64::from_lexical(b"1a"));

    // Add tests discovered via fuzzing. This won't necessarily be the
    // proper index, since we use multi-digit parsing.
    assert!(i64::from_lexical(b"406260572150672006000066000000060060007667760000000000000000000+00000006766767766666767665670000000000000000000000666").err().unwrap().is_invalid_digit());
    assert!(i64::from_lexical(b"406260572150672006000066000000060060007667760000000000000000000")
        .err()
        .unwrap()
        .is_overflow());
}
fn scalar_add_test() {
    assert_eq!(bigint::scalar_add(5, 5), (10, false));
    assert_eq!(bigint::scalar_add(Limb::MAX, 1), (0, true));
}
fn is_valid_letter_test() {
    assert_eq!(ascii::is_valid_letter(b'\x00'), false);
    assert_eq!(ascii::is_valid_letter(b'\n'), false);
    assert_eq!(ascii::is_valid_letter(b'\r'), false);
    assert_eq!(ascii::is_valid_letter(b'\x1b'), false);
    assert_eq!(ascii::is_valid_letter(b' '), false);
    assert_eq!(ascii::is_valid_letter(b'0'), false);
    assert_eq!(ascii::is_valid_letter(b'9'), false);
    assert_eq!(ascii::is_valid_letter(b':'), false);
    assert_eq!(ascii::is_valid_letter(b'A'), true);
    assert_eq!(ascii::is_valid_letter(b'Z'), true);
    assert_eq!(ascii::is_valid_letter(b']'), false);
    assert_eq!(ascii::is_valid_letter(b'a'), true);
    assert_eq!(ascii::is_valid_letter(b'z'), true);
    assert_eq!(ascii::is_valid_letter(b'~'), false);
    assert_eq!(ascii::is_valid_letter(b'\x7f'), false);
}
fn computef32_test() {
    // Halfway, round-down tests
    assert_eq!(compute_float32::<BINARY>(0, 16777216, false), (151, 0));
    assert_eq!(compute_float32::<BINARY>(0, 16777217, false), (151, 0));
    assert_eq!(compute_float32::<BINARY>(0, 16777218, false), (151, 1));

    assert_eq!(compute_float32::<BINARY>(0, 33554432, false), (152, 0));
    assert_eq!(compute_float32::<BINARY>(0, 33554434, false), (152, 0));
    assert_eq!(compute_float32::<BINARY>(0, 33554436, false), (152, 1));
}
fn compute_right_closed_directed_test() {
    assert_eq!(compute_right_closed_directed(1.23456), (123456, -5));
    assert_eq!(
        compute_right_closed_directed(13.9999999999999982236431606),
        (13999999999999982, -15)
    );
}
fn max_digit_test() {
    assert_eq!(f32::max_digits(10), Some(114));
    assert_eq!(f64::max_digits(10), Some(769));
}
fn exponent_fast_path_test() {
    assert_eq!(f32::min_exponent_fast_path(10), -10);
    assert_eq!(f32::max_exponent_fast_path(10), 10);
    assert_eq!(f32::max_exponent_disguised_fast_path(10), 17);

    assert_eq!(f64::min_exponent_fast_path(10), -22);
    assert_eq!(f64::max_exponent_fast_path(10), 22);
    assert_eq!(f64::max_exponent_disguised_fast_path(10), 37);
}
