fn borrowed_str() {
    assert_eq!(
        ron::de::from_str(BORROWED).ok(),
        Some(Borrowed { value: "test" })
    );
}
fn lower_n_halfway_test() {
    assert_eq!(mask::lower_n_halfway(2), 0b10);
}
fn deflate_decoder_empty_read() {
    let original: &[u8] = b"Lorem ipsum dolor sit amet.";
    let mut encoder =
        flate2::write::DeflateEncoder::new(Vec::new(), flate2::Compression::default());
    encoder.write_all(original).unwrap();
    let encoded: Vec<u8> = encoder.finish().unwrap();
    let mut decoder = flate2::read::DeflateDecoder::new(encoded.as_slice());
    assert_eq!(decoder.read(&mut []).unwrap(), 0);
    let mut decoded = Vec::new();
    decoder.read_to_end(&mut decoded).unwrap();
    assert_eq!(decoded.as_slice(), original);
}
fn lower_n_mask_test() {
    assert_eq!(mask::lower_n_mask(2), 0b11);
}
fn sqrtd_spec_test() {
    // Not Asserted: FE_INVALID exception is raised if argument is negative.
    assert!(libm::sqrtd(-1.0).is_nan());
    assert!(libm::sqrtd(f64::NAN).is_nan());
    for f in [0.0, -0.0, f64::INFINITY].iter().copied() {
        assert_eq!(libm::sqrtd(f), f);
    }
}
fn bit_length_test() {
    let x: VecType = vec_from_u32(&[0, 0, 0, 1]);
    assert_eq!(bigint::bit_length(&x), 97);

    let x: VecType = vec_from_u32(&[0, 0, 0, 3]);
    assert_eq!(bigint::bit_length(&x), 98);

    let x = VecType::from_u64(1 << 31);
    assert_eq!(bigint::bit_length(&x), 32);
}
fn test_u128_max() {
    assert_eq!(
        std::u128::MAX,
        from_str(&to_string(&std::u128::MAX).unwrap()).unwrap()
    );
}
fn test_i32_max() {
    assert_eq!(
        std::i32::MAX,
        from_str(&to_string(&std::i32::MAX).unwrap()).unwrap()
    );
}
fn roundtrip() {
    let value = Struct {
        tuple: ((), NewType(0.5), TupleStruct(UnitStruct, -5)),
        vec: vec![None, Some(UnitStruct)],
        map: vec![
            (Key(5), Enum::Unit),
            (Key(6), Enum::Bool(false)),
            (Key(7), Enum::Bool(true)),
            (Key(9), Enum::Chars('x', "".to_string())),
        ]
        .into_iter()
        .collect(),
    };

    let serial = ron::ser::to_string(&value).unwrap();

    println!("Serialized: {}", serial);

    let deserial = ron::de::from_str(&serial);

    assert_eq!(Ok(value), deserial);
}
fn string() {
    let normal = "\"String\"";
    assert_eq!(normal.parse(), Ok(Value::String("String".into())));

    let raw = "r\"Raw String\"";
    assert_eq!(raw.parse(), Ok(Value::String("Raw String".into())));

    let raw_hashes = "r#\"Raw String\"#";
    assert_eq!(raw_hashes.parse(), Ok(Value::String("Raw String".into())));

    let raw_escaped = "r##\"Contains \"#\"##";
    assert_eq!(
        raw_escaped.parse(),
        Ok(Value::String("Contains \"#".into()))
    );

    let raw_multi_line = "r\"Multi\nLine\"";
    assert_eq!(
        raw_multi_line.parse(),
        Ok(Value::String("Multi\nLine".into()))
    );
}
fn gzip_encoder_empty_read() {
    let original: &[u8] = b"Lorem ipsum dolor sit amet.";
    let mut encoder = flate2::read::GzEncoder::new(original, flate2::Compression::default());
    assert_eq!(encoder.read(&mut []).unwrap(), 0);
    let mut encoded = Vec::new();
    encoder.read_to_end(&mut encoded).unwrap();
    let mut decoder = flate2::read::GzDecoder::new(encoded.as_slice());
    let mut decoded = Vec::new();
    decoder.read_to_end(&mut decoded).unwrap();
    assert_eq!(decoded.as_slice(), original);
}
fn fabsf_sanity_test() {
    assert_eq!(libm::fabsf(-1.0), 1.0);
    assert_eq!(libm::fabsf(2.8), 2.8);
}
fn seq() {
    let seq = vec![
        Value::Number(Number::new(1)),
        Value::Number(Number::new(2f64)),
    ];
    assert_eq!("[1, 2.0]".parse(), Ok(Value::Seq(seq)));

    let err = Value::Seq(vec![Value::Number(Number::new(1))])
        .into_rust::<[i32; 2]>()
        .unwrap_err();

    assert_eq!(
        err,
        Error::ExpectedDifferentLength {
            expected: String::from("an array of length 2"),
            found: 1,
        }
    );

    let err = Value::Seq(vec![
        Value::Number(Number::new(1)),
        Value::Number(Number::new(2)),
        Value::Number(Number::new(3)),
    ])
    .into_rust::<[i32; 2]>()
    .unwrap_err();

    assert_eq!(
        err,
        Error::ExpectedDifferentLength {
            expected: String::from("a sequence of length 2"),
            found: 3,
        }
    );
}
fn test_i64_max() {
    assert_eq!(
        std::i64::MAX,
        from_str(&to_string(&std::i64::MAX).unwrap()).unwrap()
    );
}
fn test_trailing_comma_enum_newtype_variant() {
    assert!(from_str::<Enum>("Newtype(1)").is_ok());
    assert!(from_str::<Enum>("Newtype(1,)").is_ok());
    assert!(from_str::<Enum>("Newtype(1,,)").is_err());
}
fn nth_bit_test() {
    assert_eq!(mask::nth_bit(2), 0b100);
}
fn f64_test() {
    assert_eq!(
        (184467440737095500000.0, b!("\x00\x00006")),
        parse_float::<f64>(b"000184467440737095516150\x00\x00006")
    );
}
fn gzip_decoder_empty_read() {
    let original: &[u8] = b"Lorem ipsum dolor sit amet.";
    let mut encoder = flate2::write::GzEncoder::new(Vec::new(), flate2::Compression::default());
    encoder.write_all(original).unwrap();
    let encoded: Vec<u8> = encoder.finish().unwrap();
    let mut decoder = flate2::read::GzDecoder::new(encoded.as_slice());
    assert_eq!(decoder.read(&mut []).unwrap(), 0);
    let mut decoded = Vec::new();
    decoder.read_to_end(&mut decoded).unwrap();
    assert_eq!(decoded.as_slice(), original);
}
fn sqrtf_spec_test() {
    // Not Asserted: FE_INVALID exception is raised if argument is negative.
    assert!(libm::sqrtf(-1.0).is_nan());
    assert!(libm::sqrtf(f32::NAN).is_nan());
    for f in [0.0, -0.0, f32::INFINITY].iter().copied() {
        assert_eq!(libm::sqrtf(f), f);
    }
}
fn test_trailing_comma_enum_tuple_variant() {
    assert!(from_str::<Enum>("Tuple(1,2)").is_ok());
    assert!(from_str::<Enum>("Tuple(1,2,)").is_ok());
    assert!(from_str::<Enum>("Tuple(1,2,,)").is_err());
}
fn map() {
    let mut map = Map::new();
    map.insert(Value::Char('a'), Value::Number(Number::new(1)));
    map.insert(Value::Char('b'), Value::Number(Number::new(2f64)));
    assert_eq!("{ 'a': 1, 'b': 2.0 }".parse(), Ok(Value::Map(map)));
}
fn test_trailing_comma_enum_struct_variant() {
    assert!(from_str::<Enum>("Struct(a:1,b:2)").is_ok());
    assert!(from_str::<Enum>("Struct(a:1,b:2,)").is_ok());
    assert!(from_str::<Enum>("Struct(a:1,b:2,,)").is_err());
}
fn try_fast_path_test() {
    let mut number = Number {
        exponent: -4,
        mantissa: 12345,
        many_digits: false,
    };
    assert_eq!(number.try_fast_path::<f32>(), Some(1.2345));
    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345));

    number.exponent = -10;
    assert_eq!(number.try_fast_path::<f32>(), Some(1.2345e-6));
    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345e-6));

    number.exponent = -20;
    assert_eq!(number.try_fast_path::<f32>(), None);
    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345e-16));

    number.exponent = -25;
    assert_eq!(number.try_fast_path::<f32>(), None);
    assert_eq!(number.try_fast_path::<f64>(), None);

    number.exponent = 12;
    assert_eq!(number.try_fast_path::<f32>(), Some(1.2345e16));
    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345e16));

    number.exponent = 25;
    assert_eq!(number.try_fast_path::<f32>(), None);
    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345e29));

    number.exponent = 32;
    assert_eq!(number.try_fast_path::<f32>(), None);
    assert_eq!(number.try_fast_path::<f64>(), Some(1.2345e36));

    number.exponent = 36;
    assert_eq!(number.try_fast_path::<f32>(), None);
    assert_eq!(number.try_fast_path::<f64>(), None);
}
fn sqrtf_sanity_test() {
    assert_eq!(libm::sqrtf(100.0), 10.0);
    assert_eq!(libm::sqrtf(4.0), 2.0);
}
fn f32_test() {
    assert_eq!(
        (184467440000000000000.0, b!("\x00\x00006")),
        parse_float::<f32>(b"000184467440737095516150\x00\x00006")
    );
}
fn option() {
    let opt = Some(Box::new(Value::Char('c')));
    assert_eq!("Some('c')".parse(), Ok(Value::Option(opt)));
}
fn sqrtd_sanity_test() {
    assert_eq!(libm::sqrtd(100.0), 10.0);
    assert_eq!(libm::sqrtd(4.0), 2.0);
}
fn test_i64_min() {
    assert_eq!(
        std::i64::MIN,
        from_str(&to_string(&std::i64::MIN).unwrap()).unwrap()
    );
}
fn number() {
    assert_eq!("42".parse(), Ok(Value::Number(Number::new(42))));
    assert_eq!(
        "3.141592653589793".parse(),
        Ok(Value::Number(Number::new(f64::consts::PI)))
    );
}
fn roundtrip_sep_tuple_members() {
    #[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
    pub enum FileOrMem {
        File(String),
        Memory,
    }

    #[derive(Debug, Deserialize, PartialEq, Serialize)]
    struct Both {
        a: Struct,
        b: FileOrMem,
    }

    let a = Struct {
        tuple: ((), NewType(0.5), TupleStruct(UnitStruct, -5)),
        vec: vec![None, Some(UnitStruct)],
        map: vec![
            (Key(5), Enum::Unit),
            (Key(6), Enum::Bool(false)),
            (Key(7), Enum::Bool(true)),
            (Key(9), Enum::Chars('x', "".to_string())),
        ]
        .into_iter()
        .collect(),
    };
    let b = FileOrMem::File("foo".to_owned());

    let value = Both { a, b };

    let pretty = ron::ser::PrettyConfig::new().separate_tuple_members(true);
    let serial = ron::ser::to_string_pretty(&value, pretty).unwrap();

    println!("Serialized: {}", serial);

    let deserial = ron::de::from_str(&serial);

    assert_eq!(Ok(value), deserial);
}
fn read_info() {
    let path = Path::new("tests").join("reftest").join("images").join("mozilla").join("jpg-progressive.jpg");

    let mut decoder = jpeg::Decoder::new(File::open(&path).unwrap());
    let ref_data = decoder.decode().unwrap();
    let ref_info = decoder.info().unwrap();

    decoder = jpeg::Decoder::new(File::open(&path).unwrap());
    decoder.read_info().unwrap();
    let info = decoder.info().unwrap();
    let data = decoder.decode().unwrap();

    assert_eq!(info, decoder.info().unwrap());
    assert_eq!(info, ref_info);
    assert_eq!(data, ref_data);
}
fn char() {
    assert_eq!("'a'".parse(), Ok(Value::Char('a')));
}
fn test_large_number() {
    let test_var = Value::Number(Number::new(10000000000000000000000.0f64));
    let test_ser = ron::ser::to_string(&test_var).unwrap();
    let test_deser = ron::de::from_str::<Value>(&test_ser);

    assert_eq!(
        test_deser.unwrap(),
        Value::Number(Number::new(10000000000000000000000.0))
    );
}
fn fabsd_sanity_test() {
    assert_eq!(libm::fabsd(-1.0), 1.0);
    assert_eq!(libm::fabsd(2.8), 2.8);
}
fn test_u128_min() {
    assert_eq!(
        std::u128::MIN,
        from_str(&to_string(&std::u128::MIN).unwrap()).unwrap()
    );
}
fn deflate_encoder_empty_read() {
    let original: &[u8] = b"Lorem ipsum dolor sit amet.";
    let mut encoder = flate2::read::DeflateEncoder::new(original, flate2::Compression::default());
    assert_eq!(encoder.read(&mut []).unwrap(), 0);
    let mut encoded = Vec::new();
    encoder.read_to_end(&mut encoded).unwrap();
    let mut decoder = flate2::read::DeflateDecoder::new(encoded.as_slice());
    let mut decoded = Vec::new();
    decoder.read_to_end(&mut decoded).unwrap();
    assert_eq!(decoded.as_slice(), original);
}
fn scalar_add_test() {
    assert_eq!(bigint::scalar_add(5, 5), (10, false));
    assert_eq!(bigint::scalar_add(LIMB_MAX, 1), (0, true));
}
fn fabsf_spec_test() {
    assert!(libm::fabsf(f32::NAN).is_nan());
    for f in [0.0, -0.0].iter().copied() {
        assert_eq!(libm::fabsf(f), 0.0);
    }
    for f in [f32::INFINITY, f32::NEG_INFINITY].iter().copied() {
        assert_eq!(libm::fabsf(f), f32::INFINITY);
    }
}
