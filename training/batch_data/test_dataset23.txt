fn parse_filter_section_preserves_ws() {
    let ast = parse("{% filter upper %}  {{a}}  B  {% endfilter %}").unwrap();

    assert_eq!(
        ast[0],
        Node::FilterSection(
            WS::default(),
            FilterSection {
                filter: FunctionCall { name: "upper".to_string(), args: HashMap::new() },
                body: vec![
                    Node::Text("  ".to_string()),
                    Node::VariableBlock(WS::default(), Expr::new(ExprVal::Ident("a".to_string()))),
                    Node::Text("  B  ".to_string())
                ]
            },
            WS::default(),
        )
    );
}
fn test_version_mismatch() -> Result<()> {
    let engine = Engine::default();
    let buffer = serialize(&engine, "(module)")?;

    let mut config = Config::new();
    config
        .module_version(ModuleVersionStrategy::Custom("custom!".to_owned()))
        .unwrap();
    let custom_version_engine = Engine::new(&config).unwrap();
    match unsafe { Module::deserialize(&custom_version_engine, &buffer) } {
        Ok(_) => bail!("expected deserialization to fail"),
        Err(e) => assert!(e
            .to_string()
            .starts_with("Module was compiled with incompatible version")),
    }

    let mut config = Config::new();
    config.module_version(ModuleVersionStrategy::None).unwrap();
    let none_version_engine = Engine::new(&config).unwrap();
    unsafe { Module::deserialize(&none_version_engine, &buffer) }
        .expect("accepts the wasmtime versioned module");

    let buffer = serialize(&custom_version_engine, "(module)")?;
    unsafe { Module::deserialize(&none_version_engine, &buffer) }
        .expect("accepts the custom versioned module");

    Ok(())
}
fn dont_retry_on_negative_response() {
    let mut response = Message::new();
    response
        .set_message_type(MessageType::Response)
        .set_op_code(OpCode::Update)
        .set_response_code(ResponseCode::NoError);
    let error = ResolveError::from_response(DnsResponse::from_message(response).unwrap(), false)
        .expect_err("NODATA should be an error");
    let client = RetryDnsHandle::new(
        TestClient {
            retries: 1,
            error_response: error,
            attempts: Arc::new(AtomicU16::new(0)),
        },
        2,
    );
    let test1 = Message::new();
    assert!(block_on(client.send(test1).first_answer()).is_err());
}
fn parse_allow_block_in_filter_section() {
    let ast =
        parse("{% filter upper %}{% block content %}Hello{% endblock %}{% endfilter %}").unwrap();

    assert_eq!(
        ast[0],
        Node::FilterSection(
            WS::default(),
            FilterSection {
                filter: FunctionCall { name: "upper".to_owned(), args: HashMap::default() },
                body: vec![Node::Block(
                    WS::default(),
                    Block {
                        name: "content".to_owned(),
                        body: vec![Node::Text("Hello".to_owned())]
                    },
                    WS::default(),
                )],
            },
            WS::default(),
        )
    );
}
fn host_return_error_no_backtrace() -> Result<()> {
    let mut config = Config::new();
    config.wasm_backtrace(false);
    let engine = Engine::new(&config)?;
    let mut store = Store::new(&engine, ());
    let module = Module::new(
        &engine,
        r#"
            (module
                (import "" "" (func $host))
                (func $foo (export "f") call $bar)
                (func $bar call $host)
            )
        "#,
    )?;
    let func = Func::wrap(&mut store, |_cx: Caller<'_, ()>| -> Result<()> {
        bail!("test")
    });
    let instance = Instance::new(&mut store, &module, &[func.into()])?;
    let f = instance.get_typed_func::<(), ()>(&mut store, "f")?;
    assert!(f.call(&mut store, ()).is_err());
    Ok(())
}
fn static_forced_max() -> Result<()> {
    let mut config = Config::new();
    config.static_memory_maximum_size(5 * 65536);
    config.static_memory_forced(true);
    let engine = Engine::new(&config)?;
    let mut store = Store::new(&engine, ());

    let mem = Memory::new(&mut store, MemoryType::new(0, None))?;
    mem.grow(&mut store, 5).unwrap();
    assert!(mem.grow(&mut store, 1).is_err());
    Ok(())
}
fn multithreaded_traps() -> Result<()> {
    // Compile and run unreachable on a thread, then moves over the whole store to another thread,
    // and make sure traps are still correctly caught after notifying the store of the move.
    let mut store = Store::<()>::default();
    let module = Module::new(
        store.engine(),
        r#"(module (func (export "run") unreachable))"#,
    )?;
    let instance = Instance::new(&mut store, &module, &[])?;

    assert!(instance
        .get_typed_func::<(), ()>(&mut store, "run")?
        .call(&mut store, ())
        .is_err());

    let handle = std::thread::spawn(move || {
        assert!(instance
            .get_typed_func::<(), ()>(&mut store, "run")
            .unwrap()
            .call(&mut store, ())
            .is_err());
    });

    handle.join().expect("couldn't join thread");

    Ok(())
}
fn parse_variable_tag_math_with_filters_and_logic_expression() {
    let ast = parse("{{ count + 1 * 2.5 | round and admin }}").unwrap();
    assert_eq!(
        ast[0],
        Node::VariableBlock(
            WS::default(),
            Expr::new(ExprVal::Logic(LogicExpr {
                lhs: Box::new(Expr::with_filters(
                    ExprVal::Math(MathExpr {
                        lhs: Box::new(Expr::new(ExprVal::Ident("count".to_string()))),
                        operator: MathOperator::Add,
                        rhs: Box::new(Expr::new(ExprVal::Math(MathExpr {
                            lhs: Box::new(Expr::new(ExprVal::Int(1))),
                            operator: MathOperator::Mul,
                            rhs: Box::new(Expr::new(ExprVal::Float(2.5))),
                        },))),
                    },),
                    vec![FunctionCall { name: "round".to_string(), args: HashMap::new() },],
                )),
                operator: LogicOperator::And,
                rhs: Box::new(Expr::new(ExprVal::Ident("admin".to_string()))),
            },))
        )
    );
}
fn parse_variable_tag_simple_test() {
    let ast = parse("{{ id is defined }}").unwrap();
    assert_eq!(
        ast[0],
        Node::VariableBlock(
            WS::default(),
            Expr::new(ExprVal::Test(Test {
                ident: "id".to_string(),
                negated: false,
                name: "defined".to_string(),
                args: vec![],
            },))
        )
    );
}
fn parse_negated_in_condition() {
    let ast = parse("{{ b not in c }}").unwrap();
    let mut args = HashMap::new();
    args.insert("some".to_string(), Expr::new(ExprVal::Int(1)));

    assert_eq!(
        ast[0],
        Node::VariableBlock(
            WS::default(),
            Expr::new(ExprVal::In(In {
                lhs: Box::new(Expr::new(ExprVal::Ident("b".to_string()))),
                rhs: Box::new(Expr::new(ExprVal::Ident("c".to_string()))),
                negated: true,
            }))
        )
    );
}
fn lex_test() {
    let inputs =
        vec!["a is defined", "a is defined()", "a is divisibleby(2)", "a is in([1, 2, something])"];
    for i in inputs {
        // The () are not counted as tokens for some reasons so can't use the macro
        assert!(TeraParser::parse(Rule::test, i).is_ok());
    }
}
fn parse_variable_tag_macro_call() {
    let ast = parse("{{ macros::get_time(some=1) }}").unwrap();
    let mut args = HashMap::new();
    args.insert("some".to_string(), Expr::new(ExprVal::Int(1)));

    assert_eq!(
        ast[0],
        Node::VariableBlock(
            WS::default(),
            Expr::new(ExprVal::MacroCall(MacroCall {
                namespace: "macros".to_string(),
                name: "get_time".to_string(),
                args,
            },)),
        )
    );
}
fn test_notify() {
    let io_loop = Runtime::new().unwrap();
    let authority = create_example();
    let mut catalog = Catalog::new();
    catalog.upsert(authority.origin().clone(), Box::new(Arc::new(authority)));

    let (stream, sender) = TestClientStream::new(Arc::new(StdMutex::new(catalog)));
    let client = AsyncClient::new(stream, sender, None);
    let (mut client, bg) = io_loop.block_on(client).expect("client failed to connect");
    hickory_proto::spawn_bg(&io_loop, bg);

    let name = Name::from_str("ping.example.com").unwrap();

    let message =
        io_loop.block_on(client.notify(name, DNSClass::IN, RecordType::A, None::<RecordSet>));
    assert!(message.is_ok());
    let message = message.unwrap();
    assert_eq!(
        message.response_code(),
        ResponseCode::NotImp,
        "the catalog must support Notify now, update this"
    );
}
fn test_lookup() {
    let runtime = Runtime::new().expect("failed to create Tokio Runtime");
    let forwarder = ForwardAuthority::new(TokioConnectionProvider::default())
        .expect("failed to create forwarder");

    let lookup = runtime
        .block_on(forwarder.lookup(
            &Name::from_str("www.example.com.").unwrap().into(),
            RecordType::A,
            Default::default(),
        ))
        .unwrap();

    let address = lookup.iter().next().expect("no addresses returned!");
    let address = address
        .data()
        .and_then(RData::as_a)
        .expect("not an A record");
    assert_eq!(*address, Ipv4Addr::new(93, 184, 216, 34).into());
}
fn test_dnssec_restart_with_update_journal() {
    // TODO: make journal path configurable, it should be in target/tests/...
    let server_path = env::var("TDNS_WORKSPACE_ROOT").unwrap_or_else(|_| "..".to_owned());
    let server_path = Path::new(&server_path);
    let journal = server_path.join("tests/test-data/test_configs/example.com_dnssec_update.jrnl");
    std::fs::remove_file(&journal).ok();

    generic_test(
        "dnssec_with_update.toml",
        "tests/test-data/test_configs/dnssec/rsa_2048.pem",
        KeyFormat::Pem,
        Algorithm::RSASHA256,
    );

    // after running the above test, the journal file should exist
    assert!(journal.exists());

    // and all dnssec tests should still pass
    generic_test(
        "dnssec_with_update.toml",
        "tests/test-data/test_configs/dnssec/rsa_2048.pem",
        KeyFormat::Pem,
        Algorithm::RSASHA256,
    );

    // and journal should still exist
    assert!(journal.exists());

    // cleanup...
    // TODO: fix journal path so that it doesn't leave the dir dirty... this might make windows an option after that
    std::fs::remove_file(&journal).expect("failed to cleanup after test");
}
