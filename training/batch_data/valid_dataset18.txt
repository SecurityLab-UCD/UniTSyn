fn creates_config_file_when_biome_installed_via_package_manager() {
    let mut fs = MemoryFileSystem::default();
    let mut console = BufferConsole::default();

    let file_path = Path::new("./node_modules/@biomejs/biome/configuration_schema.json");
    fs.insert(file_path.into(), *b"{}");

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from([("init")].as_slice()),
    );
    assert!(result.is_ok(), "run_cli returned {result:?}");

    let file_path = Path::new("biome.json");

    let mut file = fs
        .open(file_path)
        .expect("configuration file was not written on disk");

    let mut content = String::new();
    file.read_to_string(&mut content)
        .expect("failed to read file from memory FS");
    let parsed = parse_json(
        CONFIG_INIT_DEFAULT_WHEN_INSTALLED,
        JsonParserOptions::default(),
    );
    let formatted =
        biome_json_formatter::format_node(JsonFormatOptions::default(), &parsed.syntax())
            .expect("valid format document")
            .print()
            .expect("valid format document");
    assert_eq!(content, formatted.as_code());

    drop(file);

    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "creates_config_file_when_biome_installed_via_package_manager",
        fs,
        console,
        result,
    ));
}
fn bindgen_test_layout_lol_html_memory_settings_t() {
    const UNINIT: ::std::mem::MaybeUninit<lol_html_memory_settings_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lol_html_memory_settings_t>(),
        16usize,
        concat!("Size of: ", stringify!(lol_html_memory_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lol_html_memory_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lol_html_memory_settings_t))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).preallocated_parsing_buffer_size) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lol_html_memory_settings_t),
            "::",
            stringify!(preallocated_parsing_buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_allowed_memory_usage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lol_html_memory_settings_t),
            "::",
            stringify!(max_allowed_memory_usage)
        )
    );
}
fn drain() {
    let mut headers = HeaderMap::new();

    // Insert a single value
    let name: HeaderName = "hello".parse().unwrap();
    headers.insert(name, "world".parse().unwrap());

    {
        let mut iter = headers.drain();
        let (name, value) = iter.next().unwrap();
        assert_eq!(name.unwrap().as_str(), "hello");

        assert_eq!(value, "world");

        assert!(iter.next().is_none());
    }

    assert!(headers.is_empty());

    // Insert two sequential values
    headers.insert(
        "hello".parse::<HeaderName>().unwrap(),
        "world".parse().unwrap(),
    );
    headers.insert(
        "zomg".parse::<HeaderName>().unwrap(),
        "bar".parse().unwrap(),
    );
    headers.append(
        "hello".parse::<HeaderName>().unwrap(),
        "world2".parse().unwrap(),
    );

    // Drain...
    {
        let mut iter = headers.drain();

        let (name, value) = iter.next().unwrap();
        assert_eq!(name.unwrap().as_str(), "hello");
        assert_eq!(value, "world");

        let (name, value) = iter.next().unwrap();
        assert_eq!(name, None);
        assert_eq!(value, "world2");

        let (name, value) = iter.next().unwrap();
        assert_eq!(name.unwrap().as_str(), "zomg");
        assert_eq!(value, "bar");

        assert!(iter.next().is_none());
    }
}
fn ignore_comments_error_when_allow_comments() {
    let mut fs = MemoryFileSystem::default();
    let mut console = BufferConsole::default();

    let config_json = r#"{
  "json": {
    "parser": { "allowComments": true }
  }
}

    "#;
    let biome_config = "biome.json";
    let code = r#"
/*test*/ [1, 2, 3]
    "#;
    let file_path = Path::new("tsconfig.json");
    fs.insert(file_path.into(), code.as_bytes());
    fs.insert(biome_config.into(), config_json);

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from([("format"), file_path.as_os_str().to_str().unwrap()].as_slice()),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");

    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "ignore_comments_error_when_allow_comments",
        fs,
        console,
        result,
    ));
}
fn ok() {
    let mut fs = MemoryFileSystem::default();
    let mut console = BufferConsole::default();

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from([("--version")].as_slice()),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");

    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "version_ok",
        fs,
        console,
        result,
    ));
}
fn remove_entry_3_others_a() {
    let mut headers = HeaderMap::new();
    headers.insert(VIA, "1.1 example.com".parse().unwrap());
    headers.insert(SET_COOKIE, "cookie_1=value 1".parse().unwrap());
    headers.append(SET_COOKIE, "cookie_2=value 2".parse().unwrap());
    headers.append(VIA, "1.1 other.com".parse().unwrap());
    headers.append(SET_COOKIE, "cookie_3=value 3".parse().unwrap());
    headers.insert(VARY, "*".parse().unwrap());

    assert_eq!(headers.len(), 6);

    let cookie = remove_values(&mut headers, SET_COOKIE);
    assert_eq!(cookie, Some("cookie_1=value 1".parse().unwrap()));
    assert_eq!(headers.len(), 3);

    let via = remove_values(&mut headers, VIA);
    assert_eq!(via, Some("1.1 example.com".parse().unwrap()));
    assert_eq!(headers.len(), 1);

    let vary = remove_values(&mut headers, VARY);
    assert_eq!(vary, Some("*".parse().unwrap()));
    assert_eq!(headers.len(), 0);
}
fn should_create_biome_json_file() {
    let mut fs = MemoryFileSystem::default();
    let mut console = BufferConsole::default();

    let configuration = r#"{ "linter": { "enabled": true } }"#;

    let configuration_path = Path::new("rome.json");
    fs.insert(configuration_path.into(), configuration.as_bytes());

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from([("migrate"), "--write"].as_slice()),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");

    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "should_create_biome_json_file",
        fs,
        console,
        result,
    ));
}
fn ignore_vcs_ignored_file() {
    let mut fs = MemoryFileSystem::default();
    let mut console = BufferConsole::default();

    let rome_json = r#"{
        "vcs": {
            "enabled": true,
            "clientKind": "git",
            "useIgnoreFile": true
        }
    }"#;

    let git_ignore = r#"
file2.js
"#;

    let code2 = r#"foo.call();


    bar.call();"#;
    let code1 = r#"array.map(sentence =>


    sentence.split(' ')).flat();"#;

    // ignored files
    let file_path1 = Path::new("file1.js");
    fs.insert(file_path1.into(), code1.as_bytes());
    let file_path2 = Path::new("file2.js");
    fs.insert(file_path2.into(), code2.as_bytes());

    // configuration
    let config_path = Path::new("biome.json");
    fs.insert(config_path.into(), rome_json.as_bytes());

    // git ignore file
    let ignore_file = Path::new(".gitignore");
    fs.insert(ignore_file.into(), git_ignore.as_bytes());

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from(
            [
                ("format"),
                ("--write"),
                file_path1.as_os_str().to_str().unwrap(),
                file_path2.as_os_str().to_str().unwrap(),
            ]
            .as_slice(),
        ),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");

    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "ignore_vcs_ignored_file",
        fs,
        console,
        result,
    ));
}
fn drain_forget() {
    // test mem::forgetting does not double-free

    let mut headers = HeaderMap::<HeaderValue>::new();
    headers.insert("hello", "world".parse().unwrap());
    headers.insert("zomg", "bar".parse().unwrap());

    assert_eq!(headers.len(), 2);

    {
        let mut iter = headers.drain();
        assert_eq!(iter.size_hint(), (2, Some(2)));
        let _ = iter.next().unwrap();
        std::mem::forget(iter);
    }

    assert_eq!(headers.len(), 0);
}
fn small_array() {
    let arr = &[(), (), ()][..];
    assert_eq!(
        to_string_pretty(&arr, PrettyConfig::new().new_line("\n".to_string())).unwrap(),
        "[
    (),
    (),
    (),
]"
    );
    assert_eq!(
        to_string_pretty(
            &arr,
            PrettyConfig::new()
                .new_line("\n".to_string())
                .compact_arrays(true)
        )
        .unwrap(),
        "[(), (), ()]"
    );
    assert_eq!(
        to_string_pretty(
            &arr,
            PrettyConfig::new()
                .new_line("\n".to_string())
                .compact_arrays(true)
                .separator("".to_string())
        )
        .unwrap(),
        "[(),(),()]"
    );
    assert_eq!(
        to_string_pretty(
            &vec![(1, 2), (3, 4)],
            PrettyConfig::new()
                .new_line("\n".to_string())
                .separate_tuple_members(true)
                .compact_arrays(true)
        )
        .unwrap(),
        "[(
    1,
    2,
), (
    3,
    4,
)]"
    );
}
fn remove_multiple_b() {
    let mut headers = HeaderMap::new();
    headers.insert(VIA, "1.1 example.com".parse().unwrap());
    headers.insert(SET_COOKIE, "cookie_1=value 1".parse().unwrap());
    headers.append(SET_COOKIE, "cookie_2=value 2".parse().unwrap());
    headers.append(VIA, "1.1 other.com".parse().unwrap());
    headers.append(SET_COOKIE, "cookie_3=value 3".parse().unwrap());
    headers.insert(VARY, "*".parse().unwrap());

    assert_eq!(headers.len(), 6);

    let vary = headers.remove(VARY);
    assert_eq!(vary, Some("*".parse().unwrap()));
    assert_eq!(headers.len(), 5);

    let via = headers.remove(VIA);
    assert_eq!(via, Some("1.1 example.com".parse().unwrap()));
    assert_eq!(headers.len(), 3);

    let cookie = headers.remove(SET_COOKIE);
    assert_eq!(cookie, Some("cookie_1=value 1".parse().unwrap()));
    assert_eq!(headers.len(), 0);
}
fn treat_known_json_files_as_jsonc_files() {
    let mut fs = MemoryFileSystem::default();
    let mut console = BufferConsole::default();

    let code = r#"
/*test*/ [

/* some other comment*/1, 2, 3]
    "#;
    let ts = Path::new("files/typescript.json");
    fs.insert(ts.into(), code.as_bytes());
    let eslint = Path::new("files/.eslintrc.json");
    fs.insert(eslint.into(), code.as_bytes());
    let jshint = Path::new("files/.jshintrc");
    fs.insert(jshint.into(), code.as_bytes());
    let babel = Path::new("files/.babelrc");
    fs.insert(babel.into(), code.as_bytes());

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from(
            [
                ("format"),
                ts.as_os_str().to_str().unwrap(),
                eslint.as_os_str().to_str().unwrap(),
                jshint.as_os_str().to_str().unwrap(),
                babel.as_os_str().to_str().unwrap(),
            ]
            .as_slice(),
        ),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");

    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "treat_known_json_files_as_jsonc_files",
        fs,
        console,
        result,
    ));
}
fn is_informational() {
    assert!(status_code(100).is_informational());
    assert!(status_code(199).is_informational());

    assert!(!status_code(200).is_informational());
}
fn apply_noop() {
    let mut fs = MemoryFileSystem::default();
    let mut console = BufferConsole::default();

    let file_path = Path::new("fix.js");
    fs.insert(file_path.into(), FIX_AFTER.as_bytes());

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from(
            [
                ("lint"),
                ("--apply"),
                file_path.as_os_str().to_str().unwrap(),
            ]
            .as_slice(),
        ),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");

    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "apply_noop",
        fs,
        console,
        result,
    ));
}
fn should_not_format_js_files_if_disabled() {
    let mut fs = MemoryFileSystem::default();
    let mut console = BufferConsole::default();

    let biome_json = Path::new("biome.json");
    fs.insert(
        biome_json.into(),
        r#"{
        "formatter": {
            "indentStyle": "space"
        },
        "javascript": {
            "formatter": {
                "enabled": false
            }
        },
        "json": {
            "formatter": {
                "lineWidth": 80,
                "indentSize": 2
            }
        }
    }"#,
    );

    let json_file_content = r#"
{
    "array": ["lorem ipsum", "lorem ipsum", "lorem ipsum", "lorem ipsum", "lorem ipsum", "lorem ipsum", "lorem ipsum"]
}
    "#;
    let json_file = Path::new("input.json");
    fs.insert(json_file.into(), json_file_content.as_bytes());

    let js_file_content = r#"
const a = {
    "array": ["lorem ipsum", "lorem ipsum", "lorem ipsum", "lorem ipsum", "lorem ipsum", "lorem ipsum", "lorem ipsum"]
}
    "#;
    let js_file = Path::new("input.js");
    fs.insert(js_file.into(), js_file_content.as_bytes());

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from(
            [
                ("format"),
                "--write",
                json_file.as_os_str().to_str().unwrap(),
                js_file.as_os_str().to_str().unwrap(),
            ]
            .as_slice(),
        ),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");

    let mut file = fs
        .open(js_file)
        .expect("formatting target file was removed by the CLI");

    let mut content = String::new();
    file.read_to_string(&mut content)
        .expect("failed to read file from memory FS");

    assert_eq!(content, js_file_content);

    drop(file);

    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "should_not_format_js_files_if_disabled",
        fs,
        console,
        result,
    ));
}
