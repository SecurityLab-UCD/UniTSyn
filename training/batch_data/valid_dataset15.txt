fn test_skip_iter_iltc() {
    // Test iterators that skip multiple digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_internal_digit_separator(true)
        .integer_leading_digit_separator(true)
        .integer_trailing_digit_separator(true)
        .integer_consecutive_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"455");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"455");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".455");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b".455");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"45.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"45.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"45");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"45.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"45.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"45");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"45.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"45.56");
}
fn test() {
    use prost::Message;

    let mut widget_factory = widget::factory::WidgetFactory::default();
    assert_eq!(0, widget_factory.encoded_len());

    widget_factory.inner = Some(widget::factory::widget_factory::Inner {});
    assert_eq!(2, widget_factory.encoded_len());

    widget_factory.root = Some(Root {});
    assert_eq!(4, widget_factory.encoded_len());

    widget_factory.root_inner = Some(root::Inner {});
    assert_eq!(6, widget_factory.encoded_len());

    widget_factory.widget = Some(widget::Widget {});
    assert_eq!(8, widget_factory.encoded_len());

    widget_factory.widget_inner = Some(widget::widget::Inner {});
    assert_eq!(10, widget_factory.encoded_len());

    widget_factory.gizmo = Some(gizmo::Gizmo {});
    assert_eq!(12, widget_factory.encoded_len());

    widget_factory.gizmo_inner = Some(gizmo::gizmo::Inner {});
    assert_eq!(14, widget_factory.encoded_len());
}
fn test_context_merge_custom() {
    struct X;
    impl StructObject for X {
        fn get_field(&self, name: &str) -> Option<Value> {
            match name {
                "a" => Some(Value::from(1)),
                "b" => Some(Value::from(2)),
                _ => None,
            }
        }
    }

    let x = Value::from_struct_object(X);
    let ctx = context! { a => 42, ..x };

    assert_eq!(ctx.get_attr("a").unwrap(), Value::from(42));
    assert_eq!(ctx.get_attr("b").unwrap(), Value::from(2));
}
fn test_skip_iter_t() {
    // Test iterators that skip single, trailing-only digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_trailing_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"__45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b"_.45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"4__5");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4_");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4_.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"_45_5");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"__45__5");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".45_5");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b"_.45__5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"4__5_");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"4_5.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"4__5_.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"__45_");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"_45.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"__45_.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"_4_5");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"__4__5_");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"_4_5.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"__4__5_.56");
}
fn test_something() {
    let data = [];
    let from_bytes: Vec<_> = data.iter().to_utf8chars().collect();
    let mut byte_start = 0;
    let mut item_start = 0;
    loop {
        let (valid_up_to, error_length) = match str::from_utf8(&data[byte_start..]) {
            Ok(s) => (s.len(), None),
            Err(e) => (e.valid_up_to(), e.error_len()),
        };
        let valid_range = byte_start..byte_start + valid_up_to;
        let good_part = str::from_utf8(&data[valid_range]).unwrap();
        let mut chars = 0;
        for (i, c) in good_part.chars().enumerate() {
            chars += 1;
            assert_eq!(from_bytes.get(item_start + i), Some(&Ok(Utf8Char::from(c))));
        }
        let error_start = item_start + chars;
        if let Some(error_length) = error_length {
            let error_end = error_start + error_length;
            assert!(from_bytes[error_start..error_end]
                .iter()
                .all(|r| r.is_err()));
            item_start = error_end;
            byte_start = byte_start + valid_up_to + error_length;
        } else if byte_start + valid_up_to == data.len() {
            assert_eq!(from_bytes.len(), error_start);
            break;
        } else {
            data[byte_start + valid_up_to].extra_utf8_bytes().unwrap();
            assert_eq!(
                from_bytes.len() - error_start,
                data.len() - valid_up_to - byte_start
            );
            assert_eq!(
                from_bytes[error_start].map_err(|e| e.kind()),
                Err(TooFewBytes)
            );
            break;
        }
    }
    let from_slice: Vec<_> = data.utf8char_indices().map(|(_, r, _)| r).collect();
    for (i, (&br, &sr)) in from_bytes.iter().zip(&from_slice).enumerate() {
        match sr {
            Err(e) if e.kind() == TooFewBytes || e.kind() == InterruptedSequence => {
                assert!(br.is_err(), "byte {}", i)
            }
            _ => assert_eq!(sr, br, "byte {}", i),
        }
    }
    assert_eq!(from_slice.len(), from_bytes.len());
}
fn test_error_info() {
    let mut c = CodeGenerator::new("hello.html", "");
    c.set_line(1);
    c.add(Instruction::EmitRaw("<h1>Hello</h1>\n"));
    c.set_line(2);
    c.add(Instruction::Lookup("a_string"));
    c.add(Instruction::Lookup("an_int"));
    c.add(Instruction::Add);

    let mut ctx = std::collections::BTreeMap::new();
    ctx.insert("a_string", Value::from("foo"));
    ctx.insert("an_int", Value::from(42));

    let err = simple_eval(&c.finish().0, ctx).unwrap_err();
    assert_eq!(err.name(), Some("hello.html"));
    assert_eq!(err.line(), Some(2));
}
fn u128_pow10_test() {
    let values: &[u128] = &[
        0,
        1,
        5,
        9,
        10,
        11,
        15,
        99,
        100,
        101,
        105,
        999,
        1000,
        1001,
        1005,
        9999,
        10000,
        10001,
        10005,
        99999,
        100000,
        100001,
        100005,
        999999,
        1000000,
        1000001,
        1000005,
        9999999,
        10000000,
        10000001,
        10000005,
        99999999,
        100000000,
        100000001,
        100000005,
        999999999,
        1000000000,
        1000000001,
        1000000005,
        9999999999,
        10000000000,
        10000000001,
        10000000005,
        99999999999,
        100000000000,
        100000000001,
        100000000005,
        999999999999,
        1000000000000,
        1000000000001,
        1000000000005,
        9999999999999,
        10000000000000,
        10000000000001,
        10000000000005,
        99999999999999,
        100000000000000,
        100000000000001,
        100000000000005,
        999999999999999,
        1000000000000000,
        1000000000000001,
        1000000000000005,
        9999999999999999,
        10000000000000000,
        10000000000000001,
        10000000000000005,
        99999999999999999,
        100000000000000000,
        100000000000000001,
        100000000000000005,
        999999999999999999,
        1000000000000000000,
        1000000000000000001,
        1000000000000000005,
        9999999999999999999,
        10000000000000000000,
        10000000000000000001,
        10000000000000000005,
        99999999999999999999,
        100000000000000000000,
        100000000000000000001,
        100000000000000000005,
        999999999999999999999,
        1000000000000000000000,
        1000000000000000000001,
        1000000000000000000005,
        9999999999999999999999,
        10000000000000000000000,
        10000000000000000000001,
        10000000000000000000005,
        99999999999999999999999,
        100000000000000000000000,
        100000000000000000000001,
        100000000000000000000005,
        999999999999999999999999,
        1000000000000000000000000,
        1000000000000000000000001,
        1000000000000000000000005,
        9999999999999999999999999,
        10000000000000000000000000,
        10000000000000000000000001,
        10000000000000000000000005,
        99999999999999999999999999,
        100000000000000000000000000,
        100000000000000000000000001,
        100000000000000000000000005,
        999999999999999999999999999,
        1000000000000000000000000000,
        1000000000000000000000000001,
        1000000000000000000000000005,
        9999999999999999999999999999,
        10000000000000000000000000000,
        10000000000000000000000000001,
        10000000000000000000000000005,
        99999999999999999999999999999,
        100000000000000000000000000000,
        100000000000000000000000000001,
        100000000000000000000000000005,
        999999999999999999999999999999,
        1000000000000000000000000000000,
        1000000000000000000000000000001,
        1000000000000000000000000000005,
        9999999999999999999999999999999,
        10000000000000000000000000000000,
        10000000000000000000000000000001,
        10000000000000000000000000000005,
        99999999999999999999999999999999,
        100000000000000000000000000000000,
        100000000000000000000000000000001,
        100000000000000000000000000000005,
        999999999999999999999999999999999,
        1000000000000000000000000000000000,
        1000000000000000000000000000000001,
        1000000000000000000000000000000005,
        9999999999999999999999999999999999,
        10000000000000000000000000000000000,
        10000000000000000000000000000000001,
        10000000000000000000000000000000005,
        99999999999999999999999999999999999,
        100000000000000000000000000000000000,
        100000000000000000000000000000000001,
        100000000000000000000000000000000005,
        999999999999999999999999999999999999,
        1000000000000000000000000000000000000,
        1000000000000000000000000000000000001,
        1000000000000000000000000000000000005,
        9999999999999999999999999999999999999,
        10000000000000000000000000000000000000,
        10000000000000000000000000000000000001,
        10000000000000000000000000000000000005,
        99999999999999999999999999999999999999,
        100000000000000000000000000000000000000,
        100000000000000000000000000000000000001,
        100000000000000000000000000000000000005,
    ];
    for &i in values.iter() {
        assert_eq!(i, roundtrip(i));
    }
}
fn ceil_divmod_test() {
    use lexical_util::num::Integer;

    assert_eq!(5usize.ceil_divmod(7), (1, -2));
    assert_eq!(0usize.ceil_divmod(7), (0, 0));
    assert_eq!(35usize.ceil_divmod(7), (5, 0));
    assert_eq!(36usize.ceil_divmod(7), (6, -6));
}
fn test_macro_passing() {
    let env = Environment::new();
    let tmpl = env
        .template_from_str("{% macro m(a) %}{{ a }}{% endmacro %}")
        .unwrap();
    let (_, state) = tmpl.render_and_return_state(()).unwrap();
    let m = state.lookup("m").unwrap();
    assert_eq!(m.get_attr("name").unwrap().as_str(), Some("m"));
    let rv = m.call(&state, args!(42)).unwrap();
    assert_eq!(rv.as_str(), Some("42"));

    // if we call the macro on an empty state it errors
    let empty_state = env.empty_state();
    let err = m.call(&empty_state, args!(42)).unwrap_err();
    assert_eq!(err.kind(), ErrorKind::InvalidOperation);
    assert_eq!(
        err.detail(),
        Some("cannot call this macro. template state went away.")
    );
}
fn test_parse_self_debug_pubtypes() {
    let debug_info = read_section("debug_info");
    let debug_info = DebugInfo::new(&debug_info, LittleEndian);

    let debug_abbrev = read_section("debug_abbrev");
    let debug_abbrev = DebugAbbrev::new(&debug_abbrev, LittleEndian);

    let debug_pubtypes = read_section("debug_pubtypes");
    let debug_pubtypes = DebugPubTypes::new(&debug_pubtypes, LittleEndian);

    let mut units = HashMap::new();
    let mut abbrevs = HashMap::new();
    let mut pubtypes = debug_pubtypes.items();
    while let Some(entry) = pubtypes.next().expect("Should parse pubtype OK") {
        let unit_offset = entry.unit_header_offset();
        let unit = units.entry(unit_offset).or_insert_with(|| {
            debug_info
                .header_from_offset(unit_offset)
                .expect("Should parse unit header OK")
        });
        let abbrev_offset = unit.debug_abbrev_offset();
        let abbrevs = abbrevs.entry(abbrev_offset).or_insert_with(|| {
            debug_abbrev
                .abbreviations(abbrev_offset)
                .expect("Should parse abbreviations OK")
        });
        let mut cursor = unit
            .entries_at_offset(abbrevs, entry.die_offset())
            .expect("DIE offset should be valid");
        assert!(cursor.next_dfs().expect("Should parse DIE").is_some());
    }
}
fn test_value_by_index() {
    let val = Value::from(vec![1u32, 2, 3]);
    assert_eq!(val.get_item_by_index(0).unwrap(), Value::from(1));
    assert!(val.get_item_by_index(4).unwrap().is_undefined());
}
fn test_skip_iter_lt() {
    // Test iterators that skip single, leading or trailing-only digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_leading_digit_separator(true)
        .integer_trailing_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b"_.45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"4__5");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4_");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4_.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"45_5");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"_45__5");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".45_5");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b"_.45__5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"4__5_");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"4_5.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"4__5_.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"_45_");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"45.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"_45_.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"_4__5_");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"4_5.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"_4__5_.56");
}
fn test_float() {
    let thing = 25.6;
    let yaml = indoc! {"
        25.6
    "};
    test_serde(&thing, yaml);

    let thing = 25.;
    let yaml = indoc! {"
        25.0
    "};
    test_serde(&thing, yaml);

    let thing = f64::INFINITY;
    let yaml = indoc! {"
        .inf
    "};
    test_serde(&thing, yaml);

    let thing = f64::NEG_INFINITY;
    let yaml = indoc! {"
        -.inf
    "};
    test_serde(&thing, yaml);

    let float: f64 = serde_yaml::from_str(indoc! {"
        .nan
    "})
    .unwrap();
    assert!(float.is_nan());
}
fn u8_pow2_test() {
    let values: &[u8] =
        &[0, 1, 2, 3, 4, 5, 7, 8, 9, 15, 16, 17, 31, 32, 33, 63, 64, 65, 127, 128, 129, 255];
    for &i in values.iter() {
        assert_eq!(i, roundtrip(i));
    }
}
fn test_skip_iter_tc() {
    // Test iterators that skip multiple, trailing digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_trailing_digit_separator(true)
        .integer_consecutive_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"__45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"4__5");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"_45_5");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"__45__5");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".45_5");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b".45__5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"4__5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"4_5.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"4__5.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"__45");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"_45.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"__45.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"_4_5");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"__4__5");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"_4_5.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"__4__5.56");
}
