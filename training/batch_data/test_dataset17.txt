fn applies_custom_configuration() {
    let mut fs = MemoryFileSystem::default();
    let mut console = BufferConsole::default();

    let file_path = Path::new("file.js");
    fs.insert(file_path.into(), CUSTOM_CONFIGURATION_BEFORE.as_bytes());

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from(
            [
                ("format"),
                ("--line-width"),
                ("10"),
                ("--indent-style"),
                ("space"),
                ("--indent-size"),
                ("8"),
                ("--write"),
                file_path.as_os_str().to_str().unwrap(),
            ]
            .as_slice(),
        ),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");

    let mut file = fs
        .open(file_path)
        .expect("formatting target file was removed by the CLI");

    let mut content = String::new();
    file.read_to_string(&mut content)
        .expect("failed to read file from memory FS");

    assert_eq!(content, CUSTOM_CONFIGURATION_AFTER);

    drop(file);
    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "applies_custom_configuration",
        fs,
        console,
        result,
    ));
}
fn client_verifier_no_schemes() {
    for kt in ALL_KEY_TYPES.iter() {
        let client_verifier = MockClientVerifier {
            verified: ver_ok,
            subjects: get_client_root_store(*kt)
                .roots
                .iter()
                .map(|r| r.subject().clone())
                .collect(),
            mandatory: true,
            offered_schemes: Some(vec![]),
        };

        let server_config = server_config_with_verifier(*kt, client_verifier);
        let server_config = Arc::new(server_config);

        for version in rustls::ALL_VERSIONS {
            let client_config = make_client_config_with_versions_with_auth(*kt, &[version]);
            let (mut client, mut server) =
                make_pair_for_arc_configs(&Arc::new(client_config.clone()), &server_config);
            let err = do_handshake_until_error(&mut client, &mut server);
            assert_eq!(
                err,
                Err(ErrorFromPeer::Client(Error::InvalidMessage(
                    InvalidMessage::NoSignatureSchemes,
                ))),
            );
        }
    }
}
fn test_something() {
    let data = [];
    if data.len() < 50 || data.len() > 300 {
        return;
    }
    let (split_byte, data) = data.split_first().unwrap();
    let (kmer_byte, data) = data.split_first().unwrap();
    let (window_byte, data) = data.split_first().unwrap();
    let (match_score_byte, data) = data.split_first().unwrap();
    let (mismatch_score_byte, data) = data.split_first().unwrap();
    let (gap_open_byte, data) = data.split_first().unwrap();
    let (gap_extend_byte, data) = data.split_first().unwrap();
    let (xclip_prefix_byte, data) = data.split_first().unwrap();
    let (xclip_suffix_byte, data) = data.split_first().unwrap();
    let (yclip_prefix_byte, data) = data.split_first().unwrap();
    let (yclip_suffix_byte, data) = data.split_first().unwrap();
    let alphabets = b"ACGT";
    let v: Vec<_> = data
        .iter()
        .map(|i| alphabets[(*i as usize) % alphabets.len()])
        .collect();
    let kmer_len: usize = 5 + (*kmer_byte as usize) % 10;
    let window_size: usize = 5 + (*window_byte as usize) % 10;
    let split_pos: usize = min(data.len() - 1, max(*split_byte as usize, 1));
    let match_score = 1 + (*match_score_byte as i32) % 5;
    let mismatch_score = -((*mismatch_score_byte as i32) % 10);
    let gap_open = -((*gap_open_byte as i32) % 20);
    let gap_extend = -((*gap_extend_byte as i32) % 10);
    let (x, y) = v.split_at(split_pos);
    println!(
        "x: {}, y: {}, k: {}, w: {}, scoring ({}, {}, {}, {})",
        String::from_utf8(x.to_vec()).unwrap(),
        String::from_utf8(y.to_vec()).unwrap(),
        kmer_len,
        window_size,
        gap_open,
        gap_extend,
        match_score,
        mismatch_score
    );
    let base_score = Scoring::from_scores(gap_open, gap_extend, match_score, mismatch_score);
    {
        println!(
            "Clip scores ({}, {}, {}, {})",
            xclip_prefix_byte, xclip_suffix_byte, yclip_prefix_byte, yclip_suffix_byte
        );
        let scoring = Scoring {
            xclip_prefix: -(*xclip_prefix_byte as i32),
            xclip_suffix: -(*xclip_suffix_byte as i32),
            yclip_prefix: -(*yclip_prefix_byte as i32),
            yclip_suffix: -(*yclip_suffix_byte as i32),
            ..base_score.clone()
        };
        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);
        let b_alignment = b_aligner.custom(x, y);
        assert!(validate_alignment_score(&b_alignment, x, y, &scoring));
        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());
        let f_alignment = f_aligner.custom(x, y);
        assert!(validate_alignment_score(&f_alignment, x, y, &scoring));
        let band_all_alignment = b_aligner.custom_with_matches(x, y, &Vec::new());
        assert_eq!(band_all_alignment.score, f_alignment.score);
    }
    {
        let scoring = Scoring {
            xclip_prefix: 0,
            xclip_suffix: 0,
            yclip_suffix: 0,
            ..base_score.clone()
        };
        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);
        let b_alignment = b_aligner.custom(x, y);
        assert_eq!(b_alignment.ystart, 0);
        assert!(validate_alignment_score(&b_alignment, x, y, &scoring));
        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());
        let f_alignment = f_aligner.custom(x, y);
        assert_eq!(f_alignment.ystart, 0);
        assert!(validate_alignment_score(&f_alignment, x, y, &scoring));
        let band_all_alignment = b_aligner.custom_with_matches(x, y, &Vec::new());
        assert_eq!(band_all_alignment.score, f_alignment.score);
    }
    {
        let scoring = Scoring {
            xclip_prefix: 0,
            xclip_suffix: 0,
            yclip_prefix: 0,
            ..base_score.clone()
        };
        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);
        let b_alignment = b_aligner.custom(x, y);
        assert_eq!(b_alignment.yend, b_alignment.ylen);
        assert!(validate_alignment_score(&b_alignment, x, y, &scoring));
        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());
        let f_alignment = f_aligner.custom(x, y);
        assert_eq!(f_alignment.yend, f_alignment.ylen);
        assert!(validate_alignment_score(&f_alignment, x, y, &scoring));
        let band_all_alignment = b_aligner.custom_with_matches(x, y, &Vec::new());
        assert_eq!(band_all_alignment.score, f_alignment.score);
    }
    {
        let scoring = Scoring {
            xclip_suffix: 0,
            yclip_prefix: 0,
            yclip_suffix: 0,
            ..base_score.clone()
        };
        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);
        let b_alignment = b_aligner.custom(x, y);
        assert_eq!(b_alignment.xstart, 0);
        assert!(validate_alignment_score(&b_alignment, x, y, &scoring));
        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());
        let f_alignment = f_aligner.custom(x, y);
        assert_eq!(f_alignment.xstart, 0);
        assert!(validate_alignment_score(&f_alignment, x, y, &scoring));
        let band_all_alignment = b_aligner.custom_with_matches(x, y, &Vec::new());
        assert_eq!(band_all_alignment.score, f_alignment.score);
    }
    {
        let scoring = Scoring {
            xclip_prefix: 0,
            yclip_prefix: 0,
            yclip_suffix: 0,
            ..base_score.clone()
        };
        let mut b_aligner = banded::Aligner::with_scoring(scoring.clone(), kmer_len, window_size);
        let b_alignment = b_aligner.custom(x, y);
        assert_eq!(b_alignment.xend, b_alignment.xlen);
        assert!(validate_alignment_score(&b_alignment, x, y, &scoring));
        let mut f_aligner = pairwise::Aligner::with_scoring(scoring.clone());
        let f_alignment = f_aligner.custom(x, y);
        assert_eq!(f_alignment.xend, f_alignment.xlen);
        assert!(validate_alignment_score(&f_alignment, x, y, &scoring));
        let band_all_alignment = b_aligner.custom_with_matches(x, y, &Vec::new());
        assert_eq!(band_all_alignment.score, f_alignment.score);
    }
    {
        let mut aligner = banded::Aligner::with_scoring(base_score.clone(), kmer_len, window_size);
        let alignment = aligner.local(x, y);
        assert!(alignment.score >= 0);
        assert!(validate_alignment_score(&alignment, x, y, &base_score));
        let alignment = aligner.semiglobal(x, y);
        assert_eq!(alignment.xstart, 0);
        assert_eq!(alignment.xend, alignment.xlen);
        assert!(validate_alignment_score(&alignment, x, y, &base_score));
        let alignment = aligner.global(x, y);
        assert_eq!(alignment.xstart, 0);
        assert_eq!(alignment.xend, alignment.xlen);
        assert_eq!(alignment.ystart, 0);
        assert_eq!(alignment.yend, alignment.ylen);
        assert!(validate_alignment_score(&alignment, x, y, &base_score));
    }
    {
        let mut aligner = pairwise::Aligner::with_scoring(base_score.clone());
        let alignment = aligner.local(x, y);
        assert!(alignment.score >= 0);
        assert!(validate_alignment_score(&alignment, x, y, &base_score));
        let alignment = aligner.semiglobal(x, y);
        assert_eq!(alignment.xstart, 0);
        assert_eq!(alignment.xend, alignment.xlen);
        assert!(validate_alignment_score(&alignment, x, y, &base_score));
        let alignment = aligner.global(x, y);
        assert_eq!(alignment.xstart, 0);
        assert_eq!(alignment.xend, alignment.xlen);
        assert_eq!(alignment.ystart, 0);
        assert_eq!(alignment.yend, alignment.ylen);
        assert!(validate_alignment_score(&alignment, x, y, &base_score));
    }
}
fn ok_read_only() {
    let mut fs = MemoryFileSystem::new_read_only();
    let mut console = BufferConsole::default();

    let file_path = Path::new("check.js");
    fs.insert(file_path.into(), FORMATTED.as_bytes());

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from([("check"), file_path.as_os_str().to_str().unwrap()].as_slice()),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");
}
fn bad_bmps() {
    let path: PathBuf = BASE_PATH
        .iter()
        .collect::<PathBuf>()
        .join(IMAGE_DIR)
        .join("bmp/images")
        .join("*.bad_bmp");

    let pattern = &*format!("{}", path.display());
    for path in glob::glob(pattern).unwrap().filter_map(Result::ok) {
        // Manually reading the file so we can use load() instead of open()
        // We have to use load() so we can override the format
        let im_file = BufReader::new(File::open(path).unwrap());
        let im = image::load(im_file, image::ImageFormat::Bmp);
        assert!(im.is_err());
    }
}
fn server_stream_handshake_error() {
    let (client_config, server_config) = make_disjoint_suite_configs();
    let (mut client, mut server) = make_pair_for_configs(client_config, server_config);

    client
        .writer()
        .write_all(b"world")
        .unwrap();

    {
        let mut pipe = OtherSession::new_fails(&mut client);
        let mut server_stream = Stream::new(&mut server, &mut pipe);
        let mut bytes = [0u8; 5];
        let rc = server_stream.read(&mut bytes);
        assert!(rc.is_err());
        assert_eq!(
            format!("{:?}", rc),
            "Err(Custom { kind: InvalidData, error: PeerIncompatible(NoCipherSuitesInCommon) })"
        );
    }
}
fn client_can_override_certificate_verification_and_offer_no_signature_schemes() {
    for kt in ALL_KEY_TYPES.iter() {
        let verifier = Arc::new(MockServerVerifier::offers_no_signature_schemes());

        let server_config = Arc::new(make_server_config(*kt));

        for version in rustls::ALL_VERSIONS {
            let mut client_config = make_client_config_with_versions(*kt, &[version]);
            client_config
                .dangerous()
                .set_certificate_verifier(verifier.clone());

            let (mut client, mut server) =
                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);
            let errs = do_handshake_until_both_error(&mut client, &mut server);
            assert_eq!(
                errs,
                Err(vec![
                    ErrorFromPeer::Server(Error::PeerIncompatible(
                        rustls::PeerIncompatible::NoSignatureSchemesInCommon
                    )),
                    ErrorFromPeer::Client(Error::AlertReceived(AlertDescription::HandshakeFailure)),
                ])
            );
        }
    }
}
fn does_include_file_with_different_rules() {
    let mut console = BufferConsole::default();
    let mut fs = MemoryFileSystem::default();
    let file_path = Path::new("biome.json");
    fs.insert(
        file_path.into(),
        r#"{
  "overrides": [{ "include": ["special/**"], "linter": { "rules": {
    "suspicious": { "noDebugger": "off" }
  } } }]
}

"#
        .as_bytes(),
    );

    let test = Path::new("test.js");
    fs.insert(test.into(), DEBUGGER_BEFORE.as_bytes());

    let test2 = Path::new("special/test2.js");
    fs.insert(test2.into(), DEBUGGER_BEFORE.as_bytes());

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from(
            [
                ("lint"),
                ("--apply-unsafe"),
                test.as_os_str().to_str().unwrap(),
                test2.as_os_str().to_str().unwrap(),
            ]
            .as_slice(),
        ),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");

    assert_file_contents(&fs, test2, DEBUGGER_BEFORE);
    assert_file_contents(&fs, test, DEBUGGER_AFTER);

    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "does_include_file_with_different_rules",
        fs,
        console,
        result,
    ));
}
fn does_handle_included_file() {
    let mut console = BufferConsole::default();
    let mut fs = MemoryFileSystem::default();
    let file_path = Path::new("biome.json");
    fs.insert(
        file_path.into(),
        r#"{
  "files": {
    "ignore": ["test.js", "special/**"]
  },
  "overrides": [{ "include": ["special/**"] }]
}

"#
        .as_bytes(),
    );

    let test = Path::new("test.js");
    fs.insert(test.into(), UNORGANIZED.as_bytes());

    let test2 = Path::new("special/test2.js");
    fs.insert(test2.into(), UNORGANIZED.as_bytes());

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from(
            [
                ("check"),
                ("--apply"),
                "--formatter-enabled=false",
                "--linter-enabled=false",
                test.as_os_str().to_str().unwrap(),
                test2.as_os_str().to_str().unwrap(),
            ]
            .as_slice(),
        ),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");

    assert_file_contents(&fs, test2, ORGANIZED);
    assert_file_contents(&fs, test, UNORGANIZED);

    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "does_handle_included_file",
        fs,
        console,
        result,
    ));
}
fn should_disable_a_rule_group() {
    let mut fs = MemoryFileSystem::default();
    let mut console = BufferConsole::default();

    let file_path = Path::new("fix.js");
    fs.insert(file_path.into(), FIX_BEFORE.as_bytes());

    let config_path = Path::new("biome.json");
    fs.insert(
        config_path.into(),
        CONFIG_LINTER_SUPPRESSED_GROUP.as_bytes(),
    );

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from(
            [
                ("check"),
                ("--apply"),
                file_path.as_os_str().to_str().unwrap(),
            ]
            .as_slice(),
        ),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");

    let mut buffer = String::new();
    fs.open(file_path)
        .unwrap()
        .read_to_string(&mut buffer)
        .unwrap();

    assert_eq!(buffer, "1 >= -0;\n");

    assert_cli_snapshot(SnapshotPayload::new(
        module_path!(),
        "should_disable_a_rule_group",
        fs,
        console,
        result,
    ));
}
fn check_token_integration() {
    assert_eq!(
        token(
            &[
                Token::KeySelector("a"),
                Token::GroupSeparator,
                Token::KeySelector("b")
            ],
            &json!({ "a": 1, "b": 2 })
        ),
        Ok(json!([1, 2]))
    );
}
fn ok() {
    let mut fs = MemoryFileSystem::default();
    let mut console = BufferConsole::default();

    let file_path = Path::new("check.js");
    fs.insert(file_path.into(), FORMATTED.as_bytes());

    let result = run_cli(
        DynRef::Borrowed(&mut fs),
        &mut console,
        Args::from([("check"), file_path.as_os_str().to_str().unwrap()].as_slice()),
    );

    assert!(result.is_ok(), "run_cli returned {result:?}");
}
fn test_something() {
    let data = [];
    let mut set = HashSet::new();
    let mut nat = NatSet::new();
    for action in actions {
        match action {
            Action::Insert(value) => {
                let len = nat.len() + if nat.contains(&value) { 0 } else { 1 };
                nat.insert(value);
                set.insert(value);
                assert_eq!(len, set.len());
            }
            Action::Remove(value) => {
                let len = nat.len() - if nat.contains(&value) { 1 } else { 0 };
                nat.remove(&value);
                set.remove(&value);
                assert_eq!(len, set.len());
            }
        }
        assert_eq!(nat.len(), set.len());
        assert_eq!(HashSet::from(nat.clone()), set);
    }
}
fn b_test() {
    assert_eq!(b(1e-45_f32), (1, -149));
    assert_eq!(b(5e-324_f64), (1, -1074));
    assert_eq!(b(1e-323_f64), (2, -1074));
    assert_eq!(b(2e-323_f64), (4, -1074));
    assert_eq!(b(3e-323_f64), (6, -1074));
    assert_eq!(b(4e-323_f64), (8, -1074));
    assert_eq!(b(5e-323_f64), (10, -1074));
    assert_eq!(b(6e-323_f64), (12, -1074));
    assert_eq!(b(7e-323_f64), (14, -1074));
    assert_eq!(b(8e-323_f64), (16, -1074));
    assert_eq!(b(9e-323_f64), (18, -1074));
    assert_eq!(b(1_f32), (8388608, -23));
    assert_eq!(b(1_f64), (4503599627370496, -52));
    assert_eq!(b(1e38_f32), (9860761, 103));
    assert_eq!(b(1e308_f64), (5010420900022432, 971));
}
fn compute_error_scaled64_test() {
    // These are the same examples above, just using pre-computed scaled values.

    // These test near-halfway cases for double-precision floats.
    assert_eq!(
        compute_error_scaled64(0, 4611686018427387904, 10),
        (1065 + f64::INVALID_FP, 9223372036854775808)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427388416, 10),
        (1065 + f64::INVALID_FP, 9223372036854776832)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427388928, 10),
        (1065 + f64::INVALID_FP, 9223372036854777856)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427389440, 10),
        (1065 + f64::INVALID_FP, 9223372036854778880)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427389952, 10),
        (1065 + f64::INVALID_FP, 9223372036854779904)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427387904, 9),
        (1066 + f64::INVALID_FP, 9223372036854775808)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427388416, 9),
        (1066 + f64::INVALID_FP, 9223372036854776832)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427388928, 9),
        (1066 + f64::INVALID_FP, 9223372036854777856)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427389440, 9),
        (1066 + f64::INVALID_FP, 9223372036854778880)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427389952, 9),
        (1066 + f64::INVALID_FP, 9223372036854779904)
    );

    // Test a much closer set of examples.
    assert_eq!(
        compute_error_scaled64(0, 9223372036854774784, 11),
        (1064 + f64::INVALID_FP, 18446744073709549568)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427388415, 0),
        (1075 + f64::INVALID_FP, 9223372036854776830)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427388416, 0),
        (1075 + f64::INVALID_FP, 9223372036854776832)
    );
    assert_eq!(
        compute_error_scaled64(0, 4611686018427388416, 0),
        (1075 + f64::INVALID_FP, 9223372036854776832)
    );
    assert_eq!(
        compute_error_scaled64(-42, 6510716281765748947, 10),
        (925 + f64::INVALID_FP, 13021432563531497894)
    );
    assert_eq!(
        compute_error_scaled64(-43, 6510716281765749303, 7),
        (925 + f64::INVALID_FP, 13021432563531498606)
    );
    assert_eq!(
        compute_error_scaled64(-42, 6510716281765749660, 10),
        (925 + f64::INVALID_FP, 13021432563531499320)
    );

    // These are examples of the above tests, with
    // digits from the exponent shifted to the mantissa.
    assert_eq!(
        compute_error_scaled64(-3, 9223372036854775808, 1),
        (1065 + f64::INVALID_FP, 9223372036854775808)
    );
    assert_eq!(
        compute_error_scaled64(-3, 9223372036854776832, 1),
        (1065 + f64::INVALID_FP, 9223372036854776832)
    );
    assert_eq!(
        compute_error_scaled64(-3, 9223372036854777856, 1),
        (1065 + f64::INVALID_FP, 9223372036854777856)
    );
    assert_eq!(
        compute_error_scaled64(-3, 9223372036854778880, 1),
        (1065 + f64::INVALID_FP, 9223372036854778880)
    );
    assert_eq!(
        compute_error_scaled64(-3, 9223372036854779904, 1),
        (1065 + f64::INVALID_FP, 9223372036854779904)
    );

    // Test from errors in atof.
    assert_eq!(
        compute_error_scaled64(-18, 9223373686122217470, 4),
        (1012 + f64::INVALID_FP, 9223373686122217470)
    );

    // Check edge-cases from previous errors.
    assert_eq!(
        compute_error_scaled64(-342, 9223372036854775804, 2),
        (-64 + f64::INVALID_FP, 18446744073709551608)
    );
}
