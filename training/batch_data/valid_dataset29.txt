fn test_i128_min() {
    assert_eq!(
        std::i128::MIN,
        from_str(&to_string(&std::i128::MIN).unwrap()).unwrap()
    );
}
fn test_unclosed() {
    assert_eq!(
        from_str::<String>(
            "/*
        /* quite * some * nesting * going * on * /* here /* (yeah, maybe a bit too much) */ */ */
    */
    // The actual value comes.. /*
    // very soon, these are just checks that */
    // multi-line comments don't trigger in line comments /*
/* Unfortunately, this comment won't get closed :(
\"THE VALUE (which is invalid)\"
"
        ),
        Err(RonErr {
            code: Error::UnclosedBlockComment,
            position: Position { col: 1, line: 9 }
        })
    );
}
fn bool() {
    assert_eq!("true".parse(), Ok(Value::Bool(true)));
    assert_eq!("false".parse(), Ok(Value::Bool(false)));
}
fn unit() {
    use ron::error::{Error, Position, SpannedError};

    assert_eq!("()".parse(), Ok(Value::Unit));
    assert_eq!("Foo".parse(), Ok(Value::Unit));

    assert_eq!(
        "".parse::<Value>(),
        Err(SpannedError {
            code: Error::Eof,
            position: Position { col: 1, line: 1 }
        })
    );
}
fn scalar_mul_test() {
    assert_eq!(bigint::scalar_mul(5, 5, 0), (25, 0));
    assert_eq!(bigint::scalar_mul(5, 5, 1), (26, 0));
    assert_eq!(bigint::scalar_mul(LIMB_MAX, 2, 0), (LIMB_MAX - 1, 1));
}
fn test_something() {
    let data = [];
    if let Ok(s) = str::from_utf8(data) {
        if let Ok(d) = parse_http_date(s) {
            let o = fmt_http_date(d);
            assert!(!o.is_empty());
            assert_eq!(parse_http_date(&o).expect("formatting to round trip"), d);
        }
    }
}
fn test_i128_max() {
    assert_eq!(
        std::i128::MAX,
        from_str(&to_string(&std::i128::MAX).unwrap()).unwrap()
    );
}
fn normal_cases() {
    assert_eq!(libm::powd(2.0, 20.0), (1 << 20) as f64);
    assert_eq!(libm::powd(-1.0, 9.0), -1.0);
    assert!(libm::powd(-1.0, 2.2).is_nan());
    assert!(libm::powd(-1.0, -1.14).is_nan());
}
