fn builder_test() {
    let mut builder = OptionsBuilder::default();

    builder = builder.lossy(true);
    builder = builder.exponent(b'^');
    builder = builder.decimal_point(b',');
    builder = builder.nan_string(Some(b"nan"));
    builder = builder.inf_string(Some(b"Infinity"));
    builder = builder.infinity_string(Some(b"Infiniiiiiity"));

    assert_eq!(builder.get_lossy(), true);
    assert_eq!(builder.get_exponent(), b'^');
    assert_eq!(builder.get_decimal_point(), b',');
    assert_eq!(builder.get_nan_string(), Some("nan".as_bytes()));
    assert_eq!(builder.get_inf_string(), Some("Infinity".as_bytes()));
    assert_eq!(builder.get_infinity_string(), Some("Infiniiiiiity".as_bytes()));

    assert!(builder.is_valid());
    assert_eq!(builder.build(), Ok(unsafe { builder.build_unchecked() }));
}
fn parse_color() {
  assert_eq!(
    hex_color("#2F14DF"),
    Ok((
      "",
      Color {
        red: 47,
        green: 20,
        blue: 223,
      }
    ))
  );
}
fn test_date_for_invalid_file() {
    let result = new_ucmd!().arg("--file").arg("invalid_file").fails();
    result.no_stdout();
    assert_eq!(
        result.stderr_str().trim(),
        "date: invalid_file: No such file or directory",
    );
}
fn wasmer_init_works_2() {
    let tempdir = tempfile::tempdir().unwrap();
    let path = tempdir.path();
    let path = path.join("testfirstproject");
    std::fs::create_dir_all(&path).unwrap();
    std::fs::write(
        path.join("Cargo.toml"),
        include_bytes!("./fixtures/init2.toml"),
    )
    .unwrap();
    std::fs::create_dir_all(path.join("src")).unwrap();
    std::fs::write(path.join("src").join("main.rs"), b"fn main() { }").unwrap();

    Command::new(get_wasmer_path())
        .arg("init")
        .arg("--namespace=ciuser")
        .current_dir(&path)
        .assert()
        .success();

    assert_eq!(
        std::fs::read_to_string(path.join("Cargo.toml")).unwrap(),
        include_str!("./fixtures/init2.toml")
    );
    assert_eq!(
        std::fs::read_to_string(path.join("wasmer.toml")).unwrap(),
        include_str!("./fixtures/init4.toml")
    );
}
fn incomplete() {
    assert!("/*/".parse::<TokenStream>().is_err());
}
fn factor_test() {
  assert_eq!(
    factor("  3  ").map(|(i, x)| (i, format!("{:?}", x))),
    Ok(("", String::from("3")))
  );
}
fn read_lines_test() {
  let res = Ok(("", vec!["Duck", "Dog", "Cow"]));

  assert_eq!(read_lines("Duck\nDog\nCow\n"), res);
  assert_eq!(read_lines("Duck\nDog\nCow"), res);
}
fn test_uname_kernel() {
    let (_, mut ucmd) = at_and_ucmd!();

    #[cfg(target_os = "linux")]
    {
        let result = ucmd.arg("-o").succeeds();
        assert!(result.stdout_str().to_lowercase().contains("linux"));
    }

    #[cfg(not(target_os = "linux"))]
    ucmd.arg("-o").succeeds();
}
fn sanity_test_artifact_deserialize() {
    let engine = Engine::headless();
    let result = unsafe { Module::deserialize(&engine, &[]) };
    assert!(result.is_err());
}
fn compute_error_scaled32_test() {
    // These are the same examples above, just using pre-computed scaled values.

    // These test near-halfway cases for single-precision floats.
    assert_eq!(
        compute_error_scaled32(0, 4611686018427387904, 39),
        (111 + INVALID_FP, 9223372036854775808)
    );
    assert_eq!(
        compute_error_scaled32(0, 4611686293305294848, 39),
        (111 + INVALID_FP, 9223372586610589696)
    );
    assert_eq!(
        compute_error_scaled32(0, 4611686568183201792, 39),
        (111 + INVALID_FP, 9223373136366403584)
    );
    assert_eq!(
        compute_error_scaled32(0, 4611686843061108736, 39),
        (111 + INVALID_FP, 9223373686122217472)
    );
    assert_eq!(
        compute_error_scaled32(0, 4611687117939015680, 39),
        (111 + INVALID_FP, 9223374235878031360)
    );

    assert_eq!(
        compute_error_scaled32(-10, 9223372036854775808, 6),
        (111 + INVALID_FP, 9223372036854775808)
    );
    assert_eq!(
        compute_error_scaled32(-10, 9223372586610589696, 6),
        (111 + INVALID_FP, 9223372586610589696)
    );
    assert_eq!(
        compute_error_scaled32(-10, 9223373136366403584, 6),
        (111 + INVALID_FP, 9223373136366403584)
    );
    assert_eq!(
        compute_error_scaled32(-10, 9223373686122217472, 6),
        (111 + INVALID_FP, 9223373686122217472)
    );
    assert_eq!(
        compute_error_scaled32(-10, 9223374235878031360, 6),
        (111 + INVALID_FP, 9223374235878031360)
    );
}
fn test_invalid_format_string() {
    let result = new_ucmd!().arg("+%!").fails();
    result.no_stdout();
    assert!(result.stderr_str().starts_with("date: invalid format "));
}
fn wasmer_init_works_1() {
    let wasmer_dir = TempDir::new().unwrap();
    let tempdir = tempfile::tempdir().unwrap();
    let path = tempdir.path().join("testfirstproject");
    std::fs::create_dir_all(&path).unwrap();

    Command::new(get_wasmer_path())
        .arg("init")
        .arg("--namespace=ciuser")
        .current_dir(&path)
        .env("WASMER_DIR", wasmer_dir.path())
        .assert()
        .success();

    assert_eq!(
        std::fs::read_to_string(path.join("wasmer.toml")).unwrap(),
        include_str!("./fixtures/init1.toml"),
    );
}
fn test_cp_arg_no_clobber_twice() {
    let scene = TestScenario::new(util_name!());
    let at = &scene.fixtures;

    at.touch("source.txt");
    scene
        .ucmd()
        .arg("--no-clobber")
        .arg("source.txt")
        .arg("dest.txt")
        .succeeds()
        .no_stderr();

    assert_eq!(at.read("source.txt"), "");

    at.append("source.txt", "some-content");
    scene
        .ucmd()
        .arg("--no-clobber")
        .arg("source.txt")
        .arg("dest.txt")
        .fails();

    assert_eq!(at.read("source.txt"), "some-content");
    // Should be empty as the "no-clobber" should keep
    // the previous version
    assert_eq!(at.read("dest.txt"), "");
}
fn type_change() {
    let (dir, mut cmd) = at_and_ucmd!();

    dir.touch("a.tmp");
    let a_context = get_file_context(dir.plus("a.tmp")).unwrap();
    let new_a_context = if let Some(a_context) = a_context {
        let mut components: Vec<_> = a_context.split(':').collect();
        components[2] = "etc_t";
        components.join(":")
    } else {
        set_file_context(dir.plus("a.tmp"), "unconfined_u:object_r:user_tmp_t:s0").unwrap();
        String::from("unconfined_u:object_r:etc_t:s0")
    };

    cmd.args(&["--verbose", "--type=etc_t"])
        .arg(dir.plus("a.tmp"))
        .succeeds();
    assert_eq!(
        get_file_context(dir.plus("a.tmp")).unwrap(),
        Some(new_a_context)
    );
}
fn user_role_range_type() {
    let (dir, mut cmd) = at_and_ucmd!();

    dir.touch("a.tmp");
    let a_context = get_file_context(dir.plus("a.tmp")).unwrap();
    if a_context.is_none() {
        set_file_context(dir.plus("a.tmp"), "unconfined_u:object_r:user_tmp_t:s0").unwrap();
    }

    cmd.args(&[
        "--verbose",
        "--user=guest_u",
        "--role=object_r",
        "--type=etc_t",
        "--range=s0:c42",
    ])
    .arg(dir.plus("a.tmp"))
    .succeeds();

    assert_eq!(
        get_file_context(dir.plus("a.tmp")).unwrap().as_deref(),
        Some("guest_u:object_r:etc_t:s0:c42")
    );
}
