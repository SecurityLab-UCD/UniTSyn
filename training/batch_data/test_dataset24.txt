fn unnamed_field_struct() {
    #[derive(CacheKey, Hash)]
    struct UnnamedFieldsStruct(String, String);

    let mut key = CacheKeyHasher::new();

    let unnamed_fields = UnnamedFieldsStruct("Hello".into(), "World".into());

    unnamed_fields.cache_key(&mut key);

    let mut hash = CacheKeyHasher::new();
    unnamed_fields.hash(&mut hash);

    assert_eq!(hash.finish(), key.finish());
}
fn parse_if() {
    let ast = parse("{% if item or admin %}A {%- elif 1 > 2 %}B{% else -%} C{%- endif %}").unwrap();
    let end_ws = WS { left: true, ..Default::default() };
    let else_ws = WS { right: true, ..Default::default() };

    assert_eq!(
        ast[0],
        Node::If(
            If {
                conditions: vec![
                    (
                        WS::default(),
                        Expr::new(ExprVal::Logic(LogicExpr {
                            lhs: Box::new(Expr::new(ExprVal::Ident("item".to_string()))),
                            operator: LogicOperator::Or,
                            rhs: Box::new(Expr::new(ExprVal::Ident("admin".to_string()))),
                        })),
                        vec![Node::Text("A ".to_string())],
                    ),
                    (
                        end_ws,
                        Expr::new(ExprVal::Logic(LogicExpr {
                            lhs: Box::new(Expr::new(ExprVal::Int(1))),
                            operator: LogicOperator::Gt,
                            rhs: Box::new(Expr::new(ExprVal::Int(2))),
                        })),
                        vec![Node::Text("B".to_string())],
                    ),
                ],
                otherwise: Some((else_ws, vec![Node::Text(" C".to_string())])),
            },
            end_ws,
        )
    );
}
fn errors_with_inheritance_in_included_template() {
    let mut tera = Tera::default();
    tera.add_raw_templates(vec![
        ("base", "Base - {% include \"child\" %}"),
        ("parent", "{% block title %}Parent{% endblock %}"),
        ("child", "{% extends \"parent\" %}{% block title %}{{ super() }} - Child{% endblock %}"),
    ])
    .unwrap();

    let result = tera.render("base", &Context::new());

    assert_eq!(
        result.unwrap_err().source().unwrap().to_string(),
        "Inheritance in included templates is currently not supported: extended `parent`"
    );
}
fn parent_macro_cant_access_child_macro_context() {
    let mut tera = Tera::default();
    tera.add_raw_templates(vec![
        ("parent", "{% import \"macros\" as macros %}{{ macros::test_global() }}"),
        ("macros", r#"{% import "moremacros" as moremacros %}{% macro test_global() %}{% set_global value1 = "ACAB" %}{{ moremacros::another_one() }}{{ value1 }}-{{ value2 | default(value="ACAB") }}{% endmacro test_global %}"#),
        ("moremacros", r#"{% macro another_one() %}{% set_global value2 = "1312" %}{% endmacro another_one %}"#)
    ]).unwrap();

    let result = tera.render("parent", &Context::new());
    assert_eq!(result.unwrap(), "ACAB-ACAB".to_string());
}
fn do_nothing_if_unneeded() {
    let ast = vec![Node::Text("hey ".to_string())];
    assert_eq!(remove_whitespace(ast.clone(), None), ast);
}
fn parse_key_value_forloop() {
    let ast = parse("{% for key, item in get_map() %}A{%- endfor %}").unwrap();
    let start_ws = WS::default();
    let end_ws = WS { left: true, ..Default::default() };

    assert_eq!(
        ast[0],
        Node::Forloop(
            start_ws,
            Forloop {
                key: Some("key".to_string()),
                value: "item".to_string(),
                container: Expr::new(ExprVal::FunctionCall(FunctionCall {
                    name: "get_map".to_string(),
                    args: HashMap::new(),
                },)),
                body: vec![Node::Text("A".to_string())],
                empty_body: None,
            },
            end_ws,
        )
    );
}
fn parse_string_concat_multiple() {
    let ast = parse("{{ `hello` ~ ident ~ 'ho' }}").unwrap();
    assert_eq!(
        ast[0],
        Node::VariableBlock(
            WS::default(),
            Expr::new(ExprVal::StringConcat(StringConcat {
                values: vec![
                    ExprVal::String("hello".to_string()),
                    ExprVal::Ident("ident".to_string()),
                    ExprVal::String("ho".to_string()),
                ]
            }))
        ),
    );
}
fn can_load_parent_macro_in_child() {
    let mut tera = Tera::default();
    tera.add_raw_templates(vec![
        ("macros", "{% macro hello()%}{{ 1 }}{% endmacro hello %}"),
        ("parent", "{% import \"macros\" as macros %}{{ macros::hello() }}{% block bob %}{% endblock bob %}"),
        ("child", "{% extends \"parent\" %}{% block bob %}{{ super() }}Hey{% endblock bob %}"),
    ]).unwrap();

    let result = tera.render("child", &Context::new());

    assert_eq!(result.unwrap(), "1Hey".to_string());
}
fn can_load_macro_in_parent_with_grandparent() {
    let mut tera = Tera::default();
    tera.add_raw_templates(vec![
        ("macros", "{% macro hello()%}{{ 1 }}{% endmacro hello %}"),
        ("grandparent", "{% block bob %}{% endblock bob %}"),
        ("parent", "{% extends \"grandparent\" %}{% import \"macros\" as macros %}{% block bob %}{{ macros::hello() }} - Hey{% endblock bob %}"),
        ("child", "{% extends \"parent\" %}{% block bob %}{{ super() }}{% endblock bob %}"),
    ]).unwrap();

    let result = tera.render("child", &Context::new());

    assert_eq!(result.unwrap(), "1 - Hey".to_string());
}
fn test_error_render_field_unknown_in_forloop() {
    let result = render_tpl("field_unknown_forloop.html");

    assert!(result.is_err());
    let err = result.unwrap_err();
    assert_eq!(
        err.source().unwrap().to_string(),
        "Variable `r.random` not found in context while rendering \'field_unknown_forloop.html\'"
    );
}
fn error_gives_source_on_tests() {
    let mut tera = Tera::default();
    tera.add_raw_templates(vec![("tpl", "{% if a is undefined(1) %}-{% endif %}")]).unwrap();
    let result = tera.render("tpl", &Context::new());
    println!("{:?}", result);
    let err = result.unwrap_err();

    let source = err.source().unwrap();
    assert_eq!(source.to_string(), "Test call \'undefined\' failed");
    let source2 = source.source().unwrap();

    assert_eq!(
        source2.to_string(),
        "Tester `undefined` was called with some args but this test doesn\'t take args"
    );
}
fn template_cant_access_macros_context() {
    let mut tera = Tera::default();
    tera.add_raw_templates(vec![
        ("parent", r#"{% import "macros" as macros %}{{ macros::empty() }}{{ quote | default(value="I'd rather have roses on my table than diamonds on my neck.") }}"#),
        ("macros", r#"{% macro empty() %}{% set_global quote = "This should not reachable from the calling template!" %}{% endmacro empty %}"#)
    ]).unwrap();

    let result = tera.render("parent", &Context::new());
    assert_eq!(result.unwrap(), "I'd rather have roses on my table than diamonds on my neck.");
}
fn error_when_using_variable_set_in_included_templates_outside() {
    let mut tera = Tera::default();
    tera.add_raw_templates(vec![
        ("included", r#"{{a}}{% set b = "hi" %}-{{b}}"#),
        ("base", r#"{{a}}{% include "included" %}{{b}}"#),
    ])
    .unwrap();
    let mut context = Context::new();
    context.insert("a", &10);
    let result = tera.render("base", &context);

    assert_eq!(
        result.unwrap_err().source().unwrap().to_string(),
        "Variable `b` not found in context while rendering \'base\'"
    );
}
fn error_location_in_parent_block() {
    let mut tera = Tera::default();
    tera.add_raw_templates(vec![
        ("parent", "Hello {{ greeting }} {% block bob %}{{ 1 + true }}{% endblock bob %}"),
        ("child", "{% extends \"parent\" %}{% block bob %}{{ super() }}Hey{% endblock bob %}"),
    ])
    .unwrap();

    let result = tera.render("child", &Context::new());

    assert_eq!(
        result.unwrap_err().to_string(),
        "Failed to render \'child\' (error happened in 'parent')."
    );
}
fn error_location_inside_macro() {
    let mut tera = Tera::default();
    tera.add_raw_templates(vec![
        ("macros", "{% macro hello()%}{{ 1 + true }}{% endmacro hello %}"),
        ("tpl", "{% import \"macros\" as macros %}{{ macros::hello() }}"),
    ])
    .unwrap();

    let result = tera.render("tpl", &Context::new());

    assert_eq!(
        result.unwrap_err().to_string(),
        "Failed to render \'tpl\': error while rendering macro `macros::hello`"
    );
}
