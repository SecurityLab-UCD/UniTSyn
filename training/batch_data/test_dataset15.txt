fn server_stateless_reset() {
    let _guard = subscribe();
    let mut reset_key = vec![0; 64];
    let mut rng = rand::thread_rng();
    rng.fill_bytes(&mut reset_key);
    let reset_key = hmac::Key::new(hmac::HMAC_SHA256, &reset_key);

    let endpoint_config = Arc::new(EndpointConfig::new(Arc::new(reset_key)));

    let mut pair = Pair::new(endpoint_config.clone(), server_config());
    let (client_ch, _) = pair.connect();
    pair.drive(); // Flush any post-handshake frames
    pair.server.endpoint = Endpoint::new(endpoint_config, Some(Arc::new(server_config())), true);
    // Force the server to generate the smallest possible stateless reset
    pair.client.connections.get_mut(&client_ch).unwrap().ping();
    info!("resetting");
    pair.drive();
    assert_matches!(
        pair.client_conn_mut(client_ch).poll(),
        Some(Event::ConnectionLost {
            reason: ConnectionError::Reset
        })
    );
}
fn options_tests() {
    let builder = OptionsBuilder::new();
    assert!(builder.is_valid());
    assert!(unsafe { builder.build_unchecked() }.is_valid());
    assert!(OptionsBuilder::default().is_valid());

    let options: Options = Options::new();
    assert!(options.is_valid());
    assert_eq!(options, Options::default());
    assert!(OptionsBuilder::new().build().is_ok());
    assert!(OptionsBuilder::default().build().is_ok());
    assert!(OptionsBuilder::default().is_valid());
    assert_eq!(options.rebuild(), Options::builder());
}
fn u64toa_test() {
    let mut buffer = [b'\x00'; 32];
    unsafe {
        assert_eq!(5u64.decimal(&mut buffer), 1);
        assert_eq!(&buffer[..1], b"5");

        assert_eq!(11u64.decimal(&mut buffer), 2);
        assert_eq!(&buffer[..2], b"11");

        assert_eq!(99u64.decimal(&mut buffer), 2);
        assert_eq!(&buffer[..2], b"99");

        assert_eq!(101u64.decimal(&mut buffer), 3);
        assert_eq!(&buffer[..3], b"101");

        assert_eq!(999u64.decimal(&mut buffer), 3);
        assert_eq!(&buffer[..3], b"999");

        assert_eq!(1001u64.decimal(&mut buffer), 4);
        assert_eq!(&buffer[..4], b"1001");

        assert_eq!(9999u64.decimal(&mut buffer), 4);
        assert_eq!(&buffer[..4], b"9999");

        assert_eq!(10001u64.decimal(&mut buffer), 5);
        assert_eq!(&buffer[..5], b"10001");

        assert_eq!(65535u64.decimal(&mut buffer), 5);
        assert_eq!(&buffer[..5], b"65535");

        assert_eq!(99999u64.decimal(&mut buffer), 5);
        assert_eq!(&buffer[..5], b"99999");

        assert_eq!(100001u64.decimal(&mut buffer), 6);
        assert_eq!(&buffer[..6], b"100001");

        assert_eq!(999999u64.decimal(&mut buffer), 6);
        assert_eq!(&buffer[..6], b"999999");

        assert_eq!(1000001u64.decimal(&mut buffer), 7);
        assert_eq!(&buffer[..7], b"1000001");

        assert_eq!(9999999u64.decimal(&mut buffer), 7);
        assert_eq!(&buffer[..7], b"9999999");

        assert_eq!(10000001u64.decimal(&mut buffer), 8);
        assert_eq!(&buffer[..8], b"10000001");

        assert_eq!(99999999u64.decimal(&mut buffer), 8);
        assert_eq!(&buffer[..8], b"99999999");

        assert_eq!(100000001u64.decimal(&mut buffer), 9);
        assert_eq!(&buffer[..9], b"100000001");

        assert_eq!(999999999u64.decimal(&mut buffer), 9);
        assert_eq!(&buffer[..9], b"999999999");

        assert_eq!(1000000001u64.decimal(&mut buffer), 10);
        assert_eq!(&buffer[..10], b"1000000001");

        assert_eq!(9999999999u64.decimal(&mut buffer), 10);
        assert_eq!(&buffer[..10], b"9999999999");

        assert_eq!(10000000001u64.decimal(&mut buffer), 11);
        assert_eq!(&buffer[..11], b"10000000001");

        assert_eq!(99999999999u64.decimal(&mut buffer), 11);
        assert_eq!(&buffer[..11], b"99999999999");

        assert_eq!(100000000001u64.decimal(&mut buffer), 12);
        assert_eq!(&buffer[..12], b"100000000001");

        assert_eq!(999999999999u64.decimal(&mut buffer), 12);
        assert_eq!(&buffer[..12], b"999999999999");

        assert_eq!(1000000000001u64.decimal(&mut buffer), 13);
        assert_eq!(&buffer[..13], b"1000000000001");

        assert_eq!(9999999999999u64.decimal(&mut buffer), 13);
        assert_eq!(&buffer[..13], b"9999999999999");

        assert_eq!(10000000000001u64.decimal(&mut buffer), 14);
        assert_eq!(&buffer[..14], b"10000000000001");

        assert_eq!(99999999999999u64.decimal(&mut buffer), 14);
        assert_eq!(&buffer[..14], b"99999999999999");

        assert_eq!(100000000000001u64.decimal(&mut buffer), 15);
        assert_eq!(&buffer[..15], b"100000000000001");

        assert_eq!(999999999999999u64.decimal(&mut buffer), 15);
        assert_eq!(&buffer[..15], b"999999999999999");

        assert_eq!(1000000000000001u64.decimal(&mut buffer), 16);
        assert_eq!(&buffer[..16], b"1000000000000001");

        assert_eq!(9999999999999999u64.decimal(&mut buffer), 16);
        assert_eq!(&buffer[..16], b"9999999999999999");

        assert_eq!(10000000000000001u64.decimal(&mut buffer), 17);
        assert_eq!(&buffer[..17], b"10000000000000001");

        assert_eq!(99999999999999999u64.decimal(&mut buffer), 17);
        assert_eq!(&buffer[..17], b"99999999999999999");

        assert_eq!(100000000000000001u64.decimal(&mut buffer), 18);
        assert_eq!(&buffer[..18], b"100000000000000001");

        assert_eq!(999999999999999999u64.decimal(&mut buffer), 18);
        assert_eq!(&buffer[..18], b"999999999999999999");

        assert_eq!(1000000000000000001u64.decimal(&mut buffer), 19);
        assert_eq!(&buffer[..19], b"1000000000000000001");

        assert_eq!(9999999999999999999u64.decimal(&mut buffer), 19);
        assert_eq!(&buffer[..19], b"9999999999999999999");

        assert_eq!(10000000000000000001u64.decimal(&mut buffer), 20);
        assert_eq!(&buffer[..20], b"10000000000000000001");

        assert_eq!(18446744073709551615u64.decimal(&mut buffer), 20);
        assert_eq!(&buffer[..20], b"18446744073709551615");
    }
}
fn test_safe_string_roundtrip() {
    let v = Value::from_safe_string("<b>HTML</b>".into());
    let v2 = Value::from_serializable(&v);
    assert!(v.is_safe());
    assert!(v2.is_safe());
    assert_eq!(v.to_string(), v2.to_string());
}
fn decimal_test() {
    const FORMAT: u128 = NumberFormatBuilder::decimal();
    let format = NumberFormat::<FORMAT> {};
    assert!(format.is_valid());
    assert_eq!(format.radix(), 10);
    assert_eq!(format.mantissa_radix(), 10);
    assert_eq!(format.exponent_base(), 10);
    assert_eq!(format.exponent_radix(), 10);
}
fn simple_test() {
    // Test the simple properties of the stack vector.
    let mut x = VecType::from_u32(1);
    assert_eq!(x.len(), 1);
    assert_eq!(x.is_empty(), false);
    assert_eq!(x.capacity(), SIZE);
    x.try_push(5).unwrap();
    assert_eq!(x.len(), 2);
    assert_eq!(x.pop(), Some(5));
    assert_eq!(x.len(), 1);
    assert_eq!(&*x, &[1]);
    x.try_extend(&[2, 3, 4]).unwrap();
    assert_eq!(x.len(), 4);
    assert_eq!(&*x, &[1, 2, 3, 4]);
    x.try_resize(6, 0).unwrap();
    assert_eq!(x.len(), 6);
    assert_eq!(&*x, &[1, 2, 3, 4, 0, 0]);
    x.try_resize(0, 0).unwrap();
    assert_eq!(x.len(), 0);
    assert_eq!(x.is_empty(), true);

    let x = VecType::try_from(&[5, 1]).unwrap();
    assert_eq!(x.len(), 2);
    assert_eq!(x.is_empty(), false);
    assert_eq!(x.hi16(), (0x8000, true));
    if LIMB_BITS == 32 {
        assert_eq!(x.hi32(), (0x80000002, true));
        assert_eq!(x.hi64(), (0x8000000280000000, false));
    } else {
        assert_eq!(x.hi32(), (0x80000000, true));
        assert_eq!(x.hi64(), (0x8000000000000002, true));
    }
    let rview = x.rview();
    assert_eq!(x[0], 5);
    assert_eq!(x[1], 1);
    assert_eq!(rview[0], 1);
    assert_eq!(rview[1], 5);
    assert_eq!(rview.get(1), Some(&5));
    assert_eq!(rview.get(2), None);

    assert_eq!(VecType::from_u16(u16::MAX).hi16(), (u16::MAX, false));
    assert_eq!(VecType::from_u32(u32::MAX).hi32(), (u32::MAX, false));
    assert_eq!(VecType::from_u64(u64::MAX).hi64(), (u64::MAX, false));
}
fn ignore_test() {
    let fmt = format::NumberFormat::<{ format::IGNORE }> {};
    assert_eq!(fmt.flags(), format::DIGIT_SEPARATOR_FLAG_MASK);
    assert_eq!(fmt.digit_separator(), b'_');
    assert_eq!(fmt.required_integer_digits(), false);
    assert_eq!(fmt.required_fraction_digits(), false);
    assert_eq!(fmt.required_exponent_digits(), false);
    assert_eq!(fmt.required_mantissa_digits(), false);
    assert_eq!(fmt.required_digits(), false);
    assert_eq!(fmt.no_positive_mantissa_sign(), false);
    assert_eq!(fmt.required_mantissa_sign(), false);
    assert_eq!(fmt.no_exponent_notation(), false);
    assert_eq!(fmt.no_positive_exponent_sign(), false);
    assert_eq!(fmt.required_exponent_sign(), false);
    assert_eq!(fmt.no_exponent_without_fraction(), false);
    assert_eq!(fmt.no_special(), false);
    assert_eq!(fmt.case_sensitive_special(), false);
    assert_eq!(fmt.no_integer_leading_zeros(), false);
    assert_eq!(fmt.no_float_leading_zeros(), false);
    assert_eq!(fmt.required_exponent_notation(), false);
    assert_eq!(fmt.case_sensitive_exponent(), false);
    #[cfg(feature = "power-of-two")]
    assert_eq!(fmt.case_sensitive_base_prefix(), false);
    #[cfg(feature = "power-of-two")]
    assert_eq!(fmt.case_sensitive_base_suffix(), false);
    assert_eq!(fmt.integer_internal_digit_separator(), true);
    assert_eq!(fmt.fraction_internal_digit_separator(), true);
    assert_eq!(fmt.exponent_internal_digit_separator(), true);
    assert_eq!(fmt.internal_digit_separator(), true);
    assert_eq!(fmt.integer_leading_digit_separator(), true);
    assert_eq!(fmt.fraction_leading_digit_separator(), true);
    assert_eq!(fmt.exponent_leading_digit_separator(), true);
    assert_eq!(fmt.leading_digit_separator(), true);
    assert_eq!(fmt.integer_trailing_digit_separator(), true);
    assert_eq!(fmt.fraction_trailing_digit_separator(), true);
    assert_eq!(fmt.exponent_trailing_digit_separator(), true);
    assert_eq!(fmt.trailing_digit_separator(), true);
    assert_eq!(fmt.integer_consecutive_digit_separator(), true);
    assert_eq!(fmt.fraction_consecutive_digit_separator(), true);
    assert_eq!(fmt.exponent_consecutive_digit_separator(), true);
    assert_eq!(fmt.consecutive_digit_separator(), true);
    assert_eq!(fmt.special_digit_separator(), true);
}
fn test_context_merge() {
    let one = context!(a => 1);
    let two = context!(b => 2, a => 42);
    let ctx = context![..one, ..two];
    assert_eq!(ctx.get_attr("a").unwrap(), Value::from(1));
    assert_eq!(ctx.get_attr("b").unwrap(), Value::from(2));

    let two = context!(b => 2, a => 42);
    let ctx = context!(a => 1, ..two);
    assert_eq!(ctx.get_attr("a").unwrap(), Value::from(1));
    assert_eq!(ctx.get_attr("b").unwrap(), Value::from(2));
}
fn test_no_leak() {
    let dropped = Arc::new(AtomicBool::new(false));

    struct X(Arc<AtomicBool>);

    impl StructObject for X {
        fn get_field(&self, _name: &str) -> Option<Value> {
            None
        }
    }

    impl Drop for X {
        fn drop(&mut self) {
            self.0.store(true, std::sync::atomic::Ordering::Relaxed);
        }
    }

    let ctx = context! {
        x => Value::from_struct_object(X(dropped.clone())),
    };
    let mut env = Environment::new();
    env.add_template("x", "{% macro meh() %}{{ x }}{{ meh }}{% endmacro %}")
        .unwrap();
    let rv = env
        .render_str(
            r#"
        {%- from 'x' import meh %}
        {{- meh() }}
        {%- set closure = x %}
        {%- macro foo() %}{{ foo }}{{ closure }}{% endmacro %}
        {{- foo() -}}

        {%- for y in range(3) %}
            {%- set closure = x %}
            {%- macro foo() %}{{ foo }}{{ closure }}{% endmacro %}
            {{- foo() -}}
        {%- endfor -%}
    "#,
            ctx,
        )
        .unwrap();

    assert!(dropped.load(std::sync::atomic::Ordering::Relaxed));
    assert_eq!(
        rv,
        "{}<macro meh><macro foo>{}<macro foo>{}<macro foo>{}<macro foo>{}"
    );
}
fn test_return_none() {
    let env = Environment::empty();
    let val = Value::from_function(|| -> Result<(), Error> { Ok(()) });
    let rv = val.call(&env.empty_state(), &[][..]).unwrap();
    assert!(rv.is_none());
    let val = Value::from_function(|| ());
    let rv = val.call(&env.empty_state(), &[][..]).unwrap();
    assert!(rv.is_none());
}
fn options_tests() {
    const X: Options = Options::new();
    assert!(X.is_valid());
    assert_eq!(X, Options::default());
    assert!(OptionsBuilder::new().build().is_ok());
    assert!(OptionsBuilder::default().build().is_ok());
    assert!(OptionsBuilder::default().is_valid());
    assert_eq!(X.rebuild(), Options::builder());
}
fn test_chainable_undefined() {
    let mut env = Environment::new();
    env.set_undefined_behavior(UndefinedBehavior::Chainable);
    env.add_filter("test", |state: &State, value: String| -> String {
        assert_eq!(state.undefined_behavior(), UndefinedBehavior::Chainable);
        assert_eq!(value, "");
        value
    });

    assert_eq!(render!(in env, "<{{ true.missing_attribute }}>"), "<>");
    assert_eq!(render!(in env, "<{{ undefined.missing_attribute }}>"), "<>");
    assert_eq!(
        render!(in env, "<{% for x in undefined %}...{% endfor %}>"),
        "<>"
    );
    assert_eq!(render!(in env, "<{{ undefined }}>"), "<>");
    assert_eq!(render!(in env, "{{ undefined is undefined }}"), "true");
    assert_eq!(render!(in env, "{{ undefined|list }}"), "[]");
    assert_eq!(render!(in env, "<{{ undefined|test }}>"), "<>");
    assert_eq!(render!(in env, "{{ 42 in undefined }}"), "false");
}
fn u128_pow2_test() {
    let values: &[u128] = &[
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        8,
        9,
        15,
        16,
        17,
        31,
        32,
        33,
        63,
        64,
        65,
        127,
        128,
        129,
        255,
        256,
        257,
        511,
        512,
        513,
        1023,
        1024,
        1025,
        2047,
        2048,
        2049,
        4095,
        4096,
        4097,
        8191,
        8192,
        8193,
        16383,
        16384,
        16385,
        32767,
        32768,
        32769,
        65535,
        65536,
        65537,
        131071,
        131072,
        131073,
        262143,
        262144,
        262145,
        524287,
        524288,
        524289,
        1048575,
        1048576,
        1048577,
        2097151,
        2097152,
        2097153,
        4194303,
        4194304,
        4194305,
        8388607,
        8388608,
        8388609,
        16777215,
        16777216,
        16777217,
        33554431,
        33554432,
        33554433,
        67108863,
        67108864,
        67108865,
        134217727,
        134217728,
        134217729,
        268435455,
        268435456,
        268435457,
        536870911,
        536870912,
        536870913,
        1073741823,
        1073741824,
        1073741825,
        2147483647,
        2147483648,
        2147483649,
        4294967295,
        4294967296,
        4294967297,
        8589934591,
        8589934592,
        8589934593,
        17179869183,
        17179869184,
        17179869185,
        34359738367,
        34359738368,
        34359738369,
        68719476735,
        68719476736,
        68719476737,
        137438953471,
        137438953472,
        137438953473,
        274877906943,
        274877906944,
        274877906945,
        549755813887,
        549755813888,
        549755813889,
        1099511627775,
        1099511627776,
        1099511627777,
        2199023255551,
        2199023255552,
        2199023255553,
        4398046511103,
        4398046511104,
        4398046511105,
        8796093022207,
        8796093022208,
        8796093022209,
        17592186044415,
        17592186044416,
        17592186044417,
        35184372088831,
        35184372088832,
        35184372088833,
        70368744177663,
        70368744177664,
        70368744177665,
        140737488355327,
        140737488355328,
        140737488355329,
        281474976710655,
        281474976710656,
        281474976710657,
        562949953421311,
        562949953421312,
        562949953421313,
        1125899906842623,
        1125899906842624,
        1125899906842625,
        2251799813685247,
        2251799813685248,
        2251799813685249,
        4503599627370495,
        4503599627370496,
        4503599627370497,
        9007199254740991,
        9007199254740992,
        9007199254740993,
        18014398509481983,
        18014398509481984,
        18014398509481985,
        36028797018963967,
        36028797018963968,
        36028797018963969,
        72057594037927935,
        72057594037927936,
        72057594037927937,
        144115188075855871,
        144115188075855872,
        144115188075855873,
        288230376151711743,
        288230376151711744,
        288230376151711745,
        576460752303423487,
        576460752303423488,
        576460752303423489,
        1152921504606846975,
        1152921504606846976,
        1152921504606846977,
        2305843009213693951,
        2305843009213693952,
        2305843009213693953,
        4611686018427387903,
        4611686018427387904,
        4611686018427387905,
        9223372036854775807,
        9223372036854775808,
        9223372036854775809,
        18446744073709551615,
        18446744073709551616,
        18446744073709551617,
        36893488147419103231,
        36893488147419103232,
        36893488147419103233,
        73786976294838206463,
        73786976294838206464,
        73786976294838206465,
        147573952589676412927,
        147573952589676412928,
        147573952589676412929,
        295147905179352825855,
        295147905179352825856,
        295147905179352825857,
        590295810358705651711,
        590295810358705651712,
        590295810358705651713,
        1180591620717411303423,
        1180591620717411303424,
        1180591620717411303425,
        2361183241434822606847,
        2361183241434822606848,
        2361183241434822606849,
        4722366482869645213695,
        4722366482869645213696,
        4722366482869645213697,
        9444732965739290427391,
        9444732965739290427392,
        9444732965739290427393,
        18889465931478580854783,
        18889465931478580854784,
        18889465931478580854785,
        37778931862957161709567,
        37778931862957161709568,
        37778931862957161709569,
        75557863725914323419135,
        75557863725914323419136,
        75557863725914323419137,
        151115727451828646838271,
        151115727451828646838272,
        151115727451828646838273,
        302231454903657293676543,
        302231454903657293676544,
        302231454903657293676545,
        604462909807314587353087,
        604462909807314587353088,
        604462909807314587353089,
        1208925819614629174706175,
        1208925819614629174706176,
        1208925819614629174706177,
        2417851639229258349412351,
        2417851639229258349412352,
        2417851639229258349412353,
        4835703278458516698824703,
        4835703278458516698824704,
        4835703278458516698824705,
        9671406556917033397649407,
        9671406556917033397649408,
        9671406556917033397649409,
        19342813113834066795298815,
        19342813113834066795298816,
        19342813113834066795298817,
        38685626227668133590597631,
        38685626227668133590597632,
        38685626227668133590597633,
        77371252455336267181195263,
        77371252455336267181195264,
        77371252455336267181195265,
        154742504910672534362390527,
        154742504910672534362390528,
        154742504910672534362390529,
        309485009821345068724781055,
        309485009821345068724781056,
        309485009821345068724781057,
        618970019642690137449562111,
        618970019642690137449562112,
        618970019642690137449562113,
        1237940039285380274899124223,
        1237940039285380274899124224,
        1237940039285380274899124225,
        2475880078570760549798248447,
        2475880078570760549798248448,
        2475880078570760549798248449,
        4951760157141521099596496895,
        4951760157141521099596496896,
        4951760157141521099596496897,
        9903520314283042199192993791,
        9903520314283042199192993792,
        9903520314283042199192993793,
        19807040628566084398385987583,
        19807040628566084398385987584,
        19807040628566084398385987585,
        39614081257132168796771975167,
        39614081257132168796771975168,
        39614081257132168796771975169,
        79228162514264337593543950335,
        79228162514264337593543950336,
        79228162514264337593543950337,
        158456325028528675187087900671,
        158456325028528675187087900672,
        158456325028528675187087900673,
        316912650057057350374175801343,
        316912650057057350374175801344,
        316912650057057350374175801345,
        633825300114114700748351602687,
        633825300114114700748351602688,
        633825300114114700748351602689,
        1267650600228229401496703205375,
        1267650600228229401496703205376,
        1267650600228229401496703205377,
        2535301200456458802993406410751,
        2535301200456458802993406410752,
        2535301200456458802993406410753,
        5070602400912917605986812821503,
        5070602400912917605986812821504,
        5070602400912917605986812821505,
        10141204801825835211973625643007,
        10141204801825835211973625643008,
        10141204801825835211973625643009,
        20282409603651670423947251286015,
        20282409603651670423947251286016,
        20282409603651670423947251286017,
        40564819207303340847894502572031,
        40564819207303340847894502572032,
        40564819207303340847894502572033,
        81129638414606681695789005144063,
        81129638414606681695789005144064,
        81129638414606681695789005144065,
        162259276829213363391578010288127,
        162259276829213363391578010288128,
        162259276829213363391578010288129,
        324518553658426726783156020576255,
        324518553658426726783156020576256,
        324518553658426726783156020576257,
        649037107316853453566312041152511,
        649037107316853453566312041152512,
        649037107316853453566312041152513,
        1298074214633706907132624082305023,
        1298074214633706907132624082305024,
        1298074214633706907132624082305025,
        2596148429267413814265248164610047,
        2596148429267413814265248164610048,
        2596148429267413814265248164610049,
        5192296858534827628530496329220095,
        5192296858534827628530496329220096,
        5192296858534827628530496329220097,
        10384593717069655257060992658440191,
        10384593717069655257060992658440192,
        10384593717069655257060992658440193,
        20769187434139310514121985316880383,
        20769187434139310514121985316880384,
        20769187434139310514121985316880385,
        41538374868278621028243970633760767,
        41538374868278621028243970633760768,
        41538374868278621028243970633760769,
        83076749736557242056487941267521535,
        83076749736557242056487941267521536,
        83076749736557242056487941267521537,
        166153499473114484112975882535043071,
        166153499473114484112975882535043072,
        166153499473114484112975882535043073,
        332306998946228968225951765070086143,
        332306998946228968225951765070086144,
        332306998946228968225951765070086145,
        664613997892457936451903530140172287,
        664613997892457936451903530140172288,
        664613997892457936451903530140172289,
        1329227995784915872903807060280344575,
        1329227995784915872903807060280344576,
        1329227995784915872903807060280344577,
        2658455991569831745807614120560689151,
        2658455991569831745807614120560689152,
        2658455991569831745807614120560689153,
        5316911983139663491615228241121378303,
        5316911983139663491615228241121378304,
        5316911983139663491615228241121378305,
        10633823966279326983230456482242756607,
        10633823966279326983230456482242756608,
        10633823966279326983230456482242756609,
        21267647932558653966460912964485513215,
        21267647932558653966460912964485513216,
        21267647932558653966460912964485513217,
        42535295865117307932921825928971026431,
        42535295865117307932921825928971026432,
        42535295865117307932921825928971026433,
        85070591730234615865843651857942052863,
        85070591730234615865843651857942052864,
        85070591730234615865843651857942052865,
        170141183460469231731687303715884105727,
        170141183460469231731687303715884105728,
        170141183460469231731687303715884105729,
        340282366920938463463374607431768211455,
    ];
    for &i in values.iter() {
        assert_eq!(i, roundtrip(i));
    }
}
fn u16_pow2_test() {
    let values: &[u16] = &[
        0, 1, 2, 3, 4, 5, 7, 8, 9, 15, 16, 17, 31, 32, 33, 63, 64, 65, 127, 128, 129, 255, 256,
        257, 511, 512, 513, 1023, 1024, 1025, 2047, 2048, 2049, 4095, 4096, 4097, 8191, 8192, 8193,
        16383, 16384, 16385, 32767, 32768, 32769, 65535,
    ];
    for &i in values.iter() {
        assert_eq!(i, roundtrip(i));
    }
}
fn invalid_inf_test() {
    let mut builder = OptionsBuilder::default();
    builder = builder.inf_string(Some(b"innnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnf"));
    assert!(!builder.is_valid());
    builder = builder.inf_string(Some(b"nan"));
    assert!(!builder.is_valid());
    builder = builder.inf_string(Some(b"in00f"));
    assert!(!builder.is_valid());
    assert!(builder.build().is_err());
    builder = builder.inf_string(Some(b"inf"));
    assert!(builder.is_valid());
    assert!(builder.build().is_ok());
    builder = builder.inf_string(None);
    assert!(builder.is_valid());
}
