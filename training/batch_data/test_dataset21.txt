fn manually_destroy() -> Result<()> {
    let engine = super::engine();
    let c = Component::new(
        &engine,
        r#"
            (component
                (import "t1" (type $t1 (sub resource)))

                (core module $m
                  (global $drops (mut i32) i32.const 0)
                  (global $last-drop (mut i32) i32.const 0)

                  (func (export "dtor") (param i32)
                    (global.set $drops (i32.add (global.get $drops) (i32.const 1)))
                    (global.set $last-drop (local.get 0))
                  )
                  (func (export "drops") (result i32) global.get $drops)
                  (func (export "last-drop") (result i32) global.get $last-drop)
                  (func (export "pass") (param i32) (result i32) local.get 0)
                )
                (core instance $i (instantiate $m))
                (type $t2' (resource (rep i32) (dtor (func $i "dtor"))))
                (export $t2 "t2" (type $t2'))
                (core func $ctor (canon resource.new $t2))
                (func (export "[constructor]t2") (param "rep" u32) (result (own $t2))
                  (canon lift (core func $ctor)))
                (func (export "[static]t2.drops") (result u32)
                  (canon lift (core func $i "drops")))
                (func (export "[static]t2.last-drop") (result u32)
                  (canon lift (core func $i "last-drop")))

                (func (export "t1-pass") (param "t" (own $t1)) (result (own $t1))
                  (canon lift (core func $i "pass")))
            )
        "#,
    )?;

    struct MyType;

    #[derive(Default)]
    struct Data {
        drops: u32,
        last_drop: Option<u32>,
    }

    let mut store = Store::new(&engine, Data::default());
    let mut linker = Linker::new(&engine);
    linker.root().resource::<MyType>("t1", |mut cx, rep| {
        let data: &mut Data = cx.data_mut();
        data.drops += 1;
        data.last_drop = Some(rep);
        Ok(())
    })?;
    let i = linker.instantiate(&mut store, &c)?;
    let t2_ctor = i.get_typed_func::<(u32,), (ResourceAny,)>(&mut store, "[constructor]t2")?;
    let t2_drops = i.get_typed_func::<(), (u32,)>(&mut store, "[static]t2.drops")?;
    let t2_last_drop = i.get_typed_func::<(), (u32,)>(&mut store, "[static]t2.last-drop")?;
    let t1_pass = i.get_typed_func::<(Resource<MyType>,), (ResourceAny,)>(&mut store, "t1-pass")?;

    // Host resources can be destroyed through `resource_drop`
    let t1 = Resource::new_own(100);
    let (t1,) = t1_pass.call(&mut store, (t1,))?;
    t1_pass.post_return(&mut store)?;
    assert_eq!(store.data().drops, 0);
    assert_eq!(store.data().last_drop, None);
    t1.resource_drop(&mut store)?;
    assert_eq!(store.data().drops, 1);
    assert_eq!(store.data().last_drop, Some(100));

    // Guest resources can be destroyed through `resource_drop`
    let (t2,) = t2_ctor.call(&mut store, (200,))?;
    t2_ctor.post_return(&mut store)?;
    assert_eq!(t2_drops.call(&mut store, ())?, (0,));
    t2_drops.post_return(&mut store)?;
    assert_eq!(t2_last_drop.call(&mut store, ())?, (0,));
    t2_last_drop.post_return(&mut store)?;
    t2.resource_drop(&mut store)?;
    assert_eq!(t2_drops.call(&mut store, ())?, (1,));
    t2_drops.post_return(&mut store)?;
    assert_eq!(t2_last_drop.call(&mut store, ())?, (200,));
    t2_last_drop.post_return(&mut store)?;

    // Wires weren't crossed to drop more resources
    assert_eq!(store.data().drops, 1);
    assert_eq!(store.data().last_drop, Some(100));

    Ok(())
}
fn grow_funcref_tables_via_api() -> anyhow::Result<()> {
    let mut cfg = Config::new();
    cfg.wasm_reference_types(true);
    let engine = Engine::new(&cfg)?;
    let mut store = Store::new(&engine, ());

    let table_ty = TableType::new(ValType::FuncRef, 10, None);
    let table = Table::new(&mut store, table_ty, Val::FuncRef(None))?;

    assert_eq!(table.size(&store), 10);
    table.grow(&mut store, 3, Val::FuncRef(None))?;
    assert_eq!(table.size(&store), 13);

    Ok(())
}
fn memory_zeroed() -> Result<()> {
    if skip_pooling_allocator_tests() {
        return Ok(());
    }

    let mut pool = crate::small_pool_config();
    pool.memory_pages(1).table_elements(0);
    let mut config = Config::new();
    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));
    config.dynamic_memory_guard_size(0);
    config.static_memory_guard_size(0);
    config.static_memory_maximum_size(65536);

    let engine = Engine::new(&config)?;

    let module = Module::new(&engine, r#"(module (memory (export "m") 1))"#)?;

    // Instantiate the module repeatedly after writing data to the entire memory
    for _ in 0..10 {
        let mut store = Store::new(&engine, ());
        let instance = Instance::new(&mut store, &module, &[])?;
        let memory = instance.get_memory(&mut store, "m").unwrap();

        assert_eq!(memory.size(&store,), 1);
        assert_eq!(memory.data_size(&store), 65536);

        let ptr = memory.data_mut(&mut store).as_mut_ptr();

        unsafe {
            for i in 0..8192 {
                assert_eq!(*ptr.cast::<u64>().offset(i), 0);
            }
            std::ptr::write_bytes(ptr, 0xFE, memory.data_size(&store));
        }
    }

    Ok(())
}
fn bare_bones() -> Result<()> {
    let engine = super::engine();
    let component = Component::new(&engine, "(component)")?.serialize()?;
    assert_eq!(component, engine.precompile_component(b"(component)")?);

    let component = unsafe { Component::deserialize(&engine, &component)? };
    let mut store = Store::new(&engine, ());
    Linker::new(&engine).instantiate(&mut store, &component)?;

    Ok(())
}
fn dtor_runs() {
    static HITS: AtomicUsize = AtomicUsize::new(0);

    struct A;

    impl Drop for A {
        fn drop(&mut self) {
            HITS.fetch_add(1, SeqCst);
        }
    }

    let mut store = Store::<()>::default();
    let a = A;
    assert_eq!(HITS.load(SeqCst), 0);
    Func::wrap(&mut store, move || {
        let _ = &a;
    });
    drop(store);
    assert_eq!(HITS.load(SeqCst), 1);
}
fn get_set_externref_globals_via_api() -> anyhow::Result<()> {
    let mut cfg = Config::new();
    cfg.wasm_reference_types(true);
    let engine = Engine::new(&cfg)?;
    let mut store = Store::new(&engine, ());

    // Initialize with a null externref.

    let global = Global::new(
        &mut store,
        GlobalType::new(ValType::ExternRef, Mutability::Var),
        Val::ExternRef(None),
    )?;
    assert!(global.get(&mut store).unwrap_externref().is_none());

    global.set(
        &mut store,
        Val::ExternRef(Some(ExternRef::new("hello".to_string()))),
    )?;
    let r = global.get(&mut store).unwrap_externref().unwrap();
    assert!(r.data().is::<String>());
    assert_eq!(r.data().downcast_ref::<String>().unwrap(), "hello");

    // Initialize with a non-null externref.

    let global = Global::new(
        &mut store,
        GlobalType::new(ValType::ExternRef, Mutability::Const),
        Val::ExternRef(Some(ExternRef::new(42_i32))),
    )?;
    let r = global.get(&mut store).unwrap_externref().unwrap();
    assert!(r.data().is::<i32>());
    assert_eq!(r.data().downcast_ref::<i32>().copied().unwrap(), 42);

    Ok(())
}
fn call_array_to_native() -> Result<()> {
    let mut store = Store::<()>::default();
    let func = Func::wrap(&mut store, |a: i32, b: i32, c: i32| -> (i32, i32, i32) {
        (a * 10, b * 10, c * 10)
    });
    let mut results = [Val::I32(0), Val::I32(0), Val::I32(0)];
    func.call(
        &mut store,
        &[Val::I32(10), Val::I32(20), Val::I32(30)],
        &mut results,
    )?;
    assert_eq!(results[0].i32(), Some(100));
    assert_eq!(results[1].i32(), Some(200));
    assert_eq!(results[2].i32(), Some(300));
    Ok(())
}
fn catch_trap_calling_across_stores() -> Result<()> {
    let _ = env_logger::try_init();

    let engine = Engine::default();

    let mut child_store = Store::new(&engine, ());
    let child_module = Module::new(
        child_store.engine(),
        r#"
            (module $child
              (func $trap (export "trap")
                unreachable
              )
            )
        "#,
    )?;
    let child_instance = Instance::new(&mut child_store, &child_module, &[])?;

    struct ParentCtx {
        child_store: Store<()>,
        child_instance: Instance,
    }

    let mut linker = Linker::new(&engine);
    linker.func_wrap(
        "host",
        "catch_child_trap",
        move |mut caller: Caller<'_, ParentCtx>| {
            let mut ctx = caller.as_context_mut();
            let data = ctx.data_mut();
            let func = data
                .child_instance
                .get_typed_func::<(), ()>(&mut data.child_store, "trap")
                .expect("trap function should be exported");

            let trap = func.call(&mut data.child_store, ()).unwrap_err();
            assert!(
                format!("{trap:?}").contains("unreachable"),
                "trap should contain 'unreachable', got: {trap:?}"
            );

            let trace = trap.downcast_ref::<WasmBacktrace>().unwrap().frames();

            assert_eq!(trace.len(), 1);
            assert_eq!(trace[0].func_name(), Some("trap"));
            // For now, we only get stack frames for Wasm in this store, not
            // across all stores.
            //
            // assert_eq!(trace[1].func_name(), Some("run"));

            Ok(())
        },
    )?;

    let mut store = Store::new(
        &engine,
        ParentCtx {
            child_store,
            child_instance,
        },
    );

    let parent_module = Module::new(
        store.engine(),
        r#"
            (module $parent
              (func $host.catch_child_trap (import "host" "catch_child_trap"))
              (func $run (export "run")
                call $host.catch_child_trap
              )
            )
        "#,
    )?;

    let parent_instance = linker.instantiate(&mut store, &parent_module)?;

    let func = parent_instance.get_typed_func::<(), ()>(&mut store, "run")?;
    func.call(store, ())?;

    Ok(())
}
fn div_plus_load_reported_right() -> Result<()> {
    let engine = Engine::default();
    let mut store = Store::new(&engine, ());
    let module = Module::new(
        &engine,
        r#"
            (module
                (memory (export "memory") 1)
                (func (export "i32.div_s") (param i32 i32) (result i32)
                    (i32.div_s (local.get 0) (i32.load (local.get 1))))
                (func (export "i32.div_u") (param i32 i32) (result i32)
                    (i32.div_u (local.get 0) (i32.load (local.get 1))))
                (func (export "i32.rem_s") (param i32 i32) (result i32)
                    (i32.rem_s (local.get 0) (i32.load (local.get 1))))
                (func (export "i32.rem_u") (param i32 i32) (result i32)
                    (i32.rem_u (local.get 0) (i32.load (local.get 1))))
            )
        "#,
    )?;
    let instance = Instance::new(&mut store, &module, &[])?;
    let memory = instance.get_memory(&mut store, "memory").unwrap();
    let i32_div_s = instance.get_typed_func::<(i32, i32), i32>(&mut store, "i32.div_s")?;
    let i32_div_u = instance.get_typed_func::<(u32, u32), u32>(&mut store, "i32.div_u")?;
    let i32_rem_s = instance.get_typed_func::<(i32, i32), i32>(&mut store, "i32.rem_s")?;
    let i32_rem_u = instance.get_typed_func::<(u32, u32), u32>(&mut store, "i32.rem_u")?;

    memory.write(&mut store, 0, &1i32.to_le_bytes()).unwrap();
    memory.write(&mut store, 4, &0i32.to_le_bytes()).unwrap();
    memory.write(&mut store, 8, &(-1i32).to_le_bytes()).unwrap();

    assert_eq!(i32_div_s.call(&mut store, (100, 0))?, 100);
    assert_eq!(i32_div_u.call(&mut store, (101, 0))?, 101);
    assert_eq!(i32_rem_s.call(&mut store, (102, 0))?, 0);
    assert_eq!(i32_rem_u.call(&mut store, (103, 0))?, 0);

    assert_trap(
        i32_div_s.call(&mut store, (100, 4)),
        Trap::IntegerDivisionByZero,
    );
    assert_trap(
        i32_div_u.call(&mut store, (100, 4)),
        Trap::IntegerDivisionByZero,
    );
    assert_trap(
        i32_rem_s.call(&mut store, (100, 4)),
        Trap::IntegerDivisionByZero,
    );
    assert_trap(
        i32_rem_u.call(&mut store, (100, 4)),
        Trap::IntegerDivisionByZero,
    );

    assert_trap(
        i32_div_s.call(&mut store, (i32::MIN, 8)),
        Trap::IntegerOverflow,
    );
    assert_eq!(i32_rem_s.call(&mut store, (i32::MIN, 8))?, 0);

    assert_trap(
        i32_div_s.call(&mut store, (100, 100_000)),
        Trap::MemoryOutOfBounds,
    );
    assert_trap(
        i32_div_u.call(&mut store, (100, 100_000)),
        Trap::MemoryOutOfBounds,
    );
    assert_trap(
        i32_rem_s.call(&mut store, (100, 100_000)),
        Trap::MemoryOutOfBounds,
    );
    assert_trap(
        i32_rem_u.call(&mut store, (100, 100_000)),
        Trap::MemoryOutOfBounds,
    );

    return Ok(());

    #[track_caller]
    fn assert_trap<T>(result: Result<T>, expected: Trap) {
        match result {
            Ok(_) => panic!("expected failure"),
            Err(e) => {
                if let Some(code) = e.downcast_ref::<Trap>() {
                    if *code == expected {
                        return;
                    }
                }
                panic!("unexpected error {e:?}");
            }
        }
    }
}
fn attempt_to_leave_during_malloc() -> Result<()> {
    let component = r#"
(component
  (import "thunk" (func $thunk))
  (import "ret-string" (func $ret_string (result string)))

  (core module $host_shim
    (table (export "table") 2 funcref)
    (func $shim_thunk (export "thunk")
      i32.const 0
      call_indirect)
    (func $shim_ret_string (export "ret-string") (param i32)
      local.get 0
      i32.const 1
      call_indirect (param i32))
  )
  (core instance $host_shim (instantiate $host_shim))

  (core module $m
    (import "host" "thunk" (func $thunk))
    (import "host" "ret-string" (func $ret_string (param i32)))

    (memory (export "memory") 1)

    (func $realloc (export "realloc") (param i32 i32 i32 i32) (result i32)
      call $thunk
      unreachable)

    (func $run (export "run")
      i32.const 8
      call $ret_string)

    (func (export "take-string") (param i32 i32)
        unreachable)
  )
  (core instance $m (instantiate $m (with "host" (instance $host_shim))))

  (core module $host_shim_filler_inner
    (import "shim" "table" (table 2 funcref))
    (import "host" "thunk" (func $thunk))
    (import "host" "ret-string" (func $ret_string (param i32)))
    (elem (i32.const 0) $thunk $ret_string)
  )

  (core func $thunk_lower
    (canon lower (func $thunk) (memory $m "memory") (realloc (func $m "realloc")))
  )

  (core func $ret_string_lower
    (canon lower (func $ret_string) (memory $m "memory") (realloc (func $m "realloc")))
  )

  (core instance (instantiate $host_shim_filler_inner
    (with "shim" (instance $host_shim))
    (with "host" (instance
      (export "thunk" (func $thunk_lower))
      (export "ret-string" (func $ret_string_lower))
    ))
  ))

  (func (export "run")
    (canon lift (core func $m "run"))
  )
  (func (export "take-string") (param "a" string)
    (canon lift (core func $m "take-string") (memory $m "memory") (realloc (func $m "realloc")))
  )
)
    "#;

    let engine = super::engine();
    let mut linker = Linker::new(&engine);
    linker.root().func_wrap("thunk", |_, _: ()| -> Result<()> {
        panic!("should not get here")
    })?;
    linker
        .root()
        .func_wrap("ret-string", |_, _: ()| -> Result<_> {
            Ok(("hello".to_string(),))
        })?;
    let component = Component::new(&engine, component)?;
    let mut store = Store::new(&engine, ());

    // Assert that during a host import if we return values to wasm that a trap
    // happens if we try to leave the instance.
    let trap = linker
        .instantiate(&mut store, &component)?
        .get_typed_func::<(), ()>(&mut store, "run")?
        .call(&mut store, ())
        .unwrap_err();
    assert!(
        format!("{trap:?}").contains("cannot leave component instance"),
        "bad trap: {trap:?}",
    );

    let trace = trap.downcast_ref::<WasmBacktrace>().unwrap().frames();
    assert_eq!(trace.len(), 4);

    // This was our entry point...
    assert_eq!(trace[3].module().name(), Some("m"));
    assert_eq!(trace[3].func_name(), Some("run"));

    // ... which called an imported function which ends up being originally
    // defined by the shim instance. The shim instance then does an indirect
    // call through a table which goes to the `canon.lower`'d host function
    assert_eq!(trace[2].module().name(), Some("host_shim"));
    assert_eq!(trace[2].func_name(), Some("shim_ret_string"));

    // ... and the lowered host function will call realloc to allocate space for
    // the result
    assert_eq!(trace[1].module().name(), Some("m"));
    assert_eq!(trace[1].func_name(), Some("realloc"));

    // ... but realloc calls the shim instance and tries to exit the
    // component, triggering a dynamic trap
    assert_eq!(trace[0].module().name(), Some("host_shim"));
    assert_eq!(trace[0].func_name(), Some("shim_thunk"));

    // In addition to the above trap also ensure that when we enter a wasm
    // component if we try to leave while lowering then that's also a dynamic
    // trap.
    let trap = linker
        .instantiate(&mut store, &component)?
        .get_typed_func::<(&str,), ()>(&mut store, "take-string")?
        .call(&mut store, ("x",))
        .unwrap_err();
    assert!(
        format!("{trap:?}").contains("cannot leave component instance"),
        "bad trap: {trap:?}",
    );
    Ok(())
}
fn total_core_instances_limit() -> Result<()> {
    const INSTANCE_LIMIT: u32 = 10;
    let mut pool = crate::small_pool_config();
    pool.total_core_instances(INSTANCE_LIMIT);
    let mut config = Config::new();
    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));
    config.dynamic_memory_guard_size(0);
    config.static_memory_guard_size(0);
    config.static_memory_maximum_size(65536);

    let engine = Engine::new(&config)?;
    let module = Module::new(&engine, r#"(module)"#)?;

    // Instantiate to the limit
    {
        let mut store = Store::new(&engine, ());

        for _ in 0..INSTANCE_LIMIT {
            Instance::new(&mut store, &module, &[])?;
        }

        match Instance::new(&mut store, &module, &[]) {
            Ok(_) => panic!("instantiation should fail"),
            Err(e) => assert_eq!(
                e.to_string(),
                format!(
                    "maximum concurrent core instance limit of {} reached",
                    INSTANCE_LIMIT
                )
            ),
        }
    }

    // With the above store dropped, ensure instantiations can be made

    let mut store = Store::new(&engine, ());

    for _ in 0..INSTANCE_LIMIT {
        Instance::new(&mut store, &module, &[])?;
    }

    Ok(())
}
fn same_module_multiple_stores() -> Result<()> {
    let _ = env_logger::try_init();

    let engine = Engine::default();

    let module = Module::new(
        &engine,
        r#"
            (module
                (import "" "f" (func $f))
                (import "" "call_ref" (func $call_ref (param funcref)))
                (global $g (mut i32) (i32.const 0))
                (func $a (export "a")
                    call $b
                )
                (func $b
                    call $c
                )
                (func $c
                    global.get $g
                    if
                        call $f
                    else
                        i32.const 1
                        global.set $g
                        ref.func $a
                        call $call_ref
                    end
                )
            )
        "#,
    )?;

    let stacks = Arc::new(Mutex::new(vec![]));

    let mut store3 = Store::new(&engine, ());
    let f3 = Func::new(&mut store3, FuncType::new([], []), {
        let stacks = stacks.clone();
        move |caller, _params, _results| {
            stacks
                .lock()
                .unwrap()
                .push(WasmBacktrace::force_capture(caller));
            Ok(())
        }
    });
    let call_ref3 = Func::wrap(&mut store3, |caller: Caller<'_, _>, f: Option<Func>| {
        f.unwrap().call(caller, &[], &mut [])
    });
    let instance3 = Instance::new(&mut store3, &module, &[f3.into(), call_ref3.into()])?;

    let mut store2 = Store::new(&engine, store3);
    let f2 = Func::new(&mut store2, FuncType::new([], []), {
        let stacks = stacks.clone();
        move |mut caller, _params, _results| {
            stacks
                .lock()
                .unwrap()
                .push(WasmBacktrace::force_capture(&mut caller));
            instance3
                .get_typed_func::<(), ()>(caller.data_mut(), "a")
                .unwrap()
                .call(caller.data_mut(), ())
                .unwrap();
            Ok(())
        }
    });
    let call_ref2 = Func::wrap(&mut store2, |caller: Caller<'_, _>, f: Option<Func>| {
        f.unwrap().call(caller, &[], &mut [])
    });
    let instance2 = Instance::new(&mut store2, &module, &[f2.into(), call_ref2.into()])?;

    let mut store1 = Store::new(&engine, store2);
    let f1 = Func::new(&mut store1, FuncType::new([], []), {
        let stacks = stacks.clone();
        move |mut caller, _params, _results| {
            stacks
                .lock()
                .unwrap()
                .push(WasmBacktrace::force_capture(&mut caller));
            instance2
                .get_typed_func::<(), ()>(caller.data_mut(), "a")
                .unwrap()
                .call(caller.data_mut(), ())
                .unwrap();
            Ok(())
        }
    });
    let call_ref1 = Func::wrap(&mut store1, |caller: Caller<'_, _>, f: Option<Func>| {
        f.unwrap().call(caller, &[], &mut [])
    });
    let instance1 = Instance::new(&mut store1, &module, &[f1.into(), call_ref1.into()])?;

    instance1
        .get_typed_func(&mut store1, "a")?
        .call(&mut store1, ())?;

    let expected_stacks = vec![
        // [f1, c1, b1, a1, call_ref1, c1, b1, a1]
        vec!["c", "b", "a", "c", "b", "a"],
        // [f2, c2, b2, a2, call_ref2, c2, b2, a2, f1, c1, b1, a1, call_ref1, c1, b1, a1]
        vec!["c", "b", "a", "c", "b", "a"],
        // [f3, c3, b3, a3, call_ref3, c3, b3, a3, f2, c2, b2, a2, call_ref2, c2, b2, a2, f1, c1, b1, a1, call_ref1, c1, b1, a1]
        vec!["c", "b", "a", "c", "b", "a"],
    ];
    eprintln!("expected = {expected_stacks:#?}");
    let actual_stacks = stacks.lock().unwrap();
    eprintln!("actaul = {actual_stacks:#?}");

    assert_eq!(actual_stacks.len(), expected_stacks.len());
    for (expected_stack, actual_stack) in expected_stacks.into_iter().zip(actual_stacks.iter()) {
        assert_eq!(expected_stack.len(), actual_stack.frames().len());
        for (expected_frame, actual_frame) in expected_stack.into_iter().zip(actual_stack.frames())
        {
            assert_eq!(actual_frame.func_name(), Some(expected_frame));
        }
    }

    Ok(())
}
fn test_module_no_name() -> anyhow::Result<()> {
    let engine = Engine::default();
    let wat = r#"
        (module
        (func (export "run") (nop))
        )
    "#;

    let module = Module::new(&engine, wat)?;
    assert_eq!(module.name(), None);

    Ok(())
}
fn test_unknown_import_error() -> Result<()> {
    let mut store = Store::<()>::default();
    let linker = Linker::new(store.engine());
    let module = Module::new(
        store.engine(),
        r#"(module (import "unknown-module" "unknown-name" (func)))"#,
    )?;
    let err = linker
        .instantiate(&mut store, &module)
        .expect_err("should fail");
    let unknown_import: UnknownImportError = err.downcast()?;
    assert_eq!(unknown_import.module(), "unknown-module");
    assert_eq!(unknown_import.name(), "unknown-name");
    unknown_import.ty().unwrap_func();
    Ok(())
}
fn test_pooling_allocator_initial_limits_exceeded() -> Result<()> {
    let mut pool = crate::small_pool_config();
    pool.total_memories(2)
        .max_memories_per_module(2)
        .memory_pages(5);
    let mut config = Config::new();
    config.wasm_multi_memory(true);
    config.allocation_strategy(InstanceAllocationStrategy::Pooling(pool));

    let engine = Engine::new(&config)?;
    let module = Module::new(
        &engine,
        r#"(module (memory (export "m1") 2) (memory (export "m2") 5))"#,
    )?;

    let mut store = Store::new(
        &engine,
        StoreLimitsBuilder::new()
            .memory_size(3 * WASM_PAGE_SIZE)
            .build(),
    );
    store.limiter(|s| s as &mut dyn ResourceLimiter);

    match Instance::new(&mut store, &module, &[]) {
        Ok(_) => unreachable!(),
        Err(e) => assert_eq!(
            e.to_string(),
            "memory minimum size of 5 pages exceeds memory limits"
        ),
    }

    // An instance should still be able to be created after the failure above
    let module = Module::new(&engine, r#"(module (memory (export "m") 2))"#)?;

    Instance::new(&mut store, &module, &[])?;

    Ok(())
}
