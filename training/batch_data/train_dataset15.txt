fn format_properties_test() {
    let format = NumberFormat::<{ STANDARD }> {};
    assert_eq!(format.flags(), STANDARD & format::FLAG_MASK);
    assert_eq!(format.interface_flags(), STANDARD & format::INTERFACE_FLAG_MASK);
    assert_eq!(format.digit_separator(), b'\x00');
    assert_eq!(format.base_prefix(), b'\x00');
    assert_eq!(format.base_suffix(), b'\x00');
    assert_eq!(format.mantissa_radix(), 10);
    assert_eq!(format.radix(), 10);
    assert_eq!(format.exponent_base(), 10);
    assert_eq!(format.exponent_radix(), 10);
    assert_eq!(format.required_integer_digits(), false);
    assert_eq!(format.required_fraction_digits(), false);
    assert_eq!(format.required_exponent_digits(), true);
    assert_eq!(format.required_mantissa_digits(), true);
    assert_eq!(format.required_digits(), true);
    assert_eq!(format.no_positive_mantissa_sign(), false);
    assert_eq!(format.required_mantissa_sign(), false);
    assert_eq!(format.no_exponent_notation(), false);
    assert_eq!(format.no_positive_exponent_sign(), false);
    assert_eq!(format.required_exponent_sign(), false);
    assert_eq!(format.no_exponent_without_fraction(), false);
    assert_eq!(format.no_special(), false);
    assert_eq!(format.case_sensitive_special(), false);
    assert_eq!(format.no_integer_leading_zeros(), false);
    assert_eq!(format.no_float_leading_zeros(), false);
    assert_eq!(format.required_exponent_notation(), false);
    assert_eq!(format.case_sensitive_exponent(), false);
    assert_eq!(format.case_sensitive_base_prefix(), false);
    assert_eq!(format.case_sensitive_base_suffix(), false);
    assert_eq!(format.integer_internal_digit_separator(), false);
    assert_eq!(format.fraction_internal_digit_separator(), false);
    assert_eq!(format.exponent_internal_digit_separator(), false);
    assert_eq!(format.internal_digit_separator(), false);
    assert_eq!(format.integer_leading_digit_separator(), false);
    assert_eq!(format.fraction_leading_digit_separator(), false);
    assert_eq!(format.exponent_leading_digit_separator(), false);
    assert_eq!(format.leading_digit_separator(), false);
    assert_eq!(format.integer_trailing_digit_separator(), false);
    assert_eq!(format.fraction_trailing_digit_separator(), false);
    assert_eq!(format.exponent_trailing_digit_separator(), false);
    assert_eq!(format.trailing_digit_separator(), false);
    assert_eq!(format.integer_consecutive_digit_separator(), false);
    assert_eq!(format.fraction_consecutive_digit_separator(), false);
    assert_eq!(format.exponent_consecutive_digit_separator(), false);
    assert_eq!(format.consecutive_digit_separator(), false);
    assert_eq!(format.special_digit_separator(), false);
}
fn test_cjk_compat_variants() {
    // These codepoints have singleton decompositions in the canonical
    // decomposition, and can use standardized variations.
    let s = "\u{2f999}\u{2f8a6}";

    // These codepoints have canonical decompositions.
    let mut nfd_iter = s.chars().nfd();
    assert_eq!(nfd_iter.next(), Some('\u{831d}'));
    assert_eq!(nfd_iter.next(), Some('\u{6148}'));
    assert_eq!(nfd_iter.next(), None);

    let mut nfkd_iter = s.chars().nfkd();
    assert_eq!(nfkd_iter.next(), Some('\u{831d}'));
    assert_eq!(nfkd_iter.next(), Some('\u{6148}'));
    assert_eq!(nfkd_iter.next(), None);

    let mut nfc_iter = s.chars().nfc();
    assert_eq!(nfc_iter.next(), Some('\u{831d}'));
    assert_eq!(nfc_iter.next(), Some('\u{6148}'));
    assert_eq!(nfc_iter.next(), None);

    let mut nfkc_iter = s.chars().nfkc();
    assert_eq!(nfkc_iter.next(), Some('\u{831d}'));
    assert_eq!(nfkc_iter.next(), Some('\u{6148}'));
    assert_eq!(nfkc_iter.next(), None);

    // However they also have standardized variants.
    let mut var_iter = s.chars().cjk_compat_variants();
    assert_eq!(var_iter.next(), Some('\u{831d}'));
    assert_eq!(var_iter.next(), Some('\u{fe00}'));
    assert_eq!(var_iter.next(), Some('\u{6148}'));
    assert_eq!(var_iter.next(), Some('\u{fe00}'));
    assert_eq!(var_iter.next(), None);

    // The standardized variants are normalization-stable.
    let mut var_nfc_iter = s.chars().cjk_compat_variants().nfc();
    assert_eq!(var_nfc_iter.next(), Some('\u{831d}'));
    assert_eq!(var_nfc_iter.next(), Some('\u{fe00}'));
    assert_eq!(var_nfc_iter.next(), Some('\u{6148}'));
    assert_eq!(var_nfc_iter.next(), Some('\u{fe00}'));
    assert_eq!(var_nfc_iter.next(), None);

    let mut var_nfd_iter = s.chars().cjk_compat_variants().nfd();
    assert_eq!(var_nfd_iter.next(), Some('\u{831d}'));
    assert_eq!(var_nfd_iter.next(), Some('\u{fe00}'));
    assert_eq!(var_nfd_iter.next(), Some('\u{6148}'));
    assert_eq!(var_nfd_iter.next(), Some('\u{fe00}'));
    assert_eq!(var_nfd_iter.next(), None);

    let mut var_nfkc_iter = s.chars().cjk_compat_variants().nfkc();
    assert_eq!(var_nfkc_iter.next(), Some('\u{831d}'));
    assert_eq!(var_nfkc_iter.next(), Some('\u{fe00}'));
    assert_eq!(var_nfkc_iter.next(), Some('\u{6148}'));
    assert_eq!(var_nfkc_iter.next(), Some('\u{fe00}'));
    assert_eq!(var_nfkc_iter.next(), None);

    let mut var_nfkd_iter = s.chars().cjk_compat_variants().nfkd();
    assert_eq!(var_nfkd_iter.next(), Some('\u{831d}'));
    assert_eq!(var_nfkd_iter.next(), Some('\u{fe00}'));
    assert_eq!(var_nfkd_iter.next(), Some('\u{6148}'));
    assert_eq!(var_nfkd_iter.next(), Some('\u{fe00}'));
    assert_eq!(var_nfkd_iter.next(), None);
}
fn test_rest_args() {
    fn sum(val: u32, rest: Rest<u32>) -> u32 {
        rest.iter().fold(val, |a, b| a + b)
    }

    let mut env = Environment::new();
    env.add_filter("sum", sum);
    assert_eq!(
        env.empty_state()
            .apply_filter("sum", args!(1, 2, 3, 4))
            .unwrap(),
        Value::from(1 + 2 + 3 + 4)
    );
}
fn invalid_decimal_point_test() {
    let mut builder = OptionsBuilder::default();
    builder = builder.decimal_point(b'\x00');
    assert!(!builder.is_valid());
    builder = builder.decimal_point(b'\x7f');
    assert!(!builder.is_valid());
    assert!(builder.build().is_err());
    builder = builder.decimal_point(b',');
    assert!(builder.is_valid());
    assert!(builder.build().is_ok());
}
fn version_negotiate_client() {
    let _guard = subscribe();
    let server_addr = "[::2]:7890".parse().unwrap();
    let cid_generator_factory: fn() -> Box<dyn ConnectionIdGenerator> =
        || Box::new(RandomConnectionIdGenerator::new(0));
    let mut client = Endpoint::new(
        Arc::new(EndpointConfig {
            connection_id_generator_factory: Arc::new(cid_generator_factory),
            ..Default::default()
        }),
        None,
        true,
    );
    let (_, mut client_ch) = client
        .connect(client_config(), server_addr, "localhost")
        .unwrap();
    let now = Instant::now();
    let opt_event = client.handle(
        now,
        server_addr,
        None,
        None,
        // Version negotiation packet for reserved version
        hex!(
            "80 00000000 04 00000000 04 00000000
             0a1a2a3a"
        )[..]
            .into(),
    );
    if let Some((_, DatagramEvent::ConnectionEvent(event))) = opt_event {
        client_ch.handle_event(event);
    }
    assert_matches!(
        client_ch.poll(),
        Some(Event::ConnectionLost {
            reason: ConnectionError::VersionMismatch,
        })
    );
}
fn as_f32_test() {
    assert_eq!(bf16::from_bits(1).as_f32(), 9.18355e-41f32);
    assert_eq!(bf16::ZERO.as_f32(), 0.0f32);
    assert_eq!(bf16::ZERO.to_bits(), 0);
    assert_eq!(bf16::ONE.as_f32(), 1.0f32);
    assert_eq!(bf16::ONE.to_bits(), (127 << 7));
    assert_eq!(bf16::TWO.as_f32(), 2.0f32);
    assert_eq!(bf16::TWO.to_bits(), (128 << 7));
    assert_eq!(bf16::from_bits(126 << 7).as_f32(), 0.5f32);
    assert!(bf16::NAN.as_f32().is_nan());
    assert!(bf16::INFINITY.as_f32().is_inf());
    assert!(bf16::NEG_INFINITY.as_f32().is_inf());
}
fn test_basic() {
    let env = create_env();
    let t = env.get_template("hello").unwrap();
    assert_eq!(t.render(()).unwrap(), "Hello World!");
}
fn test_macro_fuel() {
    let mut env = Environment::new();
    assert_eq!(env.fuel(), None);
    env.set_fuel(Some(100));
    assert_eq!(env.fuel(), Some(100));
    env.add_template(
        "test",
        "
        {% macro x() %}{% for item in range(5) %}...{% endfor %}{% endmacro %}
        {% for count in range(macros) %}{{ x() }}{% endfor %}
    ",
    )
    .unwrap();
    let t = env.get_template("test").unwrap();

    // this should succeed
    t.render(context!(macros => 3)).unwrap();

    // but running more macros should not
    let err = t.render(context!(macros => 5)).unwrap_err();
    assert_eq!(err.kind(), ErrorKind::OutOfFuel);
}
fn u32_pow2_test() {
    let values: &[u32] = &[
        0, 1, 2, 3, 4, 5, 7, 8, 9, 15, 16, 17, 31, 32, 33, 63, 64, 65, 127, 128, 129, 255, 256,
        257, 511, 512, 513, 1023, 1024, 1025, 2047, 2048, 2049, 4095, 4096, 4097, 8191, 8192, 8193,
        16383, 16384, 16385, 32767, 32768, 32769, 65535, 65536, 65537, 131071, 131072, 131073,
        262143, 262144, 262145, 524287, 524288, 524289, 1048575, 1048576, 1048577, 2097151,
        2097152, 2097153, 4194303, 4194304, 4194305, 8388607, 8388608, 8388609, 16777215, 16777216,
        16777217, 33554431, 33554432, 33554433, 67108863, 67108864, 67108865, 134217727, 134217728,
        134217729, 268435455, 268435456, 268435457, 536870911, 536870912, 536870913, 1073741823,
        1073741824, 1073741825, 2147483647, 2147483648, 2147483649, 4294967295,
    ];
    for &i in values.iter() {
        assert_eq!(i, roundtrip(i));
    }
}
fn test_skip_iter_il() {
    // Test iterators that skip single, internal or leading-only digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_internal_digit_separator(true)
        .integer_leading_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b"_.45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4_");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4__");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4_.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4__.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"455");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"_45_5");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".455");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b"_.45_5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"45_");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"4_5__");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"45_.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"4_5__.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"45_");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"_45__");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"45_.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"_45__.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"45_");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"_4_5__");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"45_.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"_4_5__.56");
}
fn test_streamsafe_regression(){
    let input = "\u{342}".repeat(55) + &"\u{344}".repeat(3);
    let nfc_ss = input.chars().nfc().stream_safe().collect::<String>();

    // The result should be NFC:
    assert!(is_nfc(&nfc_ss));
    // and should be stream-safe:
    assert!(is_nfc_stream_safe(&nfc_ss))
}
fn u16_pow10_test() {
    let values: &[u16] = &[
        0, 1, 5, 9, 10, 11, 15, 99, 100, 101, 105, 999, 1000, 1001, 1005, 9999, 10000, 10001, 10005,
    ];
    for &i in values.iter() {
        assert_eq!(i, roundtrip(i));
    }
}
fn as_f32_test() {
    assert_eq!(f16::from_bits(1).as_f32(), 0.000000059604645);
    assert_eq!(f16::ZERO.as_f32(), 0.0f32);
    assert_eq!(f16::ZERO.to_bits(), 0);
    assert_eq!(f16::ONE.as_f32(), 1.0f32);
    assert_eq!(f16::ONE.to_bits(), (15 << 10));
    assert_eq!(f16::TWO.as_f32(), 2.0f32);
    assert_eq!(f16::TWO.to_bits(), (16 << 10));
    assert_eq!(f16::from_bits(14 << 10).as_f32(), 0.5f32);
    assert!(f16::NAN.as_f32().is_nan());
    assert!(f16::INFINITY.as_f32().is_inf());
    assert!(f16::NEG_INFINITY.as_f32().is_inf());
}
fn draft_version_compat() {
    let _guard = subscribe();

    let mut client_config = client_config();
    client_config.version(0xff00_0020);

    let mut pair = Pair::default();
    let (client_ch, server_ch) = pair.connect_with(client_config);

    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);
    assert!(pair.client_conn_mut(client_ch).using_ecn());
    assert!(pair.server_conn_mut(server_ch).using_ecn());

    const REASON: &[u8] = b"whee";
    info!("closing");
    pair.client.connections.get_mut(&client_ch).unwrap().close(
        pair.time,
        VarInt(42),
        REASON.into(),
    );
    pair.drive();
    assert_matches!(pair.server_conn_mut(server_ch).poll(),
                    Some(Event::ConnectionLost { reason: ConnectionError::ApplicationClosed(
                        ApplicationClose { error_code: VarInt(42), ref reason }
                    )}) if reason == REASON);
    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);
    assert_eq!(pair.client.known_connections(), 0);
    assert_eq!(pair.client.known_cids(), 0);
    assert_eq!(pair.server.known_connections(), 0);
    assert_eq!(pair.server.known_cids(), 0);
}
fn invalid_exponent_test() {
    let mut builder = OptionsBuilder::default();
    builder = builder.exponent(b'\x00');
    assert!(!builder.is_valid());
    builder = builder.exponent(b'\x7f');
    assert!(!builder.is_valid());
    assert!(builder.build().is_err());
    builder = builder.exponent(b'^');
    assert!(builder.is_valid());
    assert!(builder.build().is_ok());
}
fn test_skip_iter_ilt() {
    // Test iterators that skip single digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_internal_digit_separator(true)
        .integer_leading_digit_separator(true)
        .integer_trailing_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b"_.45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4_");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4_.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"455");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"_45_5");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".455");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b"_.45_5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"4_5_");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"45.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"4_5_.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"_45_");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"45.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"_45_.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"_4_5_");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"45.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"_4_5_.56");
}
fn test_value_object_interface() {
    let val = Value::from_seq_object(vec![1u32, 2, 3, 4]);
    let seq = val.as_seq().unwrap();
    assert_eq!(seq.item_count(), 4);

    let obj = val.as_object().unwrap();
    let seq2 = match obj.kind() {
        ObjectKind::Seq(s) => s,
        _ => panic!("did not expect this"),
    };
    assert_eq!(seq2.item_count(), 4);
    assert_eq!(obj.to_string(), "[1, 2, 3, 4]");
}
fn test_skip_iter_ltc() {
    // Test iterators that skip multiple, leading or trailing digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_leading_digit_separator(true)
        .integer_trailing_digit_separator(true)
        .integer_consecutive_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"4__5");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"45_5");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"45__5");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".45_5");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b".45__5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"4__5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"4_5.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"4__5.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"45");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"45.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"45.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"4__5");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"4_5.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"4__5.56");
}
fn test_globals() {
    let mut env = Environment::new();
    env.add_global("a", Value::from(42));
    env.add_template("test", "{{ a }}").unwrap();
    let tmpl = env.get_template("test").unwrap();
    assert_eq!(tmpl.render(()).unwrap(), "42");
}
fn test_skip_iter_i() {
    // Test iterators that skip single, internal-only digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_internal_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"__45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b"_.45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b"__.45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4_");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4__");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4_.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4__.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"_455");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"__45_5");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b"_.455");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b"__.45_5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"45_");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"4_5__");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"45_.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"4_5__.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"_45_");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"__45__");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"_45_.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"__45__.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"_45_");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"__4_5__");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"_45_.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"__4_5__.56");
}
fn test_skip_iter_itc() {
    // Test iterators that skip multiple, internal or trailing digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_internal_digit_separator(true)
        .integer_trailing_digit_separator(true)
        .integer_consecutive_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"__45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"_455");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"__455");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".455");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b".455");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"45.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"45.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"__45");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"_45.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"__45.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"__45");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"_45.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"__45.56");
}
fn test_try_parse_8digits() {
    let parse = |bytes: &[u8]| {
        let mut digits = bytes.bytes::<{ STANDARD }>();
        algorithm::try_parse_8digits::<u64, _, STANDARD>(&mut digits.integer_iter())
    };

    assert_eq!(parse(b"12345678"), Some(12345678));
    assert_eq!(parse(b"1234567"), None);
    assert_eq!(parse(b"1234567\x00"), None);
    assert_eq!(parse(b"1234567."), None);
    assert_eq!(parse(b"1234567_"), None);
    assert_eq!(parse(b"12345678"), Some(12345678));
}
fn test_skip_iter_it() {
    // Test iterators that skip single, internal or trailing-only digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_internal_digit_separator(true)
        .integer_trailing_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"__45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b"_.45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4_");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4_.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"_455");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"__45_5");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".455");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b"_.45_5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"4_5_");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"45.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"4_5_.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"__45_");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"_45.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"__45_.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"__4_5_");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"_45.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"__4_5_.56");
}
fn u64_pow10_test() {
    let values: &[u64] = &[
        0,
        1,
        5,
        9,
        10,
        11,
        15,
        99,
        100,
        101,
        105,
        999,
        1000,
        1001,
        1005,
        9999,
        10000,
        10001,
        10005,
        99999,
        100000,
        100001,
        100005,
        999999,
        1000000,
        1000001,
        1000005,
        9999999,
        10000000,
        10000001,
        10000005,
        99999999,
        100000000,
        100000001,
        100000005,
        999999999,
        1000000000,
        1000000001,
        1000000005,
        9999999999,
        10000000000,
        10000000001,
        10000000005,
        99999999999,
        100000000000,
        100000000001,
        100000000005,
        999999999999,
        1000000000000,
        1000000000001,
        1000000000005,
        9999999999999,
        10000000000000,
        10000000000001,
        10000000000005,
        99999999999999,
        100000000000000,
        100000000000001,
        100000000000005,
        999999999999999,
        1000000000000000,
        1000000000000001,
        1000000000000005,
        9999999999999999,
        10000000000000000,
        10000000000000001,
        10000000000000005,
        99999999999999999,
        100000000000000000,
        100000000000000001,
        100000000000000005,
        999999999999999999,
        1000000000000000000,
        1000000000000000001,
        1000000000000000005,
    ];
    for &i in values.iter() {
        assert_eq!(i, roundtrip(i));
    }
}
fn from_f32_test() {
    assert_eq!(f16::from_f32(2.980232e-08).to_bits(), 0);
    assert_eq!(f16::from_f32(2.9802322e-08).to_bits(), 0);
    assert_eq!(f16::from_f32(2.9802326e-08).to_bits(), 1);
    assert_eq!(f16::from_f32(5.960464e-08).to_bits(), 1);
    assert_eq!(f16::from_f32(5.9604645e-08).to_bits(), 1);
    assert_eq!(f16::from_f32(5.960465e-08).to_bits(), 1);
    assert!(f16::from_f32(f32::NAN).is_nan());
    assert!(f16::from_f32(f32::INFINITY).is_inf());
    assert!(f16::from_f32(f32::NEG_INFINITY).is_inf());
}
fn test_undefined_roundtrip() {
    let v = Value::UNDEFINED;
    let v2 = Value::from_serializable(&v);
    assert!(v.is_undefined());
    assert!(v2.is_undefined());
}
fn from_f32_test() {
    assert_eq!(bf16::from_f32(4.5917e-41f32).to_bits(), 0);
    assert_eq!(bf16::from_f32(4.5918e-41f32).to_bits(), 0);
    assert_eq!(bf16::from_f32(4.5919e-41f32).to_bits(), 1);
    assert_eq!(bf16::from_f32(9.18354e-41f32).to_bits(), 1);
    assert_eq!(bf16::from_f32(9.18355e-41f32).to_bits(), 1);
    assert_eq!(bf16::from_f32(9.18356e-41f32).to_bits(), 1);
    assert_eq!(bf16::from_f32(1.37752e-40f32).to_bits(), 1);
    assert_eq!(bf16::from_f32(1.37753e-40f32).to_bits(), 2);
    assert_eq!(bf16::from_f32(1.37754e-40f32).to_bits(), 2);
    assert!(bf16::from_f32(f32::NAN).is_nan());
    assert!(bf16::from_f32(f32::INFINITY).is_inf());
    assert!(bf16::from_f32(f32::NEG_INFINITY).is_inf());
}
fn test_basic() {
    let mut env = Environment::new();
    assert_eq!(env.fuel(), None);
    env.set_fuel(Some(100));
    assert_eq!(env.fuel(), Some(100));
    env.add_template("test", "{% for x in seq %}{{ x }}\n{% endfor %}")
        .unwrap();
    let t = env.get_template("test").unwrap();

    // this will still manage to run with 100 fuel
    let rv = t
        .render(context!(seq => (0..15).collect::<Vec<_>>()))
        .unwrap();
    assert_eq!(rv.lines().count(), 15);

    // this is above the limit
    let rv = t
        .render(context!(seq => (0..20).collect::<Vec<_>>()))
        .unwrap_err();
    assert_eq!(rv.kind(), ErrorKind::OutOfFuel);
}
fn u32_pow10_test() {
    let values: &[u32] = &[
        0, 1, 5, 9, 10, 11, 15, 99, 100, 101, 105, 999, 1000, 1001, 1005, 9999, 10000, 10001,
        10005, 99999, 100000, 100001, 100005, 999999, 1000000, 1000001, 1000005, 9999999, 10000000,
        10000001, 10000005, 99999999, 100000000, 100000001, 100000005, 999999999, 1000000000,
        1000000001, 1000000005,
    ];
    for &i in values.iter() {
        assert_eq!(i, roundtrip(i));
    }
}
fn test_serialize_nested_enum() {
    #[derive(Serialize, Debug)]
    enum Outer {
        Inner(Inner),
    }
    #[derive(Serialize, Debug)]
    enum Inner {
        Newtype(usize),
        Tuple(usize, usize),
        Struct { x: usize },
    }

    let expected = "serializing nested enums in YAML is not supported yet";

    let e = Outer::Inner(Inner::Newtype(0));
    let error = serde_yaml::to_string(&e).unwrap_err();
    assert_eq!(error.to_string(), expected);

    let e = Outer::Inner(Inner::Tuple(0, 0));
    let error = serde_yaml::to_string(&e).unwrap_err();
    assert_eq!(error.to_string(), expected);

    let e = Outer::Inner(Inner::Struct { x: 0 });
    let error = serde_yaml::to_string(&e).unwrap_err();
    assert_eq!(error.to_string(), expected);

    let e = Value::Tagged(Box::new(TaggedValue {
        tag: Tag::new("Outer"),
        value: Value::Tagged(Box::new(TaggedValue {
            tag: Tag::new("Inner"),
            value: Value::Null,
        })),
    }));
    let error = serde_yaml::to_string(&e).unwrap_err();
    assert_eq!(error.to_string(), expected);
}
fn take_till0_issue() {
    use winnow::token::take_till0;

    fn nothing(i: Partial<&[u8]>) -> IResult<Partial<&[u8]>, &[u8]> {
        take_till0(|_| true).parse_peek(i)
    }

    assert_eq!(
        nothing(Partial::new(b"")),
        Err(ErrMode::Incomplete(Needed::new(1)))
    );
    assert_eq!(
        nothing(Partial::new(b"abc")),
        Ok((Partial::new(&b"abc"[..]), &b""[..]))
    );
}
fn reset_stream() {
    let _guard = subscribe();
    let mut pair = Pair::default();
    let (client_ch, server_ch) = pair.connect();

    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();

    const MSG: &[u8] = b"hello";
    pair.client_send(client_ch, s).write(MSG).unwrap();
    pair.drive();

    info!("resetting stream");
    const ERROR: VarInt = VarInt(42);
    pair.client_send(client_ch, s).reset(ERROR).unwrap();
    pair.drive();

    assert_matches!(
        pair.server_conn_mut(server_ch).poll(),
        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))
    );
    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);
    let mut recv = pair.server_recv(server_ch, s);
    let mut chunks = recv.read(false).unwrap();
    assert_matches!(chunks.next(usize::MAX), Err(ReadError::Reset(ERROR)));
    let _ = chunks.finalize();
    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);
}
fn test_parse_self_debug_pubnames() {
    let debug_info = read_section("debug_info");
    let debug_info = DebugInfo::new(&debug_info, LittleEndian);

    let debug_abbrev = read_section("debug_abbrev");
    let debug_abbrev = DebugAbbrev::new(&debug_abbrev, LittleEndian);

    let debug_pubnames = read_section("debug_pubnames");
    let debug_pubnames = DebugPubNames::new(&debug_pubnames, LittleEndian);

    let mut units = HashMap::new();
    let mut abbrevs = HashMap::new();
    let mut pubnames = debug_pubnames.items();
    while let Some(entry) = pubnames.next().expect("Should parse pubname OK") {
        let unit_offset = entry.unit_header_offset();
        let unit = units.entry(unit_offset).or_insert_with(|| {
            debug_info
                .header_from_offset(unit_offset)
                .expect("Should parse unit header OK")
        });
        let abbrev_offset = unit.debug_abbrev_offset();
        let abbrevs = abbrevs.entry(abbrev_offset).or_insert_with(|| {
            debug_abbrev
                .abbreviations(abbrev_offset)
                .expect("Should parse abbreviations OK")
        });
        let mut cursor = unit
            .entries_at_offset(abbrevs, entry.die_offset())
            .expect("DIE offset should be valid");
        assert!(cursor.next_dfs().expect("Should parse DIE").is_some());
    }
}
fn u128toa_test() {
    let mut buffer = [b'\x00'; 48];
    unsafe {
        assert_eq!(5u128.decimal(&mut buffer), 1);
        assert_eq!(&buffer[..1], b"5");

        assert_eq!(11u128.decimal(&mut buffer), 2);
        assert_eq!(&buffer[..2], b"11");

        assert_eq!(99u128.decimal(&mut buffer), 2);
        assert_eq!(&buffer[..2], b"99");

        assert_eq!(101u128.decimal(&mut buffer), 3);
        assert_eq!(&buffer[..3], b"101");

        assert_eq!(999u128.decimal(&mut buffer), 3);
        assert_eq!(&buffer[..3], b"999");

        assert_eq!(1001u128.decimal(&mut buffer), 4);
        assert_eq!(&buffer[..4], b"1001");

        assert_eq!(9999u128.decimal(&mut buffer), 4);
        assert_eq!(&buffer[..4], b"9999");

        assert_eq!(10001u128.decimal(&mut buffer), 5);
        assert_eq!(&buffer[..5], b"10001");

        assert_eq!(65535u128.decimal(&mut buffer), 5);
        assert_eq!(&buffer[..5], b"65535");

        assert_eq!(99999u128.decimal(&mut buffer), 5);
        assert_eq!(&buffer[..5], b"99999");

        assert_eq!(100001u128.decimal(&mut buffer), 6);
        assert_eq!(&buffer[..6], b"100001");

        assert_eq!(999999u128.decimal(&mut buffer), 6);
        assert_eq!(&buffer[..6], b"999999");

        assert_eq!(1000001u128.decimal(&mut buffer), 7);
        assert_eq!(&buffer[..7], b"1000001");

        assert_eq!(9999999u128.decimal(&mut buffer), 7);
        assert_eq!(&buffer[..7], b"9999999");

        assert_eq!(10000001u128.decimal(&mut buffer), 8);
        assert_eq!(&buffer[..8], b"10000001");

        assert_eq!(99999999u128.decimal(&mut buffer), 8);
        assert_eq!(&buffer[..8], b"99999999");

        assert_eq!(100000001u128.decimal(&mut buffer), 9);
        assert_eq!(&buffer[..9], b"100000001");

        assert_eq!(999999999u128.decimal(&mut buffer), 9);
        assert_eq!(&buffer[..9], b"999999999");

        assert_eq!(1000000001u128.decimal(&mut buffer), 10);
        assert_eq!(&buffer[..10], b"1000000001");

        assert_eq!(9999999999u128.decimal(&mut buffer), 10);
        assert_eq!(&buffer[..10], b"9999999999");

        assert_eq!(10000000001u128.decimal(&mut buffer), 11);
        assert_eq!(&buffer[..11], b"10000000001");

        assert_eq!(99999999999u128.decimal(&mut buffer), 11);
        assert_eq!(&buffer[..11], b"99999999999");

        assert_eq!(100000000001u128.decimal(&mut buffer), 12);
        assert_eq!(&buffer[..12], b"100000000001");

        assert_eq!(999999999999u128.decimal(&mut buffer), 12);
        assert_eq!(&buffer[..12], b"999999999999");

        assert_eq!(1000000000001u128.decimal(&mut buffer), 13);
        assert_eq!(&buffer[..13], b"1000000000001");

        assert_eq!(9999999999999u128.decimal(&mut buffer), 13);
        assert_eq!(&buffer[..13], b"9999999999999");

        assert_eq!(10000000000001u128.decimal(&mut buffer), 14);
        assert_eq!(&buffer[..14], b"10000000000001");

        assert_eq!(99999999999999u128.decimal(&mut buffer), 14);
        assert_eq!(&buffer[..14], b"99999999999999");

        assert_eq!(100000000000001u128.decimal(&mut buffer), 15);
        assert_eq!(&buffer[..15], b"100000000000001");

        assert_eq!(999999999999999u128.decimal(&mut buffer), 15);
        assert_eq!(&buffer[..15], b"999999999999999");

        assert_eq!(1000000000000001u128.decimal(&mut buffer), 16);
        assert_eq!(&buffer[..16], b"1000000000000001");

        assert_eq!(9999999999999999u128.decimal(&mut buffer), 16);
        assert_eq!(&buffer[..16], b"9999999999999999");

        assert_eq!(10000000000000001u128.decimal(&mut buffer), 17);
        assert_eq!(&buffer[..17], b"10000000000000001");

        assert_eq!(99999999999999999u128.decimal(&mut buffer), 17);
        assert_eq!(&buffer[..17], b"99999999999999999");

        assert_eq!(100000000000000001u128.decimal(&mut buffer), 18);
        assert_eq!(&buffer[..18], b"100000000000000001");

        assert_eq!(999999999999999999u128.decimal(&mut buffer), 18);
        assert_eq!(&buffer[..18], b"999999999999999999");

        assert_eq!(1000000000000000001u128.decimal(&mut buffer), 19);
        assert_eq!(&buffer[..19], b"1000000000000000001");

        assert_eq!(9999999999999999999u128.decimal(&mut buffer), 19);
        assert_eq!(&buffer[..19], b"9999999999999999999");

        assert_eq!(10000000000000000001u128.decimal(&mut buffer), 20);
        assert_eq!(&buffer[..20], b"10000000000000000001");

        assert_eq!(999999999999999999999999u128.decimal(&mut buffer), 24);
        assert_eq!(&buffer[..24], b"999999999999999999999999");

        assert_eq!(1000000000000000000000001u128.decimal(&mut buffer), 25);
        assert_eq!(&buffer[..25], b"1000000000000000000000001");

        assert_eq!(66620387370000000000000000000u128.decimal(&mut buffer), 29);
        assert_eq!(&buffer[..29], b"66620387370000000000000000000");

        assert_eq!(99999999999999999999999999999u128.decimal(&mut buffer), 29);
        assert_eq!(&buffer[..29], b"99999999999999999999999999999");

        assert_eq!(100000000000000000000000000001u128.decimal(&mut buffer), 30);
        assert_eq!(&buffer[..30], b"100000000000000000000000000001");

        assert_eq!(9999999999999999999999999999999999u128.decimal(&mut buffer), 34);
        assert_eq!(&buffer[..34], b"9999999999999999999999999999999999");

        assert_eq!(10000000000000000000000000000000001u128.decimal(&mut buffer), 35);
        assert_eq!(&buffer[..35], b"10000000000000000000000000000000001");

        assert_eq!(340282366920938463463374607431768211455u128.decimal(&mut buffer), 39);
        assert_eq!(&buffer[..39], b"340282366920938463463374607431768211455");
    }
}
fn test_normalization_tests_unaffected() {
    for test in NORMALIZATION_TESTS {
        for &s in &[test.source, test.nfc, test.nfd, test.nfkc, test.nfkd] {
            assert_eq!(stream_safe(s), s);
        }
    }
}
fn test_dynamic() {
    let mut env = Environment::new();
    let template = String::from("Hello World 2!");
    env.add_template_owned("hello2", template).unwrap();
    env.set_loader(|name| match name {
        "hello" => Ok(Some("Hello World!".into())),
        _ => Ok(None),
    });
    let t = env.get_template("hello").unwrap();
    assert_eq!(t.render(()).unwrap(), "Hello World!");
    let t = env.get_template("hello2").unwrap();
    assert_eq!(t.render(()).unwrap(), "Hello World 2!");
    let err = env.get_template("missing").unwrap_err();
    assert_eq!(
        err.to_string(),
        "template not found: template \"missing\" does not exist"
    );
}
fn test_something() {
    let data = [];
    if data.len() > 0 {
        match Utf8Char::from_slice_start(data) {
            Err(_) => assert!(std::str::from_utf8(data).is_err()),
            Ok((c, len)) => assert_eq!(c.as_str(), std::str::from_utf8(&data[..len]).unwrap()),
        }
    }
}
fn test_context() {
    let var1 = 23;
    let ctx = context!(var1, var2 => 42);
    assert_eq!(ctx.get_attr("var1").unwrap(), Value::from(23));
    assert_eq!(ctx.get_attr("var2").unwrap(), Value::from(42));
}
fn test_clone() {
    let mut env = Environment::new();
    env.add_template("test", "a").unwrap();
    let mut env2 = env.clone();
    assert_eq!(env2.get_template("test").unwrap().render(()).unwrap(), "a");
    env2.add_template("test", "b").unwrap();
    assert_eq!(env2.get_template("test").unwrap().render(()).unwrap(), "b");
    assert_eq!(env.get_template("test").unwrap().render(()).unwrap(), "a");
}
fn client_stateless_reset() {
    let _guard = subscribe();
    let mut reset_key = vec![0; 64];
    let mut rng = rand::thread_rng();
    rng.fill_bytes(&mut reset_key);
    let reset_key = hmac::Key::new(hmac::HMAC_SHA256, &reset_key);

    let endpoint_config = Arc::new(EndpointConfig::new(Arc::new(reset_key)));

    let mut pair = Pair::new(endpoint_config.clone(), server_config());
    let (_, server_ch) = pair.connect();
    pair.client.endpoint = Endpoint::new(endpoint_config, Some(Arc::new(server_config())), true);
    // Send something big enough to allow room for a smaller stateless reset.
    pair.server.connections.get_mut(&server_ch).unwrap().close(
        pair.time,
        VarInt(42),
        (&[0xab; 128][..]).into(),
    );
    info!("resetting");
    pair.drive();
    assert_matches!(
        pair.server_conn_mut(server_ch).poll(),
        Some(Event::ConnectionLost {
            reason: ConnectionError::Reset
        })
    );
}
fn test_value_as_bytes() {
    assert_eq!(Value::from("foo").as_bytes(), Some(&b"foo"[..]));
    assert_eq!(Value::from(&b"foo"[..]).as_bytes(), Some(&b"foo"[..]));
}
fn u32toa_test() {
    let mut buffer = [b'\x00'; 16];
    unsafe {
        assert_eq!(5u32.decimal(&mut buffer), 1);
        assert_eq!(&buffer[..1], b"5");

        assert_eq!(11u32.decimal(&mut buffer), 2);
        assert_eq!(&buffer[..2], b"11");

        assert_eq!(99u32.decimal(&mut buffer), 2);
        assert_eq!(&buffer[..2], b"99");

        assert_eq!(101u32.decimal(&mut buffer), 3);
        assert_eq!(&buffer[..3], b"101");

        assert_eq!(999u32.decimal(&mut buffer), 3);
        assert_eq!(&buffer[..3], b"999");

        assert_eq!(1001u32.decimal(&mut buffer), 4);
        assert_eq!(&buffer[..4], b"1001");

        assert_eq!(9999u32.decimal(&mut buffer), 4);
        assert_eq!(&buffer[..4], b"9999");

        assert_eq!(10001u32.decimal(&mut buffer), 5);
        assert_eq!(&buffer[..5], b"10001");

        assert_eq!(65535u32.decimal(&mut buffer), 5);
        assert_eq!(&buffer[..5], b"65535");

        assert_eq!(99999u32.decimal(&mut buffer), 5);
        assert_eq!(&buffer[..5], b"99999");

        assert_eq!(100001u32.decimal(&mut buffer), 6);
        assert_eq!(&buffer[..6], b"100001");

        assert_eq!(999999u32.decimal(&mut buffer), 6);
        assert_eq!(&buffer[..6], b"999999");

        assert_eq!(1000001u32.decimal(&mut buffer), 7);
        assert_eq!(&buffer[..7], b"1000001");

        assert_eq!(9999999u32.decimal(&mut buffer), 7);
        assert_eq!(&buffer[..7], b"9999999");

        assert_eq!(10000001u32.decimal(&mut buffer), 8);
        assert_eq!(&buffer[..8], b"10000001");

        assert_eq!(99999999u32.decimal(&mut buffer), 8);
        assert_eq!(&buffer[..8], b"99999999");

        assert_eq!(100000001u32.decimal(&mut buffer), 9);
        assert_eq!(&buffer[..9], b"100000001");

        assert_eq!(999999999u32.decimal(&mut buffer), 9);
        assert_eq!(&buffer[..9], b"999999999");

        assert_eq!(1000000001u32.decimal(&mut buffer), 10);
        assert_eq!(&buffer[..10], b"1000000001");

        assert_eq!(4294967295u32.decimal(&mut buffer), 10);
        assert_eq!(&buffer[..10], b"4294967295");
    }
}
fn read_lines_test() {
    let res = Ok(("", vec!["Duck", "Dog", "Cow"]));

    assert_eq!(read_lines("Duck\nDog\nCow\n"), res);
    assert_eq!(read_lines("Duck\nDog\nCow"), res);
}
fn test_public_assigned() {
    // Misc assigned.
    assert!(is_public_assigned('\0'));
    assert!(is_public_assigned('a'));
    assert!(is_public_assigned('\u{7f}'));
    assert!(is_public_assigned('\u{80}'));
    assert!(!is_public_assigned('\u{9e4}'));

    // Around the first unassigned non-private-use.
    assert!(is_public_assigned('\u{377}'));
    assert!(!is_public_assigned('\u{378}'));
    assert!(!is_public_assigned('\u{379}'));
    assert!(is_public_assigned('\u{37a}'));
    assert!(is_public_assigned('\u{37f}'));

    // Around the last assigned non-private-use.
    assert!(!is_public_assigned('\u{e00ff}'));
    assert!(is_public_assigned('\u{e0100}'));
    assert!(is_public_assigned('\u{e01ef}'));
    assert!(!is_public_assigned('\u{e01f0}'));

    // Private-Use areas
    assert!(!is_public_assigned('\u{e000}'));
    assert!(!is_public_assigned('\u{f8ff}'));
    assert!(!is_public_assigned('\u{f0000}'));
    assert!(!is_public_assigned('\u{ffffd}'));
    assert!(!is_public_assigned('\u{100000}'));
    assert!(!is_public_assigned('\u{10fffd}'));

    // Noncharacters are considered unassigned.
    assert!(!is_public_assigned('\u{fdd0}'));
    assert!(!is_public_assigned('\u{fdef}'));
    assert!(!is_public_assigned('\u{fffe}'));
    assert!(!is_public_assigned('\u{ffff}'));
    assert!(!is_public_assigned('\u{1fffe}'));
    assert!(!is_public_assigned('\u{1ffff}'));
    assert!(!is_public_assigned('\u{2fffe}'));
    assert!(!is_public_assigned('\u{2ffff}'));
    assert!(!is_public_assigned('\u{3fffe}'));
    assert!(!is_public_assigned('\u{3ffff}'));
    assert!(!is_public_assigned('\u{4fffe}'));
    assert!(!is_public_assigned('\u{4ffff}'));
    assert!(!is_public_assigned('\u{5fffe}'));
    assert!(!is_public_assigned('\u{5ffff}'));
    assert!(!is_public_assigned('\u{6fffe}'));
    assert!(!is_public_assigned('\u{6ffff}'));
    assert!(!is_public_assigned('\u{7fffe}'));
    assert!(!is_public_assigned('\u{7ffff}'));
    assert!(!is_public_assigned('\u{8fffe}'));
    assert!(!is_public_assigned('\u{8ffff}'));
    assert!(!is_public_assigned('\u{9fffe}'));
    assert!(!is_public_assigned('\u{9ffff}'));
    assert!(!is_public_assigned('\u{afffe}'));
    assert!(!is_public_assigned('\u{affff}'));
    assert!(!is_public_assigned('\u{bfffe}'));
    assert!(!is_public_assigned('\u{bffff}'));
    assert!(!is_public_assigned('\u{cfffe}'));
    assert!(!is_public_assigned('\u{cffff}'));
    assert!(!is_public_assigned('\u{dfffe}'));
    assert!(!is_public_assigned('\u{dffff}'));
    assert!(!is_public_assigned('\u{efffe}'));
    assert!(!is_public_assigned('\u{effff}'));
    assert!(!is_public_assigned('\u{ffffe}'));
    assert!(!is_public_assigned('\u{fffff}'));
    assert!(!is_public_assigned('\u{10fffe}'));
    assert!(!is_public_assigned('\u{10ffff}'));

    // Several ranges are defined by "<..., First>" and "<..., Last>" pairs in
    // UnicodeData.txt:

    // CJK Ideograph Extension A
    assert!(is_public_assigned('\u{3400}'));
    assert!(is_public_assigned('\u{4dbf}'));

    // CJK Ideograph
    assert!(is_public_assigned('\u{4e00}'));
    assert!(is_public_assigned('\u{9ffc}'));

    // Hangul Syllable
    assert!(is_public_assigned('\u{ac00}'));
    assert!(is_public_assigned('\u{d7a3}'));

    // Tangut Ideograph
    assert!(is_public_assigned('\u{17000}'));
    assert!(is_public_assigned('\u{187f7}'));

    // Tangut Ideograph Supplement
    assert!(is_public_assigned('\u{18d00}'));
    assert!(is_public_assigned('\u{18d08}'));

    // CJK Ideograph Extension B
    assert!(is_public_assigned('\u{20000}'));
    assert!(is_public_assigned('\u{2a6dd}'));

    // CJK Ideograph Extension C
    assert!(is_public_assigned('\u{2a700}'));
    assert!(is_public_assigned('\u{2b734}'));

    // CJK Ideograph Extension D
    assert!(is_public_assigned('\u{2b740}'));
    assert!(is_public_assigned('\u{2b81d}'));

    // CJK Ideograph Extension E
    assert!(is_public_assigned('\u{2b820}'));
    assert!(is_public_assigned('\u{2cea1}'));

    // CJK Ideograph Extension F
    assert!(is_public_assigned('\u{2ceb0}'));
    assert!(is_public_assigned('\u{2ebe0}'));

    // CJK Ideograph Extension G
    assert!(is_public_assigned('\u{30000}'));
    assert!(is_public_assigned('\u{3134a}'));
}
fn finish_stream_simple() {
    let _guard = subscribe();
    let mut pair = Pair::default();
    let (client_ch, server_ch) = pair.connect();

    let s = pair.client_streams(client_ch).open(Dir::Uni).unwrap();

    const MSG: &[u8] = b"hello";
    pair.client_send(client_ch, s).write(MSG).unwrap();
    assert_eq!(pair.client_streams(client_ch).send_streams(), 1);
    pair.client_send(client_ch, s).finish().unwrap();
    pair.drive();

    assert_matches!(
        pair.client_conn_mut(client_ch).poll(),
        Some(Event::Stream(StreamEvent::Finished { id })) if id == s
    );
    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);
    assert_eq!(pair.client_streams(client_ch).send_streams(), 0);
    assert_eq!(pair.server_conn_mut(client_ch).streams().send_streams(), 0);
    assert_matches!(
        pair.server_conn_mut(server_ch).poll(),
        Some(Event::Stream(StreamEvent::Opened { dir: Dir::Uni }))
    );
    // Receive-only streams do not get `StreamFinished` events
    assert_eq!(pair.server_conn_mut(client_ch).streams().send_streams(), 0);
    assert_matches!(pair.server_streams(server_ch).accept(Dir::Uni), Some(stream) if stream == s);
    assert_matches!(pair.server_conn_mut(server_ch).poll(), None);

    let mut recv = pair.server_recv(server_ch, s);
    let mut chunks = recv.read(false).unwrap();
    assert_matches!(
        chunks.next(usize::MAX),
        Ok(Some(chunk)) if chunk.offset == 0 && chunk.bytes == MSG
    );
    assert_matches!(chunks.next(usize::MAX), Ok(None));
    let _ = chunks.finalize();
}
fn issue_655() {
    use winnow::ascii::{line_ending, not_line_ending};
    fn twolines(i: Partial<&str>) -> IResult<Partial<&str>, (&str, &str)> {
        let (i, l1) = not_line_ending.parse_peek(i)?;
        let (i, _) = line_ending.parse_peek(i)?;
        let (i, l2) = not_line_ending.parse_peek(i)?;
        let (i, _) = line_ending.parse_peek(i)?;

        Ok((i, (l1, l2)))
    }

    assert_eq!(
        twolines(Partial::new("foo\nbar\n")),
        Ok((Partial::new(""), ("foo", "bar")))
    );
    assert_eq!(
        twolines(Partial::new("féo\nbar\n")),
        Ok((Partial::new(""), ("féo", "bar")))
    );
    assert_eq!(
        twolines(Partial::new("foé\nbar\n")),
        Ok((Partial::new(""), ("foé", "bar")))
    );
    assert_eq!(
        twolines(Partial::new("foé\r\nbar\n")),
        Ok((Partial::new(""), ("foé", "bar")))
    );
}

#[cf
fn test_strict_undefined() {
    let mut env = Environment::new();
    env.set_undefined_behavior(UndefinedBehavior::Strict);
    env.add_filter("test", |_state: &State, _value: String| -> String {
        panic!("filter must not be called");
    });

    assert_eq!(
        env.render_str("{{ true.missing_attribute }}", ())
            .unwrap_err()
            .kind(),
        ErrorKind::UndefinedError
    );
    assert_eq!(
        env.render_str("{{ undefined.missing_attribute }}", ())
            .unwrap_err()
            .kind(),
        ErrorKind::UndefinedError
    );
    assert_eq!(
        env.render_str("<{% for x in undefined %}...{% endfor %}>", ())
            .unwrap_err()
            .kind(),
        ErrorKind::UndefinedError
    );
    assert_eq!(
        env.render_str("<{{ undefined }}>", ()).unwrap_err().kind(),
        ErrorKind::UndefinedError
    );
    assert_eq!(render!(in env, "{{ undefined is undefined }}"), "true");
    assert_eq!(
        env.render_str("{{ undefined|list }}", ())
            .unwrap_err()
            .kind(),
        ErrorKind::InvalidOperation
    );
    assert_eq!(
        env.render_str("{{ undefined|test }}", ())
            .unwrap_err()
            .kind(),
        ErrorKind::UndefinedError
    );
    assert_eq!(
        env.render_str("{{ 42 in undefined }}", ())
            .unwrap_err()
            .kind(),
        ErrorKind::UndefinedError
    );
}
fn u8_pow10_test() {
    let values: &[u8] = &[0, 1, 5, 9, 10, 11, 15, 99, 100, 101, 105];
    for &i in values.iter() {
        assert_eq!(i, roundtrip(i));
    }
}
fn lifecycle() {
    let _guard = subscribe();
    let mut pair = Pair::default();
    let (client_ch, server_ch) = pair.connect();
    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);
    assert!(pair.client_conn_mut(client_ch).using_ecn());
    assert!(pair.server_conn_mut(server_ch).using_ecn());

    const REASON: &[u8] = b"whee";
    info!("closing");
    pair.client.connections.get_mut(&client_ch).unwrap().close(
        pair.time,
        VarInt(42),
        REASON.into(),
    );
    pair.drive();
    assert_matches!(pair.server_conn_mut(server_ch).poll(),
                    Some(Event::ConnectionLost { reason: ConnectionError::ApplicationClosed(
                        ApplicationClose { error_code: VarInt(42), ref reason }
                    )}) if reason == REASON);
    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);
    assert_eq!(pair.client.known_connections(), 0);
    assert_eq!(pair.client.known_cids(), 0);
    assert_eq!(pair.server.known_connections(), 0);
    assert_eq!(pair.server.known_cids(), 0);
}
fn test_referenced_names_empty_bug() {
    let c = CodeGenerator::new("<unknown>", "");
    let instructions = c.finish().0;
    let rv = instructions.get_referenced_names(0);
    assert!(rv.is_empty());
}
fn test_keep_trailing_newlines() {
    let mut env = Environment::new();
    env.add_template("foo.txt", "blub\r\n").unwrap();
    assert_eq!(env.render_str("blub\r\n", ()).unwrap(), "blub");

    env.set_keep_trailing_newline(true);
    env.add_template("foo_keep.txt", "blub\r\n").unwrap();
    assert_eq!(
        env.get_template("foo.txt").unwrap().render(()).unwrap(),
        "blub"
    );
    assert_eq!(
        env.get_template("foo_keep.txt")
            .unwrap()
            .render(())
            .unwrap(),
        "blub\r\n"
    );
    assert_eq!(env.render_str("blub\r\n", ()).unwrap(), "blub\r\n");
}
fn test_filter_basics() {
    fn test(a: u32, b: u32) -> Result<u32, Error> {
        Ok(a + b)
    }

    let mut env = Environment::new();
    env.add_filter("test", test);
    assert_eq!(
        env.empty_state()
            .apply_filter("test", args!(23, 42))
            .unwrap(),
        Value::from(65)
    );
}
fn u64_pow2_test() {
    let values: &[u64] = &[
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        8,
        9,
        15,
        16,
        17,
        31,
        32,
        33,
        63,
        64,
        65,
        127,
        128,
        129,
        255,
        256,
        257,
        511,
        512,
        513,
        1023,
        1024,
        1025,
        2047,
        2048,
        2049,
        4095,
        4096,
        4097,
        8191,
        8192,
        8193,
        16383,
        16384,
        16385,
        32767,
        32768,
        32769,
        65535,
        65536,
        65537,
        131071,
        131072,
        131073,
        262143,
        262144,
        262145,
        524287,
        524288,
        524289,
        1048575,
        1048576,
        1048577,
        2097151,
        2097152,
        2097153,
        4194303,
        4194304,
        4194305,
        8388607,
        8388608,
        8388609,
        16777215,
        16777216,
        16777217,
        33554431,
        33554432,
        33554433,
        67108863,
        67108864,
        67108865,
        134217727,
        134217728,
        134217729,
        268435455,
        268435456,
        268435457,
        536870911,
        536870912,
        536870913,
        1073741823,
        1073741824,
        1073741825,
        2147483647,
        2147483648,
        2147483649,
        4294967295,
        4294967296,
        4294967297,
        8589934591,
        8589934592,
        8589934593,
        17179869183,
        17179869184,
        17179869185,
        34359738367,
        34359738368,
        34359738369,
        68719476735,
        68719476736,
        68719476737,
        137438953471,
        137438953472,
        137438953473,
        274877906943,
        274877906944,
        274877906945,
        549755813887,
        549755813888,
        549755813889,
        1099511627775,
        1099511627776,
        1099511627777,
        2199023255551,
        2199023255552,
        2199023255553,
        4398046511103,
        4398046511104,
        4398046511105,
        8796093022207,
        8796093022208,
        8796093022209,
        17592186044415,
        17592186044416,
        17592186044417,
        35184372088831,
        35184372088832,
        35184372088833,
        70368744177663,
        70368744177664,
        70368744177665,
        140737488355327,
        140737488355328,
        140737488355329,
        281474976710655,
        281474976710656,
        281474976710657,
        562949953421311,
        562949953421312,
        562949953421313,
        1125899906842623,
        1125899906842624,
        1125899906842625,
        2251799813685247,
        2251799813685248,
        2251799813685249,
        4503599627370495,
        4503599627370496,
        4503599627370497,
        9007199254740991,
        9007199254740992,
        9007199254740993,
        18014398509481983,
        18014398509481984,
        18014398509481985,
        36028797018963967,
        36028797018963968,
        36028797018963969,
        72057594037927935,
        72057594037927936,
        72057594037927937,
        144115188075855871,
        144115188075855872,
        144115188075855873,
        288230376151711743,
        288230376151711744,
        288230376151711745,
        576460752303423487,
        576460752303423488,
        576460752303423489,
        1152921504606846975,
        1152921504606846976,
        1152921504606846977,
        2305843009213693951,
        2305843009213693952,
        2305843009213693953,
        4611686018427387903,
        4611686018427387904,
        4611686018427387905,
        9223372036854775807,
        9223372036854775808,
        9223372036854775809,
        18446744073709551615,
    ];
    for &i in values.iter() {
        assert_eq!(i, roundtrip(i));
    }
}
fn invalid_nan_test() {
    let mut builder = OptionsBuilder::default();
    builder = builder.nan_string(Some(b"naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaan"));
    assert!(!builder.is_valid());
    builder = builder.nan_string(Some(b"inf"));
    assert!(!builder.is_valid());
    builder = builder.nan_string(Some(b"na00n"));
    assert!(!builder.is_valid());
    assert!(builder.build().is_err());
    builder = builder.nan_string(Some(b"nan"));
    assert!(builder.is_valid());
    assert!(builder.build().is_ok());
    builder = builder.nan_string(None);
    assert!(builder.is_valid());
}
fn cmp_test() {
    // Simple
    let x = VecType::from_u32(1);
    let y = VecType::from_u32(2);
    assert_eq!(x.partial_cmp(&x), Some(cmp::Ordering::Equal));
    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);
    assert_eq!(x.cmp(&y), cmp::Ordering::Less);

    // Check asymmetric
    let x = VecType::try_from(&[5, 1]).unwrap();
    let y = VecType::from_u32(2);
    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);
    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);

    // Check when we use reverse ordering properly.
    let x = VecType::try_from(&[5, 1, 9]).unwrap();
    let y = VecType::try_from(&[6, 2, 8]).unwrap();
    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);
    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);

    // Complex scenario, check it properly uses reverse ordering.
    let x = VecType::try_from(&[0, 1, 9]).unwrap();
    let y = VecType::try_from(&[4294967295, 0, 9]).unwrap();
    assert_eq!(x.cmp(&x), cmp::Ordering::Equal);
    assert_eq!(x.cmp(&y), cmp::Ordering::Greater);
}
fn test() {
    use prost::Message;

    let mut widget_factory = widget::factory::WidgetFactory::default();
    assert_eq!(0, widget_factory.encoded_len());

    widget_factory.inner = Some(widget::factory::widget_factory::Inner {});
    assert_eq!(2, widget_factory.encoded_len());

    widget_factory.root = Some(Root {});
    assert_eq!(4, widget_factory.encoded_len());

    widget_factory.root_inner = Some(root::Inner {});
    assert_eq!(6, widget_factory.encoded_len());

    widget_factory.widget = Some(widget::Widget {});
    assert_eq!(8, widget_factory.encoded_len());

    widget_factory.widget_inner = Some(widget::widget::Inner {});
    assert_eq!(10, widget_factory.encoded_len());

    widget_factory.gizmo = Some(gizmo::Gizmo {});
    assert_eq!(12, widget_factory.encoded_len());

    widget_factory.gizmo_inner = Some(gizmo::gizmo::Inner {});
    assert_eq!(14, widget_factory.encoded_len());
}
fn test_skip_iter_lc() {
    // Test iterators that skip multiple, leading digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_leading_digit_separator(true)
        .integer_consecutive_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"4__5");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4_");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4__");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4_.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4__.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"45_5");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"45__5");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".45_5");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b".45__5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"4_5_");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"4__5__");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"4_5_.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"4__5__.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"45_");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"45__");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"45_.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"45__.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"4_5_");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"4__5__");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"4_5_.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"4__5__.56");
}
fn test_try_parse_4digits() {
    let parse = |bytes: &[u8]| {
        let mut digits = bytes.bytes::<{ STANDARD }>();
        algorithm::try_parse_4digits::<u32, _, STANDARD>(&mut digits.integer_iter())
    };
    assert_eq!(parse(b"1234"), Some(1234));
    assert_eq!(parse(b"123"), None);
    assert_eq!(parse(b"123\x00"), None);
    assert_eq!(parse(b"123."), None);
    assert_eq!(parse(b"123_"), None);
    assert_eq!(parse(b"1234_"), Some(1234));
}
fn test_skip_iter_ilc() {
    // Test iterators that skip multiple, internal or leading digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_internal_digit_separator(true)
        .integer_leading_digit_separator(true)
        .integer_consecutive_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4_");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4__");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4_.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4__.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"455");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"455");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".455");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b".455");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"45_");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"45__");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"45_.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"45__.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"45_");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"45__");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"45_.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"45__.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"45_");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"45__");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"45_.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"45__.56");
}
fn test_seq_object_borrow() {
    fn connect(values: &dyn SeqObject) -> String {
        let mut rv = String::new();
        for item in values.iter() {
            rv.push_str(&item.to_string())
        }
        rv
    }

    let mut env = Environment::new();
    env.add_filter("connect", connect);
    let state = env.empty_state();
    assert_eq!(
        state
            .apply_filter(
                "connect",
                args!(vec![Value::from("HELLO"), Value::from(42)])
            )
            .unwrap(),
        Value::from("HELLO42")
    );
}
fn test_float32() {
    let thing: f32 = 25.5;
    let yaml = indoc! {"
        25.5
    "};
    test_serde(&thing, yaml);

    let thing = f32::INFINITY;
    let yaml = indoc! {"
        .inf
    "};
    test_serde(&thing, yaml);

    let thing = f32::NEG_INFINITY;
    let yaml = indoc! {"
        -.inf
    "};
    test_serde(&thing, yaml);

    let single_float: f32 = serde_yaml::from_str(indoc! {"
        .nan
    "})
    .unwrap();
    assert!(single_float.is_nan());
}
fn test_lenient_undefined() {
    let mut env = Environment::new();
    env.add_filter("test", |state: &State, value: String| -> String {
        assert_eq!(state.undefined_behavior(), UndefinedBehavior::Lenient);
        assert_eq!(value, "");
        value
    });

    assert_eq!(env.undefined_behavior(), UndefinedBehavior::Lenient);
    assert_eq!(render!(in env, "<{{ true.missing_attribute }}>"), "<>");
    assert_eq!(
        env.render_str("{{ undefined.missing_attribute }}", ())
            .unwrap_err()
            .kind(),
        ErrorKind::UndefinedError
    );
    assert_eq!(
        render!(in env, "<{% for x in undefined %}...{% endfor %}>"),
        "<>"
    );
    assert_eq!(render!(in env, "<{{ undefined }}>"), "<>");
    assert_eq!(render!(in env, "{{ undefined is undefined }}"), "true");
    assert_eq!(render!(in env, "{{ undefined|list }}"), "[]");
    assert_eq!(render!(in env, "<{{ undefined|test }}>"), "<>");
    assert_eq!(render!(in env, "{{ 42 in undefined }}"), "false");
}
fn test_values_in_vec() {
    fn upper(value: &str) -> String {
        value.to_uppercase()
    }

    fn sum(value: Vec<i64>) -> i64 {
        value.into_iter().sum::<i64>()
    }

    let mut env = Environment::new();
    env.add_filter("upper", upper);
    env.add_filter("sum", sum);
    let state = env.empty_state();

    assert_eq!(
        state.apply_filter("upper", args!("Hello World!")).unwrap(),
        Value::from("HELLO WORLD!")
    );

    assert_eq!(
        state.apply_filter("sum", args!(vec![1, 2])).unwrap(),
        Value::from(3)
    );
}
fn test_kwargs_error() {
    let kwargs = Kwargs::from_iter([("foo", Value::from(42))]);
    let bar = kwargs.get::<Value>("bar").unwrap_err();
    assert_eq!(bar.detail(), Some("missing keyword argument 'bar'"));
}
fn test_skip_iter_ic() {
    // Test iterators that skip multiple, internal digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_internal_digit_separator(true)
        .integer_consecutive_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"__45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b"_.45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b"__.45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"45");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4_");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4__");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4_.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4__.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"_455");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"__455");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b"_.455");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b"__.455");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"45_");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"45__");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"45_.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"45__.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"_45_");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"__45__");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"_45_.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"__45__.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"_45_");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"__45__");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"_45_.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"__45__.56");
}
fn test_expression() {
    let env = Environment::new();
    let expr = env.compile_expression("foo + bar").unwrap();
    let mut ctx = BTreeMap::new();
    ctx.insert("foo", 42);
    ctx.insert("bar", 23);
    assert_eq!(expr.eval(&ctx).unwrap(), Value::from(65));
}
fn test_args() {
    fn type_name_of_val<T: ?Sized>(_val: &T) -> &str {
        std::any::type_name::<T>()
    }

    let args = args!();
    assert_eq!(args.len(), 0);
    assert_eq!(type_name_of_val(args), "[minijinja::value::Value]");

    let args = args!(1, 2);
    assert_eq!(args[0], Value::from(1));
    assert_eq!(args[1], Value::from(2));
    assert_eq!(type_name_of_val(args), "[minijinja::value::Value]");

    let args = args!(1, 2,);
    assert_eq!(args[0], Value::from(1));
    assert_eq!(args[1], Value::from(2));

    let args = args!(1, 2, foo => 42, bar => 23);
    assert_eq!(args[0], Value::from(1));
    assert_eq!(args[1], Value::from(2));
    let kwargs = Kwargs::try_from(args[2].clone()).unwrap();
    assert_eq!(kwargs.get::<i32>("foo").unwrap(), 42);
    assert_eq!(kwargs.get::<i32>("bar").unwrap(), 23);

    let args = args!(1, 2, foo => 42, bar => 23,);
    assert_eq!(args[0], Value::from(1));
    assert_eq!(args[1], Value::from(2));
    let kwargs = Kwargs::try_from(args[2].clone()).unwrap();
    assert_eq!(kwargs.get::<i32>("foo").unwrap(), 42);
    assert_eq!(kwargs.get::<i32>("bar").unwrap(), 23);
    assert_eq!(type_name_of_val(args), "[minijinja::value::Value]");
}
fn test_skip_iter_l() {
    // Test iterators that skip single, leading-only digit separators.
    pub const FORMAT: u128 = NumberFormatBuilder::new()
        .digit_separator(num::NonZeroU8::new(b'_'))
        .integer_leading_digit_separator(true)
        .build();
    const_assert!(NumberFormat::<{ FORMAT }> {}.is_valid());

    skip_iter_eq::<{ FORMAT }>(b"123.45", b"123.45");
    skip_iter_eq::<{ FORMAT }>(b"1e45", b"1e45");
    skip_iter_eq::<{ FORMAT }>(b"1e", b"1e");
    skip_iter_eq::<{ FORMAT }>(b"1", b"1");
    skip_iter_eq::<{ FORMAT }>(b"_45", b"45");
    skip_iter_eq::<{ FORMAT }>(b"__45", b"_45");
    skip_iter_eq::<{ FORMAT }>(b"_.45", b".45");
    skip_iter_eq::<{ FORMAT }>(b"__.45", b"_.45");
    skip_iter_eq::<{ FORMAT }>(b"4_5", b"4_5");
    skip_iter_eq::<{ FORMAT }>(b"4__5", b"4__5");
    skip_iter_eq::<{ FORMAT }>(b"4_", b"4_");
    skip_iter_eq::<{ FORMAT }>(b"4__", b"4__");
    skip_iter_eq::<{ FORMAT }>(b"4_.", b"4_.");
    skip_iter_eq::<{ FORMAT }>(b"4__.", b"4__.");
    skip_iter_eq::<{ FORMAT }>(b"_45_5", b"45_5");
    skip_iter_eq::<{ FORMAT }>(b"__45__5", b"_45__5");
    skip_iter_eq::<{ FORMAT }>(b"_.45_5", b".45_5");
    skip_iter_eq::<{ FORMAT }>(b"__.45__5", b"_.45__5");
    skip_iter_eq::<{ FORMAT }>(b"4_5_", b"4_5_");
    skip_iter_eq::<{ FORMAT }>(b"4__5__", b"4__5__");
    skip_iter_eq::<{ FORMAT }>(b"4_5_.5", b"4_5_.5");
    skip_iter_eq::<{ FORMAT }>(b"4__5__.5", b"4__5__.5");
    skip_iter_eq::<{ FORMAT }>(b"_45_", b"45_");
    skip_iter_eq::<{ FORMAT }>(b"__45__", b"_45__");
    skip_iter_eq::<{ FORMAT }>(b"_45_.56", b"45_.56");
    skip_iter_eq::<{ FORMAT }>(b"__45__.56", b"_45__.56");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_", b"4_5_");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__", b"_4__5__");
    skip_iter_eq::<{ FORMAT }>(b"_4_5_.56", b"4_5_.56");
    skip_iter_eq::<{ FORMAT }>(b"__4__5__.56", b"_4__5__.56");
}
fn test_nan() {
    let pos_nan = serde_yaml::from_str::<Value>(".nan").unwrap();
    assert!(pos_nan.is_f64());
    assert_eq!(pos_nan, pos_nan);

    let neg_fake_nan = serde_yaml::from_str::<Value>("-.nan").unwrap();
    assert!(neg_fake_nan.is_string());

    let significand_mask = 0xF_FFFF_FFFF_FFFF;
    let bits = (f64::NAN.copysign(1.0).to_bits() ^ significand_mask) | 1;
    let different_pos_nan = Value::Number(Number::from(f64::from_bits(bits)));
    assert_eq!(pos_nan, different_pos_nan);
}
fn test() {
    use crate::packages::gizmo;
    use crate::packages::DoIt;
    use prost::Message;

    let mut widget_factory = widget::factory::WidgetFactory::default();
    assert_eq!(0, widget_factory.encoded_len());

    widget_factory.inner = Some(widget::factory::widget_factory::Inner {});
    assert_eq!(2, widget_factory.encoded_len());

    widget_factory.root = Some(Root {});
    assert_eq!(4, widget_factory.encoded_len());

    widget_factory.root_inner = Some(root::Inner {});
    assert_eq!(6, widget_factory.encoded_len());

    widget_factory.widget = Some(widget::Widget {});
    assert_eq!(8, widget_factory.encoded_len());

    widget_factory.widget_inner = Some(widget::widget::Inner {});
    assert_eq!(10, widget_factory.encoded_len());

    widget_factory.gizmo = Some(gizmo::Gizmo {});
    assert_eq!(12, widget_factory.encoded_len());
    widget_factory.gizmo.as_ref().map(DoIt::do_it);

    widget_factory.gizmo_inner = Some(gizmo::gizmo::Inner {});
    assert_eq!(14, widget_factory.encoded_len());
}
