fn zlib_decoder_empty_read() {
    let original: &[u8] = b"Lorem ipsum dolor sit amet.";
    let mut encoder = flate2::write::ZlibEncoder::new(Vec::new(), flate2::Compression::default());
    encoder.write_all(original).unwrap();
    let encoded: Vec<u8> = encoder.finish().unwrap();
    let mut decoder = flate2::read::ZlibDecoder::new(encoded.as_slice());
    assert_eq!(decoder.read(&mut []).unwrap(), 0);
    let mut decoded = Vec::new();
    decoder.read_to_end(&mut decoded).unwrap();
    assert_eq!(decoded.as_slice(), original);
}
fn test_nested() {
    assert_eq!(
        from_str(
            "/*
        /* quite * some * nesting * going * on * /* here /* (yeah, maybe a bit too much) */ */ */
    */
    // The actual value comes.. /*
    // very soon, these are just checks that */
    // multi-line comments don't trigger in line comments /*
\"THE VALUE\" /* This is the value /* :) */ */
    "
        ),
        Ok("THE VALUE".to_owned())
    );
}
fn is_fast_path_test() {
    let mut number = Number {
        exponent: -4,
        mantissa: 12345,
        many_digits: false,
    };
    assert_eq!(number.is_fast_path::<f32>(), true);
    assert_eq!(number.is_fast_path::<f64>(), true);

    number.exponent = -15;
    assert_eq!(number.is_fast_path::<f32>(), false);
    assert_eq!(number.is_fast_path::<f64>(), true);

    number.exponent = -25;
    assert_eq!(number.is_fast_path::<f32>(), false);
    assert_eq!(number.is_fast_path::<f64>(), false);

    number.exponent = 25;
    assert_eq!(number.is_fast_path::<f32>(), false);
    assert_eq!(number.is_fast_path::<f64>(), true);

    number.exponent = 36;
    assert_eq!(number.is_fast_path::<f32>(), false);
    assert_eq!(number.is_fast_path::<f64>(), true);

    number.exponent = 38;
    assert_eq!(number.is_fast_path::<f32>(), false);
    assert_eq!(number.is_fast_path::<f64>(), false);

    number.mantissa = 1 << 25;
    number.exponent = 0;
    assert_eq!(number.is_fast_path::<f32>(), false);
    assert_eq!(number.is_fast_path::<f64>(), true);

    number.mantissa = 1 << 54;
    assert_eq!(number.is_fast_path::<f32>(), false);
    assert_eq!(number.is_fast_path::<f64>(), false);

    number.mantissa = 1 << 52;
    assert_eq!(number.is_fast_path::<f32>(), false);
    assert_eq!(number.is_fast_path::<f64>(), true);

    number.many_digits = true;
    assert_eq!(number.is_fast_path::<f32>(), false);
    assert_eq!(number.is_fast_path::<f64>(), false);
}
fn roundtrip_pretty() {
    let value = Struct {
        tuple: ((), NewType(0.5), TupleStruct(UnitStruct, -5)),
        vec: vec![None, Some(UnitStruct)],
        map: vec![
            (Key(5), Enum::Unit),
            (Key(6), Enum::Bool(false)),
            (Key(7), Enum::Bool(true)),
            (Key(9), Enum::Chars('x', "".to_string())),
        ]
        .into_iter()
        .collect(),
    };

    let pretty = ron::ser::PrettyConfig::new()
        .enumerate_arrays(true)
        .extensions(Extensions::IMPLICIT_SOME);
    let serial = ron::ser::to_string_pretty(&value, pretty).unwrap();

    println!("Serialized: {}", serial);

    let deserial = ron::de::from_str(&serial);

    assert_eq!(Ok(value), deserial);
}
fn manually_deserialize_dyn() {
    let ron = r#"SerializeDyn(
        type: "engine_utils::types::registry::tests::Player",
    )"#;

    let mut de = ron::Deserializer::from_bytes(ron.as_bytes()).unwrap();

    let result = de
        .deserialize_struct("SerializeDyn", &["type"], SerializeDynVisitor)
        .unwrap();

    assert_eq!(
        *result.downcast::<Option<(String, String)>>().unwrap(),
        Some((
            String::from("type"),
            String::from("engine_utils::types::registry::tests::Player")
        ))
    );
}
fn test_i32_min() {
    assert_eq!(
        std::i32::MIN,
        from_str(&to_string(&std::i32::MIN).unwrap()).unwrap()
    );
}
fn fabsd_spec_test() {
    assert!(libm::fabsd(f64::NAN).is_nan());
    for f in [0.0, -0.0].iter().copied() {
        assert_eq!(libm::fabsd(f), 0.0);
    }
    for f in [f64::INFINITY, f64::NEG_INFINITY].iter().copied() {
        assert_eq!(libm::fabsd(f), f64::INFINITY);
    }
}
fn test_inserts() {
    const N: usize = 2000;
    let mut v = Vector::new();
    for i in 0..N {
        v.insert(v.len() / 2, i);
    }
    let mut rv: Vec<usize> = Vec::new();
    rv.extend((0..N).skip(1).step_by(2));
    rv.extend((0..N).step_by(2).rev());
    assert_eq!(rv.iter().cloned().collect::<Vector<_>>(), v);
}
fn zlib_encoder_empty_read() {
    let original: &[u8] = b"Lorem ipsum dolor sit amet.";
    let mut encoder = flate2::read::ZlibEncoder::new(original, flate2::Compression::default());
    assert_eq!(encoder.read(&mut []).unwrap(), 0);
    let mut encoded = Vec::new();
    encoder.read_to_end(&mut encoded).unwrap();
    let mut decoder = flate2::read::ZlibDecoder::new(encoded.as_slice());
    let mut decoded = Vec::new();
    decoder.read_to_end(&mut decoded).unwrap();
    assert_eq!(decoded.as_slice(), original);
}
