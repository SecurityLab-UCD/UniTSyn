fn invocation_directory() {
  let tmp = temptree! {
    ".git": {},
  };

  let test = Test::with_tempdir(tmp);

  let justfile_path = test.justfile_path();

  let _tmp = test
    .no_justfile()
    .stderr_regex("Wrote justfile to `.*`\n")
    .arg("--init")
    .run();

  assert_eq!(fs::read_to_string(justfile_path).unwrap(), EXPECTED);
}
fn eph_weak_gc_test() {
    run_test(|| {
        let gc_value = Gc::new(3);

        {
            let cloned_gc = gc_value.clone();

            let weak = WeakGc::new(&cloned_gc);

            assert_eq!(*weak.upgrade().expect("Is live currently"), 3);
            drop(cloned_gc);
            force_collect();
            assert_eq!(*weak.upgrade().expect("WeakGc is still live here"), 3);

            drop(gc_value);
            force_collect();

            assert!(weak.upgrade().is_none());
        }
    });
}
fn from_file() {
  assert_eq!(
    CommandBuilder::new("decode transaction.bin")
      .write("transaction.bin", transaction())
      .run_and_deserialize_output::<Output>(),
    Output {
      inscriptions: vec![Inscription {
        body: Some(vec![0, 1, 2, 3]),
        content_type: Some(b"text/plain;charset=utf-8".to_vec()),
        ..Default::default()
      }],
    }
  );
}
fn test_integer128_to_value() {
    let signed = &[i128::from(i64::min_value()), i128::from(u64::max_value())];
    let unsigned = &[0, u128::from(u64::max_value())];

    for integer128 in signed {
        let expected = integer128.to_string();
        assert_eq!(to_value(integer128).unwrap().to_string(), expected);
    }

    for integer128 in unsigned {
        let expected = integer128.to_string();
        assert_eq!(to_value(integer128).unwrap().to_string(), expected);
    }

    if !cfg!(feature = "arbitrary_precision") {
        let err = to_value(u128::from(u64::max_value()) + 1).unwrap_err();
        assert_eq!(err.to_string(), "number out of range");
    }
}
fn index_runs_with_rpc_user_and_pass_as_env_vars() {
  let rpc_server = test_bitcoincore_rpc::spawn();
  rpc_server.mine_blocks(1);

  let tempdir = TempDir::new().unwrap();

  let ord = Command::new(executable_path("ord"))
    .args(
      format!(
        "--rpc-url {} --bitcoin-data-dir {} --data-dir {} index update",
        rpc_server.url(),
        tempdir.path().display(),
        tempdir.path().display()
      )
      .to_args(),
    )
    .env("ORD_BITCOIN_RPC_PASS", "bar")
    .env("ORD_BITCOIN_RPC_USER", "foo")
    .env("ORD_INTEGRATION_TEST", "1")
    .current_dir(&tempdir)
    .spawn()
    .unwrap();

  rpc_server.mine_blocks(1);

  assert_eq!(ord.wait_with_output().unwrap().status.code(), Some(0));
}
fn output() {
  let tempdir = tempdir();

  let output = Command::new(executable_path("just"))
    .arg("--completions")
    .arg("bash")
    .current_dir(tempdir.path())
    .output()
    .unwrap();

  assert!(output.status.success());

  let text = String::from_utf8_lossy(&output.stdout);

  assert!(text.starts_with("_just() {"));
}
fn server_respects_buffer_limit_pre_handshake_with_vectored_write() {
    let (mut client, mut server) = make_pair(KeyType::Rsa);

    server.set_buffer_limit(Some(32));

    assert_eq!(
        server
            .writer()
            .write_vectored(&[
                IoSlice::new(b"01234567890123456789"),
                IoSlice::new(b"01234567890123456789")
            ])
            .unwrap(),
        32
    );

    do_handshake(&mut client, &mut server);
    transfer(&mut server, &mut client);
    client.process_new_packets().unwrap();

    check_read(&mut client.reader(), b"01234567890123456789012345678901");
}
fn server_respects_buffer_limit_pre_handshake() {
    let (mut client, mut server) = make_pair(KeyType::Rsa);

    server.set_buffer_limit(Some(32));

    assert_eq!(
        server
            .writer()
            .write(b"01234567890123456789")
            .unwrap(),
        20
    );
    assert_eq!(
        server
            .writer()
            .write(b"01234567890123456789")
            .unwrap(),
        12
    );

    do_handshake(&mut client, &mut server);
    transfer(&mut server, &mut client);
    client.process_new_packets().unwrap();

    check_read(&mut client.reader(), b"01234567890123456789012345678901");
}
fn mantissa_exponent_test() {
    assert_eq!(mantissa_exponent(10, 5, 0), 5);
    assert_eq!(mantissa_exponent(0, 5, 0), -5);
    assert_eq!(
        mantissa_exponent(i32::max_value(), 5, 0),
        i32::max_value() - 5
    );
    assert_eq!(mantissa_exponent(i32::max_value(), 0, 5), i32::max_value());
    assert_eq!(mantissa_exponent(i32::min_value(), 5, 0), i32::min_value());
    assert_eq!(
        mantissa_exponent(i32::min_value(), 0, 5),
        i32::min_value() + 5
    );
}
fn justfile_and_working_directory() {
  let tmp = temptree! {
    sub: {
      ".git": {},
    },
  };

  let output = Command::new(executable_path("just"))
    .current_dir(tmp.path().join("sub"))
    .arg("--init")
    .arg("--justfile")
    .arg(tmp.path().join("justfile"))
    .arg("--working-directory")
    .arg("/")
    .output()
    .unwrap();

  assert!(output.status.success());

  assert_eq!(
    fs::read_to_string(tmp.path().join("justfile")).unwrap(),
    EXPECTED
  );
}
fn eph_allocation_chains() {
    run_test(|| {
        let gc_value = Gc::new(String::from("foo"));

        {
            let cloned_gc = gc_value.clone();
            let weak = WeakGc::new(&cloned_gc);
            let wrap = Gc::new(weak);

            assert_eq!(wrap.upgrade().as_deref().map(String::as_str), Some("foo"));

            let eph = Ephemeron::new(&wrap, 3);

            drop(cloned_gc);
            force_collect();
            assert_eq!(wrap.upgrade().as_deref().map(String::as_str), Some("foo"));
            assert_eq!(eph.value(), Some(3));

            drop(gc_value);
            force_collect();
            assert!(wrap.upgrade().is_none());
            assert_eq!(eph.value(), Some(3));

            drop(wrap);
            force_collect();
            assert!(eph.value().is_none());
        }
    });
}
fn scientific_exponent_test() {
    // 0 digits in the integer
    assert_eq!(scientific_exponent(0, 0, 5), -6);
    assert_eq!(scientific_exponent(10, 0, 5), 4);
    assert_eq!(scientific_exponent(-10, 0, 5), -16);

    // >0 digits in the integer
    assert_eq!(scientific_exponent(0, 1, 5), 0);
    assert_eq!(scientific_exponent(0, 2, 5), 1);
    assert_eq!(scientific_exponent(0, 2, 20), 1);
    assert_eq!(scientific_exponent(10, 2, 20), 11);
    assert_eq!(scientific_exponent(-10, 2, 20), -9);

    // Underflow
    assert_eq!(
        scientific_exponent(i32::min_value(), 0, 0),
        i32::min_value()
    );
    assert_eq!(
        scientific_exponent(i32::min_value(), 0, 5),
        i32::min_value()
    );

    // Overflow
    assert_eq!(
        scientific_exponent(i32::max_value(), 0, 0),
        i32::max_value() - 1
    );
    assert_eq!(
        scientific_exponent(i32::max_value(), 5, 0),
        i32::max_value()
    );
}
fn invoke_error() {
  let tmp = temptree! {
    justfile: JUSTFILE,
  };

  let output = Command::new(executable_path("just"))
    .current_dir(tmp.path())
    .output()
    .unwrap();

  assert!(!output.status.success());

  let output = Command::new(executable_path("just"))
    .current_dir(tmp.path())
    .arg("--edit")
    .env("VISUAL", "/")
    .output()
    .unwrap();

  assert_eq!(
    String::from_utf8_lossy(&output.stderr),
    if cfg!(windows) {
      "error: Editor `/` invocation failed: program path has no file name\n"
    } else {
      "error: Editor `/` invocation failed: Permission denied (os error 13)\n"
    }
  );
}
fn transactions() {
  let rpc_server = test_bitcoincore_rpc::spawn();

  let tempdir = TempDir::new().unwrap();

  let index_path = tempdir.path().join("index.redb");

  assert!(CommandBuilder::new(format!(
    "--index {} info --transactions",
    index_path.display()
  ))
  .rpc_server(&rpc_server)
  .run_and_deserialize_output::<Vec<TransactionsOutput>>()
  .is_empty());

  rpc_server.mine_blocks(10);

  let output = CommandBuilder::new(format!(
    "--index {} info --transactions",
    index_path.display()
  ))
  .rpc_server(&rpc_server)
  .run_and_deserialize_output::<Vec<TransactionsOutput>>();

  assert_eq!(output[0].start, 0);
  assert_eq!(output[0].end, 1);
  assert_eq!(output[0].count, 1);

  rpc_server.mine_blocks(10);

  let output = CommandBuilder::new(format!(
    "--index {} info --transactions",
    index_path.display()
  ))
  .rpc_server(&rpc_server)
  .run_and_deserialize_output::<Vec<TransactionsOutput>>();

  assert_eq!(output[1].start, 1);
  assert_eq!(output[1].end, 11);
  assert_eq!(output[1].count, 10);
}
fn test_integer128() {
    let signed = &[i128::min_value(), -1, 0, 1, i128::max_value()];
    let unsigned = &[0, 1, u128::max_value()];

    for integer128 in signed {
        let expected = integer128.to_string();
        assert_eq!(to_string(integer128).unwrap(), expected);
        assert_eq!(from_str::<i128>(&expected).unwrap(), *integer128);
    }

    for integer128 in unsigned {
        let expected = integer128.to_string();
        assert_eq!(to_string(integer128).unwrap(), expected);
        assert_eq!(from_str::<u128>(&expected).unwrap(), *integer128);
    }

    test_parse_err::<i128>(&[
        (
            "-170141183460469231731687303715884105729",
            "number out of range at line 1 column 40",
        ),
        (
            "170141183460469231731687303715884105728",
            "number out of range at line 1 column 39",
        ),
    ]);

    test_parse_err::<u128>(&[
        ("-1", "number out of range at line 1 column 1"),
        (
            "340282366920938463463374607431768211456",
            "number out of range at line 1 column 39",
        ),
    ]);
}
fn issue_195() {
    setup();

    let path = format!(
        "{}/JLCPCB SMT Parts Library(20210204).xls",
        env!("CARGO_MANIFEST_DIR")
    );
    let mut excel: Xls<_> = open_workbook(&path).expect("can't open wb");
    let range = excel
        .worksheet_range("JLCPCB SMT Parts Library")
        .expect("error in wks range")
        .expect("sheet not found");
    assert_eq!(range.get_size(), (52046, 12));
}
fn server_exposes_offered_sni_even_if_resolver_fails() {
    let kt = KeyType::Rsa;
    let resolver = rustls::server::ResolvesServerCertUsingSni::new();

    let mut server_config = make_server_config(kt);
    server_config.cert_resolver = Arc::new(resolver);
    let server_config = Arc::new(server_config);

    for version in rustls::ALL_VERSIONS {
        let client_config = make_client_config_with_versions(kt, &[version]);
        let mut server = ServerConnection::new(Arc::clone(&server_config)).unwrap();
        let mut client =
            ClientConnection::new(Arc::new(client_config), dns_name("thisdoesNOTexist.com"))
                .unwrap();

        assert_eq!(None, server.server_name());
        transfer(&mut client, &mut server);
        assert_eq!(
            server.process_new_packets(),
            Err(Error::General(
                "no server certificate chain resolved".to_string()
            ))
        );
        assert_eq!(Some("thisdoesnotexist.com"), server.server_name());
    }
}
fn test_integer128_key() {
    let map = treemap! {
        100000000000000000000000000000000000000u128 => (),
    };
    let j = r#"{"100000000000000000000000000000000000000":null}"#;
    assert_eq!(to_string(&map).unwrap(), j);
    assert_eq!(from_str::<BTreeMap<u128, ()>>(j).unwrap(), map);
}
fn server_closes_uncleanly() {
    let kt = KeyType::Rsa;
    let server_config = Arc::new(make_server_config(kt));

    for version in rustls::ALL_VERSIONS {
        let client_config = make_client_config_with_versions(kt, &[version]);
        let (mut client, mut server) =
            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);
        do_handshake(&mut client, &mut server);

        // check that unclean EOF reporting does not overtake appdata
        assert_eq!(
            12,
            server
                .writer()
                .write(b"from-server!")
                .unwrap()
        );
        assert_eq!(
            12,
            client
                .writer()
                .write(b"from-client!")
                .unwrap()
        );

        transfer(&mut server, &mut client);
        transfer_eof(&mut client);
        let io_state = client.process_new_packets().unwrap();
        assert!(!io_state.peer_has_closed());
        check_read(&mut client.reader(), b"from-server!");

        check_read_err(
            &mut client.reader() as &mut dyn io::Read,
            io::ErrorKind::UnexpectedEof,
        );

        // may still transmit pending frames
        transfer(&mut client, &mut server);
        server.process_new_packets().unwrap();
        check_read(&mut server.reader(), b"from-client!");
    }
}
fn alternate_marker() {
  let tmp = temptree! {
    "_darcs": {},
  };

  let output = Command::new(executable_path("just"))
    .current_dir(tmp.path())
    .arg("--init")
    .output()
    .unwrap();

  assert!(output.status.success());

  assert_eq!(
    fs::read_to_string(tmp.path().join("justfile")).unwrap(),
    EXPECTED
  );
}
fn test_integer_key() {
    // map with integer keys
    let map = treemap!(
        1 => 2,
        -1 => 6,
    );
    let j = r#"{"-1":6,"1":2}"#;
    test_encode_ok(&[(&map, j)]);
    test_parse_ok(vec![(j, map)]);

    test_parse_err::<BTreeMap<i32, ()>>(&[
        (
            r#"{"x":null}"#,
            "invalid value: expected key to be a number in quotes at line 1 column 2",
        ),
        (
            r#"{" 123":null}"#,
            "invalid value: expected key to be a number in quotes at line 1 column 2",
        ),
        (r#"{"123 ":null}"#, "expected `\"` at line 1 column 6"),
    ]);

    let err = from_value::<BTreeMap<i32, ()>>(json!({" 123":null})).unwrap_err();
    assert_eq!(
        err.to_string(),
        "invalid value: expected key to be a number in quotes",
    );

    let err = from_value::<BTreeMap<i32, ()>>(json!({"123 ":null})).unwrap_err();
    assert_eq!(
        err.to_string(),
        "invalid value: expected key to be a number in quotes",
    );
}
fn working_directory_is_correct() {
  let tmp = tempdir();

  fs::write(tmp.path().join("justfile"), "").unwrap();
  fs::write(tmp.path().join("bar"), "baz").unwrap();
  fs::create_dir(tmp.path().join("foo")).unwrap();

  let output = Command::new(executable_path("just"))
    .args(["--command", "cat", "bar"])
    .current_dir(tmp.path().join("foo"))
    .output()
    .unwrap();

  assert_eq!(str::from_utf8(&output.stderr).unwrap(), "");

  assert!(output.status.success());

  assert_eq!(str::from_utf8(&output.stdout).unwrap(), "baz");
}
fn invocation_directory_native() {
  let Output { stdout, tempdir } = Test::new()
    .justfile("x := invocation_directory_native()")
    .args(["--evaluate", "x"])
    .stdout_regex(".*")
    .run();

  if cfg!(windows) {
    assert_eq!(Path::new(&stdout), tempdir.path());
  } else {
    assert_eq!(Path::new(&stdout), tempdir.path().canonicalize().unwrap());
  }
}
fn bit_length_test() {
    let x = Bigint {
        data: from_u32(&[0, 0, 0, 1]),
    };
    assert_eq!(x.bit_length(), 97);

    let x = Bigint {
        data: from_u32(&[0, 0, 0, 3]),
    };
    assert_eq!(x.bit_length(), 98);

    let x = Bigint {
        data: from_u32(&[1 << 31]),
    };
    assert_eq!(x.bit_length(), 32);
}
fn unstable_passed() {
  let tmp = tempdir();

  let justfile = tmp.path().join("justfile");

  fs::write(&justfile, "x    :=    'hello'   ").unwrap();

  let output = Command::new(executable_path("just"))
    .current_dir(tmp.path())
    .arg("--fmt")
    .arg("--unstable")
    .output()
    .unwrap();

  if !output.status.success() {
    eprintln!("{}", String::from_utf8_lossy(&output.stderr));
    eprintln!("{}", String::from_utf8_lossy(&output.stdout));
    panic!("justfile failed with status: {}", output.status);
  }

  assert_eq!(fs::read_to_string(&justfile).unwrap(), "x := 'hello'\n");
}
fn server_complete_io_for_handshake_ending_with_alert() {
    let (client_config, server_config) = make_disjoint_suite_configs();
    let (mut client, mut server) = make_pair_for_configs(client_config, server_config);

    assert!(server.is_handshaking());

    let mut pipe = OtherSession::new_fails(&mut client);
    let rc = server.complete_io(&mut pipe);
    assert!(rc.is_err(), "server io failed due to handshake failure");
    assert!(!server.wants_write(), "but server did send its alert");
    assert_eq!(
        format!("{:?}", pipe.last_error),
        "Some(AlertReceived(HandshakeFailure))",
        "which was received by client"
    );
}
fn invalid_justfile() {
  let tmp = temptree! {
    justfile: JUSTFILE,
  };

  let output = Command::new(executable_path("just"))
    .current_dir(tmp.path())
    .output()
    .unwrap();

  assert!(!output.status.success());

  let output = Command::new(executable_path("just"))
    .current_dir(tmp.path())
    .arg("--edit")
    .env("VISUAL", "cat")
    .output()
    .unwrap();

  assert_stdout(&output, JUSTFILE);
}
fn client_cert_resolve() {
    for kt in ALL_KEY_TYPES.iter() {
        let server_config = Arc::new(make_server_config_with_mandatory_client_auth(*kt));

        let expected_issuers = match *kt {
            KeyType::Rsa => vec![
                b"0,1*0(\x06\x03U\x04\x03\x0c!ponytown RSA level 2 intermediate".to_vec(),
                b"0\x1a1\x180\x16\x06\x03U\x04\x03\x0c\x0fponytown RSA CA".to_vec(),
            ],
            KeyType::Ecdsa => vec![
                b"0.1,0*\x06\x03U\x04\x03\x0c#ponytown ECDSA level 2 intermediate".to_vec(),
                b"0\x1c1\x1a0\x18\x06\x03U\x04\x03\x0c\x11ponytown ECDSA CA".to_vec(),
            ],
            KeyType::Ed25519 => vec![
                b"0.1,0*\x06\x03U\x04\x03\x0c#ponytown EdDSA level 2 intermediate".to_vec(),
                b"0\x1c1\x1a0\x18\x06\x03U\x04\x03\x0c\x11ponytown EdDSA CA".to_vec(),
            ],
        };

        for version in rustls::ALL_VERSIONS {
            let expected_sigschemes = match version.version {
                ProtocolVersion::TLSv1_2 => vec![
                    SignatureScheme::ECDSA_NISTP384_SHA384,
                    SignatureScheme::ECDSA_NISTP256_SHA256,
                    SignatureScheme::ED25519,
                    SignatureScheme::RSA_PSS_SHA512,
                    SignatureScheme::RSA_PSS_SHA384,
                    SignatureScheme::RSA_PSS_SHA256,
                    SignatureScheme::RSA_PKCS1_SHA512,
                    SignatureScheme::RSA_PKCS1_SHA384,
                    SignatureScheme::RSA_PKCS1_SHA256,
                ],
                ProtocolVersion::TLSv1_3 => vec![
                    SignatureScheme::ECDSA_NISTP384_SHA384,
                    SignatureScheme::ECDSA_NISTP256_SHA256,
                    SignatureScheme::ED25519,
                    SignatureScheme::RSA_PSS_SHA512,
                    SignatureScheme::RSA_PSS_SHA384,
                    SignatureScheme::RSA_PSS_SHA256,
                ],
                _ => unreachable!(),
            };

            println!("{:?} {:?}:", version.version, *kt);

            let mut client_config = make_client_config_with_versions(*kt, &[version]);
            client_config.client_auth_cert_resolver = Arc::new(ClientCheckCertResolve::new(
                1,
                expected_issuers.clone(),
                expected_sigschemes,
            ));

            let (mut client, mut server) =
                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);

            assert_eq!(
                do_handshake_until_error(&mut client, &mut server),
                Err(ErrorFromPeer::Server(Error::NoCertificatesPresented))
            );
        }
    }
}
fn compare_test() {
    // Simple
    let x = Bigint {
        data: from_u32(&[1]),
    };
    let y = Bigint {
        data: from_u32(&[2]),
    };
    assert_eq!(x.compare(&y), cmp::Ordering::Less);
    assert_eq!(x.compare(&x), cmp::Ordering::Equal);
    assert_eq!(y.compare(&x), cmp::Ordering::Greater);

    // Check asymmetric
    let x = Bigint {
        data: from_u32(&[5, 1]),
    };
    let y = Bigint {
        data: from_u32(&[2]),
    };
    assert_eq!(x.compare(&y), cmp::Ordering::Greater);
    assert_eq!(x.compare(&x), cmp::Ordering::Equal);
    assert_eq!(y.compare(&x), cmp::Ordering::Less);

    // Check when we use reverse ordering properly.
    let x = Bigint {
        data: from_u32(&[5, 1, 9]),
    };
    let y = Bigint {
        data: from_u32(&[6, 2, 8]),
    };
    assert_eq!(x.compare(&y), cmp::Ordering::Greater);
    assert_eq!(x.compare(&x), cmp::Ordering::Equal);
    assert_eq!(y.compare(&x), cmp::Ordering::Less);

    // Complex scenario, check it properly uses reverse ordering.
    let x = Bigint {
        data: from_u32(&[0, 1, 9]),
    };
    let y = Bigint {
        data: from_u32(&[4294967295, 0, 9]),
    };
    assert_eq!(x.compare(&y), cmp::Ordering::Greater);
    assert_eq!(x.compare(&x), cmp::Ordering::Equal);
    assert_eq!(y.compare(&x), cmp::Ordering::Less);
}
fn find_range_command_returns_satpoints_and_ranges() {
  let rpc_server = test_bitcoincore_rpc::spawn();

  rpc_server.mine_blocks(1);

  pretty_assert_eq!(
    CommandBuilder::new(format!("--index-sats find 0 {}", 55 * COIN_VALUE))
      .rpc_server(&rpc_server)
      .run_and_deserialize_output::<Vec<FindRangeOutput>>(),
    vec![
      FindRangeOutput {
        start: 0,
        size: 50 * COIN_VALUE,
        satpoint: "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b:0:0"
          .parse()
          .unwrap()
      },
      FindRangeOutput {
        start: 50 * COIN_VALUE,
        size: 5 * COIN_VALUE,
        satpoint: "30f2f037629c6a21c1f40ed39b9bd6278df39762d68d07f49582b23bcb23386a:0:0"
          .parse()
          .unwrap()
      }
    ]
  );
}
fn spread_in_arrow_function() {
    let s = r#"
    (...b) => {
        b
    }
    "#;

    let interner = &mut Interner::default();
    let b = interner.get_or_intern_static("b", utf16!("b"));
    let params = FormalParameterList::from(FormalParameter::new(
        Variable::from_identifier(b.into(), None),
        true,
    ));
    assert_eq!(params.flags(), FormalParameterListFlags::HAS_REST_PARAMETER);
    assert_eq!(params.length(), 0);
    check_script_parser(
        s,
        vec![Statement::Expression(Expression::from(ArrowFunction::new(
            None,
            params,
            FunctionBody::new(
                vec![Statement::Expression(Expression::from(Identifier::from(b))).into()].into(),
            ),
        )))
        .into()],
        interner,
    );
}
fn genesis() {
  assert_eq!(
    CommandBuilder::new("subsidy 0").run_and_deserialize_output::<Output>(),
    Output {
      first: 0,
      subsidy: 5000000000,
      name: "nvtdijuwxlp".into(),
    }
  );
}
fn weak_map_multiple() {
    run_test(|| {
        let key1 = Gc::new(String::from("key1"));
        let key2 = Gc::new(String::from("key2"));
        let key3 = Gc::new(String::from("key3"));

        assert!(!has_weak_maps());

        let mut map_1 = WeakMap::new();
        let mut map_2 = WeakMap::new();

        assert!(has_weak_maps());

        map_1.insert(&key1, ());
        map_1.insert(&key2, ());
        map_2.insert(&key3, ());

        force_collect();
        assert!(has_weak_maps());

        assert!(map_1.contains_key(&key1));
        assert!(map_1.contains_key(&key2));
        assert!(!map_1.contains_key(&key3));
        assert!(!map_2.contains_key(&key1));
        assert!(!map_2.contains_key(&key2));
        assert!(map_2.contains_key(&key3));

        force_collect();
        assert!(has_weak_maps());

        drop(key1);
        drop(key2);

        force_collect();
        assert!(has_weak_maps());

        assert!(!map_1.contains_key(&key3));
        assert!(map_2.contains_key(&key3));

        drop(key3);

        force_collect();
        assert!(has_weak_maps());

        drop(map_1);

        force_collect();
        assert!(has_weak_maps());

        drop(map_2);

        force_collect();
        assert!(!has_weak_maps());
    });
}
fn lower_n_halfway_test() {
    assert_eq!(lower_n_halfway(0u64), 0b0);
    assert_eq!(lower_n_halfway(1u64), 0b1);
    assert_eq!(lower_n_halfway(2u64), 0b10);
    assert_eq!(lower_n_halfway(10u64), 0b1000000000);
    assert_eq!(lower_n_halfway(32u64), 0b10000000000000000000000000000000);
}
fn eph_basic_alloc_dump_test() {
    run_test(|| {
        let gc_value = Gc::new(String::from("gc here"));
        let _gc_two = Gc::new("hmmm");

        let eph = Ephemeron::new(&gc_value, 4);
        let _fourth = Gc::new("tail");

        assert_eq!(eph.value(), Some(4));
    });
}
fn server_respects_buffer_limit_post_handshake() {
    let (mut client, mut server) = make_pair(KeyType::Rsa);

    // this test will vary in behaviour depending on the default suites
    do_handshake(&mut client, &mut server);
    server.set_buffer_limit(Some(48));

    assert_eq!(
        server
            .writer()
            .write(b"01234567890123456789")
            .unwrap(),
        20
    );
    assert_eq!(
        server
            .writer()
            .write(b"01234567890123456789")
            .unwrap(),
        6
    );

    transfer(&mut server, &mut client);
    client.process_new_packets().unwrap();

    check_read(&mut client.reader(), b"01234567890123456789012345");
}
fn gc_basic_cell_allocation() {
    run_test(|| {
        let gc_cell = Gc::new(GcRefCell::new(16_u16));

        force_collect();
        Harness::assert_collections(1);
        Harness::assert_bytes_allocated();
        assert_eq!(*gc_cell.borrow_mut(), 16);
    });
}
fn client_respects_buffer_limit_pre_handshake() {
    let (mut client, mut server) = make_pair(KeyType::Rsa);

    client.set_buffer_limit(Some(32));

    assert_eq!(
        client
            .writer()
            .write(b"01234567890123456789")
            .unwrap(),
        20
    );
    assert_eq!(
        client
            .writer()
            .write(b"01234567890123456789")
            .unwrap(),
        12
    );

    do_handshake(&mut client, &mut server);
    transfer(&mut client, &mut server);
    server.process_new_packets().unwrap();

    check_read(&mut server.reader(), b"01234567890123456789012345678901");
}
fn client_close_notify() {
    let kt = KeyType::Rsa;
    let server_config = Arc::new(make_server_config_with_mandatory_client_auth(kt));

    for version in rustls::ALL_VERSIONS {
        let client_config = make_client_config_with_versions_with_auth(kt, &[version]);
        let (mut client, mut server) =
            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);
        do_handshake(&mut client, &mut server);

        // check that alerts don't overtake appdata
        assert_eq!(
            12,
            server
                .writer()
                .write(b"from-server!")
                .unwrap()
        );
        assert_eq!(
            12,
            client
                .writer()
                .write(b"from-client!")
                .unwrap()
        );
        client.send_close_notify();

        transfer(&mut client, &mut server);
        let io_state = server.process_new_packets().unwrap();
        assert!(io_state.peer_has_closed());
        check_read_and_close(&mut server.reader(), b"from-client!");

        transfer(&mut server, &mut client);
        client.process_new_packets().unwrap();
        check_read(&mut client.reader(), b"from-server!");
    }
}
fn hash() {
  assert_eq!(
    CommandBuilder::new("parse 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef")
      .run_and_deserialize_output::<Output>(),
    Output {
      object: "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
        .parse::<Object>()
        .unwrap(),
    }
  );
}
fn server_exposes_offered_sni() {
    let kt = KeyType::Rsa;
    for version in rustls::ALL_VERSIONS {
        let client_config = make_client_config_with_versions(kt, &[version]);
        let mut client =
            ClientConnection::new(Arc::new(client_config), dns_name("second.testserver.com"))
                .unwrap();
        let mut server = ServerConnection::new(Arc::new(make_server_config(kt))).unwrap();

        assert_eq!(None, server.server_name());
        do_handshake(&mut client, &mut server);
        assert_eq!(Some("second.testserver.com"), server.server_name());
    }
}
fn shl_test() {
    // Pattern generated via `''.join(["1" +"0"*i for i in range(20)])`
    let mut big = Bigint {
        data: from_u32(&[0xD2210408]),
    };
    big.ishl(5);
    assert_eq!(big.data, from_u32(&[0x44208100, 0x1A]));
    big.ishl(32);
    assert_eq!(big.data, from_u32(&[0, 0x44208100, 0x1A]));
    big.ishl(27);
    assert_eq!(big.data, from_u32(&[0, 0, 0xD2210408]));

    // 96-bits of previous pattern
    let mut big = Bigint {
        data: from_u32(&[0x20020010, 0x8040100, 0xD2210408]),
    };
    big.ishl(5);
    assert_eq!(big.data, from_u32(&[0x400200, 0x802004, 0x44208101, 0x1A]));
    big.ishl(32);
    assert_eq!(
        big.data,
        from_u32(&[0, 0x400200, 0x802004, 0x44208101, 0x1A])
    );
    big.ishl(27);
    assert_eq!(
        big.data,
        from_u32(&[0, 0, 0x20020010, 0x8040100, 0xD2210408])
    );
}
fn buffered_server_data_sent() {
    let server_config = Arc::new(make_server_config(KeyType::Rsa));

    for version in rustls::ALL_VERSIONS {
        let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);
        let (mut client, mut server) =
            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);

        assert_eq!(5, server.writer().write(b"hello").unwrap());

        do_handshake(&mut client, &mut server);
        transfer(&mut server, &mut client);
        client.process_new_packets().unwrap();

        check_read(&mut client.reader(), b"hello");
    }
}
fn eph_ephemeron_test() {
    run_test(|| {
        let gc_value = Gc::new(3);

        {
            let cloned_gc = gc_value.clone();

            let ephemeron = Ephemeron::new(&cloned_gc, String::from("Hello World!"));

            assert_eq!(
                *ephemeron.value().expect("Ephemeron is live"),
                String::from("Hello World!")
            );
            drop(cloned_gc);
            force_collect();
            assert_eq!(
                *ephemeron.value().expect("Ephemeron is still live here"),
                String::from("Hello World!")
            );

            drop(gc_value);
            force_collect();

            assert!(ephemeron.value().is_none());
        }
    });
}
fn run() {
  let rpc_server = test_bitcoincore_rpc::spawn();

  let port = TcpListener::bind("127.0.0.1:0")
    .unwrap()
    .local_addr()
    .unwrap()
    .port();

  let builder = CommandBuilder::new(format!("server --address 127.0.0.1 --http-port {port}"))
    .rpc_server(&rpc_server);

  let mut command = builder.command();

  let mut child = command.spawn().unwrap();

  for attempt in 0.. {
    if let Ok(response) = reqwest::blocking::get(format!("http://localhost:{port}/status")) {
      if response.status() == 200 {
        assert_eq!(response.text().unwrap(), "OK");
        break;
      }
    }

    if attempt == 100 {
      panic!("Server did not respond to status check",);
    }

    thread::sleep(Duration::from_millis(50));
  }

  child.kill().unwrap();
}
fn buffered_client_data_sent() {
    let server_config = Arc::new(make_server_config(KeyType::Rsa));

    for version in rustls::ALL_VERSIONS {
        let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);
        let (mut client, mut server) =
            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);

        assert_eq!(5, client.writer().write(b"hello").unwrap());

        do_handshake(&mut client, &mut server);
        transfer(&mut client, &mut server);
        server.process_new_packets().unwrap();

        check_read(&mut server.reader(), b"hello");
    }
}
fn client_complete_io_for_handshake_eof() {
    let (mut client, _) = make_pair(KeyType::Rsa);
    let mut input = io::Cursor::new(Vec::new());

    assert!(client.is_handshaking());
    let err = client
        .complete_io(&mut input)
        .unwrap_err();
    assert_eq!(io::ErrorKind::UnexpectedEof, err.kind());
}
fn test_raw_invalid_utf8() {
    let j = &[b'"', b'\xCE', b'\xF8', b'"'];
    let value_err = serde_json::from_slice::<Value>(j).unwrap_err();
    let raw_value_err = serde_json::from_slice::<Box<RawValue>>(j).unwrap_err();

    assert_eq!(
        value_err.to_string(),
        "invalid unicode code point at line 1 column 4",
    );
    assert_eq!(
        raw_value_err.to_string(),
        "invalid unicode code point at line 1 column 4",
    );
}
fn export_inscription_number_to_id_tsv() {
  let rpc_server = test_bitcoincore_rpc::spawn();
  let temp_dir = TempDir::new().unwrap();
  create_wallet(&rpc_server);

  inscribe(&rpc_server);
  inscribe(&rpc_server);
  let (inscription, _) = inscribe(&rpc_server);

  rpc_server.mine_blocks(1);

  let tsv = CommandBuilder::new("index export --tsv foo.tsv")
    .rpc_server(&rpc_server)
    .temp_dir(temp_dir)
    .stdout_regex(r"\{\}\n")
    .run_and_extract_file("foo.tsv");

  let entries: std::collections::BTreeMap<i64, ord::Object> = tsv
    .lines()
    .filter(|line| !line.is_empty() && !line.starts_with('#'))
    .map(|line| {
      let value = line.split('\t').collect::<Vec<&str>>();
      let inscription_number = i64::from_str(value[0]).unwrap();
      let inscription_id = ord::Object::from_str(value[1]).unwrap();

      (inscription_number, inscription_id)
    })
    .collect();

  assert_eq!(
    entries.get(&2).unwrap(),
    &ord::Object::InscriptionId(inscription),
  );
}
fn buffered_both_data_sent() {
    let server_config = Arc::new(make_server_config(KeyType::Rsa));

    for version in rustls::ALL_VERSIONS {
        let client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);
        let (mut client, mut server) =
            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);

        assert_eq!(
            12,
            server
                .writer()
                .write(b"from-server!")
                .unwrap()
        );
        assert_eq!(
            12,
            client
                .writer()
                .write(b"from-client!")
                .unwrap()
        );

        do_handshake(&mut client, &mut server);

        transfer(&mut server, &mut client);
        client.process_new_packets().unwrap();
        transfer(&mut client, &mut server);
        server.process_new_packets().unwrap();

        check_read(&mut client.reader(), b"from-server!");
        check_read(&mut server.reader(), b"from-client!");
    }
}
fn client_closes_uncleanly() {
    let kt = KeyType::Rsa;
    let server_config = Arc::new(make_server_config(kt));

    for version in rustls::ALL_VERSIONS {
        let client_config = make_client_config_with_versions(kt, &[version]);
        let (mut client, mut server) =
            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);
        do_handshake(&mut client, &mut server);

        // check that unclean EOF reporting does not overtake appdata
        assert_eq!(
            12,
            server
                .writer()
                .write(b"from-server!")
                .unwrap()
        );
        assert_eq!(
            12,
            client
                .writer()
                .write(b"from-client!")
                .unwrap()
        );

        transfer(&mut client, &mut server);
        transfer_eof(&mut server);
        let io_state = server.process_new_packets().unwrap();
        assert!(!io_state.peer_has_closed());
        check_read(&mut server.reader(), b"from-client!");

        check_read_err(
            &mut server.reader() as &mut dyn io::Read,
            io::ErrorKind::UnexpectedEof,
        );

        // may still transmit pending frames
        transfer(&mut server, &mut client);
        client.process_new_packets().unwrap();
        check_read(&mut client.reader(), b"from-server!");
    }
}
fn test_something() {
    let data = [];
    let mut rdr = Reader::init(data);
    if let Ok(m) = OpaqueMessage::read(&mut rdr) {
        let msg = match Message::try_from(m.into_plain_message()) {
            Ok(msg) => msg,
            Err(_) => return,
        };
        let enc = PlainMessage::from(msg)
            .into_unencrypted_opaque()
            .encode();
        assert_eq!(enc, data[..rdr.used()]);
    }
}
fn hi64_test() {
    assert_eq!(Bigint::from_u64(0xA).hi64(), (0xA000000000000000, false));
    assert_eq!(Bigint::from_u64(0xAB).hi64(), (0xAB00000000000000, false));
    assert_eq!(
        Bigint::from_u64(0xAB00000000).hi64(),
        (0xAB00000000000000, false)
    );
    assert_eq!(
        Bigint::from_u64(0xA23456789A).hi64(),
        (0xA23456789A000000, false)
    );
}
fn test_borrowed_raw_value() {
    #[derive(Serialize, Deserialize)]
    struct Wrapper<'a> {
        a: i8,
        #[serde(borrow)]
        b: &'a RawValue,
        c: i8,
    }

    let wrapper_from_str: Wrapper =
        serde_json::from_str(r#"{"a": 1, "b": {"foo": 2}, "c": 3}"#).unwrap();
    assert_eq!(r#"{"foo": 2}"#, wrapper_from_str.b.get());

    let wrapper_to_string = serde_json::to_string(&wrapper_from_str).unwrap();
    assert_eq!(r#"{"a":1,"b":{"foo": 2},"c":3}"#, wrapper_to_string);

    let wrapper_to_value = serde_json::to_value(&wrapper_from_str).unwrap();
    assert_eq!(json!({"a": 1, "b": {"foo": 2}, "c": 3}), wrapper_to_value);

    let array_from_str: Vec<&RawValue> =
        serde_json::from_str(r#"["a", 42, {"foo": "bar"}, null]"#).unwrap();
    assert_eq!(r#""a""#, array_from_str[0].get());
    assert_eq!(r#"42"#, array_from_str[1].get());
    assert_eq!(r#"{"foo": "bar"}"#, array_from_str[2].get());
    assert_eq!(r#"null"#, array_from_str[3].get());

    let array_to_string = serde_json::to_string(&array_from_str).unwrap();
    assert_eq!(r#"["a",42,{"foo": "bar"},null]"#, array_to_string);
}
fn valid_version_with_trailing_characters_is_other() {
  assert_eq!(
    stdout("refs/tags/0.0.0-rc1"),
    "::set-output name=value::other\n"
  );
}
fn eph_finalizer() {
    #[derive(Clone, Trace)]
    struct S {
        #[unsafe_ignore_trace]
        inner: Rc<Cell<bool>>,
    }

    impl Finalize for S {
        fn finalize(&self) {
            self.inner.set(true);
        }
    }

    run_test(|| {
        let val = S {
            inner: Rc::new(Cell::new(false)),
        };

        let key = Gc::new(50u32);
        let eph = Ephemeron::new(&key, Gc::new(val.clone()));
        assert!(eph.has_value());
        // finalize hasn't been run
        assert!(!val.inner.get());

        drop(key);
        force_collect();
        assert!(!eph.has_value());
        // finalize ran when collecting
        assert!(val.inner.get());
    });
}
fn test_serialize_rejects_adt_keys() {
    let map = treemap!(
        Some("a") => 2,
        Some("b") => 4,
        None => 6,
    );

    let err = to_vec(&map).unwrap_err();
    assert_eq!(err.to_string(), "key must be a string");
}
fn valid_version_with_lots_of_digits_is_release() {
  assert_eq!(
    stdout("refs/tags/01232132.098327498374.43268473849734"),
    "::set-output name=value::release\n"
  );
}
fn test_byte_buf_ser() {
    let bytes = ByteBuf::new();
    assert_eq!(to_string(&bytes).unwrap(), "[]".to_string());

    let bytes = ByteBuf::from(vec![1, 2, 3]);
    assert_eq!(to_string(&bytes).unwrap(), "[1,2,3]".to_string());
}
fn empty() {
  assert_eq!(
    CommandBuilder::new("epochs").run_and_deserialize_output::<Output>(),
    Output {
      starting_sats: vec![
        Sat(0),
        Sat(1050000000000000),
        Sat(1575000000000000),
        Sat(1837500000000000),
        Sat(1968750000000000),
        Sat(2034375000000000),
        Sat(2067187500000000),
        Sat(2083593750000000),
        Sat(2091796875000000),
        Sat(2095898437500000),
        Sat(2097949218750000),
        Sat(2098974609270000),
        Sat(2099487304530000),
        Sat(2099743652160000),
        Sat(2099871825870000),
        Sat(2099935912620000),
        Sat(2099967955890000),
        Sat(2099983977420000),
        Sat(2099991988080000),
        Sat(2099995993410000),
        Sat(2099997995970000),
        Sat(2099998997250000),
        Sat(2099999497890000),
        Sat(2099999748210000),
        Sat(2099999873370000),
        Sat(2099999935950000),
        Sat(2099999967240000),
        Sat(2099999982780000),
        Sat(2099999990550000),
        Sat(2099999994330000),
        Sat(2099999996220000),
        Sat(2099999997060000),
        Sat(2099999997480000),
        Sat(2099999997690000)
      ]
    }
  );
}
fn custom_index_path() {
  let rpc_server = test_bitcoincore_rpc::spawn();
  rpc_server.mine_blocks(1);

  let tempdir = TempDir::new().unwrap();

  let index_path = tempdir.path().join("foo.redb");

  CommandBuilder::new(format!("--index {} index update", index_path.display()))
    .rpc_server(&rpc_server)
    .run_and_deserialize_output::<Empty>();

  assert!(index_path.is_file())
}
fn buffered_client_complete_io_for_handshake() {
    let (mut client, mut server) = make_pair(KeyType::Rsa);

    assert!(client.is_handshaking());
    let (rdlen, wrlen) = client
        .complete_io(&mut OtherSession::new_buffered(&mut server))
        .unwrap();
    assert!(rdlen > 0 && wrlen > 0);
    assert!(!client.is_handshaking());
    assert!(!client.wants_write());
}
fn from_stdin() {
  assert_eq!(
    CommandBuilder::new("decode")
      .stdin(transaction())
      .run_and_deserialize_output::<Output>(),
    Output {
      inscriptions: vec![Inscription {
        body: Some(vec![0, 1, 2, 3]),
        content_type: Some(b"text/plain;charset=utf-8".to_vec()),
        ..Default::default()
      }],
    }
  );
}
fn exercise_key_log_file_for_client() {
    serialized(|| {
        let server_config = Arc::new(make_server_config(KeyType::Rsa));
        env::set_var("SSLKEYLOGFILE", "./sslkeylogfile.txt");

        for version in rustls::ALL_VERSIONS {
            let mut client_config = make_client_config_with_versions(KeyType::Rsa, &[version]);
            client_config.key_log = Arc::new(rustls::KeyLogFile::new());

            let (mut client, mut server) =
                make_pair_for_arc_configs(&Arc::new(client_config), &server_config);

            assert_eq!(5, client.writer().write(b"hello").unwrap());

            do_handshake(&mut client, &mut server);
            transfer(&mut client, &mut server);
            server.process_new_packets().unwrap();
        }
    })
}
fn test_serialize_char() {
    let value = json!(
        ({
            let mut map = BTreeMap::new();
            map.insert('c', ());
            map
        })
    );
    assert_eq!(&Value::Null, value.get("c").unwrap());
}
fn server_close_notify() {
    let kt = KeyType::Rsa;
    let server_config = Arc::new(make_server_config_with_mandatory_client_auth(kt));

    for version in rustls::ALL_VERSIONS {
        let client_config = make_client_config_with_versions_with_auth(kt, &[version]);
        let (mut client, mut server) =
            make_pair_for_arc_configs(&Arc::new(client_config), &server_config);
        do_handshake(&mut client, &mut server);

        // check that alerts don't overtake appdata
        assert_eq!(
            12,
            server
                .writer()
                .write(b"from-server!")
                .unwrap()
        );
        assert_eq!(
            12,
            client
                .writer()
                .write(b"from-client!")
                .unwrap()
        );
        server.send_close_notify();

        transfer(&mut server, &mut client);
        let io_state = client.process_new_packets().unwrap();
        assert!(io_state.peer_has_closed());
        check_read_and_close(&mut client.reader(), b"from-server!");

        transfer(&mut client, &mut server);
        server.process_new_packets().unwrap();
        check_read(&mut server.reader(), b"from-client!");
    }
}
fn new_server_returns_initial_io_state() {
    let (_, mut server) = make_pair(KeyType::Rsa);
    let io_state = server.process_new_packets().unwrap();
    println!("IoState is Debug {:?}", io_state);
    assert_eq!(io_state.plaintext_bytes_to_read(), 0);
    assert!(!io_state.peer_has_closed());
    assert_eq!(io_state.tls_bytes_to_write(), 0);
}
fn search_directory() {
  let tmp = temptree! {
    sub: {
      ".git": {},
    },
  };

  let output = Command::new(executable_path("just"))
    .current_dir(tmp.path())
    .arg("--init")
    .arg("sub/")
    .output()
    .unwrap();

  assert!(output.status.success());

  assert_eq!(
    fs::read_to_string(tmp.path().join("sub/justfile")).unwrap(),
    EXPECTED
  );
}
fn re_opening_database_does_not_trigger_schema_check() {
  let rpc_server = test_bitcoincore_rpc::spawn();
  rpc_server.mine_blocks(1);

  let tempdir = TempDir::new().unwrap();

  let index_path = tempdir.path().join("foo.redb");

  CommandBuilder::new(format!("--index {} index update", index_path.display()))
    .rpc_server(&rpc_server)
    .run_and_deserialize_output::<Empty>();

  assert!(index_path.is_file());

  CommandBuilder::new(format!("--index {} index update", index_path.display()))
    .rpc_server(&rpc_server)
    .run_and_deserialize_output::<Empty>();
}
fn eph_basic_clone_test() {
    run_test(|| {
        let init_gc = Gc::new(String::from("bar"));

        let weak = WeakGc::new(&init_gc);

        let new_gc = weak.upgrade().expect("Weak is live");
        let new_weak = weak.clone();

        drop(weak);
        force_collect();

        assert_eq!(*new_gc, *new_weak.upgrade().expect("weak should be live"));
        assert_eq!(
            *init_gc,
            *new_weak.upgrade().expect("weak_should be live still")
        );
    });
}
