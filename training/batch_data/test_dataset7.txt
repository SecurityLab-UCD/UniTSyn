fn error_tests() {
    let mut buffer = [b'\x00'; BUFFER_SIZE];
    let f = 2762159900.0f32;
    let actual = unsafe { std::str::from_utf8_unchecked(f.to_lexical(&mut buffer)) };
    let roundtrip = actual.parse::<f32>();
    assert_eq!(Ok(f), roundtrip);

    let f = 77371252000000000000000000.0f32;
    let actual = unsafe { std::str::from_utf8_unchecked(f.to_lexical(&mut buffer)) };
    let roundtrip = actual.parse::<f32>();
    assert_eq!(Ok(f), roundtrip);
}
fn test_timestamp() {
    use std::collections::HashSet;

    let timestamp = ::prost_types::Timestamp {
        seconds: 100,
        nanos: 42,
    };

    let mut non_normalized_timestamp = ::prost_types::Timestamp {
        seconds: 99,
        nanos: 1_000_000_042,
    };

    let mut hashset = HashSet::new();
    assert!(hashset.insert(timestamp.clone()));
    assert!(
        hashset.insert(non_normalized_timestamp.clone()),
        "hash for non-normalized different and should be inserted"
    );

    assert_ne!(
        timestamp, non_normalized_timestamp,
        "non-nomarlized timestamp considered different"
    );
    non_normalized_timestamp.normalize();
    assert_eq!(
        timestamp, non_normalized_timestamp,
        "normalized timestamp matches"
    );

    let mut hashset = HashSet::new();
    assert!(hashset.insert(timestamp));
    assert!(
        !hashset.insert(non_normalized_timestamp),
        "hash for normalized should match and not inserted"
    );
}
fn parse_partial_number_test() {
    const FORMAT: u128 = STANDARD;
    let options = Options::new();
    let string = b"1.2345e10";
    let byte = string.bytes::<{ FORMAT }>();
    let result = parse::parse_partial_number(byte, false, &options);
    assert!(result.is_ok());
    let (num, count) = result.unwrap();
    assert_eq!(num.mantissa, 12345);
    assert_eq!(num.exponent, 6);
    assert_eq!(num.many_digits, false);
    assert_eq!(count, 9);

    let string = b"1.2345e";
    let byte = string.bytes::<{ FORMAT }>();
    let result = parse::parse_partial_number(byte, false, &options);
    assert!(result.is_err());

    let string = b"1.2345 ";
    let byte = string.bytes::<{ FORMAT }>();
    let result = parse::parse_partial_number(byte, false, &options);
    assert!(result.is_ok());
    let (num, count) = result.unwrap();
    assert_eq!(num.mantissa, 12345);
    assert_eq!(num.exponent, -4);
    assert_eq!(num.many_digits, false);
    assert_eq!(count, 6);

    // Leading zeros
    let string = b"00000000000000000000001.2345 ";
    let byte = string.bytes::<{ FORMAT }>();
    let result = parse::parse_partial_number(byte, false, &options);
    assert!(result.is_ok());
    let (num, count) = result.unwrap();
    assert_eq!(num.mantissa, 12345);
    assert_eq!(num.exponent, -4);
    assert_eq!(num.many_digits, false);
    assert_eq!(count, 28);

    // Leading zeros
    let string = b"0.00000000000000000000012345 ";
    let byte = string.bytes::<{ FORMAT }>();
    let result = parse::parse_partial_number(byte, false, &options);
    assert!(result.is_ok());
    let (num, count) = result.unwrap();
    assert_eq!(num.mantissa, 12345);
    assert_eq!(num.exponent, -26);
    assert_eq!(num.many_digits, false);
    assert_eq!(count, 28);
}
fn u8_decimal_test() {
    assert_eq!(Ok((0, 1)), u8::from_lexical_partial(b"0"));
    assert_eq!(Ok((127, 3)), u8::from_lexical_partial(b"127"));
    assert_eq!(Ok((128, 3)), u8::from_lexical_partial(b"128"));
    assert_eq!(Ok((255, 3)), u8::from_lexical_partial(b"255"));
    assert_eq!(Err(Error::InvalidDigit(0)), u8::from_lexical(b"-1"));
    assert_eq!(Ok((1, 1)), u8::from_lexical_partial(b"1a"));

    let options = Options::default();
    assert_eq!(Ok((0, 1)), u8::from_lexical_partial_with_options::<{ STANDARD }>(b"0", &options));
}
fn f64_decimal_test() {
    // integer test
    assert_eq!(0.0, f64::from_lexical(b"0").unwrap());
    assert_eq!(1.0, f64::from_lexical(b"1").unwrap());
    assert_eq!(12.0, f64::from_lexical(b"12").unwrap());
    assert_eq!(123.0, f64::from_lexical(b"123").unwrap());
    assert_eq!(1234.0, f64::from_lexical(b"1234").unwrap());
    assert_eq!(12345.0, f64::from_lexical(b"12345").unwrap());
    assert_eq!(123456.0, f64::from_lexical(b"123456").unwrap());
    assert_eq!(1234567.0, f64::from_lexical(b"1234567").unwrap());
    assert_eq!(12345678.0, f64::from_lexical(b"12345678").unwrap());

    // No fraction after decimal point test
    assert_eq!(1.0, f64::from_lexical(b"1.").unwrap());
    assert_eq!(12.0, f64::from_lexical(b"12.").unwrap());
    assert_eq!(1234567.0, f64::from_lexical(b"1234567.").unwrap());

    // No integer before decimal point test
    assert_eq!(0.1, f64::from_lexical(b".1").unwrap());
    assert_eq!(0.12, f64::from_lexical(b".12").unwrap());
    assert_eq!(0.1234567, f64::from_lexical(b".1234567").unwrap());

    // decimal test
    assert_eq!(123456789.0, f64::from_lexical(b"123456789").unwrap());
    assert_eq!(123456789.1, f64::from_lexical(b"123456789.1").unwrap());
    assert_eq!(123456789.12, f64::from_lexical(b"123456789.12").unwrap());
    assert_eq!(123456789.123, f64::from_lexical(b"123456789.123").unwrap());
    assert_eq!(123456789.1234, f64::from_lexical(b"123456789.1234").unwrap());
    assert_eq!(123456789.12345, f64::from_lexical(b"123456789.12345").unwrap());
    assert_eq!(123456789.123456, f64::from_lexical(b"123456789.123456").unwrap());
    assert_eq!(123456789.1234567, f64::from_lexical(b"123456789.1234567").unwrap());
    assert_eq!(123456789.12345678, f64::from_lexical(b"123456789.12345678").unwrap());

    // rounding test
    assert_eq!(123456789.12345679, f64::from_lexical(b"123456789.123456789").unwrap());
    assert_eq!(123456789.12345679, f64::from_lexical(b"123456789.1234567890").unwrap());
    assert_eq!(123456789.12345679, f64::from_lexical(b"123456789.123456789012").unwrap());
    assert_eq!(123456789.12345679, f64::from_lexical(b"123456789.1234567890123").unwrap());
    assert_eq!(123456789.12345679, f64::from_lexical(b"123456789.12345678901234").unwrap());

    // exponent test
    assert_eq!(123456789.12345, f64::from_lexical(b"1.2345678912345e8").unwrap());
    assert_eq!(123450000.0, f64::from_lexical(b"1.2345e+8").unwrap());
    assert_eq!(1.2345e+11, f64::from_lexical(b"123450000000").unwrap());
    assert_eq!(1.2345e+11, f64::from_lexical(b"1.2345e+11").unwrap());
    assert_eq!(1.2345e+38, f64::from_lexical(b"1.2345e+38").unwrap());
    assert_eq!(1.2345e+38, f64::from_lexical(b"123450000000000000000000000000000000000").unwrap());
    assert_eq!(1.2345e+308, f64::from_lexical(b"1.2345e+308").unwrap());
    assert_eq!(1.2345e+308, f64::from_lexical(b"123450000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000").unwrap());
    assert_eq!(0.000000012345, f64::from_lexical(b"1.2345e-8").unwrap());
    assert_eq!(1.2345e-8, f64::from_lexical(b"0.000000012345").unwrap());
    assert_eq!(1.2345e-38, f64::from_lexical(b"1.2345e-38").unwrap());
    assert_eq!(
        1.2345e-38,
        f64::from_lexical(b"0.000000000000000000000000000000000000012345").unwrap()
    );

    // denormalized (try extremely low values)
    assert_eq!(1.2345e-308, f64::from_lexical(b"1.2345e-308").unwrap());

    // due to issues in how the data is parsed, manually extracting
    // non-exponents of 1.<e-299 is prone to error
    // test the limit of our ability
    // We tend to get relative errors of 1e-16, even at super low values.
    assert_eq!(1.2345e-299, f64::from_lexical(b"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012345").unwrap());

    // Keep pushing from -300 to -324
    assert_eq!(1.2345e-300, f64::from_lexical(b"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012345").unwrap());

    assert_eq!(1.2345e-310, f64::from_lexical(b"0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012345").unwrap());
    assert_eq!(1.2345e-320, f64::from_lexical(b"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012345").unwrap());
    assert_eq!(1.2345e-321, f64::from_lexical(b"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012345").unwrap());
    assert_eq!(1.24e-322, f64::from_lexical(b"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000124").unwrap());
    assert_eq!(Ok(1e-323), f64::from_lexical(b"0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"));
    assert_eq!(Ok(5e-324), f64::from_lexical(b"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005"));

    assert!(f64::from_lexical(b"NaN").unwrap().is_nan());
    assert!(f64::from_lexical(b"nan").unwrap().is_nan());
    assert!(f64::from_lexical(b"NAN").unwrap().is_nan());
    assert!(f64::from_lexical(b"inf").unwrap().is_infinite());
    assert!(f64::from_lexical(b"INF").unwrap().is_infinite());
    assert!(f64::from_lexical(b"+inf").unwrap().is_infinite());
    assert!(f64::from_lexical(b"-inf").unwrap().is_infinite());

    // Check various expected failures.
    assert_eq!(Err(Error::Empty(0)), f64::from_lexical(b""));
    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b"e"));
    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b"E"));
    assert_eq!(Err(Error::EmptyMantissa(1)), f64::from_lexical(b".e1"));
    assert_eq!(Err(Error::EmptyMantissa(1)), f64::from_lexical(b".e-1"));
    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b"e1"));
    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b"e-1"));

    // Check various reports from a fuzzer.
    assert_eq!(Err(Error::EmptyExponent(2)), f64::from_lexical(b"0e"));
    assert_eq!(Err(Error::EmptyExponent(4)), f64::from_lexical(b"0.0e"));
    assert_eq!(Err(Error::EmptyMantissa(1)), f64::from_lexical(b".E"));
    assert_eq!(Err(Error::EmptyMantissa(1)), f64::from_lexical(b".e"));
    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b"E2252525225"));
    assert_eq!(Err(Error::EmptyMantissa(0)), f64::from_lexical(b"e2252525225"));
    assert_eq!(Ok(f64::INFINITY), f64::from_lexical(b"2E200000000000"));

    // Add various unittests from proptests.
    assert_eq!(Err(Error::EmptyExponent(2)), f64::from_lexical(b"0e"));
    assert_eq!(Err(Error::EmptyMantissa(1)), f64::from_lexical(b"."));
    assert_eq!(Err(Error::EmptyMantissa(2)), f64::from_lexical(b"+."));
    assert_eq!(Err(Error::EmptyMantissa(2)), f64::from_lexical(b"-."));
    assert_eq!(Err(Error::Empty(1)), f64::from_lexical(b"+"));
    assert_eq!(Err(Error::Empty(1)), f64::from_lexical(b"-"));

    // Bug fix for Issue #8
    assert_eq!(Ok(5.002868148396374), f64::from_lexical(b"5.002868148396374"));

    // Other bug fixes
    assert_eq!(Ok(1.620515050981309e+308), f64::from_lexical(b"162051505098130900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"));
    assert_eq!(Ok(1.620515050981309e+308), f64::from_lexical(b"162051505098130900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0"));
    assert_eq!(Ok(-1.620515050981309e+308), f64::from_lexical(b"-162051505098130900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"));
    assert_eq!(Ok(-1.620515050981309e+308), f64::from_lexical(b"-162051505098130900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0"));
}
fn test_parse_self_debug_line() {
    let debug_info = read_section("debug_info");
    let debug_info = DebugInfo::new(&debug_info, LittleEndian);

    let debug_abbrev = read_section("debug_abbrev");
    let debug_abbrev = DebugAbbrev::new(&debug_abbrev, LittleEndian);

    let debug_line = read_section("debug_line");
    let debug_line = DebugLine::new(&debug_line, LittleEndian);

    let debug_str = read_section("debug_str");
    let debug_str = DebugStr::new(&debug_str, LittleEndian);

    let mut iter = debug_info.units();
    while let Some(unit) = iter.next().expect("Should parse compilation unit") {
        let abbrevs = unit
            .abbreviations(&debug_abbrev)
            .expect("Should parse abbreviations");

        let mut cursor = unit.entries(&abbrevs);
        cursor.next_dfs().expect("Should parse next dfs");

        let unit_entry = cursor.current().expect("Should have a root entry");

        let comp_dir = unit_entry
            .attr_value(gimli::DW_AT_comp_dir)
            .expect("Should parse comp_dir attribute")
            .and_then(|val| val.string_value(&debug_str));
        let comp_name = unit_entry
            .attr_value(gimli::DW_AT_name)
            .expect("Should parse name attribute")
            .and_then(|val| val.string_value(&debug_str));

        if let Some(AttributeValue::DebugLineRef(offset)) = unit_entry
            .attr_value(gimli::DW_AT_stmt_list)
            .expect("Should parse stmt_list")
        {
            let program = debug_line
                .program(offset, unit.address_size(), comp_dir, comp_name)
                .expect("should parse line number program header");

            let mut results = Vec::new();
            let mut rows = program.rows();
            while let Some((_, row)) = rows
                .next_row()
                .expect("Should parse and execute all rows in the line number program")
            {
                results.push(*row);
            }
            results.reverse();

            let program = debug_line
                .program(offset, unit.address_size(), comp_dir, comp_name)
                .expect("should parse line number program header");
            let (program, sequences) = program
                .sequences()
                .expect("should parse and execute the entire line number program");
            assert!(!sequences.is_empty()); // Should be at least one sequence.
            for sequence in sequences {
                let mut rows = program.resume_from(&sequence);
                while let Some((_, row)) = rows
                    .next_row()
                    .expect("Should parse and execute all rows after resuming")
                {
                    let other_row = results.pop().unwrap();
                    assert!(row.address() >= sequence.start);
                    assert!(row.address() <= sequence.end);
                    assert_eq!(row.address(), other_row.address());
                    assert_eq!(row.line(), other_row.line());
                }
            }
            assert!(results.is_empty());
        }
    }
}
fn f32_decimal_test() {
    // integer test
    assert_eq!(0.0, f32::from_lexical(b"0").unwrap());
    assert_eq!(1.0, f32::from_lexical(b"1").unwrap());
    assert_eq!(12.0, f32::from_lexical(b"12").unwrap());
    assert_eq!(123.0, f32::from_lexical(b"123").unwrap());
    assert_eq!(1234.0, f32::from_lexical(b"1234").unwrap());
    assert_eq!(12345.0, f32::from_lexical(b"12345").unwrap());
    assert_eq!(123456.0, f32::from_lexical(b"123456").unwrap());
    assert_eq!(1234567.0, f32::from_lexical(b"1234567").unwrap());
    assert_eq!(12345678.0, f32::from_lexical(b"12345678").unwrap());

    // No fraction after decimal point test
    assert_eq!(1.0, f32::from_lexical(b"1.").unwrap());
    assert_eq!(12.0, f32::from_lexical(b"12.").unwrap());
    assert_eq!(1234567.0, f32::from_lexical(b"1234567.").unwrap());

    // No integer before decimal point test
    assert_eq!(0.1, f32::from_lexical(b".1").unwrap());
    assert_eq!(0.12, f32::from_lexical(b".12").unwrap());
    assert_eq!(0.1234567, f32::from_lexical(b".1234567").unwrap());

    // decimal test
    assert_eq!(123.1, f32::from_lexical(b"123.1").unwrap());
    assert_eq!(123.12, f32::from_lexical(b"123.12").unwrap());
    assert_eq!(123.123, f32::from_lexical(b"123.123").unwrap());
    assert_eq!(123.1234, f32::from_lexical(b"123.1234").unwrap());
    assert_eq!(123.12345, f32::from_lexical(b"123.12345").unwrap());

    // rounding test
    assert_eq!(123456790.0, f32::from_lexical(b"123456789").unwrap());
    assert_eq!(123456790.0, f32::from_lexical(b"123456789.1").unwrap());
    assert_eq!(123456790.0, f32::from_lexical(b"123456789.12").unwrap());
    assert_eq!(123456790.0, f32::from_lexical(b"123456789.123").unwrap());
    assert_eq!(123456790.0, f32::from_lexical(b"123456789.1234").unwrap());
    assert_eq!(123456790.0, f32::from_lexical(b"123456789.12345").unwrap());

    // exponent test
    assert_eq!(123456789.12345, f32::from_lexical(b"1.2345678912345e8").unwrap());
    assert_eq!(123450000.0, f32::from_lexical(b"1.2345e+8").unwrap());
    assert_eq!(1.2345e+11, f32::from_lexical(b"1.2345e+11").unwrap());
    assert_eq!(1.2345e+11, f32::from_lexical(b"123450000000").unwrap());
    assert_eq!(1.2345e+38, f32::from_lexical(b"1.2345e+38").unwrap());
    assert_eq!(1.2345e+38, f32::from_lexical(b"123450000000000000000000000000000000000").unwrap());
    assert_eq!(1.2345e-8, f32::from_lexical(b"1.2345e-8").unwrap());
    assert_eq!(1.2345e-8, f32::from_lexical(b"0.000000012345").unwrap());
    assert_eq!(1.2345e-38, f32::from_lexical(b"1.2345e-38").unwrap());
    assert_eq!(
        1.2345e-38,
        f32::from_lexical(b"0.000000000000000000000000000000000000012345").unwrap()
    );

    assert!(f32::from_lexical(b"NaN").unwrap().is_nan());
    assert!(f32::from_lexical(b"nan").unwrap().is_nan());
    assert!(f32::from_lexical(b"NAN").unwrap().is_nan());
    assert!(f32::from_lexical(b"inf").unwrap().is_infinite());
    assert!(f32::from_lexical(b"INF").unwrap().is_infinite());
    assert!(f32::from_lexical(b"+inf").unwrap().is_infinite());
    assert!(f32::from_lexical(b"-inf").unwrap().is_infinite());

    // Check various expected failures.
    assert_eq!(Err(Error::Empty(0)), f32::from_lexical(b""));
    assert_eq!(Err(Error::EmptyMantissa(0)), f32::from_lexical(b"e"));
    assert_eq!(Err(Error::EmptyMantissa(0)), f32::from_lexical(b"E"));
    assert_eq!(Err(Error::EmptyMantissa(1)), f32::from_lexical(b".e1"));
    assert_eq!(Err(Error::EmptyMantissa(1)), f32::from_lexical(b".e-1"));
    assert_eq!(Err(Error::EmptyMantissa(0)), f32::from_lexical(b"e1"));
    assert_eq!(Err(Error::EmptyMantissa(0)), f32::from_lexical(b"e-1"));
    assert_eq!(Err(Error::Empty(1)), f32::from_lexical(b"+"));
    assert_eq!(Err(Error::Empty(1)), f32::from_lexical(b"-"));

    // Bug fix for Issue #8
    assert_eq!(Ok(5.002868148396374), f32::from_lexical(b"5.002868148396374"));

    // Other bug fixes
    assert_eq!(Ok(7.2625224e+37), f32::from_lexical(b"72625224000000000000000000000000000000"));
    assert_eq!(Ok(7.2625224e+37), f32::from_lexical(b"72625224000000000000000000000000000000.0"));
    assert_eq!(Ok(-7.2625224e+37), f32::from_lexical(b"-72625224000000000000000000000000000000"));
    assert_eq!(Ok(-7.2625224e+37), f32::from_lexical(b"-72625224000000000000000000000000000000.0"));
}
fn u32_decimal_test() {
    assert_eq!(Ok(0), u32::from_lexical(b"0"));
    assert_eq!(Ok(2147483647), u32::from_lexical(b"2147483647"));
    assert_eq!(Ok(2147483648), u32::from_lexical(b"2147483648"));
    assert_eq!(Ok(4294967295), u32::from_lexical(b"4294967295"));
    assert_eq!(Err(Error::InvalidDigit(0)), u32::from_lexical(b"-1"));
    assert_eq!(Err(Error::InvalidDigit(1)), u32::from_lexical(b"1a"));
}
fn u128_decimal_test() {
    assert_eq!(Ok(0), u128::from_lexical(b"0"));
    assert_eq!(
        Ok(170141183460469231731687303715884105727),
        u128::from_lexical(b"170141183460469231731687303715884105727")
    );
    assert_eq!(
        Ok(170141183460469231731687303715884105728),
        u128::from_lexical(b"170141183460469231731687303715884105728")
    );
    assert_eq!(
        Ok(340282366920938463463374607431768211455),
        u128::from_lexical(b"340282366920938463463374607431768211455")
    );
    assert_eq!(Err(Error::InvalidDigit(0)), u128::from_lexical(b"-1"));
    assert_eq!(Err(Error::InvalidDigit(1)), u128::from_lexical(b"1a"));
}
fn pow64_test() {
    assert_eq!(algorithm::pow64(10, 1), 10);
    assert_eq!(algorithm::pow64(10, 2), 100);
}
fn parse_parse_special_test() {
    const FORMAT: u128 = STANDARD;

    let options = Options::new();
    let digits = b"NaN";
    let byte = digits.bytes::<{ FORMAT }>();
    let result = parse::parse_special::<f64, FORMAT>(byte, true, &options).unwrap();
    assert!(f64::is_nan(result));
    assert!(f64::is_sign_negative(result));

    let digits = b"NaN1";
    let byte = digits.bytes::<{ FORMAT }>();
    let result = parse::parse_special::<f64, FORMAT>(byte, true, &options);
    assert_eq!(result, None);
}
fn algorithm_test() {
    let parse_u32 = |digits: &[u8]| compact::algorithm_partial::<u32, u32, STANDARD>(digits);
    let parse_i32 = |digits: &[u8]| compact::algorithm_partial::<i32, u32, STANDARD>(digits);

    assert_eq!(parse_u32(b"12345"), Ok((12345, 5)));
    assert_eq!(parse_u32(b"+12345"), Ok((12345, 6)));
    // This just parses 0 digits, since it's an unsigned type.
    assert_eq!(parse_u32(b"-12345"), Ok((0, 0)));
    assert_eq!(parse_i32(b"12345"), Ok((12345, 5)));
    assert_eq!(parse_i32(b"-12345"), Ok((-12345, 6)));
    assert_eq!(parse_i32(b"+12345"), Ok((12345, 6)));
    assert_eq!(parse_i32(b"+123.45"), Ok((123, 4)));
}
fn parse_partial_test() {
    const FORMAT: u128 = STANDARD;
    let options = Options::new();
    let string = b"1.2345e10";
    let result = parse::parse_partial::<f64, FORMAT>(string, &options);
    assert_eq!(result, Ok((1.2345e10, 9)));

    let string = b"1.2345e";
    let result = parse::parse_partial::<f64, FORMAT>(string, &options);
    assert!(result.is_err());

    let string = b"1.2345 ";
    let result = parse::parse_partial::<f64, FORMAT>(string, &options);
    assert_eq!(result, Ok((1.2345, 6)));
}
fn lower_n_halfway_test() {
    assert_eq!(mask::lower_n_halfway(2), 0b10);
}
fn power_limit_test() {
    assert_eq!(limits::u32_power_limit(5), 13);
    assert_eq!(limits::u32_power_limit(10), 9);
    assert_eq!(limits::u64_power_limit(5), 27);
    assert_eq!(limits::u64_power_limit(10), 19);
}
